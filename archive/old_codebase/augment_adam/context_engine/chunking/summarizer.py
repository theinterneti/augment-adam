"""Summarizer for the Context Engine.

This module provides a summarizer for condensing content when needed.

Version: 0.1.0
Created: 2025-04-26
"""

import logging
from typing import Dict, List, Any, Optional, Union, Tuple

from augment_adam.core.errors import (
    ResourceError, wrap_error, log_error, ErrorCategory
)

logger = logging.getLogger(__name__)


class Summarizer:
    """Summarizer for the Context Engine.
    
    This class provides methods for summarizing content at different levels
    of detail.
    
    Attributes:
        model: The model to use for summarization
        max_input_tokens: The maximum number of tokens for the model input
        max_output_tokens: The maximum number of tokens for the model output
    """
    
    def __init__(
        self,
        model: Optional[Any] = None,
        max_input_tokens: int = 4000,
        max_output_tokens: int = 1000
    ):
        """Initialize the Summarizer.
        
        Args:
            model: The model to use for summarization
            max_input_tokens: The maximum number of tokens for the model input
            max_output_tokens: The maximum number of tokens for the model output
        """
        self.model = model
        self.max_input_tokens = max_input_tokens
        self.max_output_tokens = max_output_tokens
        
        logger.info("Summarizer initialized")
    
    def summarize(
        self,
        content: str,
        target_length: Optional[int] = None,
        detail_level: str = "medium"
    ) -> str:
        """Summarize content.
        
        Args:
            content: The content to summarize
            target_length: The target length of the summary in tokens
            detail_level: The level of detail for the summary (low, medium, high)
            
        Returns:
            The summarized content
        """
        try:
            if not content:
                return ""
            
            # If model is not available, fall back to extractive summarization
            if self.model is None:
                return self._extractive_summarize(content, target_length, detail_level)
            
            # Determine target length if not specified
            if target_length is None:
                if detail_level == "low":
                    target_length = min(len(content.split()) // 8, self.max_output_tokens)
                elif detail_level == "medium":
                    target_length = min(len(content.split()) // 4, self.max_output_tokens)
                else:  # high
                    target_length = min(len(content.split()) // 2, self.max_output_tokens)
            
            # Ensure target length is reasonable
            target_length = min(target_length, self.max_output_tokens)
            
            # Truncate content if too long for model
            if len(content.split()) > self.max_input_tokens:
                content = " ".join(content.split()[:self.max_input_tokens])
            
            # Create prompt for summarization
            prompt = (
                f"Summarize the following content in about {target_length} words. "
                f"Maintain a {detail_level} level of detail.\n\n"
                f"{content}"
            )
            
            # Generate summary using model
            # This is a placeholder for actual model integration
            summary = "This is a placeholder summary. In a real implementation, this would be generated by a language model."
            
            logger.info(f"Summarized content from {len(content.split())} words to {len(summary.split())} words")
            return summary
        except Exception as e:
            error = wrap_error(
                e,
                message="Failed to summarize content",
                category=ErrorCategory.RESOURCE,
                details={
                    "content_length": len(content) if content else 0,
                    "detail_level": detail_level,
                },
            )
            log_error(error, logger=logger)
            
            # Fall back to extractive summarization
            return self._extractive_summarize(content, target_length, detail_level)
    
    def _extractive_summarize(
        self,
        content: str,
        target_length: Optional[int] = None,
        detail_level: str = "medium"
    ) -> str:
        """Perform extractive summarization.
        
        Args:
            content: The content to summarize
            target_length: The target length of the summary in tokens
            detail_level: The level of detail for the summary (low, medium, high)
            
        Returns:
            The summarized content
        """
        if not content:
            return ""
        
        # Split into sentences
        sentences = content.replace("\n", " ").split(". ")
        
        # Determine target length if not specified
        if target_length is None:
            if detail_level == "low":
                target_length = max(1, len(sentences) // 8)
            elif detail_level == "medium":
                target_length = max(1, len(sentences) // 4)
            else:  # high
                target_length = max(1, len(sentences) // 2)
        
        # Ensure target length is reasonable
        target_length = min(target_length, len(sentences))
        
        # Simple extractive summarization: take first N sentences
        summary_sentences = sentences[:target_length]
        
        # Join sentences
        summary = ". ".join(summary_sentences)
        if not summary.endswith("."):
            summary += "."
        
        return summary
    
    def hierarchical_summarize(
        self,
        content: str,
        levels: int = 3
    ) -> List[str]:
        """Perform hierarchical summarization.
        
        Args:
            content: The content to summarize
            levels: The number of summary levels to generate
            
        Returns:
            List of summaries at different levels of detail
        """
        try:
            if not content:
                return []
            
            summaries = []
            
            # Generate summaries at different levels of detail
            detail_levels = ["high", "medium", "low"]
            for i in range(min(levels, len(detail_levels))):
                detail_level = detail_levels[i]
                summary = self.summarize(content, detail_level=detail_level)
                summaries.append(summary)
                
                # Use the previous summary as content for the next level
                content = summary
            
            logger.info(f"Generated {len(summaries)} levels of hierarchical summaries")
            return summaries
        except Exception as e:
            error = wrap_error(
                e,
                message="Failed to perform hierarchical summarization",
                category=ErrorCategory.RESOURCE,
                details={
                    "content_length": len(content) if content else 0,
                    "levels": levels,
                },
            )
            log_error(error, logger=logger)
            return []
