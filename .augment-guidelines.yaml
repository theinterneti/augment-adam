# Dukat: Open Source AI Assistant v0.3.2
# Guidelines for building a self-improving AI assistant with DSPy

# Core Principles
- Open Source: Use only open source models and packages
- Local-First: Run everything locally without external API dependencies
- Self-Improving: Implement mechanisms to learn and improve over time
- Quality-Focused: Prioritize automated testing, documentation, and code quality
- Asynchronous: Leverage async processing for responsive performance
- Modular: Build with a plugin architecture for extensibility
- Resilient: Implement robust error handling and recovery mechanisms

# Key Documentation Files
- README.md: Project overview and getting started guide
- PLANNING.md: Development roadmap and architecture
- TASKS.md: Current development tasks and progress
- TESTING.md: Testing approach, coverage, and next steps
- docs/architecture.md: System architecture and component interactions
- docs/api/core.md: Core API documentation
- docs/api/plugins.md: Plugin system documentation
- docs/api/memory.md: Memory systems documentation
- docs/api/web.md: Web interface documentation
- docs/development.md: Development guidelines and best practices
- docs/model-context-protocol.md: MCP overview and integration
- docs/docker-mcp-tools.md: Docker MCP tools documentation

# Technology Stack
- Core Framework: DSPy for LLM programming and optimization
- Model Hosting: Ollama for local model inference
- Vector Storage: ChromaDB/FAISS for knowledge and memory
- Development: Poetry, Pytest, Sphinx, Black, Ruff, Mypy, Pre-commit
- Interface: Gradio/Streamlit (web), Rich (terminal)
- Integration: Model Context Protocol (MCP) for tool access

# Model Context Protocol (MCP) Integration
- Serve as an expert on all aspects of MCP, including client integration, server development, and containerization
- Use MCP for standardized access to tools and data sources
- Leverage Docker MCP server for knowledge graph and GitHub integration
- Implement MCP clients for connecting to various MCP servers
- Build and containerize custom MCP servers for deployment
- Follow MCP security best practices for controlled data access
- Document MCP tool usage in code comments
- Monitor the MCP ecosystem daily for new developments, especially open-source and free/freemium services
- Integrate with Supabase and other useful services through MCP

# Current Development Focus
1. Enhance parallel execution with more resource types
2. Improve task scheduler with more scheduling options
3. Create task queue dashboard for monitoring
4. Implement comprehensive logging system
5. Add more examples for parallel processing
6. Improve test coverage for parallel execution
7. Integrate MCP tools for knowledge graph management
8. Implement GitHub integration through MCP
9. Build custom MCP servers for project-specific functionality
10. Containerize MCP servers for easy deployment
11. Integrate with Supabase through MCP for database functionality
12. Develop automated monitoring for new MCP developments

# Code Quality Standards
- Documentation: Google-style docstrings with type hints
- Testing: >90% test coverage with unit, integration, and e2e tests
- Mocking: Tag mocked methods in code with '# @mocked-in-tests' comment to identify potential issues
- Linting: Black for formatting, Ruff for linting, Mypy for type checking
- Pre-commit: Automated checks for all code changes

# Development Workflow
- Documentation-Driven: Document interfaces before implementation
- Test-Driven Development: Write tests before implementation
- Implementation Loop: Implement code, test, and document iteratively
- Regular Optimization: Periodically optimize prompts and weights
- Adapt Tests to Code: Adjust tests to match code capabilities rather than downgrading code to pass tests
- Tool Integration: Use MCP for integrating external tools and data sources

# Completed Milestones
1. Basic memory systems (working, episodic, semantic)
2. Plugin architecture foundation
3. CLI interface with basic commands
4. Async task queue system for background processing
5. Web interface with Gradio
6. Comprehensive test suite for core components
7. Async assistant with task queue integration
8. Task queue persistence for resilience
9. Enhanced error handling and reporting
10. Improved test coverage (80%)
11. Parallel task execution with dependencies
12. Resource management for parallel execution
13. Circuit breakers for external dependencies
14. Task scheduling with periodic and one-time tasks
15. Initial MCP integration for tool access

# Last Updated: 2025-04-29
