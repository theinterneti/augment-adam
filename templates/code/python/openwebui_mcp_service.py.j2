{# Template for creating a service that exposes both FastAPI REST endpoints and MCP tools using open-webui-mcp #}
{# @tags: code, api, mcp, fastapi, open-webui-mcp #}
{# @description: This template is used to generate a service that exposes functionality as both REST API endpoints and MCP tools using FastAPI and open-webui-mcp #}
{# @variables: service_name:str, service_description:str, endpoints:list, models:list, version:str, mcp_tools:list #}
{# @examples: [{"service_name": "Memory Service", "service_description": "A service for managing memory storage and retrieval", "endpoints": [{"name": "add_memory", "path": "/memories", "method": "POST", "description": "Add a new memory", "parameters": [{"name": "text", "type": "str", "description": "The text content of the memory"}, {"name": "metadata", "type": "dict", "description": "Additional metadata for the memory"}], "returns": {"type": "dict", "description": "The created memory with ID"}}], "models": [{"name": "Memory", "description": "A memory item", "fields": [{"name": "id", "type": "str", "required": true, "description": "Unique identifier"}, {"name": "text", "type": "str", "required": true, "description": "Text content"}, {"name": "metadata", "type": "dict", "required": false, "description": "Additional metadata"}]}], "mcp_tools": [{"name": "add_memory", "description": "Add a new memory", "parameters": [{"name": "text", "type": "str", "description": "The text content of the memory"}, {"name": "metadata", "type": "dict", "description": "Additional metadata for the memory"}], "returns": {"type": "dict", "description": "The created memory with ID"}}], "version": "0.1.0"}] #}
#!/usr/bin/env python3
"""
{{ service_description }}

This module provides a service that exposes functionality as both REST API endpoints
and MCP tools using FastAPI and open-webui-mcp.

Version: {{ version }}
"""

import logging
import os
import json
import subprocess
import tempfile
from typing import Dict, List, Any, Optional, Union
from fastapi import FastAPI, APIRouter, HTTPException, Depends
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, Field
import uvicorn

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)

# Create FastAPI app
app = FastAPI(
    title="{{ service_name }}",
    description="{{ service_description }}",
    version="{{ version }}"
)

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Create router
router = APIRouter()

{% if models %}
# Define models
{% for model in models %}
class {{ model.name }}(BaseModel):
    """{{ model.description }}"""
    {% for field in model.fields %}
    {{ field.name }}: {% if not field.required %}Optional[{% endif %}{{ field.type }}{% if not field.required %}]{% endif %} = Field(
        {% if not field.required %}None{% else %}...{% endif %},
        description="{{ field.description }}"
    )
    {% endfor %}
{% endfor %}
{% endif %}

{% if endpoints %}
# Define endpoints
{% for endpoint in endpoints %}
@router.{{ endpoint.method|lower }}("{{ endpoint.path }}", tags=["{{ endpoint.name }}"])
async def {{ endpoint.name }}(
    {% for param in endpoint.parameters %}
    {{ param.name }}: {{ param.type }}{% if not loop.last %}, {% endif %}
    {% endfor %}
):
    """{{ endpoint.description }}
    
    {% for param in endpoint.parameters %}
    Args:
        {{ param.name }}: {{ param.description }}
    {% endfor %}
    
    Returns:
        {{ endpoint.returns.description }}
    """
    try:
        # Implementation goes here
        logger.info(f"Processing {{ endpoint.name }} request")
        
        # Example implementation
        result = {
            {% for param in endpoint.parameters %}
            "{{ param.name }}": {{ param.name }}{% if not loop.last %},{% endif %}
            {% endfor %}
        }
        
        return result
    except Exception as e:
        logger.error(f"Error in {{ endpoint.name }}: {e}")
        raise HTTPException(status_code=500, detail=str(e))
{% endfor %}
{% endif %}

# Include router in app
app.include_router(router)

# Create MCP server script
def create_mcp_server_script():
    """Create a Python script for the MCP server."""
    script_content = """#!/usr/bin/env python3
import json
import sys
import logging

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    filename="mcp_server.log"
)
logger = logging.getLogger(__name__)

# Define MCP server
server_info = {
    "name": "{{ service_name }} MCP",
    "version": "{{ version }}"
}

# Define tools
tools = [
    {% for tool in mcp_tools %}
    {
        "name": "{{ tool.name }}",
        "description": "{{ tool.description }}",
        "parameters": {
            {% for param in tool.parameters %}
            "{{ param.name }}": {
                "type": "{{ param.type }}",
                "description": "{{ param.description }}"
            }{% if not loop.last %},{% endif %}
            {% endfor %}
        }
    }{% if not loop.last %},{% endif %}
    {% endfor %}
]

# Define resources
resources = []

# Define prompts
prompts = []

# Initialize server
print(json.dumps({"type": "server_info", "server_info": server_info}))
sys.stdout.flush()

# Main loop
while True:
    try:
        line = sys.stdin.readline()
        if not line:
            break
            
        request = json.loads(line)
        request_type = request.get("type")
        request_id = request.get("request_id")
        
        if request_type == "list_tools":
            response = {
                "type": "list_tools_response",
                "request_id": request_id,
                "tools": tools
            }
            print(json.dumps(response))
            sys.stdout.flush()
            
        elif request_type == "list_resources":
            response = {
                "type": "list_resources_response",
                "request_id": request_id,
                "resources": resources
            }
            print(json.dumps(response))
            sys.stdout.flush()
            
        elif request_type == "list_prompts":
            response = {
                "type": "list_prompts_response",
                "request_id": request_id,
                "prompts": prompts
            }
            print(json.dumps(response))
            sys.stdout.flush()
            
        elif request_type == "call_tool":
            tool_name = request.get("name")
            parameters = request.get("parameters", {})
            
            # Process tool call
            logger.info(f"Tool call: {tool_name} with parameters {parameters}")
            
            # Make HTTP request to the FastAPI endpoint
            import requests
            
            # Map MCP tool names to API endpoints
            tool_to_endpoint = {
                {% for tool in mcp_tools %}
                "{{ tool.name }}": "http://localhost:8000{{ endpoints|selectattr('name', 'equalto', tool.name)|map(attribute='path')|first }}"{% if not loop.last %},{% endif %}
                {% endfor %}
            }
            
            endpoint = tool_to_endpoint.get(tool_name)
            if endpoint:
                api_response = requests.post(endpoint, json=parameters)
                result = api_response.json()
                
                response = {
                    "type": "call_tool_response",
                    "request_id": request_id,
                    "result": result
                }
                print(json.dumps(response))
                sys.stdout.flush()
            else:
                response = {
                    "type": "error",
                    "request_id": request_id,
                    "error": f"Unknown tool: {tool_name}"
                }
                print(json.dumps(response))
                sys.stdout.flush()
                
        elif request_type == "ping":
            response = {
                "type": "pong",
                "request_id": request_id
            }
            print(json.dumps(response))
            sys.stdout.flush()
            
    except Exception as e:
        logger.error(f"Error processing request: {e}")
        response = {
            "type": "error",
            "request_id": request_id if 'request_id' in locals() else None,
            "error": str(e)
        }
        print(json.dumps(response))
        sys.stdout.flush()
"""
    
    # Create a temporary file for the script
    fd, path = tempfile.mkstemp(suffix='.py')
    with os.fdopen(fd, 'w') as f:
        f.write(script_content)
    
    # Make the script executable
    os.chmod(path, 0o755)
    
    return path

# Create MCP config file
def create_mcp_config():
    """Create a config file for open-webui-mcp."""
    config = {
        "mcpServers": {
            "{{ service_name|lower|replace(' ', '_') }}": {
                "command": "python",
                "args": ["mcp_server_script.py"]
            }
        }
    }
    
    # Create a temporary file for the config
    fd, path = tempfile.mkstemp(suffix='.json')
    with os.fdopen(fd, 'w') as f:
        json.dump(config, f, indent=2)
    
    return path

# Start MCP server
def start_mcp_server(api_key: str = "top-secret", port: int = 8001):
    """Start the MCP server using open-webui-mcp.
    
    Args:
        api_key: API key for the MCP server
        port: Port for the MCP server
    """
    script_path = create_mcp_server_script()
    config_path = create_mcp_config()
    
    # Update the config to point to the actual script path
    with open(config_path, 'r') as f:
        config = json.load(f)
    
    config["mcpServers"]["{{ service_name|lower|replace(' ', '_') }}"]["args"][0] = script_path
    
    with open(config_path, 'w') as f:
        json.dump(config, f, indent=2)
    
    # Start the MCP server
    cmd = [
        "mcpo",
        "--port", str(port),
        "--api-key", api_key,
        "--config", config_path
    ]
    
    # Start the process
    process = subprocess.Popen(
        cmd,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True
    )
    
    logger.info(f"Started MCP server on port {port}")
    return process

def start_server(host: str = "0.0.0.0", port: int = 8000, mcp_port: int = 8001, api_key: str = "top-secret"):
    """Start the server.
    
    Args:
        host: Host to bind to
        port: Port to bind to for the REST API
        mcp_port: Port to bind to for the MCP server
        api_key: API key for the MCP server
    """
    # Start MCP server in a separate process
    mcp_process = start_mcp_server(api_key=api_key, port=mcp_port)
    
    try:
        # Start FastAPI server
        uvicorn.run(app, host=host, port=port)
    finally:
        # Clean up MCP server process
        mcp_process.terminate()
        mcp_process.wait()

if __name__ == "__main__":
    start_server()
