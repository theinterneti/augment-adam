{# Template for creating a service that integrates all three MCP approaches #}
{# @tags: code, api, mcp, fastapi, fastapi-mcp, open-webui-mcp, fastmcp, integrated #}
{# @description: This template is used to generate a service that integrates all three MCP approaches: FastAPI with FastAPI-MCP, FastAPI with open-webui-mcp, and FastMCP with FastAPI generation #}
{# @variables: service_name:str, service_description:str, endpoints:list, models:list, tools:list, resources:list, version:str #}
{# @examples: [{"service_name": "Memory Service", "service_description": "A service for managing memory storage and retrieval", "endpoints": [{"name": "add_memory", "path": "/memories", "method": "POST", "description": "Add a new memory", "parameters": [{"name": "text", "type": "str", "description": "The text content of the memory"}, {"name": "metadata", "type": "dict", "description": "Additional metadata for the memory"}], "returns": {"type": "dict", "description": "The created memory with ID"}}], "models": [{"name": "Memory", "description": "A memory item", "fields": [{"name": "id", "type": "str", "required": true, "description": "Unique identifier"}, {"name": "text", "type": "str", "required": true, "description": "Text content"}, {"name": "metadata", "type": "dict", "required": false, "description": "Additional metadata"}]}], "tools": [{"name": "add_memory", "description": "Add a new memory", "parameters": [{"name": "text", "type": "str", "description": "The text content of the memory"}, {"name": "metadata", "type": "dict", "description": "Additional metadata for the memory"}], "returns": {"type": "dict", "description": "The created memory with ID"}}], "resources": [{"name": "get_memory", "uri": "memory://{memory_id}", "description": "Get a memory by ID", "parameters": [{"name": "memory_id", "type": "str", "description": "The ID of the memory to retrieve"}], "returns": {"type": "dict", "description": "The memory with the specified ID"}}], "version": "0.1.0"}] #}
#!/usr/bin/env python3
"""
{{ service_description }}

This module provides a service that integrates all three MCP approaches:
1. FastAPI with FastAPI-MCP for direct API-to-MCP conversion
2. FastAPI with open-webui-mcp for secure, proxied MCP access
3. FastMCP with FastAPI generation for MCP-first design

Version: {{ version }}
"""

import logging
import os
import json
import subprocess
import tempfile
import threading
import asyncio
from typing import Dict, List, Any, Optional, Union
from fastapi import FastAPI, APIRouter, HTTPException, Depends, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from pydantic import BaseModel, Field
import uvicorn
from fastapi_mcp import FastApiMCP
from fastmcp import FastMCP, Client
from fastmcp.client.transports import FastMCPTransport

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)

# Define models
{% if models %}
{% for model in models %}
class {{ model.name }}(BaseModel):
    """{{ model.description }}"""
    {% for field in model.fields %}
    {{ field.name }}: {% if not field.required %}Optional[{% endif %}{{ field.type }}{% if not field.required %}]{% endif %} = Field(
        {% if not field.required %}None{% else %}...{% endif %},
        description="{{ field.description }}"
    )
    {% endfor %}
{% endfor %}
{% endif %}

# Define service implementation
class {{ service_name|replace(' ', '') }}Service:
    """Implementation of the {{ service_name }} service."""
    
    def __init__(self):
        """Initialize the service."""
        # In-memory storage for this example
        self.db = {}
    
    {% for endpoint in endpoints %}
    async def {{ endpoint.name }}(self, {% for param in endpoint.parameters %}{{ param.name }}: {{ param.type }}{% if not loop.last %}, {% endif %}{% endfor %}) -> {{ endpoint.returns.type }}:
        """{{ endpoint.description }}
        
        {% for param in endpoint.parameters %}
        Args:
            {{ param.name }}: {{ param.description }}
        {% endfor %}
        
        Returns:
            {{ endpoint.returns.description }}
        """
        # Implementation goes here
        logger.info(f"Processing {{ endpoint.name }} request")
        
        {% if endpoint.method|lower == 'post' and endpoint.name.startswith('add_') %}
        # Generate a simple ID
        item_id = f"item_{len(self.db) + 1}"
        
        # Create item object
        item = {
            "id": item_id,
            {% for param in endpoint.parameters %}
            "{{ param.name }}": {{ param.name }}{% if not loop.last %},{% endif %}
            {% endfor %}
        }
        
        # Store in database
        self.db[item_id] = item
        
        return {"item": item}
        {% elif endpoint.method|lower == 'get' and endpoint.name.startswith('get_') and endpoint.parameters|length == 1 and endpoint.parameters[0].name.endswith('_id') %}
        # Get item by ID
        item_id = {{ endpoint.parameters[0].name }}
        if item_id not in self.db:
            raise ValueError(f"Item {item_id} not found")
        
        return {"item": self.db[item_id]}
        {% elif endpoint.method|lower == 'get' and endpoint.name.startswith('list_') %}
        # List all items
        items = list(self.db.values())
        return {"items": items}
        {% elif endpoint.method|lower == 'delete' %}
        # Delete item
        item_id = {{ endpoint.parameters[0].name }}
        if item_id not in self.db:
            raise ValueError(f"Item {item_id} not found")
        
        del self.db[item_id]
        return {"status": "success", "message": f"Item {item_id} deleted"}
        {% else %}
        # Example implementation
        result = {
            {% for param in endpoint.parameters %}
            "{{ param.name }}": {{ param.name }}{% if not loop.last %},{% endif %}
            {% endfor %}
        }
        
        return result
        {% endif %}
    {% endfor %}
    
    {% for resource in resources %}
    async def {{ resource.name }}(self, {% for param in resource.parameters %}{{ param.name }}: {{ param.type }}{% if not loop.last %}, {% endif %}{% endfor %}) -> {{ resource.returns.type }}:
        """{{ resource.description }}
        
        {% for param in resource.parameters %}
        Args:
            {{ param.name }}: {{ param.description }}
        {% endfor %}
        
        Returns:
            {{ resource.returns.description }}
        """
        # Implementation goes here
        logger.info(f"Processing {{ resource.name }} request")
        
        {% if resource.name.startswith('get_') and resource.parameters|length == 1 and resource.parameters[0].name.endswith('_id') %}
        # Get item by ID
        item_id = {{ resource.parameters[0].name }}
        if item_id not in self.db:
            raise ValueError(f"Item {item_id} not found")
        
        return self.db[item_id]
        {% else %}
        # Example implementation
        result = {
            {% for param in resource.parameters %}
            "{{ param.name }}": {{ param.name }}{% if not loop.last %},{% endif %}
            {% endfor %}
        }
        
        return result
        {% endif %}
    {% endfor %}

# Create service instance
service = {{ service_name|replace(' ', '') }}Service()

#
# APPROACH 1: FastAPI with FastAPI-MCP
#

# Create FastAPI app for direct API-to-MCP conversion
fastapi_app = FastAPI(
    title="{{ service_name }} Direct API",
    description="{{ service_description }} (Direct API-to-MCP)",
    version="{{ version }}",
    docs_url="/direct/docs",
    openapi_url="/direct/openapi.json"
)

# Add CORS middleware
fastapi_app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Create router for direct API
direct_router = APIRouter(prefix="/direct")

# Define direct API endpoints
{% for endpoint in endpoints %}
@direct_router.{{ endpoint.method|lower }}("{{ endpoint.path }}", tags=["direct", "{{ endpoint.name }}"])
async def direct_{{ endpoint.name }}(
    {% for param in endpoint.parameters %}
    {{ param.name }}: {{ param.type }}{% if not loop.last %}, {% endif %}
    {% endfor %}
):
    """{{ endpoint.description }} (Direct API)"""
    try:
        return await service.{{ endpoint.name }}({% for param in endpoint.parameters %}{{ param.name }}{% if not loop.last %}, {% endif %}{% endfor %})
    except ValueError as e:
        raise HTTPException(status_code=404, detail=str(e))
    except Exception as e:
        logger.error(f"Error in direct_{{ endpoint.name }}: {e}")
        raise HTTPException(status_code=500, detail=str(e))
{% endfor %}

# Include direct router in app
fastapi_app.include_router(direct_router)

# Create MCP server from FastAPI app
direct_mcp = FastApiMCP(fastapi_app)

# Mount MCP server to FastAPI app
direct_mcp.mount()

#
# APPROACH 2: FastMCP with FastAPI Generation
#

# Create FastMCP server
fastmcp_server = FastMCP("{{ service_name }} Native MCP")

# Define MCP tools
{% for tool in tools %}
@fastmcp_server.tool()
async def native_{{ tool.name }}({% for param in tool.parameters %}{{ param.name }}: {{ param.type }}{% if not loop.last %}, {% endif %}{% endfor %}) -> {{ tool.returns.type }}:
    """{{ tool.description }} (Native MCP)
    
    {% for param in tool.parameters %}
    Args:
        {{ param.name }}: {{ param.description }}
    {% endfor %}
    
    Returns:
        {{ tool.returns.description }}
    """
    return await service.{{ tool.name }}({% for param in tool.parameters %}{{ param.name }}{% if not loop.last %}, {% endif %}{% endfor %})
{% endfor %}

# Define MCP resources
{% for resource in resources %}
@fastmcp_server.resource("native+{{ resource.uri }}")
async def native_{{ resource.name }}({% for param in resource.parameters %}{{ param.name }}: {{ param.type }}{% if not loop.last %}, {% endif %}{% endfor %}) -> {{ resource.returns.type }}:
    """{{ resource.description }} (Native MCP)
    
    {% for param in resource.parameters %}
    Args:
        {{ param.name }}: {{ param.description }}
    {% endfor %}
    
    Returns:
        {{ resource.returns.description }}
    """
    return await service.{{ resource.name }}({% for param in resource.parameters %}{{ param.name }}{% if not loop.last %}, {% endif %}{% endfor %})
{% endfor %}

# Generate FastAPI app from FastMCP
native_app = FastMCP.from_fastmcp(fastmcp_server)
native_app.title = "{{ service_name }} Native MCP API"
native_app.description = "{{ service_description }} (Native MCP-to-API)"
native_app.version = "{{ version }}"
native_app.docs_url = "/native/docs"
native_app.openapi_url = "/native/openapi.json"

# Create router for native API
for route in native_app.routes:
    if hasattr(route, "path") and isinstance(route.path, str):
        route.path = "/native" + route.path

#
# APPROACH 3: FastAPI with open-webui-mcp
#

# Create FastAPI app for proxied API
proxy_app = FastAPI(
    title="{{ service_name }} Proxied API",
    description="{{ service_description }} (Proxied API-to-MCP)",
    version="{{ version }}",
    docs_url="/proxy/docs",
    openapi_url="/proxy/openapi.json"
)

# Add CORS middleware
proxy_app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Create router for proxied API
proxy_router = APIRouter(prefix="/proxy")

# Define proxied API endpoints
{% for endpoint in endpoints %}
@proxy_router.{{ endpoint.method|lower }}("{{ endpoint.path }}", tags=["proxy", "{{ endpoint.name }}"])
async def proxy_{{ endpoint.name }}(
    {% for param in endpoint.parameters %}
    {{ param.name }}: {{ param.type }}{% if not loop.last %}, {% endif %}
    {% endfor %}
):
    """{{ endpoint.description }} (Proxied API)"""
    try:
        return await service.{{ endpoint.name }}({% for param in endpoint.parameters %}{{ param.name }}{% if not loop.last %}, {% endif %}{% endfor %})
    except ValueError as e:
        raise HTTPException(status_code=404, detail=str(e))
    except Exception as e:
        logger.error(f"Error in proxy_{{ endpoint.name }}: {e}")
        raise HTTPException(status_code=500, detail=str(e))
{% endfor %}

# Include proxy router in app
proxy_app.include_router(proxy_router)

# Create MCP server script for open-webui-mcp
def create_mcp_server_script():
    """Create a Python script for the MCP server."""
    script_content = """#!/usr/bin/env python3
import json
import sys
import logging
import requests

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    filename="mcp_server.log"
)
logger = logging.getLogger(__name__)

# Define MCP server
server_info = {
    "name": "{{ service_name }} Proxied MCP",
    "version": "{{ version }}"
}

# Define tools
tools = [
    {% for tool in tools %}
    {
        "name": "proxied_{{ tool.name }}",
        "description": "{{ tool.description }} (Proxied MCP)",
        "parameters": {
            {% for param in tool.parameters %}
            "{{ param.name }}": {
                "type": "{{ param.type }}",
                "description": "{{ param.description }}"
            }{% if not loop.last %},{% endif %}
            {% endfor %}
        }
    }{% if not loop.last %},{% endif %}
    {% endfor %}
]

# Define resources
resources = []

# Define prompts
prompts = []

# Initialize server
print(json.dumps({"type": "server_info", "server_info": server_info}))
sys.stdout.flush()

# API base URL
API_BASE_URL = "http://localhost:8000/proxy"

# Main loop
while True:
    try:
        line = sys.stdin.readline()
        if not line:
            break
            
        request = json.loads(line)
        request_type = request.get("type")
        request_id = request.get("request_id")
        
        if request_type == "list_tools":
            response = {
                "type": "list_tools_response",
                "request_id": request_id,
                "tools": tools
            }
            print(json.dumps(response))
            sys.stdout.flush()
            
        elif request_type == "list_resources":
            response = {
                "type": "list_resources_response",
                "request_id": request_id,
                "resources": resources
            }
            print(json.dumps(response))
            sys.stdout.flush()
            
        elif request_type == "list_prompts":
            response = {
                "type": "list_prompts_response",
                "request_id": request_id,
                "prompts": prompts
            }
            print(json.dumps(response))
            sys.stdout.flush()
            
        elif request_type == "call_tool":
            tool_name = request.get("name")
            parameters = request.get("parameters", {})
            
            # Process tool call
            logger.info(f"Tool call: {tool_name} with parameters {parameters}")
            
            # Map MCP tool names to API endpoints
            tool_to_endpoint = {
                {% for tool in tools %}
                "proxied_{{ tool.name }}": f"{API_BASE_URL}{{ endpoints|selectattr('name', 'equalto', tool.name)|map(attribute='path')|first }}"{% if not loop.last %},{% endif %}
                {% endfor %}
            }
            
            # Map MCP tool names to HTTP methods
            tool_to_method = {
                {% for tool in tools %}
                "proxied_{{ tool.name }}": "{{ endpoints|selectattr('name', 'equalto', tool.name)|map(attribute='method')|first }}"{% if not loop.last %},{% endif %}
                {% endfor %}
            }
            
            endpoint = tool_to_endpoint.get(tool_name)
            method = tool_to_method.get(tool_name)
            
            if endpoint and method:
                # Replace path parameters in the endpoint URL
                for param_name, param_value in parameters.items():
                    if "{" + param_name + "}" in endpoint:
                        endpoint = endpoint.replace("{" + param_name + "}", str(param_value))
                
                # Make the API request
                if method == "GET":
                    # For GET requests, add query parameters
                    query_params = {k: v for k, v in parameters.items() if "{" + k + "}" not in endpoint}
                    api_response = requests.get(endpoint, params=query_params)
                elif method == "POST":
                    api_response = requests.post(endpoint, json=parameters)
                elif method == "PUT":
                    api_response = requests.put(endpoint, json=parameters)
                elif method == "DELETE":
                    api_response = requests.delete(endpoint)
                else:
                    raise ValueError(f"Unsupported method: {method}")
                
                # Check if the request was successful
                if api_response.status_code >= 200 and api_response.status_code < 300:
                    result = api_response.json()
                    
                    response = {
                        "type": "call_tool_response",
                        "request_id": request_id,
                        "result": result
                    }
                    print(json.dumps(response))
                    sys.stdout.flush()
                else:
                    error_msg = f"API request failed with status code {api_response.status_code}: {api_response.text}"
                    logger.error(error_msg)
                    response = {
                        "type": "error",
                        "request_id": request_id,
                        "error": error_msg
                    }
                    print(json.dumps(response))
                    sys.stdout.flush()
            else:
                response = {
                    "type": "error",
                    "request_id": request_id,
                    "error": f"Unknown tool: {tool_name}"
                }
                print(json.dumps(response))
                sys.stdout.flush()
                
        elif request_type == "ping":
            response = {
                "type": "pong",
                "request_id": request_id
            }
            print(json.dumps(response))
            sys.stdout.flush()
            
    except Exception as e:
        logger.error(f"Error processing request: {e}")
        response = {
            "type": "error",
            "request_id": request_id if 'request_id' in locals() else None,
            "error": str(e)
        }
        print(json.dumps(response))
        sys.stdout.flush()
"""
    
    # Create a temporary file for the script
    fd, path = tempfile.mkstemp(suffix='.py')
    with os.fdopen(fd, 'w') as f:
        f.write(script_content)
    
    # Make the script executable
    os.chmod(path, 0o755)
    
    return path

# Create MCP config file
def create_mcp_config(script_path):
    """Create a config file for open-webui-mcp."""
    config = {
        "mcpServers": {
            "{{ service_name|lower|replace(' ', '_') }}_proxied": {
                "command": "python",
                "args": [script_path]
            }
        }
    }
    
    # Create a temporary file for the config
    fd, path = tempfile.mkstemp(suffix='.json')
    with os.fdopen(fd, 'w') as f:
        json.dump(config, f, indent=2)
    
    return path

#
# INTEGRATED APP
#

# Create the main FastAPI app that combines all approaches
app = FastAPI(
    title="{{ service_name }} Integrated API",
    description="{{ service_description }} (Integrated API with all MCP approaches)",
    version="{{ version }}"
)

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Create a router for the root API
root_router = APIRouter()

@root_router.get("/", tags=["root"])
async def root():
    """Root endpoint for the integrated API."""
    return {
        "name": "{{ service_name }} Integrated API",
        "description": "{{ service_description }} (Integrated API with all MCP approaches)",
        "version": "{{ version }}",
        "approaches": [
            {
                "name": "Direct API-to-MCP",
                "description": "FastAPI with FastAPI-MCP for direct API-to-MCP conversion",
                "api_prefix": "/direct",
                "docs_url": "/direct/docs"
            },
            {
                "name": "Native MCP-to-API",
                "description": "FastMCP with FastAPI generation for MCP-first design",
                "api_prefix": "/native",
                "docs_url": "/native/docs"
            },
            {
                "name": "Proxied API-to-MCP",
                "description": "FastAPI with open-webui-mcp for secure, proxied MCP access",
                "api_prefix": "/proxy",
                "docs_url": "/proxy/docs"
            }
        ]
    }

# Include the root router
app.include_router(root_router)

# Mount the direct API app
@app.middleware("http")
async def route_direct_requests(request: Request, call_next):
    """Route requests to the direct API app."""
    if request.url.path.startswith("/direct"):
        # Forward the request to the direct API app
        scope = request.scope.copy()
        scope["path"] = scope["path"][len("/direct"):]
        if scope["path"] == "":
            scope["path"] = "/"
        scope["raw_path"] = scope["path"].encode()
        
        response = await fastapi_app(scope, request._receive, request._send)
        return response
    
    # Continue with the normal request handling
    return await call_next(request)

# Mount the native API app
@app.middleware("http")
async def route_native_requests(request: Request, call_next):
    """Route requests to the native API app."""
    if request.url.path.startswith("/native"):
        # Forward the request to the native API app
        scope = request.scope.copy()
        scope["path"] = scope["path"][len("/native"):]
        if scope["path"] == "":
            scope["path"] = "/"
        scope["raw_path"] = scope["path"].encode()
        
        response = await native_app(scope, request._receive, request._send)
        return response
    
    # Continue with the normal request handling
    return await call_next(request)

# Mount the proxy API app
@app.middleware("http")
async def route_proxy_requests(request: Request, call_next):
    """Route requests to the proxy API app."""
    if request.url.path.startswith("/proxy"):
        # Forward the request to the proxy API app
        scope = request.scope.copy()
        scope["path"] = scope["path"][len("/proxy"):]
        if scope["path"] == "":
            scope["path"] = "/"
        scope["raw_path"] = scope["path"].encode()
        
        response = await proxy_app(scope, request._receive, request._send)
        return response
    
    # Continue with the normal request handling
    return await call_next(request)

# Start MCP servers
def start_direct_mcp_server():
    """Start the direct MCP server."""
    asyncio.run(fastmcp_server.run_async(transport="sse", port=8001))

def start_native_mcp_server():
    """Start the native MCP server."""
    asyncio.run(fastmcp_server.run_async(transport="sse", port=8002))

def start_proxy_mcp_server(api_key: str = "top-secret", port: int = 8003):
    """Start the proxy MCP server using open-webui-mcp."""
    script_path = create_mcp_server_script()
    config_path = create_mcp_config(script_path)
    
    # Start the MCP server
    cmd = [
        "mcpo",
        "--port", str(port),
        "--api-key", api_key,
        "--config", config_path
    ]
    
    # Start the process
    process = subprocess.Popen(
        cmd,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True
    )
    
    logger.info(f"Started proxy MCP server on port {port}")
    return process, script_path, config_path

def start_server(host: str = "0.0.0.0", port: int = 8000):
    """Start the integrated server.
    
    Args:
        host: Host to bind to
        port: Port to bind to for the main API
    """
    # Start direct MCP server in a separate thread
    direct_thread = threading.Thread(target=start_direct_mcp_server)
    direct_thread.daemon = True
    direct_thread.start()
    
    # Start native MCP server in a separate thread
    native_thread = threading.Thread(target=start_native_mcp_server)
    native_thread.daemon = True
    native_thread.start()
    
    # Start proxy MCP server in a separate process
    proxy_process, script_path, config_path = start_proxy_mcp_server(port=8003)
    
    try:
        # Start the main FastAPI server
        uvicorn.run(app, host=host, port=port)
    finally:
        # Clean up proxy MCP server process
        proxy_process.terminate()
        proxy_process.wait()
        
        # Clean up temporary files
        try:
            os.remove(script_path)
            os.remove(config_path)
        except Exception as e:
            logger.error(f"Error cleaning up temporary files: {e}")

if __name__ == "__main__":
    start_server()
