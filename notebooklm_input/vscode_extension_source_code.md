# VS Code Extension: Source



---

### File: `scripts/package-extension.js`

```javascript
#!/usr/bin/env node

const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

// Ensure the scripts directory exists
const scriptsDir = path.join(__dirname);
if (!fs.existsSync(scriptsDir)) {
  fs.mkdirSync(scriptsDir, { recursive: true });
}

// Function to execute shell commands
function executeCommand(command) {
  console.log(`Executing: ${command}`);
  try {
    execSync(command, { stdio: 'inherit' });
  } catch (error) {
    console.error(`Error executing command: ${command}`);
    console.error(error);
    process.exit(1);
  }
}

// Main function
function packageExtension() {
  console.log('Packaging VS Code Extension...');
  
  // Check if vsce is installed
  try {
    execSync('which vsce', { stdio: 'ignore' });
  } catch (error) {
    console.log('vsce not found, installing...');
    executeCommand('npm install -g @vscode/vsce');
  }
  
  // Clean the out directory
  console.log('Cleaning output directory...');
  if (fs.existsSync('out')) {
    fs.rmSync('out', { recursive: true, force: true });
  }
  
  // Compile the TypeScript code
  console.log('Compiling TypeScript...');
  executeCommand('npm run compile');
  
  // Run linting
  console.log('Running linting...');
  executeCommand('npm run lint');
  
  // Package the extension
  console.log('Creating VSIX package...');
  executeCommand('vsce package');
  
  console.log('Extension packaging complete!');
}

// Run the main function
packageExtension();

```


---

### File: `out/contextProvider.js`

```javascript
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.getEditorContext = getEditorContext;
exports.getProjectContext = getProjectContext;
exports.getContextForFile = getContextForFile;
exports.getContextForSymbol = getContextForSymbol;
exports.initializeContextEngine = initializeContextEngine;
exports.disposeContextEngine = disposeContextEngine;
const path = __importStar(require("path"));
const vscode = __importStar(require("vscode"));
const contextEngine_1 = require("./context/contextEngine");
// Create a singleton instance of the context engine
const contextEngine = new contextEngine_1.ContextEngine();
async function getEditorContext() {
    const editor = vscode.window.activeTextEditor;
    if (!editor) {
        return null;
    }
    const document = editor.document;
    const selection = editor.selection;
    const selectedText = document.getText(selection);
    const fullText = document.getText();
    const fileName = path.basename(document.fileName);
    const fileExtension = path.extname(document.fileName).substring(1);
    const language = document.languageId;
    // Get visible range text
    const visibleRanges = editor.visibleRanges;
    let visibleText = '';
    for (const range of visibleRanges) {
        visibleText += document.getText(range) + '\n';
    }
    return {
        selectedCode: selectedText,
        fullDocumentText: fullText,
        fileName,
        fileExtension,
        language,
        selection: selection.isEmpty ? null : selection,
        visibleRangeText: visibleText
    };
}
async function getProjectContext(query = '', maxTokens = 4000) {
    try {
        // Initialize the context engine if it hasn't been initialized yet
        if (!contextEngine) {
            return "Context engine not available";
        }
        // Get context from the context engine
        return await contextEngine.getContext(query, maxTokens);
    }
    catch (error) {
        console.error('Error getting project context:', error);
        return `Error getting project context: ${error instanceof Error ? error.message : String(error)}`;
    }
}
async function getContextForFile(filePath, maxTokens = 4000) {
    try {
        // Initialize the context engine if it hasn't been initialized yet
        if (!contextEngine) {
            return "Context engine not available";
        }
        // Get context for the file
        return await contextEngine.getContextForFile(filePath, maxTokens);
    }
    catch (error) {
        console.error('Error getting file context:', error);
        return `Error getting file context: ${error instanceof Error ? error.message : String(error)}`;
    }
}
async function getContextForSymbol(symbol, maxTokens = 4000) {
    try {
        // Initialize the context engine if it hasn't been initialized yet
        if (!contextEngine) {
            return "Context engine not available";
        }
        // Get context for the symbol
        return await contextEngine.getContextForSymbol(symbol, maxTokens);
    }
    catch (error) {
        console.error('Error getting symbol context:', error);
        return `Error getting symbol context: ${error instanceof Error ? error.message : String(error)}`;
    }
}
async function initializeContextEngine() {
    try {
        await contextEngine.initialize();
    }
    catch (error) {
        console.error('Error initializing context engine:', error);
    }
}
async function disposeContextEngine() {
    try {
        await contextEngine.dispose();
    }
    catch (error) {
        console.error('Error disposing context engine:', error);
    }
}
//# sourceMappingURL=contextProvider.js.map
```


---

### File: `out/qwenApi.js`

```javascript
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.QwenApiClient = void 0;
const axios_1 = __importDefault(require("axios"));
const cache_1 = require("./cache");
const errorHandler_1 = require("./errorHandler");
class QwenApiClient {
    constructor(config) {
        this.config = config;
        this.client = axios_1.default.create({
            baseURL: config.apiEndpoint,
            headers: config.apiKey ? {
                'Authorization': `Bearer ${config.apiKey}`,
                'Content-Type': 'application/json'
            } : {
                'Content-Type': 'application/json'
            }
        });
        this.cache = cache_1.ResponseCache.getInstance();
    }
    updateConfig(config) {
        this.config = config;
        this.client = axios_1.default.create({
            baseURL: config.apiEndpoint,
            headers: config.apiKey ? {
                'Authorization': `Bearer ${config.apiKey}`,
                'Content-Type': 'application/json'
            } : {
                'Content-Type': 'application/json'
            }
        });
        // Update cache configuration if provided
        if (config.cacheTTLMinutes && config.cacheMaxEntries) {
            this.cache.configure(config.cacheMaxEntries, config.cacheTTLMinutes);
        }
    }
    async generateCompletion(options) {
        // Check cache first (unless skipCache is true)
        if (!options.skipCache) {
            const cacheKey = (0, cache_1.generateCacheKey)(options.prompt, {
                systemPrompt: options.systemPrompt,
                maxTokens: options.maxTokens || this.config.maxTokens,
                temperature: options.temperature || this.config.temperature
            });
            const cachedResponse = this.cache.get(cacheKey);
            if (cachedResponse) {
                console.log('Using cached response for prompt:', options.prompt.substring(0, 50) + '...');
                return {
                    ...cachedResponse,
                    cached: true
                };
            }
        }
        try {
            // Set timeout for the request
            const timeoutMs = 30000; // 30 seconds timeout
            const response = await this.client.post('/chat/completions', {
                model: 'qwen3-coder',
                messages: [
                    ...(options.systemPrompt ? [{ role: 'system', content: options.systemPrompt }] : []),
                    { role: 'user', content: options.prompt }
                ],
                max_tokens: options.maxTokens || this.config.maxTokens,
                temperature: options.temperature || this.config.temperature
            }, { timeout: timeoutMs });
            const result = {
                text: response.data.choices[0].message.content,
                usage: response.data.usage
            };
            // Cache the response (unless skipCache is true)
            if (!options.skipCache) {
                const cacheKey = (0, cache_1.generateCacheKey)(options.prompt, {
                    systemPrompt: options.systemPrompt,
                    maxTokens: options.maxTokens || this.config.maxTokens,
                    temperature: options.temperature || this.config.temperature
                });
                this.cache.set(cacheKey, result);
            }
            return result;
        }
        catch (error) {
            // Use the error handler to process the error
            const errorDetails = errorHandler_1.ErrorHandler.processError(error);
            console.error(`Error calling Qwen API: ${errorDetails.type}`, error);
            // Throw a more informative error
            throw new Error(errorDetails.message);
        }
    }
    /**
     * Generate a streaming completion
     * @param options Request options
     * @param onChunk Callback function to handle streaming chunks
     */
    async generateStreamingCompletion(options, onChunk) {
        // Streaming responses can't be cached, so we don't check the cache
        try {
            // Set timeout for the request
            const timeoutMs = 60000; // 60 seconds timeout for streaming
            const response = await this.client.post('/chat/completions', {
                model: 'qwen3-coder',
                messages: [
                    ...(options.systemPrompt ? [{ role: 'system', content: options.systemPrompt }] : []),
                    { role: 'user', content: options.prompt }
                ],
                max_tokens: options.maxTokens || this.config.maxTokens,
                temperature: options.temperature || this.config.temperature,
                stream: true
            }, {
                timeout: timeoutMs,
                responseType: 'stream'
            });
            // Process the streaming response
            const stream = response.data;
            stream.on('data', (chunk) => {
                try {
                    const lines = chunk.toString().split('\n').filter(line => line.trim() !== '');
                    for (const line of lines) {
                        // Skip empty lines and "data: [DONE]" messages
                        if (!line || line === 'data: [DONE]') {
                            continue;
                        }
                        // Remove the "data: " prefix
                        const jsonStr = line.replace(/^data: /, '');
                        try {
                            const json = JSON.parse(jsonStr);
                            if (json.choices && json.choices[0] && json.choices[0].delta && json.choices[0].delta.content) {
                                const content = json.choices[0].delta.content;
                                onChunk(content, false);
                            }
                        }
                        catch (parseError) {
                            console.error('Error parsing streaming response JSON:', parseError);
                        }
                    }
                }
                catch (error) {
                    console.error('Error processing stream chunk:', error);
                }
            });
            stream.on('end', () => {
                onChunk('', true); // Signal that streaming is complete
            });
            stream.on('error', (error) => {
                const errorDetails = errorHandler_1.ErrorHandler.processError(error);
                console.error(`Error in stream: ${errorDetails.type}`, error);
                throw new Error(errorDetails.message);
            });
        }
        catch (error) {
            // Use the error handler to process the error
            const errorDetails = errorHandler_1.ErrorHandler.processError(error);
            console.error(`Error setting up streaming: ${errorDetails.type}`, error);
            // Signal error to the handler
            onChunk(`Error: ${errorDetails.message}`, true);
            // Throw a more informative error
            throw new Error(errorDetails.message);
        }
    }
    /**
     * Chat with Qwen using messages
     * @param messages Array of messages
     * @param options Chat options
     * @returns Promise that resolves to the response text
     */
    async chat(messages, options = {}) {
        // Check cache first (unless skipCache is true)
        if (!options.skipCache) {
            const cacheKey = (0, cache_1.generateCacheKey)(JSON.stringify(messages), {
                enableThinking: options.enableThinking,
                temperature: options.temperature || this.config.temperature,
                maxTokens: options.maxTokens || this.config.maxTokens,
                modelName: options.modelName || 'qwen3-coder'
            });
            const cachedResponse = this.cache.get(cacheKey);
            if (cachedResponse) {
                console.log('Using cached response for chat');
                return cachedResponse.text;
            }
        }
        try {
            // Set timeout for the request
            const timeoutMs = 60000; // 60 seconds timeout for chat
            // Add thinking mode if enabled
            let systemMessage = messages.find(m => m.role === 'system');
            if (options.enableThinking && systemMessage) {
                systemMessage.content = `${systemMessage.content}\n\nWhen solving complex problems, use <think></think> tags to show your reasoning process.`;
            }
            const response = await this.client.post('/chat/completions', {
                model: options.modelName || 'qwen3-coder',
                messages,
                max_tokens: options.maxTokens || this.config.maxTokens,
                temperature: options.temperature || this.config.temperature
            }, { timeout: timeoutMs });
            const result = {
                text: response.data.choices[0].message.content,
                usage: response.data.usage
            };
            // Cache the response (unless skipCache is true)
            if (!options.skipCache) {
                const cacheKey = (0, cache_1.generateCacheKey)(JSON.stringify(messages), {
                    enableThinking: options.enableThinking,
                    temperature: options.temperature || this.config.temperature,
                    maxTokens: options.maxTokens || this.config.maxTokens,
                    modelName: options.modelName || 'qwen3-coder'
                });
                this.cache.set(cacheKey, result);
            }
            return result.text;
        }
        catch (error) {
            // Use the error handler to process the error
            const errorDetails = errorHandler_1.ErrorHandler.processError(error);
            console.error(`Error calling Qwen API chat: ${errorDetails.type}`, error);
            // Throw a more informative error
            throw new Error(errorDetails.message);
        }
    }
    /**
     * Chat with Qwen using messages with streaming response
     * @param messages Array of messages
     * @param options Chat options
     * @param onChunk Callback function to handle streaming chunks
     */
    async chatStream(messages, options = {}, onChunk) {
        try {
            // Set timeout for the request
            const timeoutMs = 60000; // 60 seconds timeout for streaming
            // Add thinking mode if enabled
            let systemMessage = messages.find(m => m.role === 'system');
            if (options.enableThinking && systemMessage) {
                systemMessage.content = `${systemMessage.content}\n\nWhen solving complex problems, use <think></think> tags to show your reasoning process.`;
            }
            const response = await this.client.post('/chat/completions', {
                model: options.modelName || 'qwen3-coder',
                messages,
                max_tokens: options.maxTokens || this.config.maxTokens,
                temperature: options.temperature || this.config.temperature,
                stream: true
            }, {
                timeout: timeoutMs,
                responseType: 'stream'
            });
            // Process the streaming response
            const stream = response.data;
            stream.on('data', (chunk) => {
                try {
                    const lines = chunk.toString().split('\n').filter(line => line.trim() !== '');
                    for (const line of lines) {
                        // Skip empty lines and "data: [DONE]" messages
                        if (!line || line === 'data: [DONE]') {
                            continue;
                        }
                        // Remove the "data: " prefix
                        const jsonStr = line.replace(/^data: /, '');
                        try {
                            const json = JSON.parse(jsonStr);
                            if (json.choices && json.choices[0] && json.choices[0].delta && json.choices[0].delta.content) {
                                const content = json.choices[0].delta.content;
                                onChunk(content, false);
                            }
                        }
                        catch (parseError) {
                            console.error('Error parsing streaming response JSON:', parseError);
                        }
                    }
                }
                catch (error) {
                    console.error('Error processing stream chunk:', error);
                }
            });
            stream.on('end', () => {
                onChunk('', true); // Signal that streaming is complete
            });
            stream.on('error', (error) => {
                const errorDetails = errorHandler_1.ErrorHandler.processError(error);
                console.error(`Error in stream: ${errorDetails.type}`, error);
                throw new Error(errorDetails.message);
            });
        }
        catch (error) {
            // Use the error handler to process the error
            const errorDetails = errorHandler_1.ErrorHandler.processError(error);
            console.error(`Error setting up streaming chat: ${errorDetails.type}`, error);
            // Signal error to the handler
            onChunk(`Error: ${errorDetails.message}`, true);
            // Throw a more informative error
            throw new Error(errorDetails.message);
        }
    }
    /**
     * Chat with Qwen using messages and tools
     * @param messages Array of messages
     * @param options Chat options including tools
     * @returns Promise that resolves to the response with possible tool calls
     */
    async chatWithTools(messages, options = {}) {
        // Check cache first (unless skipCache is true)
        if (!options.skipCache) {
            const cacheKey = (0, cache_1.generateCacheKey)(JSON.stringify(messages), {
                enableThinking: options.enableThinking,
                thinkingMode: options.thinkingMode,
                thinkingBudget: options.thinkingBudget,
                temperature: options.temperature || this.config.temperature,
                maxTokens: options.maxTokens || this.config.maxTokens,
                modelName: options.modelName || 'qwen3-coder',
                tools: options.tools ? JSON.stringify(options.tools) : undefined
            });
            const cachedResponse = this.cache.get(cacheKey);
            if (cachedResponse) {
                console.log('Using cached response for chat with tools');
                return cachedResponse;
            }
        }
        try {
            // Set timeout for the request
            const timeoutMs = 60000; // 60 seconds timeout for chat with tools
            // Apply thinking mode
            let systemMessage = messages.find(m => m.role === 'system');
            this._applyThinkingMode(systemMessage, options);
            // Prepare the request payload
            const payload = {
                model: options.modelName || 'qwen3-coder',
                messages,
                max_tokens: options.maxTokens || this.config.maxTokens,
                temperature: options.temperature || this.config.temperature
            };
            // Add tools if provided
            if (options.tools && options.tools.length > 0) {
                payload.tools = options.tools;
            }
            const response = await this.client.post('/chat/completions', payload, { timeout: timeoutMs });
            // Extract tool calls if present
            const toolCalls = response.data.choices[0].message.tool_calls || [];
            const result = {
                text: response.data.choices[0].message.content,
                tool_calls: toolCalls.length > 0 ? toolCalls : undefined,
                usage: response.data.usage
            };
            // Cache the response (unless skipCache is true)
            if (!options.skipCache) {
                const cacheKey = (0, cache_1.generateCacheKey)(JSON.stringify(messages), {
                    enableThinking: options.enableThinking,
                    thinkingMode: options.thinkingMode,
                    thinkingBudget: options.thinkingBudget,
                    temperature: options.temperature || this.config.temperature,
                    maxTokens: options.maxTokens || this.config.maxTokens,
                    modelName: options.modelName || 'qwen3-coder',
                    tools: options.tools ? JSON.stringify(options.tools) : undefined
                });
                this.cache.set(cacheKey, result);
            }
            return result;
        }
        catch (error) {
            // Use the error handler to process the error
            const errorDetails = errorHandler_1.ErrorHandler.processError(error);
            console.error(`Error calling Qwen API chat with tools: ${errorDetails.type}`, error);
            // Throw a more informative error
            throw new Error(errorDetails.message);
        }
    }
    /**
     * Chat with Qwen using messages and tools with streaming response
     * @param messages Array of messages
     * @param options Chat options including tools
     * @param onChunk Callback function to handle streaming chunks
     */
    async chatStreamWithTools(messages, options = {}, onChunk) {
        try {
            // Set timeout for the request
            const timeoutMs = 60000; // 60 seconds timeout for streaming
            // Apply thinking mode
            let systemMessage = messages.find(m => m.role === 'system');
            this._applyThinkingMode(systemMessage, options);
            // Prepare the request payload
            const payload = {
                model: options.modelName || 'qwen3-coder',
                messages,
                max_tokens: options.maxTokens || this.config.maxTokens,
                temperature: options.temperature || this.config.temperature,
                stream: true
            };
            // Add tools if provided
            if (options.tools && options.tools.length > 0) {
                payload.tools = options.tools;
            }
            const response = await this.client.post('/chat/completions', payload, {
                timeout: timeoutMs,
                responseType: 'stream'
            });
            // Process the streaming response
            const stream = response.data;
            let toolCalls = [];
            stream.on('data', (chunk) => {
                try {
                    const lines = chunk.toString().split('\n').filter(line => line.trim() !== '');
                    for (const line of lines) {
                        // Skip empty lines and "data: [DONE]" messages
                        if (!line || line === 'data: [DONE]') {
                            continue;
                        }
                        // Remove the "data: " prefix
                        const jsonStr = line.replace(/^data: /, '');
                        try {
                            const json = JSON.parse(jsonStr);
                            // Handle content
                            if (json.choices && json.choices[0] && json.choices[0].delta && json.choices[0].delta.content) {
                                const content = json.choices[0].delta.content;
                                onChunk(content, false);
                            }
                            // Handle tool calls
                            if (json.choices && json.choices[0] && json.choices[0].delta && json.choices[0].delta.tool_calls) {
                                // Process tool calls
                                for (const toolCallDelta of json.choices[0].delta.tool_calls) {
                                    // Find existing tool call or create a new one
                                    let toolCall = toolCalls.find(tc => tc.id === toolCallDelta.id);
                                    if (!toolCall) {
                                        // Create a new tool call
                                        toolCall = {
                                            id: toolCallDelta.id,
                                            type: 'function',
                                            function: {
                                                name: toolCallDelta.function?.name || '',
                                                arguments: toolCallDelta.function?.arguments || ''
                                            }
                                        };
                                        toolCalls.push(toolCall);
                                    }
                                    else {
                                        // Update existing tool call
                                        if (toolCallDelta.function?.name) {
                                            toolCall.function.name = toolCallDelta.function.name;
                                        }
                                        if (toolCallDelta.function?.arguments) {
                                            toolCall.function.arguments += toolCallDelta.function.arguments;
                                        }
                                    }
                                    // Notify about the tool call
                                    onChunk('', false, toolCall);
                                }
                            }
                        }
                        catch (parseError) {
                            console.error('Error parsing streaming response JSON:', parseError);
                        }
                    }
                }
                catch (error) {
                    console.error('Error processing stream chunk:', error);
                }
            });
            stream.on('end', () => {
                onChunk('', true); // Signal that streaming is complete
            });
            stream.on('error', (error) => {
                const errorDetails = errorHandler_1.ErrorHandler.processError(error);
                console.error(`Error in stream: ${errorDetails.type}`, error);
                throw new Error(errorDetails.message);
            });
        }
        catch (error) {
            // Use the error handler to process the error
            const errorDetails = errorHandler_1.ErrorHandler.processError(error);
            console.error(`Error setting up streaming chat with tools: ${errorDetails.type}`, error);
            // Signal error to the handler
            onChunk(`Error: ${errorDetails.message}`, true);
            // Throw a more informative error
            throw new Error(errorDetails.message);
        }
    }
    /**
     * Apply thinking mode to the system message based on options
     * @param systemMessage The system message to modify
     * @param options Chat options
     */
    _applyThinkingMode(systemMessage, options) {
        if (!systemMessage) {
            return;
        }
        // Handle legacy enableThinking option
        if (options.enableThinking !== undefined) {
            if (options.enableThinking) {
                systemMessage.content = `${systemMessage.content}\n\nWhen solving complex problems, use <think></think> tags to show your reasoning process.`;
            }
            return;
        }
        // Handle new thinkingMode option
        if (options.thinkingMode) {
            switch (options.thinkingMode) {
                case 'always':
                    systemMessage.content = `${systemMessage.content}\n\nAlways use <think></think> tags to show your reasoning process for all problems.`;
                    break;
                case 'auto':
                    systemMessage.content = `${systemMessage.content}\n\nWhen solving complex problems, use <think></think> tags to show your reasoning process. For simple tasks, respond directly.`;
                    if (options.thinkingBudget) {
                        systemMessage.content += `\n\nLimit your thinking to approximately ${options.thinkingBudget} tokens.`;
                    }
                    break;
                case 'never':
                    // No thinking tags
                    break;
            }
        }
    }
    /**
     * Clear the response cache
     */
    clearCache() {
        this.cache.clear();
    }
}
exports.QwenApiClient = QwenApiClient;
//# sourceMappingURL=qwenApi.js.map
```


---

### File: `out/commands.js`

```javascript
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.registerCommands = registerCommands;
const vscode = __importStar(require("vscode"));
const configuration_1 = require("./configuration");
const contextProvider_1 = require("./contextProvider");
const errorHandler_1 = require("./errorHandler");
const responseFormatter_1 = require("./responseFormatter");
function registerCommands(context, apiClient, agentCoordinator, mcpClient) {
    // Register the "Ask Qwen" command
    const askQwenCommand = vscode.commands.registerCommand('qwen-coder-assistant.askQwen', async () => {
        const userPrompt = await vscode.window.showInputBox({
            prompt: 'What would you like to ask Qwen?',
            placeHolder: 'E.g., How do I implement a binary search in JavaScript?'
        });
        if (!userPrompt) {
            return; // User cancelled
        }
        try {
            vscode.window.withProgress({
                location: vscode.ProgressLocation.Notification,
                title: 'Asking Qwen...',
                cancellable: false
            }, async (progress) => {
                progress.report({ increment: 0 });
                const editorContext = await (0, contextProvider_1.getEditorContext)();
                let prompt = userPrompt;
                if (editorContext) {
                    prompt += `\n\nContext:\nFile: ${editorContext.fileName}\nLanguage: ${editorContext.language}\n`;
                    if (editorContext.selectedCode) {
                        prompt += `\nSelected code:\n\`\`\`${editorContext.language}\n${editorContext.selectedCode}\n\`\`\``;
                    }
                }
                progress.report({ increment: 30, message: 'Retrieving code context...' });
                // Get relevant context from the context engine
                const codeContext = await (0, contextProvider_1.getProjectContext)(userPrompt);
                if (codeContext) {
                    prompt += `\n\nRelevant code context:\n${codeContext}`;
                }
                progress.report({ increment: 50 });
                const options = {
                    prompt,
                    systemPrompt: 'You are Qwen Coder, an AI assistant specialized in helping with programming tasks. Provide clear, concise, and accurate responses to coding questions. Include code examples when appropriate.'
                };
                // Check if streaming is enabled in configuration
                const config = (0, configuration_1.getConfiguration)();
                if (config.streamingEnabled) {
                    // Use streaming API
                    progress.report({ message: 'Streaming response...' });
                    // Variable to accumulate the full response for history
                    let fullResponse = '';
                    (0, responseFormatter_1.showStreamingResponseInPanel)(context, (streamHandler) => {
                        apiClient.generateStreamingCompletion(options, (chunk, done) => {
                            // Accumulate the response
                            fullResponse += chunk;
                            // Pass to the original handler
                            streamHandler(chunk, done);
                            // When streaming is complete, save to history
                            if (done) {
                                saveToHistory(context, prompt, fullResponse, options.systemPrompt);
                            }
                        }).catch(error => {
                            errorHandler_1.ErrorHandler.handleError(error);
                        });
                    });
                    progress.report({ increment: 100 });
                }
                else {
                    // Use non-streaming API
                    const response = await apiClient.generateCompletion(options);
                    progress.report({ increment: 100 });
                    // Save to conversation history
                    saveToHistory(context, prompt, response.text, options.systemPrompt);
                    // Show response in panel
                    (0, responseFormatter_1.showResponseInPanel)(response.text, context);
                }
            });
        }
        catch (error) {
            errorHandler_1.ErrorHandler.handleError(error);
        }
    });
    // Register the "Explain Code" command
    const explainCodeCommand = vscode.commands.registerCommand('qwen-coder-assistant.explainCode', async () => {
        const editorContext = await (0, contextProvider_1.getEditorContext)();
        if (!editorContext || !editorContext.selectedCode) {
            vscode.window.showInformationMessage('Please select some code to explain.');
            return;
        }
        try {
            vscode.window.withProgress({
                location: vscode.ProgressLocation.Notification,
                title: 'Explaining code...',
                cancellable: false
            }, async (progress) => {
                progress.report({ increment: 0 });
                const prompt = `Please explain the following code in detail:\n\`\`\`${editorContext.language}\n${editorContext.selectedCode}\n\`\`\``;
                const options = {
                    prompt,
                    systemPrompt: 'You are Qwen Coder, an AI assistant specialized in explaining code. Provide clear, detailed explanations of how the code works, its purpose, and any important patterns or concepts it demonstrates.'
                };
                progress.report({ increment: 50 });
                // Check if streaming is enabled in configuration
                const config = (0, configuration_1.getConfiguration)();
                if (config.streamingEnabled) {
                    // Use streaming API
                    progress.report({ message: 'Streaming response...' });
                    // Variable to accumulate the full response for history
                    let fullResponse = '';
                    (0, responseFormatter_1.showStreamingResponseInPanel)(context, (streamHandler) => {
                        apiClient.generateStreamingCompletion(options, (chunk, done) => {
                            // Accumulate the response
                            fullResponse += chunk;
                            // Pass to the original handler
                            streamHandler(chunk, done);
                            // When streaming is complete, save to history
                            if (done) {
                                saveToHistory(context, prompt, fullResponse, options.systemPrompt);
                            }
                        }).catch(error => {
                            errorHandler_1.ErrorHandler.handleError(error);
                        });
                    });
                    progress.report({ increment: 100 });
                }
                else {
                    // Use non-streaming API
                    const response = await apiClient.generateCompletion(options);
                    progress.report({ increment: 100 });
                    // Save to conversation history
                    saveToHistory(context, prompt, response.text, options.systemPrompt);
                    // Show response in panel
                    (0, responseFormatter_1.showResponseInPanel)(response.text, context);
                }
            });
        }
        catch (error) {
            errorHandler_1.ErrorHandler.handleError(error);
        }
    });
    // Register the "Generate Code" command
    const generateCodeCommand = vscode.commands.registerCommand('qwen-coder-assistant.generateCode', async () => {
        const userPrompt = await vscode.window.showInputBox({
            prompt: 'What code would you like to generate?',
            placeHolder: 'E.g., Write a function to sort an array of objects by a property'
        });
        if (!userPrompt) {
            return; // User cancelled
        }
        try {
            vscode.window.withProgress({
                location: vscode.ProgressLocation.Notification,
                title: 'Generating code...',
                cancellable: false
            }, async (progress) => {
                progress.report({ increment: 0 });
                const editorContext = await (0, contextProvider_1.getEditorContext)();
                let prompt = `Generate code for: ${userPrompt}`;
                if (editorContext) {
                    prompt += `\n\nContext:\nFile: ${editorContext.fileName}\nLanguage: ${editorContext.language}\n`;
                    if (editorContext.visibleRangeText) {
                        prompt += `\nSurrounding code:\n\`\`\`${editorContext.language}\n${editorContext.visibleRangeText}\n\`\`\``;
                    }
                }
                progress.report({ increment: 30 });
                // Get project context for better code generation
                progress.report({ message: 'Retrieving code context...' });
                const projectContext = await (0, contextProvider_1.getProjectContext)(userPrompt);
                if (projectContext) {
                    prompt += `\n\nProject context (relevant files):\n${projectContext}`;
                }
                progress.report({ increment: 50 });
                const options = {
                    prompt,
                    systemPrompt: 'You are Qwen Coder, an AI assistant specialized in generating high-quality code. Generate code that is efficient, well-documented, and follows best practices for the given language and context.'
                };
                // Check if streaming is enabled in configuration
                const config = (0, configuration_1.getConfiguration)();
                if (config.streamingEnabled) {
                    // Use streaming API
                    progress.report({ message: 'Streaming response...' });
                    // Variable to accumulate the full response for history
                    let fullResponse = '';
                    (0, responseFormatter_1.showStreamingResponseInPanel)(context, (streamHandler) => {
                        apiClient.generateStreamingCompletion(options, (chunk, done) => {
                            // Accumulate the response
                            fullResponse += chunk;
                            // Pass to the original handler
                            streamHandler(chunk, done);
                            // When streaming is complete, save to history
                            if (done) {
                                saveToHistory(context, prompt, fullResponse, options.systemPrompt);
                            }
                        }).catch(error => {
                            errorHandler_1.ErrorHandler.handleError(error);
                        });
                    });
                    progress.report({ increment: 100 });
                }
                else {
                    // Use non-streaming API
                    const response = await apiClient.generateCompletion(options);
                    progress.report({ increment: 100 });
                    // Save to conversation history
                    saveToHistory(context, prompt, response.text, options.systemPrompt);
                    // Show response in panel
                    (0, responseFormatter_1.showResponseInPanel)(response.text, context);
                }
            });
        }
        catch (error) {
            errorHandler_1.ErrorHandler.handleError(error);
        }
    });
    // Register the "Clear Cache" command
    const clearCacheCommand = vscode.commands.registerCommand('qwen-coder-assistant.clearCache', async () => {
        try {
            apiClient.clearCache();
            vscode.window.showInformationMessage('Qwen Coder cache cleared successfully.');
        }
        catch (error) {
            errorHandler_1.ErrorHandler.handleError(error);
        }
    });
    // Register the "Refactor Code" command
    const refactorCodeCommand = vscode.commands.registerCommand('qwen-coder-assistant.refactorCode', async () => {
        const editorContext = await (0, contextProvider_1.getEditorContext)();
        if (!editorContext || !editorContext.selectedCode) {
            vscode.window.showInformationMessage('Please select some code to refactor.');
            return;
        }
        try {
            vscode.window.withProgress({
                location: vscode.ProgressLocation.Notification,
                title: 'Refactoring code...',
                cancellable: false
            }, async (progress) => {
                progress.report({ increment: 0 });
                const prompt = `Please refactor the following code to improve its readability, efficiency, and maintainability. Provide the refactored code and explain the improvements made:\n\`\`\`${editorContext.language}\n${editorContext.selectedCode}\n\`\`\``;
                const options = {
                    prompt,
                    systemPrompt: 'You are Qwen Coder, an AI assistant specialized in refactoring code. Provide clean, efficient, and well-structured code that follows best practices and design patterns. Explain the improvements you made.'
                };
                progress.report({ increment: 50 });
                // Check if streaming is enabled in configuration
                const config = (0, configuration_1.getConfiguration)();
                if (config.streamingEnabled) {
                    // Use streaming API
                    progress.report({ message: 'Streaming response...' });
                    // Variable to accumulate the full response for history
                    let fullResponse = '';
                    (0, responseFormatter_1.showStreamingResponseInPanel)(context, (streamHandler) => {
                        apiClient.generateStreamingCompletion(options, (chunk, done) => {
                            // Accumulate the response
                            fullResponse += chunk;
                            // Pass to the original handler
                            streamHandler(chunk, done);
                            // When streaming is complete, save to history
                            if (done) {
                                saveToHistory(context, prompt, fullResponse, options.systemPrompt);
                            }
                        }).catch(error => {
                            errorHandler_1.ErrorHandler.handleError(error);
                        });
                    });
                    progress.report({ increment: 100 });
                }
                else {
                    // Use non-streaming API
                    const response = await apiClient.generateCompletion(options);
                    progress.report({ increment: 100 });
                    // Save to conversation history
                    saveToHistory(context, prompt, response.text, options.systemPrompt);
                    // Show response in panel
                    (0, responseFormatter_1.showResponseInPanel)(response.text, context);
                }
            });
        }
        catch (error) {
            errorHandler_1.ErrorHandler.handleError(error);
        }
    });
    // Register the "Document Code" command
    const documentCodeCommand = vscode.commands.registerCommand('qwen-coder-assistant.documentCode', async () => {
        const editorContext = await (0, contextProvider_1.getEditorContext)();
        if (!editorContext || !editorContext.selectedCode) {
            vscode.window.showInformationMessage('Please select some code to document.');
            return;
        }
        try {
            vscode.window.withProgress({
                location: vscode.ProgressLocation.Notification,
                title: 'Documenting code...',
                cancellable: false
            }, async (progress) => {
                progress.report({ increment: 0 });
                const prompt = `Please add comprehensive documentation to the following code. Include function/method descriptions, parameter explanations, return value details, and any other relevant documentation:\n\`\`\`${editorContext.language}\n${editorContext.selectedCode}\n\`\`\``;
                const options = {
                    prompt,
                    systemPrompt: 'You are Qwen Coder, an AI assistant specialized in documenting code. Provide clear, comprehensive documentation that follows the conventions of the given programming language. Include function/method descriptions, parameter explanations, return value details, and usage examples where appropriate.'
                };
                progress.report({ increment: 50 });
                // Check if streaming is enabled in configuration
                const config = (0, configuration_1.getConfiguration)();
                if (config.streamingEnabled) {
                    // Use streaming API
                    progress.report({ message: 'Streaming response...' });
                    // Variable to accumulate the full response for history
                    let fullResponse = '';
                    (0, responseFormatter_1.showStreamingResponseInPanel)(context, (streamHandler) => {
                        apiClient.generateStreamingCompletion(options, (chunk, done) => {
                            // Accumulate the response
                            fullResponse += chunk;
                            // Pass to the original handler
                            streamHandler(chunk, done);
                            // When streaming is complete, save to history
                            if (done) {
                                saveToHistory(context, prompt, fullResponse, options.systemPrompt);
                            }
                        }).catch(error => {
                            errorHandler_1.ErrorHandler.handleError(error);
                        });
                    });
                    progress.report({ increment: 100 });
                }
                else {
                    // Use non-streaming API
                    const response = await apiClient.generateCompletion(options);
                    progress.report({ increment: 100 });
                    // Save to conversation history
                    saveToHistory(context, prompt, response.text, options.systemPrompt);
                    // Show response in panel
                    (0, responseFormatter_1.showResponseInPanel)(response.text, context);
                }
            });
        }
        catch (error) {
            errorHandler_1.ErrorHandler.handleError(error);
        }
    });
    // Register the "Fix Issues" command
    const fixIssuesCommand = vscode.commands.registerCommand('qwen-coder-assistant.fixIssues', async () => {
        const editorContext = await (0, contextProvider_1.getEditorContext)();
        if (!editorContext || !editorContext.selectedCode) {
            vscode.window.showInformationMessage('Please select some code to fix.');
            return;
        }
        try {
            vscode.window.withProgress({
                location: vscode.ProgressLocation.Notification,
                title: 'Fixing code issues...',
                cancellable: false
            }, async (progress) => {
                progress.report({ increment: 0 });
                const prompt = `Please identify and fix any issues in the following code. This could include bugs, syntax errors, performance issues, or security vulnerabilities. Provide the fixed code and explain the issues that were addressed:\n\`\`\`${editorContext.language}\n${editorContext.selectedCode}\n\`\`\``;
                const options = {
                    prompt,
                    systemPrompt: 'You are Qwen Coder, an AI assistant specialized in identifying and fixing code issues. Look for bugs, syntax errors, performance issues, security vulnerabilities, and other problems. Provide the fixed code and explain the issues that were addressed.'
                };
                progress.report({ increment: 50 });
                // Check if streaming is enabled in configuration
                const config = (0, configuration_1.getConfiguration)();
                if (config.streamingEnabled) {
                    // Use streaming API
                    progress.report({ message: 'Streaming response...' });
                    // Variable to accumulate the full response for history
                    let fullResponse = '';
                    (0, responseFormatter_1.showStreamingResponseInPanel)(context, (streamHandler) => {
                        apiClient.generateStreamingCompletion(options, (chunk, done) => {
                            // Accumulate the response
                            fullResponse += chunk;
                            // Pass to the original handler
                            streamHandler(chunk, done);
                            // When streaming is complete, save to history
                            if (done) {
                                saveToHistory(context, prompt, fullResponse, options.systemPrompt);
                            }
                        }).catch(error => {
                            errorHandler_1.ErrorHandler.handleError(error);
                        });
                    });
                    progress.report({ increment: 100 });
                }
                else {
                    // Use non-streaming API
                    const response = await apiClient.generateCompletion(options);
                    progress.report({ increment: 100 });
                    // Save to conversation history
                    saveToHistory(context, prompt, response.text, options.systemPrompt);
                    // Show response in panel
                    (0, responseFormatter_1.showResponseInPanel)(response.text, context);
                }
            });
        }
        catch (error) {
            errorHandler_1.ErrorHandler.handleError(error);
        }
    });
    // Register the "Hierarchical Agent" command
    const hierarchicalAgentCommand = vscode.commands.registerCommand('qwen-coder-assistant.hierarchicalAgent', async () => {
        if (!agentCoordinator) {
            vscode.window.showErrorMessage('Hierarchical agent system is not available.');
            return;
        }
        const userPrompt = await vscode.window.showInputBox({
            prompt: 'What would you like the hierarchical agent system to do?',
            placeHolder: 'E.g., Implement a feature, refactor a module, create tests for a function'
        });
        if (!userPrompt) {
            return; // User cancelled
        }
        try {
            vscode.window.withProgress({
                location: vscode.ProgressLocation.Notification,
                title: 'Processing with hierarchical agent system...',
                cancellable: false
            }, async (progress) => {
                progress.report({ increment: 0 });
                // Create a webview panel to display the results
                const panel = vscode.window.createWebviewPanel('qwenCoderHierarchicalAgent', 'Hierarchical Agent', vscode.ViewColumn.One, {
                    enableScripts: true,
                    retainContextWhenHidden: true
                });
                // Show loading indicator
                panel.webview.html = getLoadingWebviewContent();
                progress.report({ increment: 30, message: 'Decomposing task...' });
                try {
                    // Process the request with the agent coordinator
                    progress.report({ increment: 50, message: 'Executing subtasks...' });
                    const response = await agentCoordinator.processRequest(userPrompt);
                    progress.report({ increment: 100, message: 'Aggregating results...' });
                    // Show the response in the panel
                    panel.webview.html = getWebviewContent(userPrompt, response);
                    // Save to conversation history
                    saveToHistory(context, userPrompt, response, 'Hierarchical Agent System');
                }
                catch (error) {
                    panel.webview.html = getErrorWebviewContent(userPrompt, error.message);
                    errorHandler_1.ErrorHandler.handleError(error);
                }
            });
        }
        catch (error) {
            errorHandler_1.ErrorHandler.handleError(error);
        }
    });
    // Register the "MCP Tool" command
    const mcpToolCommand = vscode.commands.registerCommand('qwen-coder-assistant.mcpTool', async () => {
        if (!mcpClient) {
            vscode.window.showErrorMessage('MCP tools are not available.');
            return;
        }
        try {
            // Get available tools
            const availableTools = mcpClient.getAvailableTools();
            if (availableTools.length === 0) {
                vscode.window.showInformationMessage('No MCP tools are currently available. Please start some tools first.');
                return;
            }
            // Let the user select a tool
            const selectedTool = await vscode.window.showQuickPick(availableTools, {
                placeHolder: 'Select an MCP tool to use'
            });
            if (!selectedTool) {
                return; // User cancelled
            }
            // Get the tool schema
            const toolSchema = mcpClient.getToolSchema(selectedTool);
            if (!toolSchema) {
                vscode.window.showErrorMessage(`Schema for tool ${selectedTool} is not available.`);
                return;
            }
            // Let the user select a function
            const functionItems = toolSchema.functions.map(func => ({
                label: func.name,
                description: func.description,
                detail: `Parameters: ${Object.keys(func.parameters.properties).join(', ')}`,
                function: func
            }));
            const selectedFunction = await vscode.window.showQuickPick(functionItems, {
                placeHolder: 'Select a function to call'
            });
            if (!selectedFunction) {
                return; // User cancelled
            }
            // Collect parameters for the function
            const parameters = {};
            for (const paramName of selectedFunction.function.parameters.required) {
                const paramSchema = selectedFunction.function.parameters.properties[paramName];
                const paramValue = await vscode.window.showInputBox({
                    prompt: `Enter value for ${paramName}`,
                    placeHolder: paramSchema.description
                });
                if (paramValue === undefined) {
                    return; // User cancelled
                }
                // Convert value to appropriate type
                if (paramSchema.type === 'number') {
                    parameters[paramName] = Number(paramValue);
                }
                else if (paramSchema.type === 'boolean') {
                    parameters[paramName] = paramValue.toLowerCase() === 'true';
                }
                else {
                    parameters[paramName] = paramValue;
                }
            }
            // Call the function
            vscode.window.withProgress({
                location: vscode.ProgressLocation.Notification,
                title: `Calling ${selectedFunction.label} on ${selectedTool}...`,
                cancellable: false
            }, async (progress) => {
                progress.report({ increment: 0 });
                const result = await mcpClient.callFunction(selectedTool, selectedFunction.label, parameters);
                progress.report({ increment: 100 });
                // Show the result
                if (result.status === 'success') {
                    // Create a webview panel to display the results
                    const panel = vscode.window.createWebviewPanel('qwenCoderMcpTool', `${selectedTool} - ${selectedFunction.label}`, vscode.ViewColumn.One, {
                        enableScripts: true,
                        retainContextWhenHidden: true
                    });
                    // Show the result
                    panel.webview.html = `<!DOCTYPE html>
          <html lang="en">
          <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>${selectedTool} - ${selectedFunction.label}</title>
            <style>
              body {
                font-family: var(--vscode-font-family);
                color: var(--vscode-editor-foreground);
                background-color: var(--vscode-editor-background);
                padding: 20px;
              }
              pre {
                background-color: var(--vscode-textCodeBlock-background);
                padding: 16px;
                border-radius: 4px;
                overflow: auto;
              }
            </style>
          </head>
          <body>
            <h1>${selectedTool} - ${selectedFunction.label}</h1>
            <h2>Parameters</h2>
            <pre>${JSON.stringify(parameters, null, 2)}</pre>
            <h2>Result</h2>
            <pre>${JSON.stringify(result.result, null, 2)}</pre>
          </body>
          </html>`;
                }
                else {
                    vscode.window.showErrorMessage(`Error calling function: ${result.error}`);
                }
            });
        }
        catch (error) {
            errorHandler_1.ErrorHandler.handleError(error);
        }
    });
    // Add commands to subscriptions
    context.subscriptions.push(askQwenCommand, explainCodeCommand, generateCodeCommand, refactorCodeCommand, documentCodeCommand, fixIssuesCommand, clearCacheCommand, hierarchicalAgentCommand, mcpToolCommand);
}
// Helper function to get loading webview content
function getLoadingWebviewContent() {
    return `<!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Processing Request</title>
    <style>
      body {
        font-family: var(--vscode-font-family);
        color: var(--vscode-editor-foreground);
        background-color: var(--vscode-editor-background);
        padding: 20px;
      }
      .loading {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 300px;
      }
      .spinner {
        width: 50px;
        height: 50px;
        border: 5px solid var(--vscode-button-background);
        border-radius: 50%;
        border-top-color: transparent;
        animation: spin 1s linear infinite;
        margin-bottom: 20px;
      }
      @keyframes spin {
        to { transform: rotate(360deg); }
      }
    </style>
  </head>
  <body>
    <div class="loading">
      <div class="spinner"></div>
      <h2>Processing your request...</h2>
      <p>The hierarchical agent system is working on your task.</p>
    </div>
  </body>
  </html>`;
}
// Helper function to get webview content
function getWebviewContent(request, response) {
    return `<!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Agent Response</title>
    <style>
      body {
        font-family: var(--vscode-font-family);
        color: var(--vscode-editor-foreground);
        background-color: var(--vscode-editor-background);
        padding: 20px;
        line-height: 1.5;
      }
      h1, h2, h3, h4, h5, h6 {
        color: var(--vscode-editor-foreground);
      }
      pre {
        background-color: var(--vscode-textCodeBlock-background);
        padding: 16px;
        border-radius: 4px;
        overflow: auto;
      }
      code {
        font-family: var(--vscode-editor-font-family);
        font-size: var(--vscode-editor-font-size);
      }
      .request {
        background-color: var(--vscode-input-background);
        padding: 10px;
        border-radius: 4px;
        margin-bottom: 20px;
        border-left: 4px solid var(--vscode-activityBarBadge-background);
      }
    </style>
  </head>
  <body>
    <div class="request">
      <strong>Your request:</strong> ${request}
    </div>
    <div class="response">
      ${markdownToHtml(response)}
    </div>
  </body>
  </html>`;
}
// Helper function to get error webview content
function getErrorWebviewContent(request, errorMessage) {
    return `<!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Error</title>
    <style>
      body {
        font-family: var(--vscode-font-family);
        color: var(--vscode-editor-foreground);
        background-color: var(--vscode-editor-background);
        padding: 20px;
      }
      .request {
        background-color: var(--vscode-input-background);
        padding: 10px;
        border-radius: 4px;
        margin-bottom: 20px;
        border-left: 4px solid var(--vscode-activityBarBadge-background);
      }
      .error {
        background-color: var(--vscode-inputValidation-errorBackground);
        color: var(--vscode-inputValidation-errorForeground);
        padding: 10px;
        border-radius: 4px;
        margin-bottom: 20px;
        border-left: 4px solid var(--vscode-errorForeground);
      }
    </style>
  </head>
  <body>
    <div class="request">
      <strong>Your request:</strong> ${request}
    </div>
    <div class="error">
      <strong>Error:</strong> ${errorMessage}
    </div>
    <p>Please try again with a more specific request or check the extension logs for more details.</p>
  </body>
  </html>`;
}
// Helper function to convert markdown to HTML
function markdownToHtml(markdown) {
    // This is a very simple markdown to HTML converter
    // In a real implementation, we would use a proper markdown parser
    // Replace headers
    let html = markdown
        .replace(/^### (.*$)/gim, '<h3>$1</h3>')
        .replace(/^## (.*$)/gim, '<h2>$1</h2>')
        .replace(/^# (.*$)/gim, '<h1>$1</h1>');
    // Replace code blocks
    html = html.replace(/```([a-z]*)\n([\s\S]*?)\n```/gim, '<pre><code class="language-$1">$2</code></pre>');
    // Replace inline code
    html = html.replace(/`([^`]+)`/gim, '<code>$1</code>');
    // Replace lists
    html = html.replace(/^\s*\*\s(.*$)/gim, '<ul><li>$1</li></ul>');
    html = html.replace(/^\s*\d+\.\s(.*$)/gim, '<ol><li>$1</li></ol>');
    // Replace paragraphs
    html = html.replace(/^\s*(\n)?([^\n]+)\n/gim, '<p>$2</p>');
    // Fix consecutive lists
    html = html.replace(/<\/ul>\s*<ul>/gim, '');
    html = html.replace(/<\/ol>\s*<ol>/gim, '');
    return html;
}
//# sourceMappingURL=commands.js.map
```


---

### File: `out/extension.js`

```javascript
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.activate = activate;
exports.deactivate = deactivate;
const vscode = __importStar(require("vscode"));
const agentCoordinator_1 = require("./agents/agentCoordinator");
const configuration_1 = require("./configuration");
const authManager_1 = require("./mcp-client/authentication/authManager");
const mcpClient_1 = require("./mcp-client/mcpClient");
const mcpServerManager_1 = require("./mcp-client/mcpServerManager");
const officialMcpServers_1 = require("./mcp-client/officialMcpServers");
const serverHealthMonitor_1 = require("./mcp-client/serverHealthMonitor");
const qwenApi_1 = require("./qwenApi");
const mcpServerTreeDataProvider_1 = require("./ui/mcpServerTreeDataProvider");
// Global state
let mcpServerManager;
let mcpClient;
let mcpServerTreeDataProvider;
let qwenApiClient;
let agentCoordinator;
let serverHealthMonitor;
let officialMcpServersManager;
let authManager;
/**
 * Activate the extension
 * @param context Extension context
 */
async function activate(context) {
    console.log('Qwen Coder Assistant is now active!');
    // Get configuration
    const config = (0, configuration_1.getConfiguration)();
    // Initialize the MCP server manager
    mcpServerManager = new mcpServerManager_1.McpServerManager();
    // Initialize the authentication manager
    authManager = new authManager_1.AuthManager(context);
    context.subscriptions.push(authManager);
    // Initialize the MCP client
    mcpClient = new mcpClient_1.McpClient(mcpServerManager, authManager);
    // Initialize the server health monitor
    serverHealthMonitor = new serverHealthMonitor_1.ServerHealthMonitor(mcpServerManager);
    context.subscriptions.push(serverHealthMonitor);
    // Initialize the official MCP servers manager
    officialMcpServersManager = new officialMcpServers_1.OfficialMcpServersManager(mcpServerManager);
    // Initialize the MCP server tree data provider
    mcpServerTreeDataProvider = new mcpServerTreeDataProvider_1.McpServerTreeDataProvider(mcpServerManager, serverHealthMonitor);
    // Register the MCP server tree data provider
    vscode.window.registerTreeDataProvider('qwenMcpServers', mcpServerTreeDataProvider);
    // Initialize the Qwen API client
    qwenApiClient = new qwenApi_1.QwenApiClient(config);
    // Initialize the agent coordinator
    agentCoordinator = new agentCoordinator_1.AgentCoordinator(qwenApiClient, mcpClient, config);
    // Register commands
    registerCommands(context);
    // Listen for configuration changes
    context.subscriptions.push((0, configuration_1.registerConfigurationListener)(handleConfigurationChange));
    // Start the server health monitor
    serverHealthMonitor.start();
    // Start auto-start servers
    await mcpServerManager.startAutoStartServers();
}
/**
 * Register commands
 * @param context Extension context
 */
function registerCommands(context) {
    // Register the askQwen command
    context.subscriptions.push(vscode.commands.registerCommand('qwen-coder-assistant.askQwen', askQwen));
    // Register the explainCode command
    context.subscriptions.push(vscode.commands.registerCommand('qwen-coder-assistant.explainCode', explainCode));
    // Register the generateCode command
    context.subscriptions.push(vscode.commands.registerCommand('qwen-coder-assistant.generateCode', generateCode));
    // Register the addMcpRepo command
    context.subscriptions.push(vscode.commands.registerCommand('qwen-coder-assistant.addMcpRepo', addMcpRepo));
    // Register the manageMcpServers command
    context.subscriptions.push(vscode.commands.registerCommand('qwen-coder-assistant.manageMcpServers', manageMcpServers));
    // Register the startMcpServer command
    context.subscriptions.push(vscode.commands.registerCommand('qwen-coder-assistant.startMcpServer', startMcpServer));
    // Register the stopMcpServer command
    context.subscriptions.push(vscode.commands.registerCommand('qwen-coder-assistant.stopMcpServer', stopMcpServer));
    // Register the restartMcpServer command
    context.subscriptions.push(vscode.commands.registerCommand('qwen-coder-assistant.restartMcpServer', restartMcpServer));
    // Register the viewMcpServerLogs command
    context.subscriptions.push(vscode.commands.registerCommand('qwen-coder-assistant.viewMcpServerLogs', viewMcpServerLogs));
    // Register the viewMcpServerSchema command
    context.subscriptions.push(vscode.commands.registerCommand('qwen-coder-assistant.viewMcpServerSchema', viewMcpServerSchema));
    // Register the refreshMcpServers command
    context.subscriptions.push(vscode.commands.registerCommand('qwen-coder-assistant.refreshMcpServers', refreshMcpServers));
    // Register the testApiConnection command
    context.subscriptions.push(vscode.commands.registerCommand('qwen-coder-assistant.testApiConnection', testApiConnection));
    // Register the verifyConfiguration command
    context.subscriptions.push(vscode.commands.registerCommand('qwen-coder-assistant.verifyConfiguration', verifyExtensionConfiguration));
    // Register the testMcpTool command
    context.subscriptions.push(vscode.commands.registerCommand('qwen-coder-assistant.testMcpTool', testMcpTool));
    // Register the testMcpQwenBridge command
    context.subscriptions.push(vscode.commands.registerCommand('qwen-coder-assistant.testMcpQwenBridge', async () => {
        try {
            // Import the test module
            const { runMcpQwenBridgeTest } = await Promise.resolve().then(() => __importStar(require('./test/mcpQwenBridgeTest')));
            // Run the test
            await runMcpQwenBridgeTest();
            // Show success message
            vscode.window.showInformationMessage('MCP-Qwen bridge test completed. Check the console for results.');
        }
        catch (error) {
            vscode.window.showErrorMessage(`Error testing MCP-Qwen bridge: ${error}`);
        }
    }));
    // Register the testMcpQwenIntegration command
    context.subscriptions.push(vscode.commands.registerCommand('qwen-coder-assistant.testMcpQwenIntegration', async () => {
        try {
            // Import the test module
            const { runMcpQwenIntegrationTest } = await Promise.resolve().then(() => __importStar(require('./test/mcpQwenIntegrationTest')));
            // Run the test
            await runMcpQwenIntegrationTest();
            // Show success message
            vscode.window.showInformationMessage('MCP-Qwen integration test completed. Check the output channel for results.');
        }
        catch (error) {
            vscode.window.showErrorMessage(`Error testing MCP-Qwen integration: ${error}`);
        }
    }));
    // Register the configureMcpServer command
    context.subscriptions.push(vscode.commands.registerCommand('qwen-coder-assistant.configureMcpServer', (item) => {
        try {
            if (!mcpServerManager || !officialMcpServersManager || !serverHealthMonitor) {
                throw new Error('MCP server manager, official servers manager, or health monitor not initialized');
            }
            // Get the server ID from the tree item
            const serverId = item?.server.id;
            // Create the configuration view
            McpServerConfigView.createOrShow(context.extensionUri, mcpServerManager, officialMcpServersManager, serverHealthMonitor, serverId);
        }
        catch (error) {
            vscode.window.showErrorMessage(`Error configuring MCP server: ${error}`);
        }
    }));
    // Register the addOfficialMcpServer command
    context.subscriptions.push(vscode.commands.registerCommand('qwen-coder-assistant.addOfficialMcpServer', async () => {
        try {
            if (!officialMcpServersManager) {
                throw new Error('Official MCP servers manager not initialized');
            }
            // Show a quick pick to select a server type
            const serverTypes = [
                { label: 'GitHub MCP Server', value: 'GITHUB' },
                { label: 'Docker MCP Server', value: 'DOCKER' },
                { label: 'Git MCP Server', value: 'GIT' },
                { label: 'Memory MCP Server', value: 'MEMORY' },
                { label: 'Filesystem MCP Server', value: 'FILESYSTEM' },
                { label: 'All Official MCP Servers', value: 'ALL' }
            ];
            const selectedType = await vscode.window.showQuickPick(serverTypes, {
                placeHolder: 'Select an official MCP server to add',
                title: 'Add Official MCP Server'
            });
            if (!selectedType) {
                return;
            }
            // Show a progress notification
            vscode.window.withProgress({
                location: vscode.ProgressLocation.Notification,
                title: `Adding ${selectedType.label}...`,
                cancellable: false
            }, async () => {
                try {
                    if (selectedType.value === 'ALL') {
                        const serverIds = await officialMcpServersManager.addAllOfficialServers();
                        vscode.window.showInformationMessage(`Added ${serverIds.length} official MCP servers`);
                    }
                    else {
                        let serverId;
                        switch (selectedType.value) {
                            case 'GITHUB':
                                serverId = await officialMcpServersManager.addGitHubServer();
                                break;
                            case 'DOCKER':
                                serverId = await officialMcpServersManager.addDockerServer();
                                break;
                            case 'GIT':
                                serverId = await officialMcpServersManager.addGitServer();
                                break;
                            case 'MEMORY':
                                serverId = await officialMcpServersManager.addMemoryServer();
                                break;
                            case 'FILESYSTEM':
                                serverId = await officialMcpServersManager.addFilesystemServer();
                                break;
                            default:
                                throw new Error(`Unknown server type: ${selectedType.value}`);
                        }
                        vscode.window.showInformationMessage(`Added ${selectedType.label}`);
                    }
                }
                catch (error) {
                    vscode.window.showErrorMessage(`Error adding official MCP server: ${error}`);
                }
            });
        }
        catch (error) {
            vscode.window.showErrorMessage(`Error adding official MCP server: ${error}`);
        }
    }));
    // Register the checkMcpServerHealth command
    context.subscriptions.push(vscode.commands.registerCommand('qwen-coder-assistant.checkMcpServerHealth', async (item) => {
        try {
            if (!serverHealthMonitor) {
                throw new Error('Server health monitor not initialized');
            }
            // If no item is provided, check all servers
            if (!item) {
                // Show a progress notification
                vscode.window.withProgress({
                    location: vscode.ProgressLocation.Notification,
                    title: 'Checking all MCP servers health...',
                    cancellable: false
                }, async () => {
                    try {
                        await serverHealthMonitor.checkAllServersHealth();
                        vscode.window.showInformationMessage('All MCP servers health checked');
                    }
                    catch (error) {
                        vscode.window.showErrorMessage(`Error checking MCP servers health: ${error}`);
                    }
                });
                return;
            }
            // Check the health of the selected server
            const serverId = item.server.id;
            // Show a progress notification
            vscode.window.withProgress({
                location: vscode.ProgressLocation.Notification,
                title: `Checking MCP server health: ${item.server.name}...`,
                cancellable: false
            }, async () => {
                try {
                    await serverHealthMonitor.checkServerHealth(serverId);
                    const server = mcpServerManager?.getServer(serverId);
                    if (server) {
                        vscode.window.showInformationMessage(`MCP server ${server.name} health: ${server.healthStatus || 'unknown'}`);
                    }
                }
                catch (error) {
                    vscode.window.showErrorMessage(`Error checking MCP server health: ${error}`);
                }
            });
        }
        catch (error) {
            vscode.window.showErrorMessage(`Error checking MCP server health: ${error}`);
        }
    }));
}
/**
 * Handle configuration changes
 * @param config New configuration
 */
function handleConfigurationChange(config) {
    console.log('Configuration changed:', config);
    // Update the Qwen API client
    if (qwenApiClient) {
        qwenApiClient.updateConfig(config);
    }
    // Update the agent coordinator
    if (agentCoordinator) {
        agentCoordinator.updateConfig(config);
    }
}
/**
 * Ask Qwen
 */
async function askQwen() {
    // Get the input from the user
    const input = await vscode.window.showInputBox({
        prompt: 'What would you like to ask Qwen?',
        placeHolder: 'Enter your question...'
    });
    if (!input) {
        return;
    }
    // Create a webview panel to display the response
    const panel = vscode.window.createWebviewPanel('qwenResponse', 'Qwen Response', vscode.ViewColumn.One, {
        enableScripts: true,
        retainContextWhenHidden: true
    });
    // Set initial content
    panel.webview.html = getLoadingWebviewContent();
    // Show a progress notification
    vscode.window.withProgress({
        location: vscode.ProgressLocation.Notification,
        title: 'Asking Qwen...',
        cancellable: false
    }, async () => {
        try {
            if (!agentCoordinator) {
                throw new Error('Agent coordinator not initialized');
            }
            // Process the request using the agent coordinator
            const response = await agentCoordinator.processRequest(input);
            // Update the webview with the response
            panel.webview.html = getResponseWebviewContent(input, response);
        }
        catch (error) {
            // Handle the error
            const errorDetails = error instanceof Error ? error.message : String(error);
            panel.webview.html = getErrorWebviewContent(input, errorDetails);
            vscode.window.showErrorMessage(`Error asking Qwen: ${errorDetails}`);
        }
    });
}
/**
 * Get loading webview content
 * @returns HTML content for the loading state
 */
function getLoadingWebviewContent() {
    return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Qwen Response</title>
  <style>
    body {
      font-family: var(--vscode-font-family);
      font-size: var(--vscode-font-size);
      color: var(--vscode-foreground);
      background-color: var(--vscode-editor-background);
      padding: 20px;
    }
    .loading {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
    }
    .spinner {
      width: 50px;
      height: 50px;
      border: 5px solid var(--vscode-button-background);
      border-top: 5px solid var(--vscode-editor-background);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 20px;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <div class="loading">
    <div class="spinner"></div>
    <p>Asking Qwen...</p>
  </div>
</body>
</html>`;
}
/**
 * Get response webview content
 * @param question The user's question
 * @param answer The answer from Qwen
 * @returns HTML content for the response
 */
function getResponseWebviewContent(question, answer) {
    // Convert the answer to HTML (replace newlines with <br>, etc.)
    const formattedAnswer = answer
        .replace(/\n/g, '<br>')
        .replace(/```(\w*)\n([\s\S]*?)\n```/g, '<pre><code class="language-$1">$2</code></pre>');
    return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Qwen Response</title>
  <style>
    body {
      font-family: var(--vscode-font-family);
      font-size: var(--vscode-font-size);
      color: var(--vscode-foreground);
      background-color: var(--vscode-editor-background);
      padding: 20px;
      line-height: 1.5;
    }
    .container {
      max-width: 800px;
      margin: 0 auto;
    }
    .question {
      background-color: var(--vscode-input-background);
      padding: 15px;
      border-radius: 5px;
      margin-bottom: 20px;
      border-left: 5px solid var(--vscode-button-background);
    }
    .answer {
      background-color: var(--vscode-editor-background);
      padding: 15px;
      border-radius: 5px;
    }
    pre {
      background-color: var(--vscode-textCodeBlock-background);
      padding: 10px;
      border-radius: 5px;
      overflow-x: auto;
    }
    code {
      font-family: var(--vscode-editor-font-family);
      font-size: var(--vscode-editor-font-size);
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>Your Question</h2>
    <div class="question">
      ${question}
    </div>
    <h2>Qwen's Response</h2>
    <div class="answer">
      ${formattedAnswer}
    </div>
  </div>
</body>
</html>`;
}
/**
 * Get error webview content
 * @param question The user's question
 * @param error The error message
 * @returns HTML content for the error state
 */
function getErrorWebviewContent(question, error) {
    return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Qwen Response</title>
  <style>
    body {
      font-family: var(--vscode-font-family);
      font-size: var(--vscode-font-size);
      color: var(--vscode-foreground);
      background-color: var(--vscode-editor-background);
      padding: 20px;
      line-height: 1.5;
    }
    .container {
      max-width: 800px;
      margin: 0 auto;
    }
    .question {
      background-color: var(--vscode-input-background);
      padding: 15px;
      border-radius: 5px;
      margin-bottom: 20px;
      border-left: 5px solid var(--vscode-button-background);
    }
    .error {
      background-color: var(--vscode-inputValidation-errorBackground);
      color: var(--vscode-inputValidation-errorForeground);
      padding: 15px;
      border-radius: 5px;
      border-left: 5px solid var(--vscode-errorForeground);
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>Your Question</h2>
    <div class="question">
      ${question}
    </div>
    <h2>Error</h2>
    <div class="error">
      <p>An error occurred while processing your request:</p>
      <p>${error}</p>
    </div>
  </div>
</body>
</html>`;
}
/**
 * Explain code
 */
async function explainCode() {
    // Get the active editor
    const editor = vscode.window.activeTextEditor;
    if (!editor) {
        vscode.window.showErrorMessage('No active editor');
        return;
    }
    // Get the selected text
    const selection = editor.selection;
    const text = editor.document.getText(selection);
    if (!text) {
        vscode.window.showErrorMessage('No text selected');
        return;
    }
    // Get the file path and language
    const filePath = editor.document.uri.fsPath;
    const fileName = filePath.split(/[\\/]/).pop() || '';
    const language = editor.document.languageId;
    // Create a webview panel to display the explanation
    const panel = vscode.window.createWebviewPanel('qwenExplanation', `Explanation: ${fileName}`, vscode.ViewColumn.Beside, {
        enableScripts: true,
        retainContextWhenHidden: true
    });
    // Set initial content
    panel.webview.html = getLoadingWebviewContent();
    // Show a progress notification
    vscode.window.withProgress({
        location: vscode.ProgressLocation.Notification,
        title: 'Explaining code...',
        cancellable: false
    }, async () => {
        try {
            if (!agentCoordinator) {
                throw new Error('Agent coordinator not initialized');
            }
            // Create a prompt that includes the code and asks for an explanation
            const prompt = `Please explain the following ${language} code:

\`\`\`${language}
${text}
\`\`\`

Please provide a detailed explanation of what this code does, how it works, and any important patterns or concepts it demonstrates.`;
            // Process the request using the agent coordinator
            const response = await agentCoordinator.processRequest(prompt);
            // Update the webview with the explanation
            panel.webview.html = getExplanationWebviewContent(text, language, response);
        }
        catch (error) {
            // Handle the error
            const errorDetails = error instanceof Error ? error.message : String(error);
            panel.webview.html = getErrorExplanationWebviewContent(text, language, errorDetails);
            vscode.window.showErrorMessage(`Error explaining code: ${errorDetails}`);
        }
    });
}
/**
 * Get explanation webview content
 * @param code The code to explain
 * @param language The code language
 * @param explanation The explanation from Qwen
 * @returns HTML content for the explanation
 */
function getExplanationWebviewContent(code, language, explanation) {
    // Convert the explanation to HTML (replace newlines with <br>, etc.)
    const formattedExplanation = explanation
        .replace(/\n/g, '<br>')
        .replace(/```(\w*)\n([\s\S]*?)\n```/g, '<pre><code class="language-$1">$2</code></pre>');
    return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Code Explanation</title>
  <style>
    body {
      font-family: var(--vscode-font-family);
      font-size: var(--vscode-font-size);
      color: var(--vscode-foreground);
      background-color: var(--vscode-editor-background);
      padding: 20px;
      line-height: 1.5;
    }
    .container {
      max-width: 800px;
      margin: 0 auto;
    }
    .code {
      background-color: var(--vscode-textCodeBlock-background);
      padding: 15px;
      border-radius: 5px;
      margin-bottom: 20px;
      overflow-x: auto;
      font-family: var(--vscode-editor-font-family);
      font-size: var(--vscode-editor-font-size);
      white-space: pre;
    }
    .explanation {
      background-color: var(--vscode-editor-background);
      padding: 15px;
      border-radius: 5px;
    }
    pre {
      background-color: var(--vscode-textCodeBlock-background);
      padding: 10px;
      border-radius: 5px;
      overflow-x: auto;
    }
    code {
      font-family: var(--vscode-editor-font-family);
      font-size: var(--vscode-editor-font-size);
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>Code</h2>
    <div class="code">
      <code>${code.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</code>
    </div>
    <h2>Explanation</h2>
    <div class="explanation">
      ${formattedExplanation}
    </div>
  </div>
</body>
</html>`;
}
/**
 * Get error explanation webview content
 * @param code The code to explain
 * @param language The code language
 * @param error The error message
 * @returns HTML content for the error state
 */
function getErrorExplanationWebviewContent(code, language, error) {
    return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Code Explanation</title>
  <style>
    body {
      font-family: var(--vscode-font-family);
      font-size: var(--vscode-font-size);
      color: var(--vscode-foreground);
      background-color: var(--vscode-editor-background);
      padding: 20px;
      line-height: 1.5;
    }
    .container {
      max-width: 800px;
      margin: 0 auto;
    }
    .code {
      background-color: var(--vscode-textCodeBlock-background);
      padding: 15px;
      border-radius: 5px;
      margin-bottom: 20px;
      overflow-x: auto;
      font-family: var(--vscode-editor-font-family);
      font-size: var(--vscode-editor-font-size);
      white-space: pre;
    }
    .error {
      background-color: var(--vscode-inputValidation-errorBackground);
      color: var(--vscode-inputValidation-errorForeground);
      padding: 15px;
      border-radius: 5px;
      border-left: 5px solid var(--vscode-errorForeground);
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>Code</h2>
    <div class="code">
      <code>${code.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</code>
    </div>
    <h2>Error</h2>
    <div class="error">
      <p>An error occurred while explaining the code:</p>
      <p>${error}</p>
    </div>
  </div>
</body>
</html>`;
}
/**
 * Generate code
 */
async function generateCode() {
    // Get the active editor
    const editor = vscode.window.activeTextEditor;
    if (!editor) {
        vscode.window.showErrorMessage('No active editor');
        return;
    }
    // Get the input from the user
    const input = await vscode.window.showInputBox({
        prompt: 'What code would you like to generate?',
        placeHolder: 'Enter your request...'
    });
    if (!input) {
        return;
    }
    // Get the language
    const language = editor.document.languageId;
    // Create a webview panel to display the generated code
    const panel = vscode.window.createWebviewPanel('qwenCodeGeneration', 'Generated Code', vscode.ViewColumn.Beside, {
        enableScripts: true,
        retainContextWhenHidden: true
    });
    // Set initial content
    panel.webview.html = getLoadingWebviewContent();
    // Show a progress notification
    vscode.window.withProgress({
        location: vscode.ProgressLocation.Notification,
        title: 'Generating code...',
        cancellable: false
    }, async () => {
        try {
            if (!agentCoordinator) {
                throw new Error('Agent coordinator not initialized');
            }
            // Create a prompt that asks for code generation
            const prompt = `Please generate ${language} code for the following request:

${input}

Please provide well-structured, efficient, and well-commented code that follows best practices for ${language}.`;
            // Process the request using the agent coordinator
            const response = await agentCoordinator.processRequest(prompt);
            // Update the webview with the generated code
            panel.webview.html = getGeneratedCodeWebviewContent(input, language, response);
            // Add a button to insert the code
            panel.webview.onDidReceiveMessage(async (message) => {
                if (message.command === 'insertCode') {
                    try {
                        // Extract the code from the response
                        const codeMatch = response.match(/```(?:\w+)?\s*([\s\S]*?)```/);
                        const codeToInsert = codeMatch ? codeMatch[1].trim() : response;
                        // Insert the code at the current cursor position
                        editor.edit(editBuilder => {
                            editBuilder.insert(editor.selection.active, codeToInsert);
                        });
                        vscode.window.showInformationMessage('Code inserted successfully');
                    }
                    catch (error) {
                        vscode.window.showErrorMessage(`Error inserting code: ${error}`);
                    }
                }
            });
            // Enable messaging from the webview
            panel.webview.options = { enableScripts: true };
        }
        catch (error) {
            // Handle the error
            const errorDetails = error instanceof Error ? error.message : String(error);
            panel.webview.html = getErrorGeneratedCodeWebviewContent(input, language, errorDetails);
            vscode.window.showErrorMessage(`Error generating code: ${errorDetails}`);
        }
    });
}
/**
 * Get generated code webview content
 * @param request The user's request
 * @param language The code language
 * @param response The response from Qwen
 * @returns HTML content for the generated code
 */
function getGeneratedCodeWebviewContent(request, language, response) {
    // Extract code blocks from the response
    const codeBlocks = [];
    const codeBlockRegex = /```(?:\w+)?\s*([\s\S]*?)```/g;
    let match;
    while ((match = codeBlockRegex.exec(response)) !== null) {
        codeBlocks.push(match[1].trim());
    }
    // Format the response
    let formattedResponse = response
        .replace(/\n/g, '<br>')
        .replace(/```(\w*)\n([\s\S]*?)\n```/g, '<pre><code class="language-$1">$2</code></pre>');
    return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Generated Code</title>
  <style>
    body {
      font-family: var(--vscode-font-family);
      font-size: var(--vscode-font-size);
      color: var(--vscode-foreground);
      background-color: var(--vscode-editor-background);
      padding: 20px;
      line-height: 1.5;
    }
    .container {
      max-width: 800px;
      margin: 0 auto;
    }
    .request {
      background-color: var(--vscode-input-background);
      padding: 15px;
      border-radius: 5px;
      margin-bottom: 20px;
      border-left: 5px solid var(--vscode-button-background);
    }
    .response {
      background-color: var(--vscode-editor-background);
      padding: 15px;
      border-radius: 5px;
    }
    pre {
      background-color: var(--vscode-textCodeBlock-background);
      padding: 10px;
      border-radius: 5px;
      overflow-x: auto;
    }
    code {
      font-family: var(--vscode-editor-font-family);
      font-size: var(--vscode-editor-font-size);
    }
    button {
      background-color: var(--vscode-button-background);
      color: var(--vscode-button-foreground);
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      margin-top: 20px;
      font-size: var(--vscode-font-size);
    }
    button:hover {
      background-color: var(--vscode-button-hoverBackground);
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>Your Request</h2>
    <div class="request">
      ${request}
    </div>
    <h2>Generated Code</h2>
    <div class="response">
      ${formattedResponse}
    </div>
    <button id="insertButton">Insert Code</button>
  </div>
  <script>
    const vscode = acquireVsCodeApi();
    document.getElementById('insertButton').addEventListener('click', () => {
      vscode.postMessage({
        command: 'insertCode'
      });
    });
  </script>
</body>
</html>`;
}
/**
 * Get error generated code webview content
 * @param request The user's request
 * @param language The code language
 * @param error The error message
 * @returns HTML content for the error state
 */
function getErrorGeneratedCodeWebviewContent(request, language, error) {
    return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Generated Code</title>
  <style>
    body {
      font-family: var(--vscode-font-family);
      font-size: var(--vscode-font-size);
      color: var(--vscode-foreground);
      background-color: var(--vscode-editor-background);
      padding: 20px;
      line-height: 1.5;
    }
    .container {
      max-width: 800px;
      margin: 0 auto;
    }
    .request {
      background-color: var(--vscode-input-background);
      padding: 15px;
      border-radius: 5px;
      margin-bottom: 20px;
      border-left: 5px solid var(--vscode-button-background);
    }
    .error {
      background-color: var(--vscode-inputValidation-errorBackground);
      color: var(--vscode-inputValidation-errorForeground);
      padding: 15px;
      border-radius: 5px;
      border-left: 5px solid var(--vscode-errorForeground);
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>Your Request</h2>
    <div class="request">
      ${request}
    </div>
    <h2>Error</h2>
    <div class="error">
      <p>An error occurred while generating code:</p>
      <p>${error}</p>
    </div>
  </div>
</body>
</html>`;
}
/**
 * Add an MCP server from a GitHub repository
 */
async function addMcpRepo() {
    // Get the repository URL from the user
    const repoUrl = await vscode.window.showInputBox({
        prompt: 'Enter the GitHub repository URL',
        placeHolder: 'https://github.com/username/repo',
        validateInput: (value) => {
            if (!value) {
                return 'Repository URL is required';
            }
            if (!value.startsWith('https://github.com/')) {
                return 'Repository URL must start with https://github.com/';
            }
            return null;
        }
    });
    if (!repoUrl) {
        return;
    }
    // Show a progress notification
    vscode.window.withProgress({
        location: vscode.ProgressLocation.Notification,
        title: 'Adding MCP server...',
        cancellable: false
    }, async () => {
        try {
            // Add the server
            const server = await mcpServerManager?.addServerFromGitHub(repoUrl);
            // Show a success message
            vscode.window.showInformationMessage(`Added MCP server: ${server?.name}`);
        }
        catch (error) {
            vscode.window.showErrorMessage(`Error adding MCP server: ${error}`);
        }
    });
}
/**
 * Manage MCP servers
 */
async function manageMcpServers() {
    // Focus the MCP servers view
    vscode.commands.executeCommand('qwenMcpServers.focus');
}
/**
 * Start an MCP server
 * @param item Server tree item
 */
async function startMcpServer(item) {
    // If no item is provided, show a quick pick to select a server
    let serverId;
    if (item?.server?.id) {
        serverId = item.server.id;
    }
    else {
        const servers = mcpServerManager?.getServers() || [];
        const stoppedServers = servers.filter(s => s.status === 'stopped');
        if (stoppedServers.length === 0) {
            vscode.window.showInformationMessage('No stopped servers to start');
            return;
        }
        const items = stoppedServers.map(s => ({
            label: s.name,
            description: s.description,
            id: s.id
        }));
        const selected = await vscode.window.showQuickPick(items, {
            placeHolder: 'Select a server to start'
        });
        if (!selected) {
            return;
        }
        serverId = selected.id;
    }
    if (!serverId) {
        return;
    }
    // Show a progress notification
    vscode.window.withProgress({
        location: vscode.ProgressLocation.Notification,
        title: 'Starting MCP server...',
        cancellable: false
    }, async () => {
        try {
            // Start the server
            if (mcpServerManager && serverId) {
                await mcpServerManager.startServer(serverId);
            }
            // Show a success message
            vscode.window.showInformationMessage(`Started MCP server: ${serverId}`);
        }
        catch (error) {
            vscode.window.showErrorMessage(`Error starting MCP server: ${error}`);
        }
    });
}
/**
 * Stop an MCP server
 * @param item Server tree item
 */
async function stopMcpServer(item) {
    // If no item is provided, show a quick pick to select a server
    let serverId;
    if (item?.server?.id) {
        serverId = item.server.id;
    }
    else {
        const servers = mcpServerManager?.getServers() || [];
        const runningServers = servers.filter(s => s.status === 'running');
        if (runningServers.length === 0) {
            vscode.window.showInformationMessage('No running servers to stop');
            return;
        }
        const items = runningServers.map(s => ({
            label: s.name,
            description: s.description,
            id: s.id
        }));
        const selected = await vscode.window.showQuickPick(items, {
            placeHolder: 'Select a server to stop'
        });
        if (!selected) {
            return;
        }
        serverId = selected.id;
    }
    if (!serverId) {
        return;
    }
    // Show a progress notification
    vscode.window.withProgress({
        location: vscode.ProgressLocation.Notification,
        title: 'Stopping MCP server...',
        cancellable: false
    }, async () => {
        try {
            // Stop the server
            if (mcpServerManager && serverId) {
                await mcpServerManager.stopServer(serverId);
            }
            // Show a success message
            vscode.window.showInformationMessage(`Stopped MCP server: ${serverId}`);
        }
        catch (error) {
            vscode.window.showErrorMessage(`Error stopping MCP server: ${error}`);
        }
    });
}
/**
 * Restart an MCP server
 * @param item Server tree item
 */
async function restartMcpServer(item) {
    // If no item is provided, show a quick pick to select a server
    let serverId;
    if (item?.server?.id) {
        serverId = item.server.id;
    }
    else {
        const servers = mcpServerManager?.getServers() || [];
        const runningServers = servers.filter(s => s.status === 'running');
        if (runningServers.length === 0) {
            vscode.window.showInformationMessage('No running servers to restart');
            return;
        }
        const items = runningServers.map(s => ({
            label: s.name,
            description: s.description,
            id: s.id
        }));
        const selected = await vscode.window.showQuickPick(items, {
            placeHolder: 'Select a server to restart'
        });
        if (!selected) {
            return;
        }
        serverId = selected.id;
    }
    if (!serverId) {
        return;
    }
    // Show a progress notification
    vscode.window.withProgress({
        location: vscode.ProgressLocation.Notification,
        title: 'Restarting MCP server...',
        cancellable: false
    }, async () => {
        try {
            // Restart the server
            if (mcpServerManager && serverId) {
                await mcpServerManager.restartServer(serverId);
            }
            // Show a success message
            vscode.window.showInformationMessage(`Restarted MCP server: ${serverId}`);
        }
        catch (error) {
            vscode.window.showErrorMessage(`Error restarting MCP server: ${error}`);
        }
    });
}
/**
 * View the logs for an MCP server
 * @param item Server tree item
 */
async function viewMcpServerLogs(item) {
    // If no item is provided, show a quick pick to select a server
    let serverId;
    if (item?.server?.id) {
        serverId = item.server.id;
    }
    else {
        const servers = mcpServerManager?.getServers() || [];
        if (servers.length === 0) {
            vscode.window.showInformationMessage('No servers available');
            return;
        }
        const items = servers.map(s => ({
            label: s.name,
            description: s.description,
            id: s.id
        }));
        const selected = await vscode.window.showQuickPick(items, {
            placeHolder: 'Select a server to view logs'
        });
        if (!selected) {
            return;
        }
        serverId = selected.id;
    }
    if (!serverId) {
        return;
    }
    try {
        // Get the server
        const server = mcpServerManager?.getServer(serverId);
        if (!server) {
            vscode.window.showErrorMessage(`Server ${serverId} not found`);
            return;
        }
        // Get the logs
        const logs = mcpServerManager?.getServerLogs(serverId);
        if (!logs || logs.length === 0) {
            vscode.window.showInformationMessage(`No logs available for server ${serverId}`);
            return;
        }
        // Create a new output channel
        const channel = vscode.window.createOutputChannel(`MCP Server: ${server.name}`);
        // Write the logs to the channel
        channel.appendLine(logs.join('\n'));
        // Show the channel
        channel.show();
    }
    catch (error) {
        vscode.window.showErrorMessage(`Error viewing logs: ${error}`);
    }
}
/**
 * View the schema for an MCP server
 * @param item Server tree item
 */
async function viewMcpServerSchema(item) {
    // If no item is provided, show a quick pick to select a server
    let serverId;
    if (item?.server?.id) {
        serverId = item.server.id;
    }
    else {
        const servers = mcpServerManager?.getServers() || [];
        const runningServers = servers.filter(s => s.status === 'running');
        if (runningServers.length === 0) {
            vscode.window.showInformationMessage('No running servers to view schema');
            return;
        }
        const items = runningServers.map(s => ({
            label: s.name,
            description: s.description,
            id: s.id
        }));
        const selected = await vscode.window.showQuickPick(items, {
            placeHolder: 'Select a server to view schema'
        });
        if (!selected) {
            return;
        }
        serverId = selected.id;
    }
    if (!serverId) {
        return;
    }
    try {
        // Get the server
        const server = mcpServerManager?.getServer(serverId);
        if (!server) {
            vscode.window.showErrorMessage(`Server ${serverId} not found`);
            return;
        }
        // Get the schema
        const schema = server.schema;
        if (!schema) {
            vscode.window.showInformationMessage(`No schema available for server ${serverId}`);
            return;
        }
        // Create a new untitled document
        const document = await vscode.workspace.openTextDocument({
            content: JSON.stringify(schema, null, 2),
            language: 'json'
        });
        // Show the document
        await vscode.window.showTextDocument(document);
    }
    catch (error) {
        vscode.window.showErrorMessage(`Error viewing schema: ${error}`);
    }
}
/**
 * Refresh the MCP servers view
 */
async function refreshMcpServers() {
    mcpServerTreeDataProvider?.refresh();
}
/**
 * Test the API connection
 */
async function testApiConnection() {
    if (!qwenApiClient) {
        vscode.window.showErrorMessage('Qwen API client not initialized');
        return;
    }
    // Show a progress notification
    vscode.window.withProgress({
        location: vscode.ProgressLocation.Notification,
        title: 'Testing API connection...',
        cancellable: false
    }, async () => {
        try {
            // Create a simple test prompt
            const response = await qwenApiClient.generateCompletion({
                prompt: 'Hello, can you respond with a simple "Hello, I am Qwen!" to test the connection?',
                maxTokens: 20,
                skipCache: true // Skip cache to ensure we're testing the actual API connection
            });
            // Show a success message
            vscode.window.showInformationMessage(`API connection successful! Response: ${response.text.substring(0, 50)}${response.text.length > 50 ? '...' : ''}`);
        }
        catch (error) {
            // Show an error message
            const errorMessage = error instanceof Error ? error.message : String(error);
            vscode.window.showErrorMessage(`API connection failed: ${errorMessage}`);
        }
    });
}
/**
 * Verify the extension configuration
 */
async function verifyExtensionConfiguration() {
    // Get the current configuration
    const config = (0, configuration_1.getConfiguration)();
    // Verify the configuration
    const verificationResult = (0, configuration_1.verifyConfiguration)(config);
    if (verificationResult.isValid) {
        // Show a success message
        vscode.window.showInformationMessage('Configuration is valid');
    }
    else {
        // Show an error message with the issues
        const issuesMessage = verificationResult.issues.join('\n');
        vscode.window.showErrorMessage(`Configuration issues found:\n${issuesMessage}`);
        // Offer to open settings
        const openSettings = 'Open Settings';
        vscode.window.showWarningMessage('Would you like to update your settings?', openSettings)
            .then(selection => {
            if (selection === openSettings) {
                vscode.commands.executeCommand('workbench.action.openSettings', 'qwen-coder-assistant');
            }
        });
    }
}
/**
 * Test an MCP tool
 */
async function testMcpTool() {
    try {
        if (!mcpClient || !mcpServerManager) {
            throw new Error('MCP client or server manager not initialized');
        }
        // Get all running servers
        const servers = mcpServerManager.getServers().filter(s => s.status === 'running');
        if (servers.length === 0) {
            throw new Error('No running MCP servers found. Please start a server first.');
        }
        // Let the user select a server
        const serverItems = servers.map(s => ({
            label: s.name,
            description: s.description,
            detail: `Status: ${s.status}, Endpoint: ${s.endpoint || 'N/A'}`,
            server: s
        }));
        const selectedServer = await vscode.window.showQuickPick(serverItems, {
            placeHolder: 'Select an MCP server',
            title: 'Test MCP Tool'
        });
        if (!selectedServer) {
            return;
        }
        // Get all tools for the selected server
        const tools = selectedServer.server.schema?.tools || [];
        if (tools.length === 0) {
            throw new Error(`No tools found for server ${selectedServer.server.name}`);
        }
        // Let the user select a tool
        const toolItems = tools.map(t => ({
            label: t.name,
            description: t.description,
            detail: `Parameters: ${t.parameters.length}`,
            tool: t
        }));
        const selectedTool = await vscode.window.showQuickPick(toolItems, {
            placeHolder: 'Select a tool to test',
            title: 'Test MCP Tool'
        });
        if (!selectedTool) {
            return;
        }
        // Collect parameters for the tool
        const parameters = {};
        for (const param of selectedTool.tool.parameters) {
            const paramValue = await vscode.window.showInputBox({
                prompt: `Enter value for parameter '${param.name}'${param.required ? ' (required)' : ''}`,
                placeHolder: param.description,
                ignoreFocusOut: true,
                validateInput: value => {
                    if (param.required && !value) {
                        return 'This parameter is required';
                    }
                    return null;
                }
            });
            if (param.required && !paramValue) {
                return; // User cancelled
            }
            if (paramValue) {
                // Convert the value to the appropriate type
                if (param.type === 'number') {
                    parameters[param.name] = Number(paramValue);
                }
                else if (param.type === 'boolean') {
                    parameters[param.name] = paramValue.toLowerCase() === 'true';
                }
                else if (param.type === 'array' || param.type === 'object') {
                    try {
                        parameters[param.name] = JSON.parse(paramValue);
                    }
                    catch (error) {
                        throw new Error(`Invalid JSON for parameter ${param.name}: ${error}`);
                    }
                }
                else {
                    parameters[param.name] = paramValue;
                }
            }
        }
        // Show a progress notification
        vscode.window.withProgress({
            location: vscode.ProgressLocation.Notification,
            title: `Invoking tool ${selectedTool.tool.name}...`,
            cancellable: false
        }, async () => {
            try {
                // Invoke the tool
                const result = await mcpClient.invokeTool(selectedServer.server.id, selectedTool.tool.name, parameters);
                // Create a new untitled document to display the result
                const document = await vscode.workspace.openTextDocument({
                    content: JSON.stringify(result, null, 2),
                    language: 'json'
                });
                // Show the document
                await vscode.window.showTextDocument(document);
                // Show a success message
                if (result.status === 'success') {
                    vscode.window.showInformationMessage(`Tool ${selectedTool.tool.name} invoked successfully`);
                }
                else {
                    vscode.window.showErrorMessage(`Error invoking tool: ${result.error}`);
                }
            }
            catch (error) {
                vscode.window.showErrorMessage(`Error invoking tool: ${error}`);
            }
        });
    }
    catch (error) {
        vscode.window.showErrorMessage(`Error testing MCP tool: ${error}`);
    }
}
/**
 * Deactivate the extension
 */
async function deactivate() {
    // Clean up resources when the extension is deactivated
    console.log('Qwen Coder Assistant is now deactivated!');
    // Dispose the agent coordinator
    if (agentCoordinator) {
        agentCoordinator.dispose();
        agentCoordinator = undefined;
    }
    // Dispose the MCP server manager
    if (mcpServerManager) {
        mcpServerManager.dispose();
        mcpServerManager = undefined;
    }
    // Dispose the MCP client
    if (mcpClient) {
        mcpClient.dispose();
        mcpClient = undefined;
    }
}
//# sourceMappingURL=extension.js.map
```


---

### File: `out/responseFormatter.js`

```javascript
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatResponse = formatResponse;
exports.insertCodeIntoEditor = insertCodeIntoEditor;
exports.showResponseInPanel = showResponseInPanel;
exports.showStreamingResponseInPanel = showStreamingResponseInPanel;
const vscode = __importStar(require("vscode"));
function formatResponse(response) {
    // Extract code blocks from the response
    const codeBlockRegex = /```(\w+)?\n([\s\S]*?)```/g;
    const codeBlocks = [];
    let match;
    while ((match = codeBlockRegex.exec(response)) !== null) {
        const language = match[1] || 'text';
        const code = match[2];
        codeBlocks.push({ language, code });
    }
    return {
        markdown: response,
        codeBlocks
    };
}
function insertCodeIntoEditor(code, editor) {
    if (!editor) {
        editor = vscode.window.activeTextEditor;
        if (!editor) {
            vscode.window.showErrorMessage('No active editor found');
            return;
        }
    }
    const selection = editor.selection;
    editor.edit(editBuilder => {
        if (selection.isEmpty) {
            editBuilder.insert(selection.start, code);
        }
        else {
            editBuilder.replace(selection, code);
        }
    });
}
function showResponseInPanel(response, context) {
    // Import the QwenResponsePanel class to use its functionality
    const { QwenResponsePanel } = require('./webview/panel');
    // Create or show the panel
    const panel = QwenResponsePanel.createOrShow(context.extensionUri, 'Qwen Coder Response');
    // Set the content
    panel.setContent(response);
}
/**
 * Show a streaming response in a webview panel
 * @param context The extension context
 * @param onPanelReady Callback that receives the streaming handler function
 */
function showStreamingResponseInPanel(context, onPanelReady) {
    // Import the QwenResponsePanel class to use its functionality
    const { QwenResponsePanel } = require('./webview/panel');
    // Create or show the panel
    const panel = QwenResponsePanel.createOrShow(context.extensionUri, 'Qwen Coder Response (Streaming)');
    // Set initial empty content
    panel.setContent('');
    // Create a streaming handler function
    const streamHandler = (chunk, isComplete) => {
        panel.appendContent(chunk, isComplete);
    };
    // Call the callback with the streaming handler
    onPanelReady(streamHandler);
}
//# sourceMappingURL=responseFormatter.js.map
```


---

### File: `out/conversationHistory.js`

```javascript
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConversationTreeItem = exports.ConversationHistoryProvider = exports.ConversationHistoryManager = void 0;
exports.registerConversationHistoryView = registerConversationHistoryView;
exports.saveToHistory = saveToHistory;
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const vscode = __importStar(require("vscode"));
/**
 * Manages conversation history for the extension
 */
class ConversationHistoryManager {
    constructor(context) {
        this.conversations = [];
        this.MAX_HISTORY_ITEMS = 50;
        this.storageUri = context.globalStorageUri;
        this.loadConversations();
    }
    /**
     * Get the singleton instance of the conversation history manager
     */
    static getInstance(context) {
        if (!ConversationHistoryManager.instance) {
            ConversationHistoryManager.instance = new ConversationHistoryManager(context);
        }
        return ConversationHistoryManager.instance;
    }
    /**
     * Add a new conversation to the history
     */
    addConversation(prompt, response, systemPrompt) {
        // Generate a title from the prompt (first line or first few words)
        const title = this.generateTitle(prompt);
        // Create a new conversation entry
        const entry = {
            id: Date.now().toString(),
            title,
            timestamp: Date.now(),
            prompt,
            response,
            systemPrompt
        };
        // Add to the beginning of the array
        this.conversations.unshift(entry);
        // Limit the number of conversations
        if (this.conversations.length > this.MAX_HISTORY_ITEMS) {
            this.conversations = this.conversations.slice(0, this.MAX_HISTORY_ITEMS);
        }
        // Save the updated conversations
        this.saveConversations();
        return entry;
    }
    /**
     * Get all conversations
     */
    getConversations() {
        return [...this.conversations];
    }
    /**
     * Get a conversation by ID
     */
    getConversation(id) {
        return this.conversations.find(c => c.id === id);
    }
    /**
     * Delete a conversation by ID
     */
    deleteConversation(id) {
        const initialLength = this.conversations.length;
        this.conversations = this.conversations.filter(c => c.id !== id);
        if (this.conversations.length !== initialLength) {
            this.saveConversations();
            return true;
        }
        return false;
    }
    /**
     * Clear all conversations
     */
    clearConversations() {
        this.conversations = [];
        this.saveConversations();
    }
    /**
     * Generate a title from the prompt
     */
    generateTitle(prompt) {
        // Use the first line if it's short enough
        const firstLine = prompt.split('\n')[0].trim();
        if (firstLine.length <= 50) {
            return firstLine;
        }
        // Otherwise use the first few words
        return firstLine.substring(0, 47) + '...';
    }
    /**
     * Load conversations from storage
     */
    loadConversations() {
        try {
            if (!this.storageUri) {
                return;
            }
            // Create the storage directory if it doesn't exist
            const dirPath = this.storageUri.fsPath;
            if (!fs.existsSync(dirPath)) {
                fs.mkdirSync(dirPath, { recursive: true });
            }
            const filePath = path.join(dirPath, 'conversations.json');
            if (fs.existsSync(filePath)) {
                const data = fs.readFileSync(filePath, 'utf8');
                this.conversations = JSON.parse(data);
            }
        }
        catch (error) {
            console.error('Error loading conversations:', error);
            this.conversations = [];
        }
    }
    /**
     * Save conversations to storage
     */
    saveConversations() {
        try {
            if (!this.storageUri) {
                return;
            }
            // Create the storage directory if it doesn't exist
            const dirPath = this.storageUri.fsPath;
            if (!fs.existsSync(dirPath)) {
                fs.mkdirSync(dirPath, { recursive: true });
            }
            const filePath = path.join(dirPath, 'conversations.json');
            fs.writeFileSync(filePath, JSON.stringify(this.conversations, null, 2), 'utf8');
        }
        catch (error) {
            console.error('Error saving conversations:', error);
        }
    }
}
exports.ConversationHistoryManager = ConversationHistoryManager;
/**
 * Tree data provider for conversation history
 */
class ConversationHistoryProvider {
    constructor(historyManager) {
        this.historyManager = historyManager;
        this._onDidChangeTreeData = new vscode.EventEmitter();
        this.onDidChangeTreeData = this._onDidChangeTreeData.event;
    }
    refresh() {
        this._onDidChangeTreeData.fire();
    }
    getTreeItem(element) {
        return element;
    }
    getChildren(element) {
        if (element) {
            return Promise.resolve([]);
        }
        else {
            const conversations = this.historyManager.getConversations();
            return Promise.resolve(conversations.map(conversation => new ConversationTreeItem(conversation)));
        }
    }
}
exports.ConversationHistoryProvider = ConversationHistoryProvider;
/**
 * Tree item for a conversation
 */
class ConversationTreeItem extends vscode.TreeItem {
    constructor(conversation) {
        super(conversation.title, vscode.TreeItemCollapsibleState.None);
        this.conversation = conversation;
        // Format the date
        const date = new Date(conversation.timestamp);
        const formattedDate = date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
        this.tooltip = `${conversation.title}\n${formattedDate}`;
        this.description = formattedDate;
        this.contextValue = 'conversation';
        // Set the command to open the conversation
        this.command = {
            command: 'qwen-coder-assistant.openConversation',
            title: 'Open Conversation',
            arguments: [conversation]
        };
    }
}
exports.ConversationTreeItem = ConversationTreeItem;
/**
 * Register the conversation history view
 */
function registerConversationHistoryView(context) {
    // Create the history manager
    const historyManager = ConversationHistoryManager.getInstance(context);
    // Create the tree data provider
    const treeDataProvider = new ConversationHistoryProvider(historyManager);
    // Register the tree view
    const treeView = vscode.window.createTreeView('qwenConversationHistory', {
        treeDataProvider,
        showCollapseAll: false
    });
    // Register the refresh command
    const refreshCommand = vscode.commands.registerCommand('qwen-coder-assistant.refreshConversationHistory', () => {
        treeDataProvider.refresh();
    });
    // Register the open conversation command
    const openConversationCommand = vscode.commands.registerCommand('qwen-coder-assistant.openConversation', (conversation) => {
        // Import the QwenResponsePanel class to use its functionality
        const { QwenResponsePanel } = require('./webview/panel');
        // Create or show the panel
        const panel = QwenResponsePanel.createOrShow(context.extensionUri, `Conversation: ${conversation.title}`);
        // Format the conversation for display
        const content = `# ${conversation.title}\n\n## Prompt\n\n${conversation.prompt}\n\n## Response\n\n${conversation.response}`;
        // Set the content
        panel.setContent(content);
    });
    // Register the delete conversation command
    const deleteConversationCommand = vscode.commands.registerCommand('qwen-coder-assistant.deleteConversation', async (item) => {
        const result = await vscode.window.showWarningMessage(`Are you sure you want to delete the conversation "${item.conversation.title}"?`, { modal: true }, 'Delete');
        if (result === 'Delete') {
            historyManager.deleteConversation(item.conversation.id);
            treeDataProvider.refresh();
        }
    });
    // Register the clear all conversations command
    const clearConversationsCommand = vscode.commands.registerCommand('qwen-coder-assistant.clearConversations', async () => {
        const result = await vscode.window.showWarningMessage('Are you sure you want to clear all conversations? This cannot be undone.', { modal: true }, 'Clear All');
        if (result === 'Clear All') {
            historyManager.clearConversations();
            treeDataProvider.refresh();
        }
    });
    // Add to subscriptions
    context.subscriptions.push(treeView, refreshCommand, openConversationCommand, deleteConversationCommand, clearConversationsCommand);
}
/**
 * Save a conversation to history
 */
function saveToHistory(context, prompt, response, systemPrompt) {
    const historyManager = ConversationHistoryManager.getInstance(context);
    historyManager.addConversation(prompt, response, systemPrompt);
    // Refresh the tree view
    vscode.commands.executeCommand('qwen-coder-assistant.refreshConversationHistory');
}
//# sourceMappingURL=conversationHistory.js.map
```


---

### File: `out/mockQwenApi.js`

```javascript
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MockQwenApiClient = void 0;
const cache_1 = require("./cache");
const qwenApi_1 = require("./qwenApi");
/**
 * A mock implementation of the QwenApiClient for testing and development
 * without requiring an actual API endpoint.
 */
class MockQwenApiClient extends qwenApi_1.QwenApiClient {
    constructor(config) {
        super(config);
    }
    /**
     * Override the updateConfig method to update the cache configuration
     */
    updateConfig(config) {
        super.updateConfig(config);
    }
    /**
     * Override the generateCompletion method to return mock responses
     */
    async generateCompletion(options) {
        // Check cache first (unless skipCache is true or cacheEnabled is false)
        if (!options.skipCache && this.config.cacheEnabled) {
            const cacheKey = (0, cache_1.generateCacheKey)(options.prompt, {
                systemPrompt: options.systemPrompt,
                maxTokens: options.maxTokens || this.config.maxTokens,
                temperature: options.temperature || this.config.temperature
            });
            const cachedResponse = this.cache.get(cacheKey);
            if (cachedResponse) {
                console.log('Using cached mock response for prompt:', options.prompt.substring(0, 50) + '...');
                return {
                    ...cachedResponse,
                    cached: true
                };
            }
        }
        // Simulate API delay
        await new Promise(resolve => setTimeout(resolve, 1000));
        // Generate a mock response based on the prompt
        const prompt = options.prompt.toLowerCase();
        let response = '';
        if (prompt.includes('explain')) {
            response = this.generateExplanationResponse(prompt);
        }
        else if (prompt.includes('generate') || prompt.includes('write')) {
            response = this.generateCodeResponse(prompt);
        }
        else {
            response = this.generateGeneralResponse(prompt);
        }
        const result = {
            text: response,
            usage: {
                promptTokens: options.prompt.length,
                completionTokens: response.length,
                totalTokens: options.prompt.length + response.length
            }
        };
        // Cache the response (unless skipCache is true or cacheEnabled is false)
        if (!options.skipCache && this.config.cacheEnabled) {
            const cacheKey = (0, cache_1.generateCacheKey)(options.prompt, {
                systemPrompt: options.systemPrompt,
                maxTokens: options.maxTokens || this.config.maxTokens,
                temperature: options.temperature || this.config.temperature
            });
            this.cache.set(cacheKey, result);
        }
        return result;
    }
    generateExplanationResponse(prompt) {
        return `# Code Explanation

This code appears to be ${prompt.includes('javascript') ? 'JavaScript' : prompt.includes('python') ? 'Python' : 'a programming language'} code that performs some operations.

## Key Components:

1. **Initialization**: The code sets up initial variables and configurations.
2. **Processing**: It processes data through several steps.
3. **Output**: Finally, it returns or displays the results.

## How It Works:

The code follows a typical pattern where it:
1. Takes input
2. Transforms the input through algorithms
3. Produces output based on the transformation

## Best Practices:

The code demonstrates several good practices:
- Clear variable naming
- Proper error handling
- Efficient algorithm implementation

Would you like me to explain any specific part in more detail?`;
    }
    generateCodeResponse(prompt) {
        const language = prompt.includes('javascript') || prompt.includes('js') ? 'javascript' :
            prompt.includes('typescript') || prompt.includes('ts') ? 'typescript' :
                prompt.includes('python') || prompt.includes('py') ? 'python' : 'javascript';
        if (language === 'javascript' || language === 'typescript') {
            return `# Generated Code

Here's a ${language} implementation for your request:

\`\`\`${language}
/**
 * A utility function that performs the requested operation
 * @param {Array} data - The input data to process
 * @param {Object} options - Configuration options
 * @returns {Array} - The processed results
 */
function processData(data, options = {}) {
  // Default options
  const config = {
    sortBy: 'name',
    filterEmpty: true,
    maxResults: 100,
    ...options
  };

  // Input validation
  if (!Array.isArray(data)) {
    throw new Error('Input must be an array');
  }

  // Filter out empty items if configured
  let results = config.filterEmpty
    ? data.filter(item => item && Object.keys(item).length > 0)
    : [...data];

  // Sort the results if needed
  if (config.sortBy) {
    results.sort((a, b) => {
      if (a[config.sortBy] < b[config.sortBy]) return -1;
      if (a[config.sortBy] > b[config.sortBy]) return 1;
      return 0;
    });
  }

  // Limit the number of results
  if (config.maxResults && results.length > config.maxResults) {
    results = results.slice(0, config.maxResults);
  }

  return results;
}

// Example usage
const sampleData = [
  { name: 'Item 3', value: 30 },
  { name: 'Item 1', value: 10 },
  { name: 'Item 2', value: 20 },
  {},  // Empty object
  { name: 'Item 4', value: 40 }
];

const result = processData(sampleData, {
  sortBy: 'value',
  maxResults: 3
});

console.log(result);
\`\`\`

This implementation includes:
- Flexible configuration options
- Input validation
- Sorting and filtering capabilities
- Example usage

You can customize the function parameters and behavior based on your specific requirements.`;
        }
        else if (language === 'python') {
            return `# Generated Code

Here's a Python implementation for your request:

\`\`\`python
from typing import List, Dict, Any, Optional
import copy

def process_data(data: List[Dict[str, Any]],
                 sort_by: Optional[str] = 'name',
                 filter_empty: bool = True,
                 max_results: Optional[int] = 100) -> List[Dict[str, Any]]:
    """
    Process a list of dictionaries based on the provided options.

    Args:
        data: List of dictionaries to process
        sort_by: Key to sort by (None for no sorting)
        filter_empty: Whether to filter out empty dictionaries
        max_results: Maximum number of results to return (None for all)

    Returns:
        Processed list of dictionaries
    """
    # Input validation
    if not isinstance(data, list):
        raise TypeError("Input must be a list")

    # Create a copy to avoid modifying the original
    results = copy.deepcopy(data)

    # Filter out empty items if configured
    if filter_empty:
        results = [item for item in results if item and len(item) > 0]

    # Sort the results if needed
    if sort_by is not None:
        results.sort(key=lambda x: x.get(sort_by, None))

    # Limit the number of results
    if max_results is not None and len(results) > max_results:
        results = results[:max_results]

    return results

# Example usage
if __name__ == "__main__":
    sample_data = [
        {"name": "Item 3", "value": 30},
        {"name": "Item 1", "value": 10},
        {"name": "Item 2", "value": 20},
        {},  # Empty dictionary
        {"name": "Item 4", "value": 40}
    ]

    result = process_data(
        data=sample_data,
        sort_by="value",
        max_results=3
    )

    print(result)
\`\`\`

This implementation includes:
- Type hints for better code quality
- Docstring with parameter descriptions
- Input validation
- Deep copying to prevent modifying the original data
- Sorting and filtering capabilities
- Example usage

You can adjust the function parameters and behavior based on your specific requirements.`;
        }
        else {
            return `# Generated Code

I'm not sure which programming language you prefer, so here's a pseudocode implementation:

\`\`\`
function ProcessData(data, options)
    // Set default options
    if options.sortBy is undefined then options.sortBy = "name"
    if options.filterEmpty is undefined then options.filterEmpty = true
    if options.maxResults is undefined then options.maxResults = 100

    // Validate input
    if data is not a list/array then
        throw Error("Input must be an array/list")
    end if

    // Create a copy of the data
    results = copy(data)

    // Filter empty items if needed
    if options.filterEmpty then
        results = filter(results, item => item is not empty)
    end if

    // Sort if needed
    if options.sortBy is not null then
        results = sort(results by options.sortBy)
    end if

    // Limit results
    if options.maxResults is not null and length(results) > options.maxResults then
        results = first options.maxResults items from results
    end if

    return results
end function
\`\`\`

Let me know which programming language you'd prefer, and I can provide a more specific implementation.`;
        }
    }
    generateGeneralResponse(_prompt) {
        return `# Response

Thank you for your question! Here's what I can tell you:

The concept you're asking about is fundamental in software development. Let me break it down:

## Key Points:

1. **Understanding the Basics**:
   It's important to grasp the fundamental concepts before diving into implementation details.

2. **Best Practices**:
   - Write clean, maintainable code
   - Document your work thoroughly
   - Test your code regularly
   - Follow established patterns and conventions

3. **Common Approaches**:
   There are several ways to tackle this problem, each with its own advantages:
   - Method A: Simple but may not scale well
   - Method B: More complex but highly efficient
   - Method C: Balanced approach for most use cases

## Example:

Here's a simplified example to illustrate:

\`\`\`javascript
function demonstrateConcept(input) {
  // Validate input
  if (!input) {
    return null;
  }

  // Process the input
  const result = input.map(item => {
    return {
      ...item,
      processed: true,
      timestamp: Date.now()
    };
  });

  return result;
}
\`\`\`

## Further Learning:

If you'd like to explore this topic further, I recommend:
- Reading the official documentation
- Practicing with small projects
- Joining community discussions

Is there a specific aspect you'd like me to elaborate on?`;
    }
    /**
     * Override the generateStreamingCompletion method to simulate streaming responses
     */
    async generateStreamingCompletion(options, onChunk) {
        try {
            // Generate a complete response first
            const prompt = options.prompt.toLowerCase();
            let fullResponse = '';
            if (prompt.includes('explain')) {
                fullResponse = this.generateExplanationResponse(prompt);
            }
            else if (prompt.includes('generate') || prompt.includes('write')) {
                fullResponse = this.generateCodeResponse(prompt);
            }
            else {
                fullResponse = this.generateGeneralResponse(prompt);
            }
            // Simulate streaming by sending chunks with delays
            const chunks = this.chunkResponse(fullResponse);
            for (let i = 0; i < chunks.length; i++) {
                // Simulate network delay
                await new Promise(resolve => setTimeout(resolve, 100));
                // Send the chunk
                const isLast = i === chunks.length - 1;
                onChunk(chunks[i], isLast);
                // If we're simulating an error, break early
                if (prompt.includes('error') && i > chunks.length / 2) {
                    onChunk('\n\nError: Simulated streaming error for testing purposes', true);
                    break;
                }
            }
        }
        catch (error) {
            console.error('Error in mock streaming:', error);
            onChunk(`Error: ${error instanceof Error ? error.message : String(error)}`, true);
        }
    }
    /**
     * Split a response into chunks for simulated streaming
     */
    chunkResponse(response) {
        // Split by sentences or line breaks for more natural chunking
        const chunks = [];
        const sentences = response.split(/(?<=\.|\?|\!|\n)\s+/);
        // Group sentences into reasonable chunks
        let currentChunk = '';
        for (const sentence of sentences) {
            currentChunk += sentence + ' ';
            // When chunk gets big enough, add it to chunks array
            if (currentChunk.length > 30) {
                chunks.push(currentChunk.trim());
                currentChunk = '';
            }
        }
        // Add any remaining content
        if (currentChunk.trim()) {
            chunks.push(currentChunk.trim());
        }
        return chunks;
    }
}
exports.MockQwenApiClient = MockQwenApiClient;
//# sourceMappingURL=mockQwenApi.js.map
```


---

### File: `out/configuration.js`

```javascript
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.getConfiguration = getConfiguration;
exports.verifyConfiguration = verifyConfiguration;
exports.registerConfigurationListener = registerConfigurationListener;
const vscode = __importStar(require("vscode"));
/**
 * Get the extension configuration
 * @returns The extension configuration
 */
function getConfiguration() {
    const config = vscode.workspace.getConfiguration('qwen-coder-assistant');
    return {
        apiEndpoint: config.get('apiEndpoint') || 'http://localhost:8000/v1',
        apiKey: config.get('apiKey') || '',
        maxTokens: config.get('maxTokens') || 2048,
        temperature: config.get('temperature') || 0.7,
        cacheEnabled: config.get('cacheEnabled') !== false, // Default to true
        cacheTTLMinutes: config.get('cacheTTLMinutes') || 30,
        cacheMaxEntries: config.get('cacheMaxEntries') || 100,
        mcpServers: {
            storagePath: config.get('mcpServers.storagePath') || '',
            autoStart: config.get('mcpServers.autoStart') !== false, // Default to true
            autoStartList: config.get('mcpServers.autoStartList') || [],
            dockerOptions: config.get('mcpServers.dockerOptions') || {
                socketPath: '/var/run/docker.sock',
                memory: 2048,
                cpus: 2
            },
            githubOptions: config.get('mcpServers.githubOptions') || {
                token: '',
                timeout: 30000
            }
        }
    };
}
/**
 * Verify that the configuration is valid
 * @param config The configuration to verify
 * @returns An object with validation results
 */
function verifyConfiguration(config) {
    const issues = [];
    // Check API configuration
    const apiConfigured = Boolean(config.apiEndpoint && config.apiEndpoint.trim() !== '');
    if (!apiConfigured) {
        issues.push('API endpoint is not configured');
    }
    // Check MCP server configuration
    const mcpConfigured = Boolean(config.mcpServers.storagePath && config.mcpServers.storagePath.trim() !== '');
    if (!mcpConfigured) {
        issues.push('MCP server storage path is not configured');
    }
    // Check Docker configuration
    if (!config.mcpServers.dockerOptions.socketPath) {
        issues.push('Docker socket path is not configured');
    }
    return {
        isValid: issues.length === 0,
        issues,
        apiConfigured,
        mcpConfigured
    };
}
// Listen for configuration changes
function registerConfigurationListener(callback) {
    return vscode.workspace.onDidChangeConfiguration(event => {
        if (event.affectsConfiguration('qwen-coder-assistant')) {
            callback(getConfiguration());
        }
    });
}
//# sourceMappingURL=configuration.js.map
```


---

### File: `out/cache.js`

```javascript
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResponseCache = void 0;
exports.generateCacheKey = generateCacheKey;
/**
 * A simple cache implementation for storing API responses
 */
class ResponseCache {
    constructor(maxEntries = 100, ttlMinutes = 30) {
        this.cache = new Map();
        this.maxEntries = maxEntries;
        this.ttl = ttlMinutes * 60 * 1000;
    }
    /**
     * Get the singleton instance of the cache
     */
    static getInstance() {
        if (!ResponseCache.instance) {
            ResponseCache.instance = new ResponseCache();
        }
        return ResponseCache.instance;
    }
    /**
     * Set cache configuration
     * @param maxEntries Maximum number of entries to store
     * @param ttlMinutes Time to live in minutes
     */
    configure(maxEntries, ttlMinutes) {
        this.maxEntries = maxEntries;
        this.ttl = ttlMinutes * 60 * 1000;
        this.cleanup();
    }
    /**
     * Get a value from the cache
     * @param key Cache key
     * @returns The cached value or undefined if not found or expired
     */
    get(key) {
        const entry = this.cache.get(key);
        if (!entry) {
            return undefined;
        }
        // Check if entry has expired
        if (Date.now() > entry.expiry) {
            this.cache.delete(key);
            return undefined;
        }
        // Update access time
        entry.lastAccessed = Date.now();
        return entry.value;
    }
    /**
     * Set a value in the cache
     * @param key Cache key
     * @param value Value to cache
     */
    set(key, value) {
        // If cache is full, remove least recently used entry
        if (this.cache.size >= this.maxEntries) {
            this.removeLRU();
        }
        this.cache.set(key, {
            value,
            expiry: Date.now() + this.ttl,
            lastAccessed: Date.now()
        });
    }
    /**
     * Check if a key exists in the cache and is not expired
     * @param key Cache key
     * @returns True if the key exists and is not expired
     */
    has(key) {
        const entry = this.cache.get(key);
        if (!entry) {
            return false;
        }
        // Check if entry has expired
        if (Date.now() > entry.expiry) {
            this.cache.delete(key);
            return false;
        }
        return true;
    }
    /**
     * Remove a key from the cache
     * @param key Cache key
     */
    delete(key) {
        this.cache.delete(key);
    }
    /**
     * Clear the entire cache
     */
    clear() {
        this.cache.clear();
    }
    /**
     * Get the number of entries in the cache
     */
    size() {
        return this.cache.size;
    }
    /**
     * Remove expired entries from the cache
     */
    cleanup() {
        const now = Date.now();
        for (const [key, entry] of this.cache.entries()) {
            if (now > entry.expiry) {
                this.cache.delete(key);
            }
        }
    }
    /**
     * Remove the least recently used entry from the cache
     */
    removeLRU() {
        let oldest = null;
        let oldestTime = Date.now();
        for (const [key, entry] of this.cache.entries()) {
            if (entry.lastAccessed < oldestTime) {
                oldest = key;
                oldestTime = entry.lastAccessed;
            }
        }
        if (oldest) {
            this.cache.delete(oldest);
        }
    }
}
exports.ResponseCache = ResponseCache;
/**
 * Generate a cache key from a request
 * @param prompt The prompt text
 * @param options Additional options that affect the response
 * @returns A string key for caching
 */
function generateCacheKey(prompt, options = {}) {
    // Create a stable representation of the options
    const optionsStr = Object.keys(options)
        .sort()
        .map(key => `${key}:${JSON.stringify(options[key])}`)
        .join('|');
    // Combine prompt and options into a single key
    return `${prompt}|${optionsStr}`;
}
//# sourceMappingURL=cache.js.map
```


---

### File: `out/errorHandler.js`

```javascript
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ErrorHandler = exports.ErrorType = void 0;
const vscode = __importStar(require("vscode"));
const axios_1 = __importDefault(require("axios"));
var ErrorType;
(function (ErrorType) {
    ErrorType["NetworkError"] = "NetworkError";
    ErrorType["AuthenticationError"] = "AuthenticationError";
    ErrorType["RateLimitError"] = "RateLimitError";
    ErrorType["ServerError"] = "ServerError";
    ErrorType["TimeoutError"] = "TimeoutError";
    ErrorType["UnknownError"] = "UnknownError";
})(ErrorType || (exports.ErrorType = ErrorType = {}));
/**
 * Handles API errors and provides user-friendly error messages
 */
class ErrorHandler {
    /**
     * Process an error and return structured error details
     * @param error The error to process
     * @returns Structured error details
     */
    static processError(error) {
        // Default error details
        let errorDetails = {
            type: ErrorType.UnknownError,
            message: 'An unknown error occurred',
            originalError: error instanceof Error ? error : undefined,
            retryable: false
        };
        // Handle Axios errors
        if (axios_1.default.isAxiosError(error)) {
            errorDetails = this.processAxiosError(error);
        }
        // Handle timeout errors
        else if (error instanceof Error && error.message.includes('timeout')) {
            errorDetails = {
                type: ErrorType.TimeoutError,
                message: 'The request timed out. The server might be overloaded.',
                originalError: error,
                retryable: true,
                suggestedAction: 'Try again later or check your internet connection.'
            };
        }
        // Handle other errors
        else if (error instanceof Error) {
            errorDetails = {
                type: ErrorType.UnknownError,
                message: `Error: ${error.message}`,
                originalError: error,
                retryable: false
            };
        }
        return errorDetails;
    }
    /**
     * Process an Axios error and return structured error details
     * @param error The Axios error to process
     * @returns Structured error details
     */
    static processAxiosError(error) {
        // Network errors
        if (error.code === 'ECONNABORTED' || error.code === 'ECONNREFUSED' || error.code === 'ENOTFOUND') {
            return {
                type: ErrorType.NetworkError,
                message: 'Could not connect to the API. Please check your internet connection.',
                originalError: error,
                retryable: true,
                suggestedAction: 'Check your network connection and try again.'
            };
        }
        // Handle based on HTTP status code
        switch (error.response?.status) {
            case 401:
            case 403:
                return {
                    type: ErrorType.AuthenticationError,
                    message: 'Authentication failed. Please check your API key.',
                    originalError: error,
                    retryable: false,
                    suggestedAction: 'Update your API key in the extension settings.'
                };
            case 429:
                return {
                    type: ErrorType.RateLimitError,
                    message: 'Rate limit exceeded. Too many requests in a short period.',
                    originalError: error,
                    retryable: true,
                    suggestedAction: 'Wait a moment before trying again.'
                };
            case 500:
            case 502:
            case 503:
            case 504:
                return {
                    type: ErrorType.ServerError,
                    message: `Server error (${error.response.status}). The API service might be experiencing issues.`,
                    originalError: error,
                    retryable: true,
                    suggestedAction: 'Try again later.'
                };
            default:
                // Try to extract error message from response if available
                let message = 'An error occurred while communicating with the API.';
                try {
                    if (error.response?.data) {
                        if (typeof error.response.data === 'string') {
                            message = error.response.data;
                        }
                        else if (typeof error.response.data === 'object' && error.response.data.error) {
                            message = error.response.data.error;
                        }
                    }
                }
                catch (e) {
                    // Ignore parsing errors
                }
                return {
                    type: ErrorType.UnknownError,
                    message,
                    originalError: error,
                    retryable: false
                };
        }
    }
    /**
     * Display an error message to the user
     * @param error The error details to display
     */
    static showErrorToUser(error) {
        const message = `${error.message}${error.suggestedAction ? '\n\n' + error.suggestedAction : ''}`;
        // Show different types of notifications based on error type
        if (error.retryable) {
            vscode.window.showWarningMessage(message, 'Retry').then(selection => {
                if (selection === 'Retry') {
                    // Emit an event that can be listened to for retrying the operation
                    // This will be implemented when we add the retry functionality
                }
            });
        }
        else {
            vscode.window.showErrorMessage(message);
        }
        // Log the error for debugging
        console.error('API Error:', error.type, error.originalError);
    }
    /**
     * Handle an error by processing it and showing a message to the user
     * @param error The error to handle
     * @returns The processed error details
     */
    static handleError(error) {
        const errorDetails = this.processError(error);
        this.showErrorToUser(errorDetails);
        return errorDetails;
    }
}
exports.ErrorHandler = ErrorHandler;
//# sourceMappingURL=errorHandler.js.map
```


---

### File: `out/webview/panel.js`

```javascript
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.QwenResponsePanel = void 0;
const vscode = __importStar(require("vscode"));
const responseFormatter_1 = require("../responseFormatter");
class QwenResponsePanel {
    static createOrShow(extensionUri, title = 'Qwen Coder Response') {
        const column = vscode.window.activeTextEditor
            ? vscode.window.activeTextEditor.viewColumn
            : undefined;
        // If we already have a panel, show it
        if (QwenResponsePanel.currentPanel) {
            QwenResponsePanel.currentPanel._panel.reveal(column);
            QwenResponsePanel.currentPanel._panel.title = title;
            return QwenResponsePanel.currentPanel;
        }
        // Otherwise, create a new panel
        const panel = vscode.window.createWebviewPanel('qwenResponse', title, column || vscode.ViewColumn.Beside, {
            enableScripts: true,
            localResourceRoots: [
                vscode.Uri.joinPath(extensionUri, 'media')
            ],
            retainContextWhenHidden: true
        });
        QwenResponsePanel.currentPanel = new QwenResponsePanel(panel, extensionUri);
        return QwenResponsePanel.currentPanel;
    }
    constructor(panel, extensionUri) {
        this._disposables = [];
        this._panel = panel;
        this._extensionUri = extensionUri;
        // Set the webview's initial html content
        this._update('');
        // Listen for when the panel is disposed
        // This happens when the user closes the panel or when the panel is closed programmatically
        this._panel.onDidDispose(() => this.dispose(), null, this._disposables);
        // Handle messages from the webview
        this._panel.webview.onDidReceiveMessage(message => {
            switch (message.command) {
                case 'copy':
                    vscode.env.clipboard.writeText(message.text);
                    vscode.window.showInformationMessage('Code copied to clipboard');
                    break;
                case 'insert':
                    (0, responseFormatter_1.insertCodeIntoEditor)(message.text);
                    vscode.window.showInformationMessage('Code inserted into editor');
                    break;
            }
        }, null, this._disposables);
    }
    dispose() {
        QwenResponsePanel.currentPanel = undefined;
        // Clean up our resources
        this._panel.dispose();
        while (this._disposables.length) {
            const x = this._disposables.pop();
            if (x) {
                x.dispose();
            }
        }
    }
    setContent(content) {
        this._update(content);
    }
    /**
     * Append content to the existing content (for streaming)
     * @param chunk The content chunk to append
     * @param isComplete Whether this is the final chunk
     */
    appendContent(chunk, isComplete) {
        // Send a message to the webview to append content
        this._panel.webview.postMessage({
            command: 'append',
            text: chunk,
            isComplete
        });
    }
    _update(content) {
        const webview = this._panel.webview;
        // Get paths to resources
        const cssUri = webview.asWebviewUri(vscode.Uri.joinPath(this._extensionUri, 'media', 'styles.css'));
        const highlightJsUri = webview.asWebviewUri(vscode.Uri.joinPath(this._extensionUri, 'media', 'highlight.js'));
        // Create HTML content
        this._panel.webview.html = `
      <!DOCTYPE html>
      <html lang="en">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" href="${cssUri}">
        <title>Qwen Coder Response</title>
      </head>
      <body>
        <div id="response-container" class="response-container">
          ${this._formatMarkdown(content)}
        </div>
        <script src="${highlightJsUri}"></script>
        <script>
          const vscode = acquireVsCodeApi();
          let currentMarkdown = '';
          let isProcessingStream = false;
          const responseContainer = document.getElementById('response-container');

          // Listen for messages from the extension
          window.addEventListener('message', event => {
            const message = event.data;

            switch (message.command) {
              case 'append':
                // Handle streaming content
                currentMarkdown += message.text;
                responseContainer.innerHTML = formatMarkdown(currentMarkdown);

                // Apply syntax highlighting and add buttons to code blocks
                applyCodeFormatting();

                // If this is the final chunk, do any final processing
                if (message.isComplete) {
                  isProcessingStream = false;
                  // Final formatting pass
                  responseContainer.innerHTML = formatMarkdown(currentMarkdown);
                  applyCodeFormatting();
                }

                // Scroll to bottom to show new content
                window.scrollTo(0, document.body.scrollHeight);
                break;
            }
          });

          // Function to format markdown text to HTML
          function formatMarkdown(text) {
            if (!text) {
              return '<p>No response yet...</p>';
            }

            // Replace code blocks
            let html = text.replace(/\`\`\`(\w+)?\n([\s\S]*?)\`\`\`/g, (_, lang, code) => {
              return \`<pre><code class="language-\${lang || 'text'}">\${escapeHtml(code)}</code></pre>\`;
            });

            // Replace inline code
            html = html.replace(/\`([^\`]+)\`/g, '<code>$1</code>');

            // Replace headers
            html = html.replace(/^### (.*$)/gm, '<h3>$1</h3>');
            html = html.replace(/^## (.*$)/gm, '<h2>$1</h2>');
            html = html.replace(/^# (.*$)/gm, '<h1>$1</h1>');

            // Replace lists
            html = html.replace(/^\* (.*$)/gm, '<ul><li>$1</li></ul>');
            html = html.replace(/^- (.*$)/gm, '<ul><li>$1</li></ul>');
            html = html.replace(/^(\d+)\. (.*$)/gm, '<ol><li>$2</li></ol>');

            // Replace paragraphs
            html = html.replace(/^(?!<[hou]).+$/gm, '<p>$&</p>');

            // Fix nested lists
            html = html.replace(/<\/ul>\s*<ul>/g, '');
            html = html.replace(/<\/ol>\s*<ol>/g, '');

            return html;
          }

          // Function to escape HTML special characters
          function escapeHtml(text) {
            return text
              .replace(/&/g, '&amp;')
              .replace(/</g, '&lt;')
              .replace(/>/g, '&gt;')
              .replace(/"/g, '&quot;')
              .replace(/'/g, '&#039;');
          }

          // Function to apply syntax highlighting and add buttons to code blocks
          function applyCodeFormatting() {
            // Apply syntax highlighting to code blocks
            document.querySelectorAll('pre code').forEach((codeBlock) => {
              const language = codeBlock.className.replace('language-', '');
              if (language && language !== 'text') {
                const originalCode = codeBlock.textContent;
                try {
                  codeBlock.innerHTML = window.HighlightJS.highlight(originalCode, language);
                } catch (e) {
                  console.error('Error highlighting code:', e);
                }
              }
            });

            // Add copy and insert buttons to code blocks that don't already have them
            document.querySelectorAll('pre:not(.processed)').forEach((pre) => {
              pre.classList.add('processed');

              const container = document.createElement('div');
              container.className = 'code-block-container';
              pre.parentNode.insertBefore(container, pre);
              container.appendChild(pre);

              const copyButton = document.createElement('button');
              copyButton.className = 'copy-button';
              copyButton.textContent = 'Copy';
              copyButton.addEventListener('click', () => {
                const code = pre.textContent;
                vscode.postMessage({
                  command: 'copy',
                  text: code
                });
                copyButton.textContent = 'Copied!';
                setTimeout(() => {
                  copyButton.textContent = 'Copy';
                }, 2000);
              });

              const insertButton = document.createElement('button');
              insertButton.className = 'insert-button';
              insertButton.textContent = 'Insert';
              insertButton.addEventListener('click', () => {
                const code = pre.textContent;
                vscode.postMessage({
                  command: 'insert',
                  text: code
                });
              });

              container.appendChild(copyButton);
              container.appendChild(insertButton);
            });
          }

          // Initial formatting for any content that's already there
          applyCodeFormatting();
        </script>
      </body>
      </html>
    `;
    }
    _formatMarkdown(text) {
        if (!text) {
            return '<p>No response yet...</p>';
        }
        // Replace code blocks
        let html = text.replace(/```(\w+)?\n([\s\S]*?)```/g, (_, lang, code) => {
            return `<pre><code class="language-${lang || 'text'}">${this._escapeHtml(code)}</code></pre>`;
        });
        // Replace inline code
        html = html.replace(/`([^`]+)`/g, '<code>$1</code>');
        // Replace headers
        html = html.replace(/^### (.*$)/gm, '<h3>$1</h3>');
        html = html.replace(/^## (.*$)/gm, '<h2>$1</h2>');
        html = html.replace(/^# (.*$)/gm, '<h1>$1</h1>');
        // Replace lists
        html = html.replace(/^\* (.*$)/gm, '<ul><li>$1</li></ul>');
        html = html.replace(/^- (.*$)/gm, '<ul><li>$1</li></ul>');
        html = html.replace(/^(\d+)\. (.*$)/gm, '<ol><li>$2</li></ol>');
        // Replace paragraphs
        html = html.replace(/^(?!<[hou]).+$/gm, '<p>$&</p>');
        // Fix nested lists
        html = html.replace(/<\/ul>\s*<ul>/g, '');
        html = html.replace(/<\/ol>\s*<ol>/g, '');
        return html;
    }
    _escapeHtml(text) {
        return text
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#039;');
    }
}
exports.QwenResponsePanel = QwenResponsePanel;
//# sourceMappingURL=panel.js.map
```


---

### File: `out/containers/containerManager.js`

```javascript
"use strict";
/**
 * Container Manager
 *
 * Handles the lifecycle of containerized MCP tools.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContainerManager = void 0;
const vscode = __importStar(require("vscode"));
const configuration_1 = require("../configuration");
/**
 * Container Manager class
 */
class ContainerManager {
    /**
     * Constructor
     */
    constructor() {
        this.outputChannel = vscode.window.createOutputChannel('Container Manager');
        this.statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left);
        this.statusBarItem.text = '$(docker) MCP Tools';
        this.statusBarItem.tooltip = 'MCP Tools Status';
        this.statusBarItem.command = 'qwenCoder.showContainerStatus';
        this.containerRegistry = {
            'github': {
                image: 'qwen-mcp-github:latest',
                command: 'uvx',
                args: ['mcp-server-github'],
                ports: [{ internal: 8080, external: 0 }]
            },
            'docker': {
                image: 'qwen-mcp-docker:latest',
                command: 'uvx',
                args: ['mcp-server-docker'],
                ports: [{ internal: 8080, external: 0 }]
            },
            'testing': {
                image: 'qwen-mcp-testing:latest',
                command: 'uvx',
                args: ['mcp-server-testing'],
                ports: [{ internal: 8080, external: 0 }]
            },
            'ci_cd': {
                image: 'qwen-mcp-cicd:latest',
                command: 'uvx',
                args: ['mcp-server-cicd'],
                ports: [{ internal: 8080, external: 0 }]
            }
        };
        this.activeContainers = {};
        this.healthCheckInterval = null;
        this.outputChannel.appendLine('Container Manager initialized');
    }
    /**
     * Initialize the container manager
     */
    async initialize() {
        try {
            this.statusBarItem.show();
            // Check if Docker is available
            const dockerAvailable = await this._checkDockerAvailability();
            if (!dockerAvailable) {
                this.outputChannel.appendLine('Docker is not available. Container features will be disabled.');
                this.statusBarItem.text = '$(alert) Docker Not Available';
                this.statusBarItem.tooltip = 'Docker is not available. Container features are disabled.';
                return;
            }
            // Start health check interval
            this._startHealthCheck();
            // Auto-start containers if configured
            const config = (0, configuration_1.getConfiguration)();
            const autoStartContainers = config.get('autoStartContainers', false);
            if (autoStartContainers) {
                this.outputChannel.appendLine('Auto-starting containers...');
                const containersToStart = config.get('autoStartContainerList', ['github', 'docker']);
                for (const containerName of containersToStart) {
                    try {
                        await this.startContainer(containerName);
                    }
                    catch (error) {
                        this.outputChannel.appendLine(`Error auto-starting container ${containerName}: ${error.message}`);
                    }
                }
            }
        }
        catch (error) {
            this.outputChannel.appendLine(`Error initializing Container Manager: ${error.message}`);
            this.statusBarItem.text = '$(error) MCP Tools Error';
            this.statusBarItem.tooltip = `Error: ${error.message}`;
        }
    }
    /**
     * Start a containerized MCP tool
     * @param containerName The name of the container to start
     * @returns The URL for accessing the container
     */
    async startContainer(containerName) {
        try {
            this.outputChannel.appendLine(`Starting container: ${containerName}`);
            // Check if container is already running
            if (this.activeContainers[containerName] && this.activeContainers[containerName].status === 'running') {
                this.outputChannel.appendLine(`Container ${containerName} is already running`);
                return this.activeContainers[containerName].url;
            }
            // Get container configuration
            const containerConfig = this.containerRegistry[containerName];
            if (!containerConfig) {
                throw new Error(`Unknown container: ${containerName}`);
            }
            // Check if Docker is available
            const dockerAvailable = await this._checkDockerAvailability();
            if (!dockerAvailable) {
                throw new Error('Docker is not available');
            }
            // Pull the image if needed
            await this._ensureImageAvailable(containerConfig.image);
            // Start the container
            const containerId = await this._startContainer(containerName, containerConfig);
            // Get container URL
            const url = await this._getContainerUrl(containerId, containerConfig);
            // Update active containers
            this.activeContainers[containerName] = {
                id: containerId,
                name: containerName,
                image: containerConfig.image,
                url,
                status: 'running',
                startTime: Date.now()
            };
            // Update status bar
            this._updateStatusBar();
            this.outputChannel.appendLine(`Container ${containerName} started successfully with URL: ${url}`);
            return url;
        }
        catch (error) {
            this.outputChannel.appendLine(`Error starting container ${containerName}: ${error.message}`);
            // Update active containers with error status
            this.activeContainers[containerName] = {
                id: '',
                name: containerName,
                image: this.containerRegistry[containerName]?.image || '',
                url: '',
                status: 'error',
                startTime: Date.now(),
                error: error.message
            };
            // Update status bar
            this._updateStatusBar();
            throw error;
        }
    }
    /**
     * Stop a containerized MCP tool
     * @param containerName The name of the container to stop
     */
    async stopContainer(containerName) {
        try {
            this.outputChannel.appendLine(`Stopping container: ${containerName}`);
            // Check if container is running
            if (!this.activeContainers[containerName] || this.activeContainers[containerName].status !== 'running') {
                this.outputChannel.appendLine(`Container ${containerName} is not running`);
                return;
            }
            const containerId = this.activeContainers[containerName].id;
            // Stop and remove the container
            await this._stopContainer(containerId);
            // Update active containers
            this.activeContainers[containerName] = {
                ...this.activeContainers[containerName],
                status: 'stopped'
            };
            // Update status bar
            this._updateStatusBar();
            this.outputChannel.appendLine(`Container ${containerName} stopped successfully`);
        }
        catch (error) {
            this.outputChannel.appendLine(`Error stopping container ${containerName}: ${error.message}`);
            throw error;
        }
    }
    /**
     * Get the URL for a running container
     * @param containerName The name of the container
     * @returns The URL for accessing the container
     */
    getContainerUrl(containerName) {
        if (!this.activeContainers[containerName] || this.activeContainers[containerName].status !== 'running') {
            throw new Error(`Container ${containerName} is not running`);
        }
        return this.activeContainers[containerName].url;
    }
    /**
     * Get the status of all containers
     * @returns The status of all containers
     */
    getContainerStatus() {
        return { ...this.activeContainers };
    }
    /**
     * Check if Docker is available
     * @returns Whether Docker is available
     */
    async _checkDockerAvailability() {
        try {
            // This is a placeholder for Docker availability check
            // In a real implementation, we would use the Docker SDK to check if Docker is running
            // For now, we'll assume Docker is available
            return true;
        }
        catch (error) {
            this.outputChannel.appendLine(`Error checking Docker availability: ${error.message}`);
            return false;
        }
    }
    /**
     * Ensure the Docker image is available
     * @param imageName The name of the image
     */
    async _ensureImageAvailable(imageName) {
        try {
            this.outputChannel.appendLine(`Ensuring image is available: ${imageName}`);
            // This is a placeholder for image availability check
            // In a real implementation, we would use the Docker SDK to check if the image exists locally
            // and pull it if it doesn't
            // For now, we'll assume the image is available
        }
        catch (error) {
            this.outputChannel.appendLine(`Error ensuring image availability: ${error.message}`);
            throw error;
        }
    }
    /**
     * Start a container
     * @param containerName The name of the container
     * @param config The container configuration
     * @returns The container ID
     */
    async _startContainer(containerName, config) {
        try {
            this.outputChannel.appendLine(`Starting container with image: ${config.image}`);
            // This is a placeholder for container start
            // In a real implementation, we would use the Docker SDK to start the container
            // For now, we'll return a fake container ID
            return `fake-container-id-${containerName}-${Date.now()}`;
        }
        catch (error) {
            this.outputChannel.appendLine(`Error starting container: ${error.message}`);
            throw error;
        }
    }
    /**
     * Stop a container
     * @param containerId The ID of the container
     */
    async _stopContainer(containerId) {
        try {
            this.outputChannel.appendLine(`Stopping container: ${containerId}`);
            // This is a placeholder for container stop
            // In a real implementation, we would use the Docker SDK to stop and remove the container
        }
        catch (error) {
            this.outputChannel.appendLine(`Error stopping container: ${error.message}`);
            throw error;
        }
    }
    /**
     * Get the URL for a container
     * @param containerId The ID of the container
     * @param config The container configuration
     * @returns The URL for accessing the container
     */
    async _getContainerUrl(containerId, config) {
        try {
            // This is a placeholder for getting the container URL
            // In a real implementation, we would use the Docker SDK to get the port mapping
            // For now, we'll return a fake URL
            return `http://localhost:${8080 + Math.floor(Math.random() * 1000)}`;
        }
        catch (error) {
            this.outputChannel.appendLine(`Error getting container URL: ${error.message}`);
            throw error;
        }
    }
    /**
     * Start health check interval
     */
    _startHealthCheck() {
        if (this.healthCheckInterval) {
            clearInterval(this.healthCheckInterval);
        }
        this.healthCheckInterval = setInterval(async () => {
            try {
                for (const containerName in this.activeContainers) {
                    const container = this.activeContainers[containerName];
                    if (container.status === 'running') {
                        // Check container health
                        const isHealthy = await this._checkContainerHealth(container);
                        if (!isHealthy) {
                            this.outputChannel.appendLine(`Container ${containerName} is not healthy, attempting to restart`);
                            // Attempt to restart the container
                            try {
                                await this.stopContainer(containerName);
                                await this.startContainer(containerName);
                                this.outputChannel.appendLine(`Container ${containerName} restarted successfully`);
                            }
                            catch (error) {
                                this.outputChannel.appendLine(`Error restarting container ${containerName}: ${error.message}`);
                            }
                        }
                    }
                }
                // Update status bar
                this._updateStatusBar();
            }
            catch (error) {
                this.outputChannel.appendLine(`Error in health check: ${error.message}`);
            }
        }, 60000); // Check every minute
    }
    /**
     * Check container health
     * @param container The container to check
     * @returns Whether the container is healthy
     */
    async _checkContainerHealth(container) {
        try {
            // This is a placeholder for container health check
            // In a real implementation, we would use the Docker SDK to check the container health
            // For now, we'll assume the container is healthy
            return true;
        }
        catch (error) {
            this.outputChannel.appendLine(`Error checking container health: ${error.message}`);
            return false;
        }
    }
    /**
     * Update status bar
     */
    _updateStatusBar() {
        const runningContainers = Object.values(this.activeContainers).filter(c => c.status === 'running').length;
        const totalContainers = Object.keys(this.activeContainers).length;
        if (runningContainers === 0) {
            this.statusBarItem.text = '$(docker) MCP Tools: None Running';
        }
        else {
            this.statusBarItem.text = `$(docker) MCP Tools: ${runningContainers}/${totalContainers} Running`;
        }
        // Update tooltip with container details
        let tooltip = 'MCP Tools Status:\n\n';
        for (const containerName in this.activeContainers) {
            const container = this.activeContainers[containerName];
            tooltip += `${containerName}: ${container.status}`;
            if (container.status === 'running') {
                tooltip += ` (${container.url})`;
            }
            else if (container.status === 'error') {
                tooltip += ` (${container.error})`;
            }
            tooltip += '\n';
        }
        this.statusBarItem.tooltip = tooltip;
    }
    /**
     * Stop all containers
     */
    async stopAllContainers() {
        try {
            this.outputChannel.appendLine('Stopping all containers');
            for (const containerName in this.activeContainers) {
                if (this.activeContainers[containerName].status === 'running') {
                    try {
                        await this.stopContainer(containerName);
                    }
                    catch (error) {
                        this.outputChannel.appendLine(`Error stopping container ${containerName}: ${error.message}`);
                    }
                }
            }
            this.outputChannel.appendLine('All containers stopped');
        }
        catch (error) {
            this.outputChannel.appendLine(`Error stopping all containers: ${error.message}`);
            throw error;
        }
    }
    /**
     * Dispose of resources
     */
    dispose() {
        if (this.healthCheckInterval) {
            clearInterval(this.healthCheckInterval);
            this.healthCheckInterval = null;
        }
        this.stopAllContainers().catch(error => {
            this.outputChannel.appendLine(`Error stopping containers during disposal: ${error.message}`);
        });
        this.statusBarItem.dispose();
        this.outputChannel.dispose();
    }
}
exports.ContainerManager = ContainerManager;
//# sourceMappingURL=containerManager.js.map
```


---

### File: `out/ui/logViewer.js`

```javascript
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.LogViewer = void 0;
const vscode = __importStar(require("vscode"));
/**
 * Log viewer for MCP servers
 */
class LogViewer {
    /**
     * Create a new log viewer
     * @param logger MCP logger
     */
    constructor(logger) {
        this.disposables = [];
        this.logger = logger;
    }
    /**
     * Show the log viewer for a server
     * @param server Server
     */
    show(server) {
        const serverId = server.id;
        this.currentServerId = serverId;
        // Create or show the panel
        if (!this.panel) {
            this.panel = vscode.window.createWebviewPanel('mcpServerLogs', `Logs: ${server.name}`, vscode.ViewColumn.Two, {
                enableScripts: true,
                retainContextWhenHidden: true,
                localResourceRoots: []
            });
            // Handle panel disposal
            this.panel.onDidDispose(() => {
                this.panel = undefined;
                this.disposeWebviewResources();
            }, null, this.disposables);
            // Handle messages from the webview
            this.panel.webview.onDidReceiveMessage(message => this.handleWebviewMessage(message), null, this.disposables);
            // Listen for log events
            this.logger.onDidLog(entry => {
                if (this.panel && entry.serverId === this.currentServerId) {
                    this.panel.webview.postMessage({ type: 'newLog', entry });
                }
            }, null, this.disposables);
        }
        else {
            // Update the panel title
            this.panel.title = `Logs: ${server.name}`;
            this.currentServerId = serverId;
        }
        // Update the webview content
        this.updateWebviewContent(server);
        // Show the panel
        this.panel.reveal();
    }
    /**
     * Dispose of resources
     */
    dispose() {
        if (this.panel) {
            this.panel.dispose();
            this.panel = undefined;
        }
        this.disposeWebviewResources();
    }
    /**
     * Dispose of webview resources
     */
    disposeWebviewResources() {
        this.disposables.forEach(d => d.dispose());
        this.disposables = [];
    }
    /**
     * Update the webview content
     * @param server Server
     */
    updateWebviewContent(server) {
        if (!this.panel) {
            return;
        }
        // Get the log entries for the server
        const logEntries = this.logger.getLogEntries(server.id, 1000);
        // Set the webview content
        this.panel.webview.html = this.getWebviewContent(server, logEntries);
    }
    /**
     * Get the webview content
     * @param server Server
     * @param logEntries Log entries
     * @returns HTML content
     */
    getWebviewContent(server, logEntries) {
        return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MCP Server Logs: ${server.name}</title>
  <style>
    body {
      font-family: var(--vscode-font-family);
      font-size: var(--vscode-font-size);
      color: var(--vscode-foreground);
      background-color: var(--vscode-editor-background);
      padding: 20px;
      line-height: 1.5;
    }
    .container {
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    .server-info {
      margin-bottom: 10px;
    }
    .server-info table {
      border-collapse: collapse;
      width: 100%;
    }
    .server-info th, .server-info td {
      text-align: left;
      padding: 8px;
      border-bottom: 1px solid var(--vscode-panel-border);
    }
    .log-controls {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
    }
    .log-controls button {
      background-color: var(--vscode-button-background);
      color: var(--vscode-button-foreground);
      border: none;
      padding: 6px 12px;
      cursor: pointer;
      border-radius: 2px;
    }
    .log-controls button:hover {
      background-color: var(--vscode-button-hoverBackground);
    }
    .log-controls select {
      background-color: var(--vscode-dropdown-background);
      color: var(--vscode-dropdown-foreground);
      border: 1px solid var(--vscode-dropdown-border);
      padding: 5px;
    }
    .log-container {
      flex: 1;
      overflow-y: auto;
      background-color: var(--vscode-editor-background);
      border: 1px solid var(--vscode-panel-border);
      padding: 10px;
      font-family: var(--vscode-editor-font-family);
      font-size: var(--vscode-editor-font-size);
    }
    .log-entry {
      margin-bottom: 5px;
      white-space: pre-wrap;
      word-break: break-all;
    }
    .log-entry.DEBUG {
      color: var(--vscode-debugIcon-startForeground);
    }
    .log-entry.INFO {
      color: var(--vscode-foreground);
    }
    .log-entry.WARNING {
      color: var(--vscode-editorWarning-foreground);
    }
    .log-entry.ERROR {
      color: var(--vscode-editorError-foreground);
    }
    .log-timestamp {
      color: var(--vscode-descriptionForeground);
      margin-right: 10px;
    }
    .log-level {
      font-weight: bold;
      margin-right: 10px;
    }
    .log-message {
      margin-right: 10px;
    }
    .log-data {
      color: var(--vscode-textPreformat-foreground);
      background-color: var(--vscode-textCodeBlock-background);
      padding: 5px;
      margin-top: 5px;
      border-radius: 3px;
      font-family: var(--vscode-editor-font-family);
      white-space: pre;
      overflow-x: auto;
    }
    .empty-logs {
      text-align: center;
      padding: 20px;
      color: var(--vscode-descriptionForeground);
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h2>MCP Server Logs: ${server.name}</h2>
    </div>
    
    <div class="server-info">
      <table>
        <tr>
          <th>Server ID</th>
          <td>${server.id}</td>
          <th>Status</th>
          <td>${server.status}</td>
        </tr>
        <tr>
          <th>Version</th>
          <td>${server.version}</td>
          <th>Health</th>
          <td>${server.healthStatus || 'unknown'}</td>
        </tr>
      </table>
    </div>
    
    <div class="log-controls">
      <button id="refresh-logs">Refresh</button>
      <button id="clear-logs">Clear Logs</button>
      <select id="log-level">
        <option value="DEBUG">Debug</option>
        <option value="INFO" selected>Info</option>
        <option value="WARNING">Warning</option>
        <option value="ERROR">Error</option>
      </select>
      <button id="export-logs">Export Logs</button>
    </div>
    
    <div class="log-container" id="log-container">
      ${this.renderLogEntries(logEntries)}
    </div>
  </div>
  
  <script>
    (function() {
      const vscode = acquireVsCodeApi();
      const logContainer = document.getElementById('log-container');
      const refreshButton = document.getElementById('refresh-logs');
      const clearButton = document.getElementById('clear-logs');
      const logLevelSelect = document.getElementById('log-level');
      const exportButton = document.getElementById('export-logs');
      
      // Store the current log entries
      let logEntries = ${JSON.stringify(logEntries)};
      
      // Set up event listeners
      refreshButton.addEventListener('click', () => {
        vscode.postMessage({ command: 'refresh' });
      });
      
      clearButton.addEventListener('click', () => {
        vscode.postMessage({ command: 'clear' });
      });
      
      logLevelSelect.addEventListener('change', () => {
        filterLogs();
      });
      
      exportButton.addEventListener('click', () => {
        vscode.postMessage({ command: 'export' });
      });
      
      // Handle messages from the extension
      window.addEventListener('message', event => {
        const message = event.data;
        
        switch (message.type) {
          case 'refreshLogs':
            logEntries = message.entries;
            renderLogs();
            break;
          case 'newLog':
            logEntries.push(message.entry);
            // Limit the number of entries to prevent performance issues
            if (logEntries.length > 1000) {
              logEntries.shift();
            }
            renderLogs();
            break;
          case 'clearLogs':
            logEntries = [];
            renderLogs();
            break;
        }
      });
      
      // Render the logs
      function renderLogs() {
        // Filter logs by level
        const filteredLogs = filterLogs();
        
        // Render the logs
        logContainer.innerHTML = filteredLogs.length > 0
          ? filteredLogs.map(entry => renderLogEntry(entry)).join('')
          : '<div class="empty-logs">No logs to display</div>';
        
        // Scroll to the bottom
        logContainer.scrollTop = logContainer.scrollHeight;
      }
      
      // Filter logs by level
      function filterLogs() {
        const selectedLevel = logLevelSelect.value;
        const levelPriority = {
          'DEBUG': 0,
          'INFO': 1,
          'WARNING': 2,
          'ERROR': 3
        };
        
        return logEntries.filter(entry => {
          return levelPriority[entry.level] >= levelPriority[selectedLevel];
        });
      }
      
      // Render a log entry
      function renderLogEntry(entry) {
        const timestamp = new Date(entry.timestamp).toLocaleTimeString();
        let html = \`
          <div class="log-entry \${entry.level}">
            <span class="log-timestamp">\${timestamp}</span>
            <span class="log-level">\${entry.level}</span>
            <span class="log-message">\${escapeHtml(entry.message)}</span>
        \`;
        
        if (entry.data) {
          let dataStr;
          try {
            dataStr = typeof entry.data === 'string'
              ? entry.data
              : JSON.stringify(entry.data, null, 2);
          } catch (error) {
            dataStr = \`[Error serializing data: \${error}]\`;
          }
          
          html += \`<div class="log-data">\${escapeHtml(dataStr)}</div>\`;
        }
        
        html += '</div>';
        return html;
      }
      
      // Escape HTML
      function escapeHtml(str) {
        return str
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#039;');
      }
    })();
  </script>
</body>
</html>`;
    }
    /**
     * Render log entries
     * @param entries Log entries
     * @returns HTML content
     */
    renderLogEntries(entries) {
        if (entries.length === 0) {
            return '<div class="empty-logs">No logs to display</div>';
        }
        return entries.map(entry => {
            const timestamp = new Date(entry.timestamp).toLocaleTimeString();
            let html = `
        <div class="log-entry ${entry.level}">
          <span class="log-timestamp">${timestamp}</span>
          <span class="log-level">${entry.level}</span>
          <span class="log-message">${this.escapeHtml(entry.message)}</span>
      `;
            if (entry.data) {
                let dataStr;
                try {
                    dataStr = typeof entry.data === 'string'
                        ? entry.data
                        : JSON.stringify(entry.data, null, 2);
                }
                catch (error) {
                    dataStr = `[Error serializing data: ${error}]`;
                }
                html += `<div class="log-data">${this.escapeHtml(dataStr)}</div>`;
            }
            html += '</div>';
            return html;
        }).join('');
    }
    /**
     * Escape HTML
     * @param str String to escape
     * @returns Escaped string
     */
    escapeHtml(str) {
        return str
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#039;');
    }
    /**
     * Handle a message from the webview
     * @param message Message
     */
    handleWebviewMessage(message) {
        if (!this.currentServerId) {
            return;
        }
        switch (message.command) {
            case 'refresh':
                this.refreshLogs();
                break;
            case 'clear':
                this.clearLogs();
                break;
            case 'export':
                this.exportLogs();
                break;
        }
    }
    /**
     * Refresh the logs
     */
    refreshLogs() {
        if (!this.panel || !this.currentServerId) {
            return;
        }
        const server = this.getServerById(this.currentServerId);
        if (!server) {
            return;
        }
        const logEntries = this.logger.getLogEntries(this.currentServerId, 1000);
        this.panel.webview.postMessage({ type: 'refreshLogs', entries: logEntries });
    }
    /**
     * Clear the logs
     */
    clearLogs() {
        if (!this.currentServerId) {
            return;
        }
        this.logger.clearLogs(this.currentServerId);
        if (this.panel) {
            this.panel.webview.postMessage({ type: 'clearLogs' });
        }
    }
    /**
     * Export the logs
     */
    async exportLogs() {
        if (!this.currentServerId) {
            return;
        }
        const server = this.getServerById(this.currentServerId);
        if (!server) {
            return;
        }
        // Get the log entries
        const logEntries = this.logger.getLogEntries(this.currentServerId, 10000);
        // Format the logs
        const formattedLogs = logEntries.map(entry => {
            const timestamp = new Date(entry.timestamp).toISOString();
            let line = `[${timestamp}] [${entry.level}] ${entry.message}`;
            if (entry.data) {
                try {
                    const dataStr = typeof entry.data === 'string'
                        ? entry.data
                        : JSON.stringify(entry.data, null, 2);
                    line += `\n${dataStr}`;
                }
                catch (error) {
                    line += `\n[Error serializing data: ${error}]`;
                }
            }
            return line;
        }).join('\n');
        // Show a save dialog
        const uri = await vscode.window.showSaveDialog({
            defaultUri: vscode.Uri.file(`${server.name}_logs.txt`),
            filters: {
                'Text Files': ['txt'],
                'All Files': ['*']
            }
        });
        if (uri) {
            // Write the logs to the file
            await vscode.workspace.fs.writeFile(uri, Buffer.from(formattedLogs, 'utf8'));
            vscode.window.showInformationMessage(`Logs exported to ${uri.fsPath}`);
        }
    }
    /**
     * Get a server by ID
     * @param serverId Server ID
     * @returns Server or undefined
     */
    getServerById(serverId) {
        // This is a placeholder - in a real implementation, you would get the server from the MCP server manager
        // For now, we'll just return a dummy server
        return {
            id: serverId,
            name: 'Unknown Server',
            description: '',
            repoUrl: '',
            version: '',
            status: 'unknown',
            type: 'docker',
            autoStart: false,
            logs: []
        };
    }
}
exports.LogViewer = LogViewer;
//# sourceMappingURL=logViewer.js.map
```


---

### File: `out/ui/serverDiscoveryView.js`

```javascript
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.ServerDiscoveryView = void 0;
const vscode = __importStar(require("vscode"));
/**
 * Server discovery view for MCP servers
 */
class ServerDiscoveryView {
    /**
     * Create a new server discovery view
     * @param discovery Server discovery
     * @param serverManager MCP server manager
     */
    constructor(discovery, serverManager) {
        this.disposables = [];
        this.searchResults = [];
        this.discovery = discovery;
        this.serverManager = serverManager;
        // Listen for server discovery events
        this.disposables.push(this.discovery.onDidDiscoverServers(results => {
            this.searchResults = results;
            this.updateWebviewContent();
        }));
        // Listen for server manager events
        this.disposables.push(this.serverManager.onDidChangeServers(() => {
            this.updateWebviewContent();
        }));
    }
    /**
     * Create or show the server discovery view
     * @param extensionUri Extension URI
     */
    static createOrShow(extensionUri, discovery, serverManager) {
        const view = new ServerDiscoveryView(discovery, serverManager);
        view.createOrShowPanel(extensionUri);
        return view;
    }
    /**
     * Create or show the panel
     * @param extensionUri Extension URI
     */
    createOrShowPanel(extensionUri) {
        // If we already have a panel, show it
        if (this.panel) {
            this.panel.reveal();
            return;
        }
        // Create a new panel
        this.panel = vscode.window.createWebviewPanel('mcpServerDiscovery', 'MCP Server Discovery', vscode.ViewColumn.One, {
            enableScripts: true,
            retainContextWhenHidden: true,
            localResourceRoots: [extensionUri]
        });
        // Set the webview's initial content
        this.panel.webview.html = this.getWebviewContent();
        // Handle messages from the webview
        this.panel.webview.onDidReceiveMessage(message => this.handleWebviewMessage(message), null, this.disposables);
        // Handle panel disposal
        this.panel.onDidDispose(() => {
            this.panel = undefined;
            this.disposeWebviewResources();
        }, null, this.disposables);
    }
    /**
     * Dispose of resources
     */
    dispose() {
        if (this.panel) {
            this.panel.dispose();
            this.panel = undefined;
        }
        this.disposeWebviewResources();
    }
    /**
     * Dispose of webview resources
     */
    disposeWebviewResources() {
        this.disposables.forEach(d => d.dispose());
        this.disposables = [];
    }
    /**
     * Update the webview content
     */
    updateWebviewContent() {
        if (!this.panel) {
            return;
        }
        this.panel.webview.html = this.getWebviewContent();
    }
    /**
     * Get the webview content
     * @returns HTML content
     */
    getWebviewContent() {
        return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MCP Server Discovery</title>
  <style>
    body {
      font-family: var(--vscode-font-family);
      font-size: var(--vscode-font-size);
      color: var(--vscode-foreground);
      background-color: var(--vscode-editor-background);
      padding: 20px;
      line-height: 1.5;
    }
    .container {
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }
    .search-container {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
    }
    .search-input {
      flex: 1;
      background-color: var(--vscode-input-background);
      color: var(--vscode-input-foreground);
      border: 1px solid var(--vscode-input-border);
      padding: 6px 12px;
      border-radius: 2px;
    }
    .search-button {
      background-color: var(--vscode-button-background);
      color: var(--vscode-button-foreground);
      border: none;
      padding: 6px 12px;
      cursor: pointer;
      border-radius: 2px;
    }
    .search-button:hover {
      background-color: var(--vscode-button-hoverBackground);
    }
    .filters {
      display: flex;
      gap: 20px;
      margin-bottom: 20px;
    }
    .filter-group {
      display: flex;
      align-items: center;
      gap: 5px;
    }
    .results-container {
      flex: 1;
      overflow-y: auto;
      background-color: var(--vscode-editor-background);
      border: 1px solid var(--vscode-panel-border);
      border-radius: 2px;
    }
    .results-table {
      width: 100%;
      border-collapse: collapse;
    }
    .results-table th, .results-table td {
      text-align: left;
      padding: 8px;
      border-bottom: 1px solid var(--vscode-panel-border);
    }
    .results-table th {
      background-color: var(--vscode-editor-background);
      position: sticky;
      top: 0;
      z-index: 1;
    }
    .results-table tr:hover {
      background-color: var(--vscode-list-hoverBackground);
    }
    .server-name {
      font-weight: bold;
    }
    .server-description {
      color: var(--vscode-descriptionForeground);
      max-width: 300px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .server-version {
      font-family: var(--vscode-editor-font-family);
    }
    .server-source {
      text-transform: capitalize;
    }
    .server-official {
      color: var(--vscode-terminal-ansiGreen);
    }
    .server-actions {
      display: flex;
      gap: 5px;
    }
    .action-button {
      background-color: var(--vscode-button-background);
      color: var(--vscode-button-foreground);
      border: none;
      padding: 4px 8px;
      cursor: pointer;
      border-radius: 2px;
      font-size: 12px;
    }
    .action-button:hover {
      background-color: var(--vscode-button-hoverBackground);
    }
    .action-button.installed {
      background-color: var(--vscode-badge-background);
      cursor: default;
    }
    .empty-results {
      text-align: center;
      padding: 20px;
      color: var(--vscode-descriptionForeground);
    }
    .loading {
      text-align: center;
      padding: 20px;
    }
    .spinner {
      width: 30px;
      height: 30px;
      border: 3px solid var(--vscode-button-background);
      border-top: 3px solid var(--vscode-editor-background);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 10px;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h2>MCP Server Discovery</h2>
    </div>
    
    <div class="search-container">
      <input type="text" id="search-input" class="search-input" placeholder="Search for MCP servers...">
      <button id="search-button" class="search-button">Search</button>
    </div>
    
    <div class="filters">
      <div class="filter-group">
        <input type="checkbox" id="filter-registry" checked>
        <label for="filter-registry">Registry</label>
      </div>
      <div class="filter-group">
        <input type="checkbox" id="filter-github" checked>
        <label for="filter-github">GitHub</label>
      </div>
      <div class="filter-group">
        <input type="checkbox" id="filter-local" checked>
        <label for="filter-local">Local</label>
      </div>
      <div class="filter-group">
        <input type="checkbox" id="filter-network" checked>
        <label for="filter-network">Network</label>
      </div>
      <div class="filter-group">
        <input type="checkbox" id="filter-official">
        <label for="filter-official">Official Only</label>
      </div>
    </div>
    
    <div class="results-container" id="results-container">
      ${this.renderSearchResults()}
    </div>
  </div>
  
  <script>
    (function() {
      const vscode = acquireVsCodeApi();
      const searchInput = document.getElementById('search-input');
      const searchButton = document.getElementById('search-button');
      const filterRegistry = document.getElementById('filter-registry');
      const filterGitHub = document.getElementById('filter-github');
      const filterLocal = document.getElementById('filter-local');
      const filterNetwork = document.getElementById('filter-network');
      const filterOfficial = document.getElementById('filter-official');
      const resultsContainer = document.getElementById('results-container');
      
      // Set up event listeners
      searchButton.addEventListener('click', () => {
        search();
      });
      
      searchInput.addEventListener('keydown', (event) => {
        if (event.key === 'Enter') {
          search();
        }
      });
      
      filterRegistry.addEventListener('change', () => {
        search();
      });
      
      filterGitHub.addEventListener('change', () => {
        search();
      });
      
      filterLocal.addEventListener('change', () => {
        search();
      });
      
      filterNetwork.addEventListener('change', () => {
        search();
      });
      
      filterOfficial.addEventListener('change', () => {
        search();
      });
      
      // Set up action button event listeners
      document.addEventListener('click', (event) => {
        if (event.target.classList.contains('action-button') && !event.target.classList.contains('installed')) {
          const serverId = event.target.dataset.serverId;
          const repoUrl = event.target.dataset.repoUrl;
          
          vscode.postMessage({
            command: 'addServer',
            repoUrl
          });
          
          // Show loading state
          event.target.textContent = 'Adding...';
          event.target.disabled = true;
        }
      });
      
      // Search function
      function search() {
        const query = searchInput.value.trim();
        const includeRegistry = filterRegistry.checked;
        const includeGitHub = filterGitHub.checked;
        const includeLocal = filterLocal.checked;
        const includeNetwork = filterNetwork.checked;
        const officialOnly = filterOfficial.checked;
        
        // Show loading state
        resultsContainer.innerHTML = \`
          <div class="loading">
            <div class="spinner"></div>
            <p>Searching for MCP servers...</p>
          </div>
        \`;
        
        vscode.postMessage({
          command: 'search',
          query,
          includeRegistry,
          includeGitHub,
          includeLocal,
          includeNetwork,
          officialOnly
        });
      }
      
      // Initial search
      search();
    })();
  </script>
</body>
</html>`;
    }
    /**
     * Render search results
     * @returns HTML content
     */
    renderSearchResults() {
        if (this.searchResults.length === 0) {
            return `
        <div class="empty-results">
          <p>No MCP servers found. Try a different search query or adjust the filters.</p>
        </div>
      `;
        }
        // Get installed servers
        const installedServers = this.serverManager.getServers();
        const installedRepoUrls = new Set(installedServers.map(server => server.repoUrl));
        return `
      <table class="results-table">
        <thead>
          <tr>
            <th>Name</th>
            <th>Description</th>
            <th>Version</th>
            <th>Source</th>
            <th>Official</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody>
          ${this.searchResults.map(result => `
            <tr>
              <td class="server-name">${this.escapeHtml(result.name)}</td>
              <td class="server-description" title="${this.escapeHtml(result.description)}">${this.escapeHtml(result.description)}</td>
              <td class="server-version">${this.escapeHtml(result.version)}</td>
              <td class="server-source">${result.source}</td>
              <td class="server-official">${result.official ? '' : ''}</td>
              <td class="server-actions">
                ${result.installed
            ? `<button class="action-button installed" disabled>Installed</button>`
            : `<button class="action-button" data-repo-url="${this.escapeHtml(result.repoUrl)}">Add Server</button>`}
              </td>
            </tr>
          `).join('')}
        </tbody>
      </table>
    `;
    }
    /**
     * Escape HTML
     * @param str String to escape
     * @returns Escaped string
     */
    escapeHtml(str) {
        return str
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#039;');
    }
    /**
     * Handle a message from the webview
     * @param message Message
     */
    async handleWebviewMessage(message) {
        switch (message.command) {
            case 'search':
                await this.handleSearch(message);
                break;
            case 'addServer':
                await this.handleAddServer(message);
                break;
        }
    }
    /**
     * Handle a search message
     * @param message Message
     */
    async handleSearch(message) {
        try {
            const options = {
                includeRegistry: message.includeRegistry,
                includeGitHub: message.includeGitHub,
                includeLocal: message.includeLocal,
                includeNetwork: message.includeNetwork,
                searchQuery: message.query,
                maxResults: 100
            };
            // Discover servers
            const results = await this.discovery.discoverServers(options);
            // Filter by official if needed
            this.searchResults = message.officialOnly
                ? results.filter(result => result.official)
                : results;
            // Update the webview content
            this.updateWebviewContent();
        }
        catch (error) {
            console.error('Error searching for servers:', error);
            vscode.window.showErrorMessage(`Error searching for servers: ${error}`);
        }
    }
    /**
     * Handle an add server message
     * @param message Message
     */
    async handleAddServer(message) {
        try {
            const repoUrl = message.repoUrl;
            // Add the server
            await this.serverManager.addServerFromGitHub(repoUrl);
            // Show a success message
            vscode.window.showInformationMessage(`Added MCP server from ${repoUrl}`);
            // Update the search results
            const result = this.searchResults.find(r => r.repoUrl === repoUrl);
            if (result) {
                result.installed = true;
            }
            // Update the webview content
            this.updateWebviewContent();
        }
        catch (error) {
            console.error('Error adding server:', error);
            vscode.window.showErrorMessage(`Error adding server: ${error}`);
        }
    }
}
exports.ServerDiscoveryView = ServerDiscoveryView;
//# sourceMappingURL=serverDiscoveryView.js.map
```


---

### File: `out/ui/mcpServerTreeDataProvider.js`

```javascript
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.McpServerTreeItem = exports.McpServerTreeDataProvider = void 0;
const vscode = __importStar(require("vscode"));
const types_1 = require("../mcp-client/types");
/**
 * Tree data provider for MCP servers
 */
class McpServerTreeDataProvider {
    /**
     * Create a new MCP server tree data provider
     * @param serverManager MCP server manager
     * @param healthMonitor Server health monitor
     */
    constructor(serverManager, healthMonitor) {
        this.serverManager = serverManager;
        this.healthMonitor = healthMonitor;
        this._onDidChangeTreeData = new vscode.EventEmitter();
        /**
         * Event that fires when the tree data changes
         */
        this.onDidChangeTreeData = this._onDidChangeTreeData.event;
        // Listen for server changes
        serverManager.onDidChangeServers(() => {
            this._onDidChangeTreeData.fire(undefined);
        });
        // Listen for health updates if health monitor is provided
        if (healthMonitor) {
            healthMonitor.onDidUpdateHealth(() => {
                this._onDidChangeTreeData.fire(undefined);
            });
        }
    }
    /**
     * Get the tree item for an element
     * @param element Tree item
     * @returns Tree item
     */
    getTreeItem(element) {
        return element;
    }
    /**
     * Get the children of an element
     * @param element Parent element
     * @returns Children of the element
     */
    getChildren(element) {
        if (!element) {
            // Root level - show all servers
            const servers = this.serverManager.getServers();
            return Promise.resolve(servers.map(server => new McpServerTreeItem(server)));
        }
        // No children for server items
        return Promise.resolve([]);
    }
    /**
     * Refresh the tree
     */
    refresh() {
        this._onDidChangeTreeData.fire(undefined);
    }
}
exports.McpServerTreeDataProvider = McpServerTreeDataProvider;
/**
 * Tree item for an MCP server
 */
class McpServerTreeItem extends vscode.TreeItem {
    /**
     * Create a new MCP server tree item
     * @param server MCP server
     */
    constructor(server) {
        super(server.name, vscode.TreeItemCollapsibleState.None);
        this.server = server;
        // Set the context value for context menu filtering
        this.contextValue = `mcpServer-${server.status}${server.healthStatus ? `-${server.healthStatus}` : ''}`;
        // Set the description
        this.description = server.healthStatus
            ? `${server.status} (${server.healthStatus})`
            : server.status;
        // Set the tooltip
        let tooltip = `${server.name} (${server.status})
${server.description}
Repository: ${server.repoUrl}
Version: ${server.version}`;
        // Add health information if available
        if (server.healthStatus) {
            tooltip += `
Health: ${server.healthStatus}`;
            if (server.lastHealthCheck) {
                tooltip += `
Last health check: ${server.lastHealthCheck.toLocaleString()}`;
            }
        }
        // Add endpoint information if available
        if (server.endpoint) {
            tooltip += `
Endpoint: ${server.endpoint}`;
        }
        this.tooltip = tooltip;
        // Set the icon
        this.iconPath = this.getIconPath(server.status, server.healthStatus);
    }
    /**
     * Get the icon path for a server status
     * @param status Server status
     * @param healthStatus Server health status
     * @returns Icon path
     */
    getIconPath(status, healthStatus) {
        // If the server is running and unhealthy, show a warning icon
        if (status === types_1.McpServerStatus.Running && healthStatus === 'unhealthy') {
            return new vscode.ThemeIcon('warning');
        }
        // Otherwise, show an icon based on the server status
        switch (status) {
            case types_1.McpServerStatus.Running:
                return new vscode.ThemeIcon('play');
            case types_1.McpServerStatus.Stopped:
                return new vscode.ThemeIcon('stop');
            case types_1.McpServerStatus.Starting:
                return new vscode.ThemeIcon('sync');
            case types_1.McpServerStatus.Stopping:
                return new vscode.ThemeIcon('sync');
            case types_1.McpServerStatus.Error:
                return new vscode.ThemeIcon('error');
            default:
                return new vscode.ThemeIcon('question');
        }
    }
}
exports.McpServerTreeItem = McpServerTreeItem;
//# sourceMappingURL=mcpServerTreeDataProvider.js.map
```


---

### File: `out/ui/mcpServerConfigView.js`

```javascript
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.McpServerConfigView = void 0;
const vscode = __importStar(require("vscode"));
/**
 * WebView panel for configuring MCP servers
 */
class McpServerConfigView {
    /**
     * Create a new MCP server configuration view
     * @param extensionUri Extension URI
     * @param serverManager MCP server manager
     * @param officialServersManager Official MCP servers manager
     * @param healthMonitor Server health monitor
     * @param serverId Optional server ID to configure
     */
    constructor(extensionUri, serverManager, officialServersManager, healthMonitor, serverId) {
        this._disposables = [];
        this._extensionUri = extensionUri;
        this._serverManager = serverManager;
        this._officialServersManager = officialServersManager;
        this._healthMonitor = healthMonitor;
        // Create the webview panel
        this._panel = vscode.window.createWebviewPanel(McpServerConfigView.viewType, 'MCP Server Configuration', vscode.ViewColumn.One, {
            enableScripts: true,
            localResourceRoots: [vscode.Uri.joinPath(extensionUri, 'media')]
        });
        // Set the webview's initial html content
        this._panel.webview.html = this._getHtmlForWebview(this._panel.webview);
        // Set the current server if provided
        if (serverId) {
            this._currentServer = this._serverManager.getServer(serverId);
        }
        // Update the webview content
        this._updateWebview();
        // Listen for when the panel is disposed
        // This happens when the user closes the panel or when the panel is closed programmatically
        this._panel.onDidDispose(() => this.dispose(), null, this._disposables);
        // Handle messages from the webview
        this._panel.webview.onDidReceiveMessage(message => {
            switch (message.command) {
                case 'saveConfig':
                    this._saveServerConfig(message.serverId, message.config);
                    return;
                case 'startServer':
                    this._startServer(message.serverId);
                    return;
                case 'stopServer':
                    this._stopServer(message.serverId);
                    return;
                case 'restartServer':
                    this._restartServer(message.serverId);
                    return;
                case 'checkHealth':
                    this._checkServerHealth(message.serverId);
                    return;
                case 'viewLogs':
                    this._viewServerLogs(message.serverId);
                    return;
                case 'addOfficialServer':
                    this._addOfficialServer(message.serverType);
                    return;
            }
        }, null, this._disposables);
        // Listen for server changes
        this._serverManager.onDidChangeServers(() => {
            // Update the current server if it's still valid
            if (this._currentServer) {
                this._currentServer = this._serverManager.getServer(this._currentServer.id);
            }
            this._updateWebview();
        }, null, this._disposables);
        // Listen for health updates
        this._healthMonitor.onDidUpdateHealth(serverId => {
            if (this._currentServer && this._currentServer.id === serverId) {
                this._updateWebview();
            }
        }, null, this._disposables);
    }
    /**
     * Create and show a new MCP server configuration view
     * @param extensionUri Extension URI
     * @param serverManager MCP server manager
     * @param officialServersManager Official MCP servers manager
     * @param healthMonitor Server health monitor
     * @param serverId Optional server ID to configure
     * @returns The created view
     */
    static createOrShow(extensionUri, serverManager, officialServersManager, healthMonitor, serverId) {
        return new McpServerConfigView(extensionUri, serverManager, officialServersManager, healthMonitor, serverId);
    }
    /**
     * Get the HTML for the webview
     * @param webview Webview
     * @returns HTML string
     */
    _getHtmlForWebview(webview) {
        // Local path to script and css for the webview
        const scriptUri = webview.asWebviewUri(vscode.Uri.joinPath(this._extensionUri, 'media', 'mcpServerConfig.js'));
        const styleUri = webview.asWebviewUri(vscode.Uri.joinPath(this._extensionUri, 'media', 'mcpServerConfig.css'));
        // Use a nonce to only allow specific scripts to be run
        const nonce = getNonce();
        return `<!DOCTYPE html>
    <html lang="en">
    <head>
      <meta charset="UTF-8">
      <meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src ${webview.cspSource}; script-src 'nonce-${nonce}';">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <link href="${styleUri}" rel="stylesheet">
      <title>MCP Server Configuration</title>
    </head>
    <body>
      <div id="app">
        <h1>MCP Server Configuration</h1>
        <div id="server-selector"></div>
        <div id="server-config"></div>
        <div id="official-servers">
          <h2>Add Official MCP Servers</h2>
          <div class="button-container">
            <button id="add-github">Add GitHub MCP Server</button>
            <button id="add-docker">Add Docker MCP Server</button>
            <button id="add-git">Add Git MCP Server</button>
            <button id="add-memory">Add Memory MCP Server</button>
            <button id="add-filesystem">Add Filesystem MCP Server</button>
            <button id="add-all">Add All Official Servers</button>
          </div>
        </div>
      </div>
      <script nonce="${nonce}" src="${scriptUri}"></script>
    </body>
    </html>`;
    }
    /**
     * Update the webview content
     */
    _updateWebview() {
        if (!this._panel.visible) {
            return;
        }
        // Get all servers
        const servers = this._serverManager.getServers();
        // Send the servers to the webview
        this._panel.webview.postMessage({
            command: 'updateServers',
            servers,
            currentServerId: this._currentServer?.id
        });
    }
    /**
     * Save server configuration
     * @param serverId Server ID
     * @param config Server configuration
     */
    async _saveServerConfig(serverId, config) {
        try {
            const server = this._serverManager.getServer(serverId);
            if (!server) {
                throw new Error(`Server ${serverId} not found`);
            }
            // Update server properties
            server.name = config.name || server.name;
            server.description = config.description || server.description;
            server.autoStart = config.autoStart !== undefined ? config.autoStart : server.autoStart;
            // Save the servers
            this._serverManager.saveServers();
            // Show a success message
            vscode.window.showInformationMessage(`Server ${server.name} configuration saved`);
            // Update the webview
            this._updateWebview();
        }
        catch (error) {
            vscode.window.showErrorMessage(`Error saving server configuration: ${error}`);
        }
    }
    /**
     * Start a server
     * @param serverId Server ID
     */
    async _startServer(serverId) {
        try {
            await this._serverManager.startServer(serverId);
            vscode.window.showInformationMessage(`Server ${serverId} started`);
        }
        catch (error) {
            vscode.window.showErrorMessage(`Error starting server: ${error}`);
        }
    }
    /**
     * Stop a server
     * @param serverId Server ID
     */
    async _stopServer(serverId) {
        try {
            await this._serverManager.stopServer(serverId);
            vscode.window.showInformationMessage(`Server ${serverId} stopped`);
        }
        catch (error) {
            vscode.window.showErrorMessage(`Error stopping server: ${error}`);
        }
    }
    /**
     * Restart a server
     * @param serverId Server ID
     */
    async _restartServer(serverId) {
        try {
            await this._serverManager.restartServer(serverId);
            vscode.window.showInformationMessage(`Server ${serverId} restarted`);
        }
        catch (error) {
            vscode.window.showErrorMessage(`Error restarting server: ${error}`);
        }
    }
    /**
     * Check server health
     * @param serverId Server ID
     */
    async _checkServerHealth(serverId) {
        try {
            await this._healthMonitor.checkServerHealth(serverId);
            const server = this._serverManager.getServer(serverId);
            if (server) {
                vscode.window.showInformationMessage(`Server ${serverId} health: ${server.healthStatus || 'unknown'}`);
            }
        }
        catch (error) {
            vscode.window.showErrorMessage(`Error checking server health: ${error}`);
        }
    }
    /**
     * View server logs
     * @param serverId Server ID
     */
    _viewServerLogs(serverId) {
        try {
            const server = this._serverManager.getServer(serverId);
            if (!server) {
                throw new Error(`Server ${serverId} not found`);
            }
            // Create a new untitled document with the logs
            vscode.workspace.openTextDocument({
                content: server.logs.join('\n'),
                language: 'log'
            }).then(doc => {
                vscode.window.showTextDocument(doc);
            });
        }
        catch (error) {
            vscode.window.showErrorMessage(`Error viewing server logs: ${error}`);
        }
    }
    /**
     * Add an official MCP server
     * @param serverType Server type
     */
    async _addOfficialServer(serverType) {
        try {
            let serverId;
            switch (serverType.toUpperCase()) {
                case 'GITHUB':
                    serverId = await this._officialServersManager.addGitHubServer();
                    break;
                case 'DOCKER':
                    serverId = await this._officialServersManager.addDockerServer();
                    break;
                case 'GIT':
                    serverId = await this._officialServersManager.addGitServer();
                    break;
                case 'MEMORY':
                    serverId = await this._officialServersManager.addMemoryServer();
                    break;
                case 'FILESYSTEM':
                    serverId = await this._officialServersManager.addFilesystemServer();
                    break;
                case 'ALL':
                    const serverIds = await this._officialServersManager.addAllOfficialServers();
                    vscode.window.showInformationMessage(`Added ${serverIds.length} official MCP servers`);
                    return;
                default:
                    throw new Error(`Unknown server type: ${serverType}`);
            }
            // Set the current server to the newly added server
            this._currentServer = this._serverManager.getServer(serverId);
            // Show a success message
            vscode.window.showInformationMessage(`Added ${serverType} MCP server`);
            // Update the webview
            this._updateWebview();
        }
        catch (error) {
            vscode.window.showErrorMessage(`Error adding ${serverType} MCP server: ${error}`);
        }
    }
    /**
     * Dispose of the view
     */
    dispose() {
        // Clean up resources
        this._panel.dispose();
        // Dispose of all disposables
        while (this._disposables.length) {
            const disposable = this._disposables.pop();
            if (disposable) {
                disposable.dispose();
            }
        }
    }
}
exports.McpServerConfigView = McpServerConfigView;
McpServerConfigView.viewType = 'qwenMcpServerConfig';
/**
 * Get a nonce string
 * @returns Random nonce string
 */
function getNonce() {
    let text = '';
    const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    for (let i = 0; i < 32; i++) {
        text += possible.charAt(Math.floor(Math.random() * possible.length));
    }
    return text;
}
//# sourceMappingURL=mcpServerConfigView.js.map
```


---

### File: `out/agents/types.js`

```javascript
"use strict";
/**
 * Type definitions for the hierarchical agent system
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ThinkingMode = exports.TaskComplexity = exports.ModelSize = exports.AgentType = void 0;
/**
 * Agent types supported by the system
 */
var AgentType;
(function (AgentType) {
    AgentType["Coordinator"] = "coordinator";
    AgentType["Development"] = "development";
    AgentType["Testing"] = "testing";
    AgentType["CICD"] = "ci_cd";
    AgentType["GitHub"] = "github";
    AgentType["Documentation"] = "documentation";
    AgentType["Architecture"] = "architecture";
    AgentType["Security"] = "security";
    AgentType["Performance"] = "performance";
    AgentType["Simple"] = "simple";
    AgentType["DevOps"] = "devops";
    AgentType["ML"] = "machine_learning";
    AgentType["WebDev"] = "web_development";
})(AgentType || (exports.AgentType = AgentType = {}));
/**
 * Model sizes available for agents
 */
var ModelSize;
(function (ModelSize) {
    ModelSize["Tiny"] = "Qwen3-0.6B";
    ModelSize["Small"] = "Qwen3-1.7B";
    ModelSize["Medium"] = "Qwen3-4B";
    ModelSize["Large"] = "Qwen3-8B";
    ModelSize["XLarge"] = "Qwen3-14B";
    ModelSize["XXLarge"] = "Qwen3-32B";
    ModelSize["MoESmall"] = "Qwen3-30B-A3B";
    ModelSize["MoELarge"] = "Qwen3-235B-A22B";
})(ModelSize || (exports.ModelSize = ModelSize = {}));
/**
 * Task complexity levels
 */
var TaskComplexity;
(function (TaskComplexity) {
    TaskComplexity["Low"] = "low";
    TaskComplexity["Medium"] = "medium";
    TaskComplexity["High"] = "high";
    // New complexity levels for dynamic agent selection
    TaskComplexity["Simple"] = "simple";
    TaskComplexity["Moderate"] = "moderate";
    TaskComplexity["Complex"] = "complex";
    TaskComplexity["VeryComplex"] = "very_complex";
})(TaskComplexity || (exports.TaskComplexity = TaskComplexity = {}));
/**
 * Thinking mode options
 */
var ThinkingMode;
(function (ThinkingMode) {
    ThinkingMode["Enabled"] = "enabled";
    ThinkingMode["Disabled"] = "disabled";
    ThinkingMode["Auto"] = "auto";
})(ThinkingMode || (exports.ThinkingMode = ThinkingMode = {}));
//# sourceMappingURL=types.js.map
```


---

### File: `out/agents/dynamicAgentSelector.js`

```javascript
"use strict";
/**
 * Dynamic Agent Selector
 *
 * Selects the most appropriate agent for a task based on its requirements,
 * complexity, and domain.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.AgentSelector = void 0;
const vscode = __importStar(require("vscode"));
const types_1 = require("./types");
/**
 * Agent Selector class for dynamic agent selection
 */
class AgentSelector {
    /**
     * Constructor
     */
    constructor() {
        this.outputChannel = vscode.window.createOutputChannel('Dynamic Agent Selector');
        this.agentAvailability = new Map();
        // Initialize available agents
        this.agents = [
            {
                name: 'SimpleAgent',
                type: types_1.AgentType.Simple,
                capabilities: ['code'],
                modelSize: types_1.ModelSize.Small,
                maxComplexity: types_1.TaskComplexity.Simple,
                systemPrompt: 'You are a simple coding assistant that helps with basic tasks.',
                available: true
            },
            {
                name: 'DevelopmentAgent',
                type: types_1.AgentType.Development,
                capabilities: ['code', 'context', 'reasoning'],
                modelSize: types_1.ModelSize.Large,
                maxComplexity: types_1.TaskComplexity.Complex,
                systemPrompt: 'You are a development assistant that helps with coding tasks.',
                available: true
            },
            {
                name: 'ArchitectAgent',
                type: types_1.AgentType.Architecture,
                capabilities: ['code', 'context', 'reasoning', 'architecture'],
                modelSize: types_1.ModelSize.XLarge,
                maxComplexity: types_1.TaskComplexity.VeryComplex,
                systemPrompt: 'You are an architecture assistant that helps with system design and architecture.',
                available: true
            },
            {
                name: 'DevOpsAgent',
                type: types_1.AgentType.DevOps,
                capabilities: ['code', 'tools', 'context'],
                modelSize: types_1.ModelSize.Large,
                maxComplexity: types_1.TaskComplexity.Complex,
                specializations: ['github', 'docker', 'ci-cd'],
                systemPrompt: 'You are a DevOps assistant that helps with CI/CD, deployment, and infrastructure.',
                available: true
            },
            {
                name: 'MLAgent',
                type: types_1.AgentType.ML,
                capabilities: ['code', 'context', 'reasoning'],
                modelSize: types_1.ModelSize.XLarge,
                maxComplexity: types_1.TaskComplexity.VeryComplex,
                specializations: ['machine-learning', 'data-science', 'neural-networks'],
                systemPrompt: 'You are a machine learning assistant that helps with ML models and algorithms.',
                available: true
            },
            {
                name: 'WebDevAgent',
                type: types_1.AgentType.WebDev,
                capabilities: ['code', 'context'],
                modelSize: types_1.ModelSize.Medium,
                maxComplexity: types_1.TaskComplexity.Complex,
                specializations: ['web-development', 'frontend', 'backend'],
                systemPrompt: 'You are a web development assistant that helps with frontend and backend tasks.',
                available: true
            }
        ];
        this.outputChannel.appendLine('Dynamic Agent Selector initialized with ' + this.agents.length + ' agents');
    }
    /**
     * Select the most appropriate agent for a task
     * @param task The task to select an agent for
     * @returns The selected agent
     */
    async selectAgent(task) {
        try {
            this.outputChannel.appendLine(`Selecting agent for task: ${task.description}`);
            // Determine task complexity if not specified
            if (!task.complexity) {
                task.complexity = this.analyzeTaskComplexity(task.description);
                this.outputChannel.appendLine(`Inferred task complexity: ${task.complexity}`);
            }
            // Filter agents by availability
            const availableAgents = this.agents.filter(agent => this.isAgentAvailable(agent.name));
            if (availableAgents.length === 0) {
                throw new Error('No agents available');
            }
            // Filter agents by complexity
            const complexityMap = {
                [types_1.TaskComplexity.Simple]: 1,
                [types_1.TaskComplexity.Moderate]: 2,
                [types_1.TaskComplexity.Complex]: 3,
                [types_1.TaskComplexity.VeryComplex]: 4
            };
            const taskComplexityValue = complexityMap[task.complexity];
            const capableAgents = availableAgents.filter(agent => {
                const agentComplexityValue = complexityMap[agent.maxComplexity];
                return agentComplexityValue >= taskComplexityValue;
            });
            if (capableAgents.length === 0) {
                // Fallback to the agent with the highest complexity capability
                const fallbackAgent = availableAgents.sort((a, b) => complexityMap[b.maxComplexity] - complexityMap[a.maxComplexity])[0];
                this.outputChannel.appendLine(`No agent capable of handling complexity ${task.complexity}, falling back to ${fallbackAgent.name}`);
                return fallbackAgent;
            }
            // Filter by required capabilities
            let filteredAgents = capableAgents;
            if (task.requiresContext) {
                filteredAgents = filteredAgents.filter(agent => agent.capabilities.includes('context'));
            }
            if (task.requiresTools) {
                filteredAgents = filteredAgents.filter(agent => agent.capabilities.includes('tools'));
            }
            if (filteredAgents.length === 0) {
                this.outputChannel.appendLine(`No agent with required capabilities, falling back to most capable agent`);
                return capableAgents[0];
            }
            // Filter by domain specialization if specified
            if (task.domain && task.domain !== 'general') {
                const domainAgents = filteredAgents.filter(agent => agent.specializations?.some(spec => spec.toLowerCase().includes(task.domain.toLowerCase())));
                if (domainAgents.length > 0) {
                    filteredAgents = domainAgents;
                    this.outputChannel.appendLine(`Found ${domainAgents.length} agents specialized in ${task.domain}`);
                }
            }
            // Filter by required tools if specified
            if (task.requiredTools && task.requiredTools.length > 0) {
                // For this example, we'll just check if the agent has tools capability
                // In a real implementation, we would check if the agent supports the specific tools
                const toolAgents = filteredAgents.filter(agent => agent.capabilities.includes('tools'));
                if (toolAgents.length > 0) {
                    filteredAgents = toolAgents;
                    this.outputChannel.appendLine(`Found ${toolAgents.length} agents with required tool support`);
                }
            }
            // Select the best agent from the filtered list
            // For now, we'll just take the first one
            // In a real implementation, we might use a more sophisticated selection algorithm
            const selectedAgent = filteredAgents[0];
            this.outputChannel.appendLine(`Selected agent: ${selectedAgent.name}`);
            return selectedAgent;
        }
        catch (error) {
            this.outputChannel.appendLine(`Error selecting agent: ${error.message}`);
            // Return a default agent as fallback
            const defaultAgent = this.agents.find(a => a.name === 'DevelopmentAgent') || this.agents[0];
            this.outputChannel.appendLine(`Falling back to default agent: ${defaultAgent.name}`);
            return defaultAgent;
        }
    }
    /**
     * Analyze task description to determine complexity
     * @param description Task description
     * @returns Inferred task complexity
     */
    analyzeTaskComplexity(description) {
        const description_lower = description.toLowerCase();
        // Check for keywords indicating very complex tasks
        const veryComplexKeywords = [
            'architecture', 'redesign', 'system design', 'microservice',
            'distributed', 'scale', 'optimize', 'performance', 'security',
            'refactor', 'monolithic'
        ];
        if (veryComplexKeywords.some(keyword => description_lower.includes(keyword))) {
            return types_1.TaskComplexity.Complex;
        }
        // Check for keywords indicating complex tasks
        const complexKeywords = [
            'implement', 'create', 'develop', 'build', 'design',
            'algorithm', 'feature', 'functionality', 'integration'
        ];
        if (complexKeywords.some(keyword => description_lower.includes(keyword))) {
            return types_1.TaskComplexity.Moderate;
        }
        // Check for keywords indicating simple tasks
        const simpleKeywords = [
            'fix', 'update', 'change', 'modify', 'add', 'remove',
            'format', 'rename', 'explain', 'help'
        ];
        if (simpleKeywords.some(keyword => description_lower.includes(keyword))) {
            return types_1.TaskComplexity.Simple;
        }
        // Default to moderate complexity
        return types_1.TaskComplexity.Moderate;
    }
    /**
     * Check if an agent is available
     * @param agentName Agent name
     * @returns Whether the agent is available
     */
    isAgentAvailable(agentName) {
        // If we have an explicit availability setting, use that
        if (this.agentAvailability.has(agentName)) {
            return this.agentAvailability.get(agentName);
        }
        // Otherwise, check the agent's default availability
        const agent = this.agents.find(a => a.name === agentName);
        return agent ? agent.available : false;
    }
    /**
     * Set agent availability
     * @param agentName Agent name
     * @param available Whether the agent is available
     */
    setAgentAvailability(agentName, available) {
        this.agentAvailability.set(agentName, available);
        this.outputChannel.appendLine(`Set ${agentName} availability to ${available}`);
    }
    /**
     * Dispose of resources
     */
    dispose() {
        this.outputChannel.dispose();
    }
}
exports.AgentSelector = AgentSelector;
//# sourceMappingURL=dynamicAgentSelector.js.map
```


---

### File: `out/agents/resultAggregator.js`

```javascript
"use strict";
/**
 * Result Aggregator
 *
 * Combines outputs from multiple agents into a coherent response.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResultAggregator = void 0;
const vscode = __importStar(require("vscode"));
/**
 * Result Aggregator class
 */
class ResultAggregator {
    /**
     * Constructor
     * @param qwenApi The Qwen API client
     */
    constructor(qwenApi) {
        this.qwenApi = qwenApi;
        this.outputChannel = vscode.window.createOutputChannel('Result Aggregator');
    }
    /**
     * Aggregate results from multiple agents
     * @param results The results from each agent
     * @param subtasks The original subtasks
     * @returns The aggregated response
     */
    async aggregate(results, subtasks) {
        try {
            this.outputChannel.appendLine(`Aggregating results from ${Object.keys(results).length} agents`);
            // Check if we have any results
            if (Object.keys(results).length === 0) {
                return 'No results were generated. Please try again with a more specific request.';
            }
            // Check if we have only one result
            if (Object.keys(results).length === 1) {
                const result = Object.values(results)[0];
                return result.content;
            }
            // Prepare the system message
            const systemMessage = `
        You are a Result Aggregator. Your job is to combine outputs from multiple specialized agents into a coherent, unified response.
        Ensure that the final response is well-structured, consistent, and addresses all aspects of the original request.
        
        Follow these guidelines:
        1. Organize information logically, grouping related content together
        2. Eliminate redundancies while preserving important details
        3. Ensure a consistent tone and style throughout
        4. Highlight key insights and recommendations
        5. Format code snippets, commands, and technical information appropriately
        6. Provide a clear summary at the beginning if the response is lengthy
      `;
            // Prepare the context with all results
            let context = "Here are the results from different specialized agents:\n\n";
            // Sort subtasks by dependencies to maintain logical order
            const sortedSubtaskIds = this._sortSubtasksByDependencies(subtasks);
            // Add results in dependency order
            for (const subtaskId of sortedSubtaskIds) {
                if (results[subtaskId]) {
                    const subtask = subtasks[subtaskId];
                    const result = results[subtaskId];
                    context += `## Subtask: ${subtask.description}\n`;
                    context += `Expertise: ${subtask.expertise}\n`;
                    context += `Status: ${result.status}\n`;
                    if (result.status === 'error') {
                        context += `Error: ${result.error}\n\n`;
                    }
                    else {
                        context += `Result:\n${result.content}\n\n`;
                    }
                }
            }
            // Prepare the user message
            const userMessage = `Please combine these results into a coherent response:\n\n${context}`;
            // Prepare the messages for the API call
            const messages = [
                { role: 'system', content: systemMessage },
                { role: 'user', content: userMessage }
            ];
            // Call the Qwen API with thinking mode enabled
            const response = await this.qwenApi.chat(messages, {
                enableThinking: true,
                temperature: 0.3,
                maxTokens: 4096
            });
            this.outputChannel.appendLine('Results aggregated successfully');
            return response;
        }
        catch (error) {
            this.outputChannel.appendLine(`Error aggregating results: ${error.message}`);
            // Fallback: concatenate results
            let fallbackResponse = '# Combined Agent Results\n\n';
            for (const subtaskId in results) {
                const result = results[subtaskId];
                const subtask = subtasks[subtaskId];
                fallbackResponse += `## ${subtask.description}\n\n`;
                if (result.status === 'error') {
                    fallbackResponse += `**Error:** ${result.error}\n\n`;
                }
                else {
                    fallbackResponse += `${result.content}\n\n`;
                }
            }
            return fallbackResponse;
        }
    }
    /**
     * Sort subtasks by dependencies
     * @param subtasks The subtasks to sort
     * @returns Sorted subtask IDs
     */
    _sortSubtasksByDependencies(subtasks) {
        const visited = new Set();
        const result = [];
        const visit = (id) => {
            if (visited.has(id)) {
                return;
            }
            visited.add(id);
            // Visit dependencies first
            for (const depId of subtasks[id].dependencies) {
                if (subtasks[depId]) {
                    visit(depId);
                }
            }
            result.push(id);
        };
        // Visit all subtasks
        for (const id in subtasks) {
            visit(id);
        }
        return result;
    }
    /**
     * Dispose of resources
     */
    dispose() {
        this.outputChannel.dispose();
    }
}
exports.ResultAggregator = ResultAggregator;
//# sourceMappingURL=resultAggregator.js.map
```


---

### File: `out/agents/developmentAgent.js`

```javascript
"use strict";
/**
 * Development Agent
 *
 * Specialized agent for code generation, refactoring, and documentation.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.DevelopmentAgent = void 0;
const vscode = __importStar(require("vscode"));
const types_1 = require("./types");
const contextProvider_1 = require("../contextProvider");
/**
 * Development Agent class
 */
class DevelopmentAgent {
    /**
     * Constructor
     * @param id The agent ID
     * @param qwenApi The Qwen API client
     * @param modelSize The model size to use
     * @param thinkingMode The thinking mode to use
     */
    constructor(id, qwenApi, modelSize, thinkingMode) {
        this.id = id;
        this.qwenApi = qwenApi;
        this.modelSize = modelSize;
        this.thinkingMode = thinkingMode;
        this.outputChannel = vscode.window.createOutputChannel(`Development Agent ${id}`);
        this.outputChannel.appendLine(`Development Agent initialized with model ${modelSize} and thinking mode ${thinkingMode}`);
    }
    /**
     * Execute a subtask
     * @param subtask The subtask to execute
     * @returns The result of the execution
     */
    async execute(subtask) {
        try {
            this.outputChannel.appendLine(`Executing subtask: ${subtask.description}`);
            // Get context from the current file
            const context = await (0, contextProvider_1.getContextForCurrentFile)();
            // Prepare the system message
            const systemMessage = `
        You are a Development Agent specializing in writing high-quality code, refactoring, and documentation.
        Your task is to help with development-related activities in a DevOps workflow.
        
        You excel at:
        1. Writing clean, efficient, and well-documented code
        2. Refactoring existing code to improve quality and maintainability
        3. Implementing best practices and design patterns
        4. Creating comprehensive documentation
        5. Solving complex programming problems
        
        When writing code:
        - Follow language-specific conventions and best practices
        - Include appropriate error handling
        - Add clear comments explaining complex logic
        - Consider edge cases and potential issues
        - Optimize for readability and maintainability
        
        When providing explanations:
        - Be clear and concise
        - Use examples to illustrate concepts
        - Explain your reasoning and decision-making process
        - Highlight trade-offs and alternatives considered
      `;
            // Prepare the user message
            const userMessage = `
        I need help with the following development task: ${subtask.description}
        
        ${context ? `Here is the current context:\n\n${context}` : ''}
      `;
            // Prepare the messages for the API call
            const messages = [
                { role: 'system', content: systemMessage },
                { role: 'user', content: userMessage }
            ];
            // Call the Qwen API with the appropriate thinking mode
            const enableThinking = this.thinkingMode === types_1.ThinkingMode.Enabled;
            const response = await this.qwenApi.chat(messages, {
                enableThinking,
                temperature: 0.3,
                maxTokens: 4096,
                modelName: this.modelSize
            });
            this.outputChannel.appendLine('Subtask executed successfully');
            return {
                subtaskId: subtask.id,
                thinking: enableThinking ? this._extractThinking(response) : undefined,
                content: this._extractContent(response, enableThinking),
                status: 'success'
            };
        }
        catch (error) {
            this.outputChannel.appendLine(`Error executing subtask: ${error.message}`);
            return {
                subtaskId: subtask.id,
                content: '',
                status: 'error',
                error: error.message
            };
        }
    }
    /**
     * Extract thinking from response
     * @param response The API response
     * @returns The extracted thinking
     */
    _extractThinking(response) {
        const thinkingMatch = response.match(/<think>([\s\S]*?)<\/think>/);
        return thinkingMatch ? thinkingMatch[1].trim() : '';
    }
    /**
     * Extract content from response
     * @param response The API response
     * @param enableThinking Whether thinking mode was enabled
     * @returns The extracted content
     */
    _extractContent(response, enableThinking) {
        if (enableThinking) {
            // Remove thinking tags and content
            return response.replace(/<think>[\s\S]*?<\/think>/, '').trim();
        }
        return response.trim();
    }
    /**
     * Dispose of resources
     */
    dispose() {
        this.outputChannel.dispose();
    }
}
exports.DevelopmentAgent = DevelopmentAgent;
//# sourceMappingURL=developmentAgent.js.map
```


---

### File: `out/agents/taskDecomposer.js`

```javascript
"use strict";
/**
 * Task Decomposer
 *
 * Breaks down complex user requests into smaller, manageable subtasks.
 * Uses Qwen's thinking mode to perform detailed analysis.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.TaskDecomposer = void 0;
const vscode = __importStar(require("vscode"));
const uuid_1 = require("uuid");
const types_1 = require("./types");
/**
 * Task Decomposer class
 */
class TaskDecomposer {
    /**
     * Constructor
     * @param qwenApi The Qwen API client
     */
    constructor(qwenApi) {
        this.qwenApi = qwenApi;
        this.outputChannel = vscode.window.createOutputChannel('Task Decomposer');
    }
    /**
     * Decompose a user request into subtasks
     * @param userRequest The user's request
     * @param availableResources Available system resources
     * @returns A record of subtasks
     */
    async decompose(userRequest, availableResources) {
        try {
            this.outputChannel.appendLine(`Decomposing request: ${userRequest}`);
            // Prepare the system message for task decomposition
            const systemMessage = `
        You are a task decomposition expert. Your job is to break down complex DevOps tasks into smaller, manageable subtasks.
        For each subtask, provide:
        1. A unique ID
        2. A clear description
        3. Required expertise (development, testing, ci_cd, github, documentation, architecture, security, performance)
        4. Estimated complexity (low, medium, high)
        5. Dependencies on other subtasks (if any)
        
        Format your response as a JSON object with the following structure:
        {
          "subtasks": [
            {
              "id": "unique_id",
              "description": "Clear description of the subtask",
              "expertise": "One of: development, testing, ci_cd, github, documentation, architecture, security, performance",
              "complexity": "One of: low, medium, high",
              "dependencies": ["id_of_dependency_1", "id_of_dependency_2"]
            },
            ...
          ]
        }
        
        Consider the available system resources when decomposing the task:
        - Memory: ${availableResources.memory * 100}%
        - CPU: ${availableResources.cpu * 100}%
        - Active Agents: ${availableResources.activeAgents}
        
        If resources are limited, prioritize essential subtasks and reduce complexity.
      `;
            // Prepare the messages for the API call
            const messages = [
                { role: 'system', content: systemMessage },
                { role: 'user', content: `Please decompose the following DevOps task into subtasks: ${userRequest}` }
            ];
            // Call the Qwen API with thinking mode enabled
            const response = await this.qwenApi.chat(messages, {
                enableThinking: true,
                temperature: 0.2,
                maxTokens: 2048
            });
            // Parse the response to extract subtasks
            const subtasks = this._parseSubtasks(response);
            // Validate subtasks and ensure they're within resource constraints
            const validatedSubtasks = this._validateSubtasks(subtasks, availableResources);
            this.outputChannel.appendLine(`Decomposed into ${Object.keys(validatedSubtasks).length} subtasks`);
            return validatedSubtasks;
        }
        catch (error) {
            this.outputChannel.appendLine(`Error decomposing task: ${error.message}`);
            throw error;
        }
    }
    /**
     * Parse the LLM response to extract subtasks
     * @param response The LLM response
     * @returns A record of subtasks
     */
    _parseSubtasks(response) {
        try {
            // Extract JSON from the response
            const jsonMatch = response.match(/```json\n([\s\S]*?)\n```/) ||
                response.match(/{[\s\S]*?}/);
            if (!jsonMatch) {
                throw new Error('No valid JSON found in the response');
            }
            const jsonStr = jsonMatch[0].startsWith('```') ? jsonMatch[1] : jsonMatch[0];
            const parsed = JSON.parse(jsonStr);
            if (!parsed.subtasks || !Array.isArray(parsed.subtasks)) {
                throw new Error('Invalid subtasks format in the response');
            }
            // Convert array to record
            const subtasks = {};
            for (const subtask of parsed.subtasks) {
                // Ensure the subtask has a valid ID
                const id = subtask.id || (0, uuid_1.v4)();
                // Ensure the subtask has valid dependencies
                const dependencies = Array.isArray(subtask.dependencies) ? subtask.dependencies : [];
                // Create the subtask object
                subtasks[id] = {
                    id,
                    description: subtask.description || '',
                    expertise: this._validateExpertise(subtask.expertise),
                    complexity: this._validateComplexity(subtask.complexity),
                    dependencies
                };
            }
            return subtasks;
        }
        catch (error) {
            this.outputChannel.appendLine(`Error parsing subtasks: ${error.message}`);
            // Fallback: create a single subtask
            const id = (0, uuid_1.v4)();
            return {
                [id]: {
                    id,
                    description: 'Execute the requested task',
                    expertise: types_1.AgentType.Development,
                    complexity: types_1.TaskComplexity.Medium,
                    dependencies: []
                }
            };
        }
    }
    /**
     * Validate the expertise field
     * @param expertise The expertise string
     * @returns A valid AgentType
     */
    _validateExpertise(expertise) {
        if (!expertise || typeof expertise !== 'string') {
            return types_1.AgentType.Development;
        }
        const normalized = expertise.toLowerCase();
        switch (normalized) {
            case 'development':
                return types_1.AgentType.Development;
            case 'testing':
                return types_1.AgentType.Testing;
            case 'ci_cd':
            case 'cicd':
                return types_1.AgentType.CICD;
            case 'github':
                return types_1.AgentType.GitHub;
            case 'documentation':
                return types_1.AgentType.Documentation;
            case 'architecture':
                return types_1.AgentType.Architecture;
            case 'security':
                return types_1.AgentType.Security;
            case 'performance':
                return types_1.AgentType.Performance;
            default:
                return types_1.AgentType.Development;
        }
    }
    /**
     * Validate the complexity field
     * @param complexity The complexity string
     * @returns A valid TaskComplexity
     */
    _validateComplexity(complexity) {
        if (!complexity || typeof complexity !== 'string') {
            return types_1.TaskComplexity.Medium;
        }
        const normalized = complexity.toLowerCase();
        switch (normalized) {
            case 'low':
                return types_1.TaskComplexity.Low;
            case 'medium':
                return types_1.TaskComplexity.Medium;
            case 'high':
                return types_1.TaskComplexity.High;
            default:
                return types_1.TaskComplexity.Medium;
        }
    }
    /**
     * Validate subtasks and ensure they're within resource constraints
     * @param subtasks The subtasks to validate
     * @param availableResources Available system resources
     * @returns Validated subtasks
     */
    _validateSubtasks(subtasks, availableResources) {
        // Check if we have enough resources for all subtasks
        const totalSubtasks = Object.keys(subtasks).length;
        if (totalSubtasks > 10 && availableResources.memory < 0.5) {
            // If resources are limited, reduce the number of subtasks
            this.outputChannel.appendLine('Limited resources detected, reducing number of subtasks');
            // Sort subtasks by dependencies (fewer dependencies first)
            const sortedSubtasks = Object.values(subtasks).sort((a, b) => a.dependencies.length - b.dependencies.length);
            // Keep only the first 5-10 subtasks
            const maxSubtasks = Math.max(5, Math.min(10, Math.floor(availableResources.memory * 20)));
            const reducedSubtasks = {};
            for (let i = 0; i < Math.min(maxSubtasks, sortedSubtasks.length); i++) {
                const subtask = sortedSubtasks[i];
                reducedSubtasks[subtask.id] = subtask;
            }
            return reducedSubtasks;
        }
        // Check for circular dependencies
        const visited = new Set();
        const visiting = new Set();
        const hasCycle = (id) => {
            if (visiting.has(id)) {
                return true;
            }
            if (visited.has(id)) {
                return false;
            }
            visiting.add(id);
            for (const depId of subtasks[id].dependencies) {
                if (!subtasks[depId]) {
                    // Remove invalid dependency
                    subtasks[id].dependencies = subtasks[id].dependencies.filter(d => d !== depId);
                    continue;
                }
                if (hasCycle(depId)) {
                    return true;
                }
            }
            visiting.delete(id);
            visited.add(id);
            return false;
        };
        // Check each subtask for cycles
        for (const id in subtasks) {
            if (hasCycle(id)) {
                // Remove circular dependencies
                this.outputChannel.appendLine(`Circular dependency detected in subtask ${id}, removing dependencies`);
                subtasks[id].dependencies = [];
            }
        }
        return subtasks;
    }
    /**
     * Dispose of resources
     */
    dispose() {
        this.outputChannel.dispose();
    }
}
exports.TaskDecomposer = TaskDecomposer;
//# sourceMappingURL=taskDecomposer.js.map
```


---

### File: `out/agents/agentCoordinator.js`

```javascript
"use strict";
/**
 * Agent Coordinator
 *
 * The central component that orchestrates the hierarchical agent system.
 * Responsible for task decomposition, agent selection, and result aggregation.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.AgentCoordinator = void 0;
const vscode = __importStar(require("vscode"));
const qwenApi_1 = require("../qwenApi");
const agentSelector_1 = require("./agentSelector");
const resourceManager_1 = require("./resourceManager");
const resultAggregator_1 = require("./resultAggregator");
const taskDecomposer_1 = require("./taskDecomposer");
const types_1 = require("./types");
/**
 * Agent Coordinator class
 */
class AgentCoordinator {
    /**
     * Constructor
     */
    constructor() {
        this.outputChannel = vscode.window.createOutputChannel('Agent Coordinator');
        this.qwenApi = new qwenApi_1.QwenApiClient();
        this.taskDecomposer = new taskDecomposer_1.TaskDecomposer(this.qwenApi);
        this.agentSelector = new agentSelector_1.AgentSelector();
        this.resourceManager = new resourceManager_1.ResourceManager();
        this.resultAggregator = new resultAggregator_1.ResultAggregator(this.qwenApi);
        this.outputChannel.appendLine('Agent Coordinator initialized');
    }
    /**
     * Update the configuration
     * @param config New configuration
     */
    updateConfig(config) {
        this.config = config;
        this.outputChannel.appendLine('Configuration updated');
    }
    /**
     * Process a user request
     * @param userRequest The user's request
     * @returns The final response
     */
    async processRequest(userRequest) {
        try {
            this.outputChannel.appendLine(`Processing request: ${userRequest}`);
            // Get available resources
            const availableResources = await this.resourceManager.getAvailableResources();
            this.outputChannel.appendLine(`Available resources: ${JSON.stringify(availableResources)}`);
            // Decompose the task
            const subtasks = await this.taskDecomposer.decompose(userRequest, availableResources);
            this.outputChannel.appendLine(`Task decomposed into ${Object.keys(subtasks).length} subtasks`);
            // Select appropriate agents for each subtask
            const agentAssignments = await this.agentSelector.selectAgents(subtasks, availableResources);
            this.outputChannel.appendLine(`Agent assignments: ${JSON.stringify(agentAssignments)}`);
            // Execute subtasks with assigned agents
            const results = {};
            for (const subtaskId in agentAssignments) {
                const agentInfo = agentAssignments[subtaskId];
                const subtask = subtasks[subtaskId];
                this.outputChannel.appendLine(`Executing subtask ${subtaskId} with agent ${agentInfo.type}`);
                // Check if all dependencies are completed
                const dependenciesMet = subtask.dependencies.every(depId => results[depId] && results[depId].status === 'success');
                if (!dependenciesMet) {
                    this.outputChannel.appendLine(`Skipping subtask ${subtaskId} due to unmet dependencies`);
                    continue;
                }
                // Execute the subtask
                try {
                    const agent = await this.instantiateAgent(agentInfo);
                    results[subtaskId] = await agent.execute(subtask);
                    this.outputChannel.appendLine(`Subtask ${subtaskId} completed successfully`);
                }
                catch (error) {
                    this.outputChannel.appendLine(`Error executing subtask ${subtaskId}: ${error.message}`);
                    results[subtaskId] = {
                        subtaskId,
                        content: '',
                        status: 'error',
                        error: error.message
                    };
                }
            }
            // Aggregate results
            const finalResponse = await this.resultAggregator.aggregate(results, subtasks);
            this.outputChannel.appendLine('Request processing completed');
            return finalResponse;
        }
        catch (error) {
            this.outputChannel.appendLine(`Error processing request: ${error.message}`);
            throw error;
        }
    }
    /**
     * Instantiate an agent based on agent info
     * @param agentInfo The agent information
     * @returns The instantiated agent
     */
    async instantiateAgent(agentInfo) {
        // This is a placeholder for agent instantiation
        // In a real implementation, we would dynamically import and instantiate the appropriate agent
        const agentType = agentInfo.type;
        const modelSize = agentInfo.modelSize;
        const thinkingMode = agentInfo.thinkingMode;
        this.outputChannel.appendLine(`Instantiating agent: ${agentType} with model ${modelSize} and thinking mode ${thinkingMode}`);
        // Register the agent with the resource manager
        const agentId = await this.resourceManager.registerAgent(agentType, {
            modelSize,
            thinkingMode
        });
        // Import the appropriate agent class
        try {
            switch (agentType) {
                case types_1.AgentType.Development:
                    const { DevelopmentAgent } = await Promise.resolve().then(() => __importStar(require('./developmentAgent')));
                    return new DevelopmentAgent(agentId, this.qwenApi, modelSize, thinkingMode);
                case types_1.AgentType.Testing:
                    const { TestingAgent } = await Promise.resolve().then(() => __importStar(require('./testingAgent')));
                    return new TestingAgent(agentId, this.qwenApi, modelSize, thinkingMode);
                case types_1.AgentType.CICD:
                    const { CICDAgent } = await Promise.resolve().then(() => __importStar(require('./cicdAgent')));
                    return new CICDAgent(agentId, this.qwenApi, modelSize, thinkingMode);
                case types_1.AgentType.GitHub:
                    const { GitHubAgent } = await Promise.resolve().then(() => __importStar(require('./githubAgent')));
                    return new GitHubAgent(agentId, this.qwenApi, modelSize, thinkingMode);
                default:
                    throw new Error(`Unsupported agent type: ${agentType}`);
            }
        }
        catch (error) {
            this.outputChannel.appendLine(`Error instantiating agent: ${error.message}`);
            await this.resourceManager.unregisterAgent(agentId);
            throw error;
        }
    }
    /**
     * Dispose of resources
     */
    dispose() {
        this.outputChannel.dispose();
    }
}
exports.AgentCoordinator = AgentCoordinator;
//# sourceMappingURL=agentCoordinator.js.map
```


---

### File: `out/agents/agentSelector.js`

```javascript
"use strict";
/**
 * Agent Selector
 *
 * Chooses the most appropriate agent for each subtask based on expertise, complexity, and available resources.
 * Also provides dynamic agent selection based on task requirements.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.AgentSelector = void 0;
const vscode = __importStar(require("vscode"));
const configuration_1 = require("../configuration");
const types_1 = require("./types");
/**
 * Agent Selector class
 */
class AgentSelector {
    /**
     * Constructor
     */
    constructor() {
        this.agents = [];
        this.agentAvailability = new Map();
        this.outputChannel = vscode.window.createOutputChannel('Agent Selector');
        // Initialize agent configurations
        this.agentConfigs = {
            [types_1.AgentType.Coordinator]: {
                [types_1.TaskComplexity.High]: { modelSize: types_1.ModelSize.MoESmall, thinkingMode: types_1.ThinkingMode.Enabled },
                [types_1.TaskComplexity.Medium]: { modelSize: types_1.ModelSize.MoESmall, thinkingMode: types_1.ThinkingMode.Enabled },
                [types_1.TaskComplexity.Low]: { modelSize: types_1.ModelSize.XXLarge, thinkingMode: types_1.ThinkingMode.Enabled }
            },
            [types_1.AgentType.Development]: {
                [types_1.TaskComplexity.High]: { modelSize: types_1.ModelSize.MoESmall, thinkingMode: types_1.ThinkingMode.Enabled },
                [types_1.TaskComplexity.Medium]: { modelSize: types_1.ModelSize.XXLarge, thinkingMode: types_1.ThinkingMode.Enabled },
                [types_1.TaskComplexity.Low]: { modelSize: types_1.ModelSize.XLarge, thinkingMode: types_1.ThinkingMode.Disabled }
            },
            [types_1.AgentType.Testing]: {
                [types_1.TaskComplexity.High]: { modelSize: types_1.ModelSize.XLarge, thinkingMode: types_1.ThinkingMode.Enabled },
                [types_1.TaskComplexity.Medium]: { modelSize: types_1.ModelSize.Large, thinkingMode: types_1.ThinkingMode.Enabled },
                [types_1.TaskComplexity.Low]: { modelSize: types_1.ModelSize.Medium, thinkingMode: types_1.ThinkingMode.Disabled }
            },
            [types_1.AgentType.CICD]: {
                [types_1.TaskComplexity.High]: { modelSize: types_1.ModelSize.Large, thinkingMode: types_1.ThinkingMode.Enabled },
                [types_1.TaskComplexity.Medium]: { modelSize: types_1.ModelSize.Medium, thinkingMode: types_1.ThinkingMode.Disabled },
                [types_1.TaskComplexity.Low]: { modelSize: types_1.ModelSize.Small, thinkingMode: types_1.ThinkingMode.Disabled }
            },
            [types_1.AgentType.GitHub]: {
                [types_1.TaskComplexity.High]: { modelSize: types_1.ModelSize.Large, thinkingMode: types_1.ThinkingMode.Enabled },
                [types_1.TaskComplexity.Medium]: { modelSize: types_1.ModelSize.Medium, thinkingMode: types_1.ThinkingMode.Disabled },
                [types_1.TaskComplexity.Low]: { modelSize: types_1.ModelSize.Small, thinkingMode: types_1.ThinkingMode.Disabled }
            },
            [types_1.AgentType.Documentation]: {
                [types_1.TaskComplexity.High]: { modelSize: types_1.ModelSize.Large, thinkingMode: types_1.ThinkingMode.Enabled },
                [types_1.TaskComplexity.Medium]: { modelSize: types_1.ModelSize.Medium, thinkingMode: types_1.ThinkingMode.Enabled },
                [types_1.TaskComplexity.Low]: { modelSize: types_1.ModelSize.Small, thinkingMode: types_1.ThinkingMode.Disabled }
            },
            [types_1.AgentType.Architecture]: {
                [types_1.TaskComplexity.High]: { modelSize: types_1.ModelSize.MoESmall, thinkingMode: types_1.ThinkingMode.Enabled },
                [types_1.TaskComplexity.Medium]: { modelSize: types_1.ModelSize.XXLarge, thinkingMode: types_1.ThinkingMode.Enabled },
                [types_1.TaskComplexity.Low]: { modelSize: types_1.ModelSize.XLarge, thinkingMode: types_1.ThinkingMode.Enabled }
            },
            [types_1.AgentType.Security]: {
                [types_1.TaskComplexity.High]: { modelSize: types_1.ModelSize.XLarge, thinkingMode: types_1.ThinkingMode.Enabled },
                [types_1.TaskComplexity.Medium]: { modelSize: types_1.ModelSize.Large, thinkingMode: types_1.ThinkingMode.Enabled },
                [types_1.TaskComplexity.Low]: { modelSize: types_1.ModelSize.Medium, thinkingMode: types_1.ThinkingMode.Disabled }
            },
            [types_1.AgentType.Performance]: {
                [types_1.TaskComplexity.High]: { modelSize: types_1.ModelSize.XLarge, thinkingMode: types_1.ThinkingMode.Enabled },
                [types_1.TaskComplexity.Medium]: { modelSize: types_1.ModelSize.Large, thinkingMode: types_1.ThinkingMode.Enabled },
                [types_1.TaskComplexity.Low]: { modelSize: types_1.ModelSize.Medium, thinkingMode: types_1.ThinkingMode.Disabled }
            }
        };
        this.outputChannel.appendLine('Agent Selector initialized');
    }
    /**
     * Select appropriate agents for each subtask
     * @param subtasks The subtasks to assign agents to
     * @param availableResources Available system resources
     * @returns Agent assignments for each subtask
     */
    async selectAgents(subtasks, availableResources) {
        try {
            this.outputChannel.appendLine(`Selecting agents for ${Object.keys(subtasks).length} subtasks`);
            // Get user configuration
            const config = (0, configuration_1.getConfiguration)();
            const preferredModel = config.get('preferredModel', 'auto');
            const preferThinking = config.get('preferThinkingMode', true);
            // Initialize agent assignments
            const agentAssignments = {};
            // Sort subtasks by dependencies (fewer dependencies first)
            const sortedSubtasks = Object.values(subtasks).sort((a, b) => a.dependencies.length - b.dependencies.length);
            // Assign agents to each subtask
            for (const subtask of sortedSubtasks) {
                const expertise = subtask.expertise;
                const complexity = subtask.complexity;
                // Get the appropriate agent configuration
                let agentConfig = this.agentConfigs[expertise][complexity];
                // Apply user preferences
                if (preferredModel !== 'auto') {
                    // Override model size based on user preference
                    const userModelSize = this._getUserModelSize(preferredModel);
                    if (userModelSize) {
                        agentConfig = { ...agentConfig, modelSize: userModelSize };
                    }
                }
                if (preferThinking) {
                    // Prefer thinking mode if user has enabled it
                    agentConfig = { ...agentConfig, thinkingMode: types_1.ThinkingMode.Enabled };
                }
                // Check if we have enough resources for this agent
                if (this._checkResources(agentConfig, availableResources)) {
                    agentAssignments[subtask.id] = {
                        type: expertise,
                        modelSize: agentConfig.modelSize,
                        thinkingMode: agentConfig.thinkingMode
                    };
                }
                else {
                    // Fallback to a smaller model if resources are constrained
                    const fallbackAgent = this._getFallbackAgent(expertise, availableResources);
                    agentAssignments[subtask.id] = fallbackAgent;
                }
                this.outputChannel.appendLine(`Assigned ${agentAssignments[subtask.id].type} agent with ${agentAssignments[subtask.id].modelSize} model to subtask ${subtask.id}`);
            }
            return agentAssignments;
        }
        catch (error) {
            this.outputChannel.appendLine(`Error selecting agents: ${error.message}`);
            throw error;
        }
    }
    /**
     * Check if we have enough resources for this agent
     * @param agentConfig The agent configuration
     * @param availableResources Available system resources
     * @returns Whether we have enough resources
     */
    _checkResources(agentConfig, availableResources) {
        // Calculate resource requirements based on model size and thinking mode
        let memoryRequirement = 0;
        let cpuRequirement = 0;
        // Memory requirements
        switch (agentConfig.modelSize) {
            case types_1.ModelSize.MoELarge:
                memoryRequirement = 0.8;
                break;
            case types_1.ModelSize.MoESmall:
                memoryRequirement = 0.5;
                break;
            case types_1.ModelSize.XXLarge:
                memoryRequirement = 0.4;
                break;
            case types_1.ModelSize.XLarge:
                memoryRequirement = 0.3;
                break;
            case types_1.ModelSize.Large:
                memoryRequirement = 0.2;
                break;
            case types_1.ModelSize.Medium:
                memoryRequirement = 0.1;
                break;
            case types_1.ModelSize.Small:
                memoryRequirement = 0.05;
                break;
            case types_1.ModelSize.Tiny:
                memoryRequirement = 0.02;
                break;
        }
        // CPU requirements
        switch (agentConfig.modelSize) {
            case types_1.ModelSize.MoELarge:
                cpuRequirement = 0.8;
                break;
            case types_1.ModelSize.MoESmall:
                cpuRequirement = 0.5;
                break;
            case types_1.ModelSize.XXLarge:
                cpuRequirement = 0.4;
                break;
            case types_1.ModelSize.XLarge:
                cpuRequirement = 0.3;
                break;
            case types_1.ModelSize.Large:
                cpuRequirement = 0.2;
                break;
            case types_1.ModelSize.Medium:
                cpuRequirement = 0.1;
                break;
            case types_1.ModelSize.Small:
                cpuRequirement = 0.05;
                break;
            case types_1.ModelSize.Tiny:
                cpuRequirement = 0.02;
                break;
        }
        // Adjust for thinking mode
        if (agentConfig.thinkingMode === types_1.ThinkingMode.Enabled) {
            memoryRequirement *= 1.5;
            cpuRequirement *= 1.5;
        }
        // Check if we have enough resources
        return (availableResources.memory >= memoryRequirement &&
            availableResources.cpu >= cpuRequirement);
    }
    /**
     * Get a fallback agent with lower resource requirements
     * @param expertise The required expertise
     * @param availableResources Available system resources
     * @returns A fallback agent configuration
     */
    _getFallbackAgent(expertise, availableResources) {
        this.outputChannel.appendLine(`Finding fallback agent for ${expertise} due to resource constraints`);
        // Try progressively smaller models
        const modelSizes = [
            types_1.ModelSize.Medium,
            types_1.ModelSize.Small,
            types_1.ModelSize.Tiny
        ];
        // Try without thinking mode first
        for (const modelSize of modelSizes) {
            const config = { modelSize, thinkingMode: types_1.ThinkingMode.Disabled };
            if (this._checkResources(config, availableResources)) {
                return { type: expertise, ...config };
            }
        }
        // If all else fails, use the smallest possible configuration
        return {
            type: expertise,
            modelSize: types_1.ModelSize.Tiny,
            thinkingMode: types_1.ThinkingMode.Disabled
        };
    }
    /**
     * Convert user model preference to ModelSize
     * @param preferredModel The user's preferred model
     * @returns The corresponding ModelSize or undefined
     */
    _getUserModelSize(preferredModel) {
        switch (preferredModel.toLowerCase()) {
            case 'tiny':
                return types_1.ModelSize.Tiny;
            case 'small':
                return types_1.ModelSize.Small;
            case 'medium':
                return types_1.ModelSize.Medium;
            case 'large':
                return types_1.ModelSize.Large;
            case 'xlarge':
                return types_1.ModelSize.XLarge;
            case 'xxlarge':
                return types_1.ModelSize.XXLarge;
            case 'moesmall':
            case 'moe-small':
                return types_1.ModelSize.MoESmall;
            case 'moelarge':
            case 'moe-large':
                return types_1.ModelSize.MoELarge;
            default:
                return undefined;
        }
    }
    /**
     * Register an agent with the selector
     * @param agent The agent to register
     */
    registerAgent(agent) {
        this.agents.push(agent);
        this.outputChannel.appendLine(`Registered agent: ${agent.name}`);
    }
    /**
     * Select the most appropriate agent for a task
     * @param task The task to select an agent for
     * @returns The selected agent
     */
    async selectAgent(task) {
        try {
            this.outputChannel.appendLine(`Selecting agent for task: ${task.description}`);
            // Determine task complexity if not specified
            if (!task.complexity) {
                task.complexity = this.analyzeTaskComplexity(task.description);
                this.outputChannel.appendLine(`Inferred task complexity: ${task.complexity}`);
            }
            // Filter agents by availability
            const availableAgents = this.agents.filter(agent => this.isAgentAvailable(agent.name));
            if (availableAgents.length === 0) {
                throw new Error('No agents available');
            }
            // Filter agents by complexity
            const complexityMap = {
                [types_1.TaskComplexity.Simple]: 1,
                [types_1.TaskComplexity.Moderate]: 2,
                [types_1.TaskComplexity.Complex]: 3,
                [types_1.TaskComplexity.VeryComplex]: 4
            };
            const taskComplexityValue = complexityMap[task.complexity];
            const capableAgents = availableAgents.filter(agent => {
                const agentComplexityValue = complexityMap[agent.maxComplexity];
                return agentComplexityValue >= taskComplexityValue;
            });
            if (capableAgents.length === 0) {
                // Fallback to the agent with the highest complexity capability
                const fallbackAgent = availableAgents.sort((a, b) => complexityMap[b.maxComplexity] - complexityMap[a.maxComplexity])[0];
                this.outputChannel.appendLine(`No agent capable of handling complexity ${task.complexity}, falling back to ${fallbackAgent.name}`);
                return fallbackAgent;
            }
            // Filter by required capabilities
            let filteredAgents = capableAgents;
            if (task.requiresContext) {
                filteredAgents = filteredAgents.filter(agent => agent.capabilities.includes('context'));
            }
            if (task.requiresTools) {
                filteredAgents = filteredAgents.filter(agent => agent.capabilities.includes('tools'));
            }
            if (filteredAgents.length === 0) {
                this.outputChannel.appendLine(`No agent with required capabilities, falling back to most capable agent`);
                return capableAgents[0];
            }
            // Filter by domain specialization if specified
            if (task.domain && task.domain !== 'general') {
                const domainAgents = filteredAgents.filter(agent => agent.specializations?.some(spec => spec.toLowerCase().includes(task.domain.toLowerCase())));
                if (domainAgents.length > 0) {
                    filteredAgents = domainAgents;
                    this.outputChannel.appendLine(`Found ${domainAgents.length} agents specialized in ${task.domain}`);
                }
            }
            // Filter by required tools if specified
            if (task.requiredTools && task.requiredTools.length > 0) {
                // For this example, we'll just check if the agent has tools capability
                // In a real implementation, we would check if the agent supports the specific tools
                const toolAgents = filteredAgents.filter(agent => agent.capabilities.includes('tools'));
                if (toolAgents.length > 0) {
                    filteredAgents = toolAgents;
                    this.outputChannel.appendLine(`Found ${toolAgents.length} agents with required tool support`);
                }
            }
            // Select the best agent from the filtered list
            // For now, we'll just take the first one
            // In a real implementation, we might use a more sophisticated selection algorithm
            const selectedAgent = filteredAgents[0];
            this.outputChannel.appendLine(`Selected agent: ${selectedAgent.name}`);
            return selectedAgent;
        }
        catch (error) {
            this.outputChannel.appendLine(`Error selecting agent: ${error instanceof Error ? error.message : String(error)}`);
            // Return a default agent as fallback
            const defaultAgent = this.agents.find(a => a.name === 'DevelopmentAgent') || this.agents[0];
            this.outputChannel.appendLine(`Falling back to default agent: ${defaultAgent.name}`);
            return defaultAgent;
        }
    }
    /**
     * Analyze task description to determine complexity
     * @param description Task description
     * @returns Inferred task complexity
     */
    analyzeTaskComplexity(description) {
        const description_lower = description.toLowerCase();
        // Check for keywords indicating very complex tasks
        const veryComplexKeywords = [
            'architecture', 'redesign', 'system design', 'microservice',
            'distributed', 'scale', 'optimize', 'performance', 'security',
            'refactor', 'monolithic'
        ];
        if (veryComplexKeywords.some(keyword => description_lower.includes(keyword))) {
            return types_1.TaskComplexity.Complex;
        }
        // Check for keywords indicating complex tasks
        const complexKeywords = [
            'implement', 'create', 'develop', 'build', 'design',
            'algorithm', 'feature', 'functionality', 'integration'
        ];
        if (complexKeywords.some(keyword => description_lower.includes(keyword))) {
            return types_1.TaskComplexity.Moderate;
        }
        // Check for keywords indicating simple tasks
        const simpleKeywords = [
            'fix', 'update', 'change', 'modify', 'add', 'remove',
            'format', 'rename', 'explain', 'help'
        ];
        if (simpleKeywords.some(keyword => description_lower.includes(keyword))) {
            return types_1.TaskComplexity.Simple;
        }
        // Default to moderate complexity
        return types_1.TaskComplexity.Moderate;
    }
    /**
     * Check if an agent is available
     * @param agentName Agent name
     * @returns Whether the agent is available
     */
    isAgentAvailable(agentName) {
        // If we have an explicit availability setting, use that
        if (this.agentAvailability.has(agentName)) {
            return this.agentAvailability.get(agentName);
        }
        // Otherwise, check the agent's default availability
        const agent = this.agents.find(a => a.name === agentName);
        return agent ? agent.available : false;
    }
    /**
     * Set agent availability
     * @param agentName Agent name
     * @param available Whether the agent is available
     */
    setAgentAvailability(agentName, available) {
        this.agentAvailability.set(agentName, available);
        this.outputChannel.appendLine(`Set ${agentName} availability to ${available}`);
    }
    /**
     * Dispose of resources
     */
    dispose() {
        this.outputChannel.dispose();
    }
}
exports.AgentSelector = AgentSelector;
//# sourceMappingURL=agentSelector.js.map
```


---

### File: `out/agents/resourceManager.js`

```javascript
"use strict";
/**
 * Resource Manager
 *
 * Monitors system resources and controls agent instantiation.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResourceManager = void 0;
const vscode = __importStar(require("vscode"));
const os = __importStar(require("os"));
const uuid_1 = require("uuid");
/**
 * Resource Manager class
 */
class ResourceManager {
    /**
     * Constructor
     * @param maxMemoryUsage Maximum memory usage (0-1)
     * @param maxCpuUsage Maximum CPU usage (0-1)
     */
    constructor(maxMemoryUsage = 0.8, maxCpuUsage = 0.8) {
        this.outputChannel = vscode.window.createOutputChannel('Resource Manager');
        this.activeAgents = {};
        this.maxMemoryUsage = maxMemoryUsage;
        this.maxCpuUsage = maxCpuUsage;
        this.resourceCheckInterval = null;
        // Start resource monitoring
        this._startResourceMonitoring();
        this.outputChannel.appendLine('Resource Manager initialized');
    }
    /**
     * Get available system resources
     * @returns Available resources
     */
    async getAvailableResources() {
        try {
            // Get current system resource usage
            const currentMemoryUsage = this._getMemoryUsage();
            const currentCpuUsage = await this._getCpuUsage();
            // Calculate available resources
            const availableMemory = Math.max(0, this.maxMemoryUsage - currentMemoryUsage);
            const availableCpu = Math.max(0, this.maxCpuUsage - currentCpuUsage);
            const resources = {
                memory: availableMemory,
                cpu: availableCpu,
                activeAgents: Object.keys(this.activeAgents).length
            };
            this.outputChannel.appendLine(`Available resources: memory=${availableMemory.toFixed(2)}, cpu=${availableCpu.toFixed(2)}, activeAgents=${resources.activeAgents}`);
            return resources;
        }
        catch (error) {
            this.outputChannel.appendLine(`Error getting available resources: ${error.message}`);
            // Return conservative estimates in case of error
            return {
                memory: 0.2,
                cpu: 0.2,
                activeAgents: Object.keys(this.activeAgents).length
            };
        }
    }
    /**
     * Register a new agent with its resource requirements
     * @param type Agent type
     * @param requirements Resource requirements
     * @returns Agent ID
     */
    async registerAgent(type, requirements) {
        const agentId = (0, uuid_1.v4)();
        this.activeAgents[agentId] = {
            type,
            modelSize: requirements.modelSize,
            thinkingMode: requirements.thinkingMode,
            startTime: Date.now()
        };
        this.outputChannel.appendLine(`Registered agent ${agentId} of type ${type} with model ${requirements.modelSize}`);
        return agentId;
    }
    /**
     * Unregister an agent when it's no longer needed
     * @param agentId Agent ID
     */
    async unregisterAgent(agentId) {
        if (agentId in this.activeAgents) {
            const agent = this.activeAgents[agentId];
            const duration = (Date.now() - agent.startTime) / 1000;
            this.outputChannel.appendLine(`Unregistered agent ${agentId} of type ${agent.type} after ${duration.toFixed(2)}s`);
            delete this.activeAgents[agentId];
        }
    }
    /**
     * Get current memory usage
     * @returns Memory usage (0-1)
     */
    _getMemoryUsage() {
        const totalMem = os.totalmem();
        const freeMem = os.freemem();
        const usedMem = totalMem - freeMem;
        return usedMem / totalMem;
    }
    /**
     * Get current CPU usage
     * @returns CPU usage (0-1)
     */
    async _getCpuUsage() {
        return new Promise((resolve) => {
            const startMeasure = os.cpus().map(cpu => cpu.times);
            // Measure CPU usage over a short interval
            setTimeout(() => {
                const endMeasure = os.cpus().map(cpu => cpu.times);
                const cpuUsage = endMeasure.map((end, i) => {
                    const start = startMeasure[i];
                    const idle = end.idle - start.idle;
                    const total = (end.user - start.user) +
                        (end.nice - start.nice) +
                        (end.sys - start.sys) +
                        (end.irq - start.irq) +
                        idle;
                    return 1 - (idle / total);
                });
                // Average CPU usage across all cores
                const avgCpuUsage = cpuUsage.reduce((sum, usage) => sum + usage, 0) / cpuUsage.length;
                resolve(avgCpuUsage);
            }, 100);
        });
    }
    /**
     * Start resource monitoring
     */
    _startResourceMonitoring() {
        if (this.resourceCheckInterval) {
            clearInterval(this.resourceCheckInterval);
        }
        this.resourceCheckInterval = setInterval(async () => {
            try {
                const resources = await this.getAvailableResources();
                // Log resource usage periodically
                if (Object.keys(this.activeAgents).length > 0) {
                    this.outputChannel.appendLine(`Resource check: memory=${(1 - resources.memory).toFixed(2)}, cpu=${(1 - resources.cpu).toFixed(2)}, activeAgents=${resources.activeAgents}`);
                }
                // Check for resource constraints
                if (resources.memory < 0.1 || resources.cpu < 0.1) {
                    this.outputChannel.appendLine('WARNING: System resources are critically low');
                    // Notify the user
                    vscode.window.showWarningMessage('System resources are running low. Some agent operations may be delayed.');
                }
            }
            catch (error) {
                this.outputChannel.appendLine(`Error monitoring resources: ${error.message}`);
            }
        }, 30000); // Check every 30 seconds
    }
    /**
     * Dispose of resources
     */
    dispose() {
        if (this.resourceCheckInterval) {
            clearInterval(this.resourceCheckInterval);
            this.resourceCheckInterval = null;
        }
        this.outputChannel.dispose();
    }
}
exports.ResourceManager = ResourceManager;
//# sourceMappingURL=resourceManager.js.map
```


---

### File: `out/agents/agentSelectorTest.js`

```javascript
"use strict";
/**
 * Standalone test for the dynamic agent selector
 *
 * This file contains a simplified version of the agent selector that can be tested
 * without the VS Code extension API.
 */
// Agent types
var AgentType;
(function (AgentType) {
    AgentType["Simple"] = "simple";
    AgentType["Development"] = "development";
    AgentType["Architecture"] = "architecture";
    AgentType["DevOps"] = "devops";
    AgentType["ML"] = "machine_learning";
    AgentType["WebDev"] = "web_development";
})(AgentType || (AgentType = {}));
// Model sizes
var ModelSize;
(function (ModelSize) {
    ModelSize["Small"] = "small";
    ModelSize["Medium"] = "medium";
    ModelSize["Large"] = "large";
    ModelSize["XLarge"] = "xlarge";
})(ModelSize || (ModelSize = {}));
// Task complexity levels
var TaskComplexity;
(function (TaskComplexity) {
    TaskComplexity["Simple"] = "simple";
    TaskComplexity["Moderate"] = "moderate";
    TaskComplexity["Complex"] = "complex";
    TaskComplexity["VeryComplex"] = "very_complex";
})(TaskComplexity || (TaskComplexity = {}));
/**
 * Agent Selector class for dynamic agent selection
 */
class AgentSelector {
    /**
     * Constructor
     */
    constructor() {
        this.agentAvailability = new Map();
        // Initialize available agents
        this.agents = [
            {
                name: 'SimpleAgent',
                type: AgentType.Simple,
                capabilities: ['code'],
                modelSize: ModelSize.Small,
                maxComplexity: TaskComplexity.Simple,
                systemPrompt: 'You are a simple coding assistant that helps with basic tasks.',
                available: true
            },
            {
                name: 'DevelopmentAgent',
                type: AgentType.Development,
                capabilities: ['code', 'context', 'reasoning'],
                modelSize: ModelSize.Large,
                maxComplexity: TaskComplexity.Complex,
                systemPrompt: 'You are a development assistant that helps with coding tasks.',
                available: true
            },
            {
                name: 'ArchitectAgent',
                type: AgentType.Architecture,
                capabilities: ['code', 'context', 'reasoning', 'architecture'],
                modelSize: ModelSize.XLarge,
                maxComplexity: TaskComplexity.VeryComplex,
                systemPrompt: 'You are an architecture assistant that helps with system design and architecture.',
                available: true
            },
            {
                name: 'DevOpsAgent',
                type: AgentType.DevOps,
                capabilities: ['code', 'tools', 'context'],
                modelSize: ModelSize.Large,
                maxComplexity: TaskComplexity.Complex,
                specializations: ['github', 'docker', 'ci-cd'],
                systemPrompt: 'You are a DevOps assistant that helps with CI/CD, deployment, and infrastructure.',
                available: true
            },
            {
                name: 'MLAgent',
                type: AgentType.ML,
                capabilities: ['code', 'context', 'reasoning'],
                modelSize: ModelSize.XLarge,
                maxComplexity: TaskComplexity.VeryComplex,
                specializations: ['machine-learning', 'data-science', 'neural-networks'],
                systemPrompt: 'You are a machine learning assistant that helps with ML models and algorithms.',
                available: true
            },
            {
                name: 'WebDevAgent',
                type: AgentType.WebDev,
                capabilities: ['code', 'context'],
                modelSize: ModelSize.Medium,
                maxComplexity: TaskComplexity.Complex,
                specializations: ['web-development', 'frontend', 'backend'],
                systemPrompt: 'You are a web development assistant that helps with frontend and backend tasks.',
                available: true
            }
        ];
        console.log('Dynamic Agent Selector initialized with ' + this.agents.length + ' agents');
    }
    /**
     * Select the most appropriate agent for a task
     * @param task The task to select an agent for
     * @returns The selected agent
     */
    async selectAgent(task) {
        try {
            console.log(`Selecting agent for task: ${task.description}`);
            // Determine task complexity if not specified
            if (!task.complexity) {
                task.complexity = this.analyzeTaskComplexity(task.description);
                console.log(`Inferred task complexity: ${task.complexity}`);
            }
            // Filter agents by availability
            const availableAgents = this.agents.filter(agent => this.isAgentAvailable(agent.name));
            if (availableAgents.length === 0) {
                throw new Error('No agents available');
            }
            // Filter agents by complexity
            const complexityMap = {
                [TaskComplexity.Simple]: 1,
                [TaskComplexity.Moderate]: 2,
                [TaskComplexity.Complex]: 3,
                [TaskComplexity.VeryComplex]: 4
            };
            const taskComplexityValue = complexityMap[task.complexity];
            const capableAgents = availableAgents.filter(agent => {
                const agentComplexityValue = complexityMap[agent.maxComplexity];
                return agentComplexityValue >= taskComplexityValue;
            });
            if (capableAgents.length === 0) {
                // Fallback to the agent with the highest complexity capability
                const fallbackAgent = availableAgents.sort((a, b) => complexityMap[b.maxComplexity] - complexityMap[a.maxComplexity])[0];
                console.log(`No agent capable of handling complexity ${task.complexity}, falling back to ${fallbackAgent.name}`);
                return fallbackAgent;
            }
            // Filter by required capabilities
            let filteredAgents = capableAgents;
            if (task.requiresContext) {
                filteredAgents = filteredAgents.filter(agent => agent.capabilities.includes('context'));
            }
            if (task.requiresTools) {
                filteredAgents = filteredAgents.filter(agent => agent.capabilities.includes('tools'));
            }
            if (filteredAgents.length === 0) {
                console.log(`No agent with required capabilities, falling back to most capable agent`);
                return capableAgents[0];
            }
            // Filter by domain specialization if specified
            if (task.domain && task.domain !== 'general') {
                const domainAgents = filteredAgents.filter(agent => agent.specializations?.some(spec => spec.toLowerCase().includes(task.domain.toLowerCase())));
                if (domainAgents.length > 0) {
                    filteredAgents = domainAgents;
                    console.log(`Found ${domainAgents.length} agents specialized in ${task.domain}`);
                }
            }
            // Filter by required tools if specified
            if (task.requiredTools && task.requiredTools.length > 0) {
                // For this example, we'll just check if the agent has tools capability
                // In a real implementation, we would check if the agent supports the specific tools
                const toolAgents = filteredAgents.filter(agent => agent.capabilities.includes('tools'));
                if (toolAgents.length > 0) {
                    filteredAgents = toolAgents;
                    console.log(`Found ${toolAgents.length} agents with required tool support`);
                }
            }
            // Select the best agent from the filtered list
            // For now, we'll just take the first one
            // In a real implementation, we might use a more sophisticated selection algorithm
            const selectedAgent = filteredAgents[0];
            console.log(`Selected agent: ${selectedAgent.name}`);
            return selectedAgent;
        }
        catch (error) {
            console.error(`Error selecting agent: ${error instanceof Error ? error.message : String(error)}`);
            // Return a default agent as fallback
            const defaultAgent = this.agents.find(a => a.name === 'DevelopmentAgent') || this.agents[0];
            console.log(`Falling back to default agent: ${defaultAgent.name}`);
            return defaultAgent;
        }
    }
    /**
     * Analyze task description to determine complexity
     * @param description Task description
     * @returns Inferred task complexity
     */
    analyzeTaskComplexity(description) {
        const description_lower = description.toLowerCase();
        // Check for keywords indicating very complex tasks
        const veryComplexKeywords = [
            'architecture', 'redesign', 'system design', 'microservice',
            'distributed', 'scale', 'optimize', 'performance', 'security',
            'refactor', 'monolithic'
        ];
        if (veryComplexKeywords.some(keyword => description_lower.includes(keyword))) {
            return TaskComplexity.Complex;
        }
        // Check for keywords indicating complex tasks
        const complexKeywords = [
            'implement', 'create', 'develop', 'build', 'design',
            'algorithm', 'feature', 'functionality', 'integration'
        ];
        if (complexKeywords.some(keyword => description_lower.includes(keyword))) {
            return TaskComplexity.Moderate;
        }
        // Check for keywords indicating simple tasks
        const simpleKeywords = [
            'fix', 'update', 'change', 'modify', 'add', 'remove',
            'format', 'rename', 'explain', 'help'
        ];
        if (simpleKeywords.some(keyword => description_lower.includes(keyword))) {
            return TaskComplexity.Simple;
        }
        // Default to moderate complexity
        return TaskComplexity.Moderate;
    }
    /**
     * Check if an agent is available
     * @param agentName Agent name
     * @returns Whether the agent is available
     */
    isAgentAvailable(agentName) {
        // If we have an explicit availability setting, use that
        if (this.agentAvailability.has(agentName)) {
            return this.agentAvailability.get(agentName);
        }
        // Otherwise, check the agent's default availability
        const agent = this.agents.find(a => a.name === agentName);
        return agent ? agent.available : false;
    }
    /**
     * Set agent availability
     * @param agentName Agent name
     * @param available Whether the agent is available
     */
    setAgentAvailability(agentName, available) {
        this.agentAvailability.set(agentName, available);
        console.log(`Set ${agentName} availability to ${available}`);
    }
}
// Run tests
async function runTests() {
    const agentSelector = new AgentSelector();
    // Test 1: Simple task
    const simpleTask = {
        description: 'Format this code snippet',
        complexity: TaskComplexity.Simple,
        requiresContext: false,
        requiresTools: false
    };
    const simpleAgent = await agentSelector.selectAgent(simpleTask);
    console.assert(simpleAgent.name === 'SimpleAgent', 'Should select SimpleAgent for simple tasks');
    // Test 2: Moderate task
    const moderateTask = {
        description: 'Explain how this algorithm works',
        complexity: TaskComplexity.Moderate,
        requiresContext: true,
        requiresTools: false
    };
    const moderateAgent = await agentSelector.selectAgent(moderateTask);
    console.assert(moderateAgent.name === 'DevelopmentAgent', 'Should select DevelopmentAgent for moderate tasks');
    // Test 3: Complex task
    const complexTask = {
        description: 'Refactor this code to use the factory pattern',
        complexity: TaskComplexity.Complex,
        requiresContext: true,
        requiresTools: false
    };
    const complexAgent = await agentSelector.selectAgent(complexTask);
    console.assert(complexAgent.name === 'ArchitectAgent', 'Should select ArchitectAgent for complex tasks');
    // Test 4: Task requiring tools
    const taskRequiringTools = {
        description: 'Create a pull request for these changes',
        complexity: TaskComplexity.Moderate,
        requiresContext: true,
        requiresTools: true,
        requiredTools: ['github.createPullRequest']
    };
    const toolAgent = await agentSelector.selectAgent(taskRequiringTools);
    console.assert(toolAgent.capabilities.includes('tools'), 'Selected agent should have tools capability');
    console.assert(toolAgent.name === 'DevOpsAgent', 'Should select DevOpsAgent for tasks requiring GitHub tools');
    // Test 5: Task requiring context
    const taskRequiringContext = {
        description: 'Explain the relationship between these classes',
        complexity: TaskComplexity.Moderate,
        requiresContext: true,
        requiresTools: false,
        contextScope: 'deep'
    };
    const contextAgent = await agentSelector.selectAgent(taskRequiringContext);
    console.assert(contextAgent.capabilities.includes('context'), 'Selected agent should have context capability');
    console.assert(contextAgent.name === 'DevelopmentAgent', 'Should select DevelopmentAgent for tasks requiring deep context');
    // Test 6: Domain-specific tasks
    const mlTask = {
        description: 'Optimize this machine learning model',
        complexity: TaskComplexity.Complex,
        requiresContext: true,
        requiresTools: false,
        domain: 'machine-learning'
    };
    const mlAgent = await agentSelector.selectAgent(mlTask);
    console.assert(mlAgent.name === 'MLAgent', 'Should select MLAgent for machine learning tasks');
    const webTask = {
        description: 'Create a responsive layout for this component',
        complexity: TaskComplexity.Moderate,
        requiresContext: true,
        requiresTools: false,
        domain: 'web-development'
    };
    const webAgent = await agentSelector.selectAgent(webTask);
    console.assert(webAgent.name === 'WebDevAgent', 'Should select WebDevAgent for web development tasks');
    // Test 7: Infer complexity from description
    const implicitComplexTask = {
        description: 'Refactor this monolithic application into a microservices architecture',
        requiresContext: true,
        requiresTools: false
    };
    const inferredComplexityAgent = await agentSelector.selectAgent(implicitComplexTask);
    console.assert(inferredComplexityAgent.name === 'ArchitectAgent', 'Should infer complexity from description and select appropriate agent');
    // Test 8: Handle agent unavailability
    agentSelector.setAgentAvailability('ArchitectAgent', false);
    const unavailableAgentTask = {
        description: 'Design a scalable system architecture',
        complexity: TaskComplexity.Complex,
        requiresContext: true,
        requiresTools: false
    };
    const fallbackAgent = await agentSelector.selectAgent(unavailableAgentTask);
    console.assert(fallbackAgent.name !== 'ArchitectAgent', 'Should not select unavailable agent');
    console.assert(fallbackAgent.name === 'DevelopmentAgent', 'Should select fallback agent when preferred agent is unavailable');
    console.log('All tests completed successfully!');
}
// Run the tests
runTests().catch(error => {
    console.error('Test failed:', error);
});
//# sourceMappingURL=agentSelectorTest.js.map
```


---

### File: `out/test/dynamicAgentSelectorTest.js`

```javascript
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const assert = __importStar(require("assert"));
const dynamicAgentSelector_1 = require("../agents/dynamicAgentSelector");
const types_1 = require("../agents/types");
describe('Dynamic Agent Selection', () => {
    let agentSelector;
    beforeEach(() => {
        agentSelector = new dynamicAgentSelector_1.AgentSelector();
    });
    it('should select appropriate agent based on task complexity', async () => {
        // Test simple task
        const simpleTask = {
            description: 'Format this code snippet',
            complexity: types_1.TaskComplexity.Simple,
            requiresContext: false,
            requiresTools: false
        };
        const simpleAgent = await agentSelector.selectAgent(simpleTask);
        assert.strictEqual(simpleAgent.name, 'SimpleAgent', 'Should select SimpleAgent for simple tasks');
        // Test moderate task
        const moderateTask = {
            description: 'Explain how this algorithm works',
            complexity: types_1.TaskComplexity.Moderate,
            requiresContext: true,
            requiresTools: false
        };
        const moderateAgent = await agentSelector.selectAgent(moderateTask);
        assert.strictEqual(moderateAgent.name, 'DevelopmentAgent', 'Should select DevelopmentAgent for moderate tasks');
        // Test complex task
        const complexTask = {
            description: 'Refactor this code to use the factory pattern',
            complexity: types_1.TaskComplexity.Complex,
            requiresContext: true,
            requiresTools: false
        };
        const complexAgent = await agentSelector.selectAgent(complexTask);
        assert.strictEqual(complexAgent.name, 'ArchitectAgent', 'Should select ArchitectAgent for complex tasks');
    });
    it('should select agent with tool capabilities when tools are required', async () => {
        const taskRequiringTools = {
            description: 'Create a pull request for these changes',
            complexity: types_1.TaskComplexity.Moderate,
            requiresContext: true,
            requiresTools: true,
            requiredTools: ['github.createPullRequest']
        };
        const agent = await agentSelector.selectAgent(taskRequiringTools);
        assert.ok(agent.capabilities.includes('tools'), 'Selected agent should have tools capability');
        assert.strictEqual(agent.name, 'DevOpsAgent', 'Should select DevOpsAgent for tasks requiring GitHub tools');
    });
    it('should select agent with context capabilities when context is required', async () => {
        const taskRequiringContext = {
            description: 'Explain the relationship between these classes',
            complexity: types_1.TaskComplexity.Moderate,
            requiresContext: true,
            requiresTools: false,
            contextScope: 'deep'
        };
        const agent = await agentSelector.selectAgent(taskRequiringContext);
        assert.ok(agent.capabilities.includes('context'), 'Selected agent should have context capability');
        assert.strictEqual(agent.name, 'DevelopmentAgent', 'Should select DevelopmentAgent for tasks requiring deep context');
    });
    it('should select specialized agent for domain-specific tasks', async () => {
        const mlTask = {
            description: 'Optimize this machine learning model',
            complexity: types_1.TaskComplexity.Complex,
            requiresContext: true,
            requiresTools: false,
            domain: 'machine-learning'
        };
        const agent = await agentSelector.selectAgent(mlTask);
        assert.strictEqual(agent.name, 'MLAgent', 'Should select MLAgent for machine learning tasks');
        const webTask = {
            description: 'Create a responsive layout for this component',
            complexity: types_1.TaskComplexity.Moderate,
            requiresContext: true,
            requiresTools: false,
            domain: 'web-development'
        };
        const webAgent = await agentSelector.selectAgent(webTask);
        assert.strictEqual(webAgent.name, 'WebDevAgent', 'Should select WebDevAgent for web development tasks');
    });
    it('should analyze task description to determine complexity when not specified', async () => {
        const implicitComplexTask = {
            description: 'Refactor this monolithic application into a microservices architecture',
            requiresContext: true,
            requiresTools: false
        };
        const agent = await agentSelector.selectAgent(implicitComplexTask);
        assert.strictEqual(agent.name, 'ArchitectAgent', 'Should infer complexity from description and select appropriate agent');
    });
    it('should handle agent unavailability by selecting fallback agent', async () => {
        // Mock unavailable agent
        agentSelector.setAgentAvailability('ArchitectAgent', false);
        const complexTask = {
            description: 'Design a scalable system architecture',
            complexity: types_1.TaskComplexity.Complex,
            requiresContext: true,
            requiresTools: false
        };
        const agent = await agentSelector.selectAgent(complexTask);
        assert.notStrictEqual(agent.name, 'ArchitectAgent', 'Should not select unavailable agent');
        assert.strictEqual(agent.name, 'DevelopmentAgent', 'Should select fallback agent when preferred agent is unavailable');
    });
});
//# sourceMappingURL=dynamicAgentSelectorTest.js.map
```


---

### File: `out/test/runDynamicAgentSelectorTest.js`

```javascript
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const mocha_1 = __importDefault(require("mocha"));
const path = __importStar(require("path"));
async function run() {
    // Create the mocha test
    const mocha = new mocha_1.default({
        ui: 'bdd',
        color: true
    });
    // Add the test file
    mocha.addFile(path.resolve(__dirname, 'dynamicAgentSelectorTest.js'));
    // Run the tests
    return new Promise((resolve, reject) => {
        mocha.run((failures) => {
            if (failures > 0) {
                reject(new Error(`${failures} tests failed.`));
            }
            else {
                resolve();
            }
        });
    });
}
// Run the tests
run().catch(err => {
    console.error('Test run failed:', err);
    process.exit(1);
});
//# sourceMappingURL=runDynamicAgentSelectorTest.js.map
```


---

### File: `out/test/mcpQwenIntegrationTest.js`

```javascript
"use strict";
/**
 * Test for MCP-Qwen integration
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.runMcpQwenIntegrationTest = runMcpQwenIntegrationTest;
exports.registerMcpQwenIntegrationTestCommand = registerMcpQwenIntegrationTestCommand;
const vscode = __importStar(require("vscode"));
const qwenApi_1 = require("../qwenApi");
const mcpClient_1 = require("../mcp/mcpClient");
const mcpQwenBridge_1 = require("../mcp/mcpQwenBridge");
const containerManager_1 = require("../containers/containerManager");
const configuration_1 = require("../configuration");
/**
 * Run the MCP-Qwen integration test
 */
async function runMcpQwenIntegrationTest() {
    // Create output channel
    const outputChannel = vscode.window.createOutputChannel('MCP-Qwen Integration Test');
    outputChannel.show();
    try {
        outputChannel.appendLine('Starting MCP-Qwen integration test...');
        // Get configuration
        const config = (0, configuration_1.getConfiguration)();
        outputChannel.appendLine(`Using API endpoint: ${config.apiEndpoint}`);
        // Create Qwen API client
        const qwenClient = new qwenApi_1.QwenApiClient(config);
        outputChannel.appendLine('Created Qwen API client');
        // Create container manager
        const containerManager = new containerManager_1.ContainerManager();
        outputChannel.appendLine('Created container manager');
        // Create MCP client
        const mcpClient = new mcpClient_1.McpClient(containerManager);
        await mcpClient.initialize();
        outputChannel.appendLine('Initialized MCP client');
        // Create MCP-Qwen bridge
        const mcpQwenBridge = new mcpQwenBridge_1.McpQwenBridge(qwenClient, mcpClient);
        outputChannel.appendLine('Created MCP-Qwen bridge');
        // Get available tools
        const tools = await mcpClient.getAllTools();
        outputChannel.appendLine(`Found ${tools.length} tools:`);
        tools.forEach(tool => {
            outputChannel.appendLine(`- ${tool.serverId}.${tool.tool.name}: ${tool.tool.description}`);
        });
        // Test message processing
        outputChannel.appendLine('\nTesting message processing...');
        const message = 'What files are in the current workspace?';
        // Process message
        const response = await mcpQwenBridge.processMessage(message, {
            systemPrompt: 'You are a helpful assistant that can use tools to answer questions.',
            thinkingMode: 'auto',
            gatherContext: true
        });
        outputChannel.appendLine('\nResponse:');
        outputChannel.appendLine(response);
        // Test streaming message processing
        outputChannel.appendLine('\nTesting streaming message processing...');
        const streamingMessage = 'What is the current git branch?';
        // Process message with streaming
        let streamingResponse = '';
        await mcpQwenBridge.processMessageStream(streamingMessage, {
            systemPrompt: 'You are a helpful assistant that can use tools to answer questions.',
            thinkingMode: 'auto',
            gatherContext: true
        }, (chunk, done) => {
            if (chunk) {
                outputChannel.append(chunk);
                streamingResponse += chunk;
            }
            if (done) {
                outputChannel.appendLine('\n\nStreaming complete');
            }
        });
        outputChannel.appendLine('\nTest completed successfully');
    }
    catch (error) {
        outputChannel.appendLine(`\nError: ${error}`);
    }
}
/**
 * Register the MCP-Qwen integration test command
 */
function registerMcpQwenIntegrationTestCommand(context) {
    const disposable = vscode.commands.registerCommand('qwen-coder-assistant.testMcpQwenIntegration', async () => {
        await runMcpQwenIntegrationTest();
    });
    context.subscriptions.push(disposable);
}
//# sourceMappingURL=mcpQwenIntegrationTest.js.map
```


---

### File: `out/test/runTest.js`

```javascript
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const path = __importStar(require("path"));
const test_electron_1 = require("@vscode/test-electron");
async function main() {
    try {
        // The folder containing the Extension Manifest package.json
        // Passed to `--extensionDevelopmentPath`
        const extensionDevelopmentPath = path.resolve(__dirname, '../../');
        // The path to the extension test script
        // Passed to --extensionTestsPath
        const extensionTestsPath = path.resolve(__dirname, './suite/index');
        // Download VS Code, unzip it and run the integration test
        await (0, test_electron_1.runTests)({ extensionDevelopmentPath, extensionTestsPath });
    }
    catch (err) {
        console.error('Failed to run tests', err);
        process.exit(1);
    }
}
main();
//# sourceMappingURL=runTest.js.map
```


---

### File: `out/test/mcpQwenBridgeTest.js`

```javascript
"use strict";
/**
 * Test file for MCP-Qwen Bridge
 *
 * This file contains a simple test for the MCP-Qwen Bridge.
 * It can be run manually to verify the implementation.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.runMcpQwenBridgeTest = runMcpQwenBridgeTest;
const vscode = __importStar(require("vscode"));
const configuration_1 = require("../configuration");
const containerManager_1 = require("../containers/containerManager");
const mcpClient_1 = require("../mcp/mcpClient");
const mcpQwenBridge_1 = require("../mcp/mcpQwenBridge");
const qwenApi_1 = require("../qwenApi");
/**
 * Run the test
 */
async function runMcpQwenBridgeTest() {
    try {
        // Get configuration
        const config = (0, configuration_1.getConfiguration)();
        // Create Qwen API client
        const qwenClient = new qwenApi_1.QwenApiClient(config);
        // Create container manager
        const containerManager = new containerManager_1.ContainerManager();
        // Create MCP client
        const mcpClient = new mcpClient_1.McpClient(containerManager);
        await mcpClient.initialize();
        // Create MCP-Qwen bridge
        const mcpQwenBridge = new mcpQwenBridge_1.McpQwenBridge(qwenClient, mcpClient);
        // Get available tools
        const tools = await mcpClient.getAllTools();
        console.log(`Found ${tools.length} tools`);
        // Process a test message
        if (tools.length > 0) {
            const response = await mcpQwenBridge.processMessage(`I need to use the following tools: ${tools.map(t => t.tool.name).join(', ')}. Please show me how to use them.`, {
                systemPrompt: 'You are a helpful assistant that can use MCP tools. When using tools, think step by step about what you need to do.',
                thinkingMode: 'auto',
                thinkingBudget: 1000
            });
            // Show the response
            vscode.window.showInformationMessage('Test completed successfully!');
            console.log('Response:', response);
            // Create output channel to show the response
            const outputChannel = vscode.window.createOutputChannel('MCP-Qwen Bridge Test');
            outputChannel.appendLine('Available Tools:');
            tools.forEach(tool => {
                outputChannel.appendLine(`- ${tool.serverId}.${tool.tool.name}: ${tool.tool.description}`);
            });
            outputChannel.appendLine('\nResponse:');
            outputChannel.appendLine(response);
            outputChannel.show();
        }
        else {
            console.log('No tools available for testing');
            vscode.window.showWarningMessage('No MCP tools available for testing. Please start some MCP servers first.');
        }
        // Clean up
        mcpQwenBridge.dispose();
        mcpClient.dispose();
    }
    catch (error) {
        console.error('Error running MCP-Qwen bridge test:', error);
    }
}
// Run the test if this file is executed directly
if (require.main === module) {
    runMcpQwenBridgeTest().then(() => {
        console.log('Test completed');
    });
}
//# sourceMappingURL=mcpQwenBridgeTest.js.map
```


---

### File: `out/test/suite/extension.test.js`

```javascript
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const assert = __importStar(require("assert"));
const vscode = __importStar(require("vscode"));
suite('Extension Test Suite', () => {
    vscode.window.showInformationMessage('Start all tests.');
    test('Extension should be present', () => {
        assert.ok(vscode.extensions.getExtension('qwen-coder-assistant'));
    });
    test('Extension should activate', async () => {
        const extension = vscode.extensions.getExtension('qwen-coder-assistant');
        if (!extension) {
            assert.fail('Extension not found');
            return;
        }
        await extension.activate();
        assert.ok(extension.isActive);
    });
    test('Commands should be registered', async () => {
        const commands = await vscode.commands.getCommands();
        assert.ok(commands.includes('qwen-coder-assistant.askQwen'));
        assert.ok(commands.includes('qwen-coder-assistant.explainCode'));
        assert.ok(commands.includes('qwen-coder-assistant.generateCode'));
    });
});
//# sourceMappingURL=extension.test.js.map
```


---

### File: `out/test/suite/agentSelector.test.js`

```javascript
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const assert = __importStar(require("assert"));
const agentSelector_1 = require("../../agents/agentSelector");
const types_1 = require("../../agents/types");
suite('Agent Selector Test Suite', () => {
    let agentSelector;
    setup(() => {
        agentSelector = new agentSelector_1.AgentSelector();
        // Add test agents to the selector
        agentSelector.registerAgent({
            name: 'SimpleAgent',
            type: types_1.AgentType.Simple,
            capabilities: ['code'],
            modelSize: types_1.ModelSize.Small,
            maxComplexity: types_1.TaskComplexity.Simple,
            systemPrompt: 'You are a simple coding assistant that helps with basic tasks.',
            available: true
        });
        agentSelector.registerAgent({
            name: 'DevelopmentAgent',
            type: types_1.AgentType.Development,
            capabilities: ['code', 'context', 'reasoning'],
            modelSize: types_1.ModelSize.Large,
            maxComplexity: types_1.TaskComplexity.Complex,
            systemPrompt: 'You are a development assistant that helps with coding tasks.',
            available: true
        });
        agentSelector.registerAgent({
            name: 'ArchitectAgent',
            type: types_1.AgentType.Architecture,
            capabilities: ['code', 'context', 'reasoning', 'architecture'],
            modelSize: types_1.ModelSize.XLarge,
            maxComplexity: types_1.TaskComplexity.VeryComplex,
            systemPrompt: 'You are an architecture assistant that helps with system design and architecture.',
            available: true
        });
        agentSelector.registerAgent({
            name: 'DevOpsAgent',
            type: types_1.AgentType.DevOps,
            capabilities: ['code', 'tools', 'context'],
            modelSize: types_1.ModelSize.Large,
            maxComplexity: types_1.TaskComplexity.Complex,
            specializations: ['github', 'docker', 'ci-cd'],
            systemPrompt: 'You are a DevOps assistant that helps with CI/CD, deployment, and infrastructure.',
            available: true
        });
        agentSelector.registerAgent({
            name: 'MLAgent',
            type: types_1.AgentType.ML,
            capabilities: ['code', 'context', 'reasoning'],
            modelSize: types_1.ModelSize.XLarge,
            maxComplexity: types_1.TaskComplexity.VeryComplex,
            specializations: ['machine-learning', 'data-science', 'neural-networks'],
            systemPrompt: 'You are a machine learning assistant that helps with ML models and algorithms.',
            available: true
        });
        agentSelector.registerAgent({
            name: 'WebDevAgent',
            type: types_1.AgentType.WebDev,
            capabilities: ['code', 'context'],
            modelSize: types_1.ModelSize.Medium,
            maxComplexity: types_1.TaskComplexity.Complex,
            specializations: ['web-development', 'frontend', 'backend'],
            systemPrompt: 'You are a web development assistant that helps with frontend and backend tasks.',
            available: true
        });
    });
    test('Should select appropriate agent based on task complexity', async () => {
        // Test simple task
        const simpleTask = {
            description: 'Format this code snippet',
            complexity: types_1.TaskComplexity.Simple,
            requiresContext: false,
            requiresTools: false
        };
        const simpleAgent = await agentSelector.selectAgent(simpleTask);
        assert.strictEqual(simpleAgent.name, 'SimpleAgent', 'Should select SimpleAgent for simple tasks');
        // Test moderate task
        const moderateTask = {
            description: 'Explain how this algorithm works',
            complexity: types_1.TaskComplexity.Moderate,
            requiresContext: true,
            requiresTools: false
        };
        const moderateAgent = await agentSelector.selectAgent(moderateTask);
        assert.strictEqual(moderateAgent.name, 'DevelopmentAgent', 'Should select DevelopmentAgent for moderate tasks');
        // Test complex task
        const complexTask = {
            description: 'Refactor this code to use the factory pattern',
            complexity: types_1.TaskComplexity.Complex,
            requiresContext: true,
            requiresTools: false
        };
        const complexAgent = await agentSelector.selectAgent(complexTask);
        assert.strictEqual(complexAgent.name, 'ArchitectAgent', 'Should select ArchitectAgent for complex tasks');
    });
    test('Should select agent with tool capabilities when tools are required', async () => {
        const taskRequiringTools = {
            description: 'Create a pull request for these changes',
            complexity: types_1.TaskComplexity.Moderate,
            requiresContext: true,
            requiresTools: true,
            requiredTools: ['github.createPullRequest']
        };
        const agent = await agentSelector.selectAgent(taskRequiringTools);
        assert.ok(agent.capabilities.includes('tools'), 'Selected agent should have tools capability');
        assert.strictEqual(agent.name, 'DevOpsAgent', 'Should select DevOpsAgent for tasks requiring GitHub tools');
    });
    test('Should select agent with context capabilities when context is required', async () => {
        const taskRequiringContext = {
            description: 'Explain the relationship between these classes',
            complexity: types_1.TaskComplexity.Moderate,
            requiresContext: true,
            requiresTools: false,
            contextScope: 'deep'
        };
        const agent = await agentSelector.selectAgent(taskRequiringContext);
        assert.ok(agent.capabilities.includes('context'), 'Selected agent should have context capability');
        assert.strictEqual(agent.name, 'DevelopmentAgent', 'Should select DevelopmentAgent for tasks requiring deep context');
    });
    test('Should select specialized agent for domain-specific tasks', async () => {
        const mlTask = {
            description: 'Optimize this machine learning model',
            complexity: types_1.TaskComplexity.Complex,
            requiresContext: true,
            requiresTools: false,
            domain: 'machine-learning'
        };
        const agent = await agentSelector.selectAgent(mlTask);
        assert.strictEqual(agent.name, 'MLAgent', 'Should select MLAgent for machine learning tasks');
        const webTask = {
            description: 'Create a responsive layout for this component',
            complexity: types_1.TaskComplexity.Moderate,
            requiresContext: true,
            requiresTools: false,
            domain: 'web-development'
        };
        const webAgent = await agentSelector.selectAgent(webTask);
        assert.strictEqual(webAgent.name, 'WebDevAgent', 'Should select WebDevAgent for web development tasks');
    });
    test('Should analyze task description to determine complexity when not specified', async () => {
        const implicitComplexTask = {
            description: 'Refactor this monolithic application into a microservices architecture',
            requiresContext: true,
            requiresTools: false
        };
        const agent = await agentSelector.selectAgent(implicitComplexTask);
        assert.strictEqual(agent.name, 'ArchitectAgent', 'Should infer complexity from description and select appropriate agent');
    });
    test('Should handle agent unavailability by selecting fallback agent', async () => {
        // Mock unavailable agent
        agentSelector.setAgentAvailability('ArchitectAgent', false);
        const complexTask = {
            description: 'Design a scalable system architecture',
            complexity: types_1.TaskComplexity.Complex,
            requiresContext: true,
            requiresTools: false
        };
        const agent = await agentSelector.selectAgent(complexTask);
        assert.notStrictEqual(agent.name, 'ArchitectAgent', 'Should not select unavailable agent');
        assert.strictEqual(agent.name, 'DevelopmentAgent', 'Should select fallback agent when preferred agent is unavailable');
    });
});
//# sourceMappingURL=agentSelector.test.js.map
```


---

### File: `out/test/suite/symbolExtractor.test.js`

```javascript
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const assert = __importStar(require("assert"));
const symbolExtractor_1 = require("../../context/symbolExtractor");
suite('Symbol Extractor Test Suite', () => {
    let symbolExtractor;
    setup(() => {
        symbolExtractor = new symbolExtractor_1.SymbolExtractor();
    });
    test('JavaScript Symbol Extraction', async () => {
        const jsCode = `
      import { useState } from 'react';
      import axios from 'axios';
      
      function calculateTotal(items) {
        return items.reduce((total, item) => total + item.price, 0);
      }
      
      class ShoppingCart {
        constructor(items = []) {
          this.items = items;
        }
        
        addItem(item) {
          this.items.push(item);
        }
        
        getTotal() {
          return calculateTotal(this.items);
        }
      }
      
      const cart = new ShoppingCart();
      const fetchItems = async () => {
        const response = await axios.get('/api/items');
        return response.data;
      };
    `;
        const result = await symbolExtractor.extractSymbols(jsCode, 'javascript');
        // Check symbols
        assert.ok(result.symbols.includes('calculateTotal'), 'Should extract function declaration');
        assert.ok(result.symbols.includes('ShoppingCart'), 'Should extract class declaration');
        assert.ok(result.symbols.includes('cart'), 'Should extract variable declaration');
        assert.ok(result.symbols.includes('fetchItems'), 'Should extract arrow function');
        assert.ok(result.symbols.includes('addItem'), 'Should extract method declaration');
        assert.ok(result.symbols.includes('getTotal'), 'Should extract method declaration');
        // Check imports
        assert.ok(result.imports.includes('react'), 'Should extract ES module import');
        assert.ok(result.imports.includes('axios'), 'Should extract default import');
    });
    test('Python Symbol Extraction', async () => {
        const pyCode = `
      import os
      import sys
      from datetime import datetime
      
      CONSTANT_VALUE = 42
      
      def calculate_age(birth_date):
          today = datetime.now()
          age = today.year - birth_date.year
          return age
      
      class Person:
          def __init__(self, name, birth_date):
              self.name = name
              self.birth_date = birth_date
          
          def get_age(self):
              return calculate_age(self.birth_date)
      
      @staticmethod
      def format_date(date):
          return date.strftime("%Y-%m-%d")
    `;
        const result = await symbolExtractor.extractSymbols(pyCode, 'python');
        // Check symbols
        assert.ok(result.symbols.includes('CONSTANT_VALUE'), 'Should extract constant');
        assert.ok(result.symbols.includes('calculate_age'), 'Should extract function declaration');
        assert.ok(result.symbols.includes('Person'), 'Should extract class declaration');
        assert.ok(result.symbols.includes('get_age'), 'Should extract method declaration');
        assert.ok(result.symbols.includes('format_date'), 'Should extract decorated function');
        // Check imports
        assert.ok(result.imports.includes('os'), 'Should extract simple import');
        assert.ok(result.imports.includes('sys'), 'Should extract simple import');
        assert.ok(result.imports.includes('datetime'), 'Should extract from import');
    });
    test('Java Symbol Extraction', async () => {
        const javaCode = `
      package com.example.app;
      
      import java.util.List;
      import java.util.ArrayList;
      
      public class UserManager {
          private List<User> users;
          
          public UserManager() {
              this.users = new ArrayList<>();
          }
          
          public void addUser(User user) {
              users.add(user);
          }
          
          public User findUserById(int id) {
              return users.stream()
                  .filter(user -> user.getId() == id)
                  .findFirst()
                  .orElse(null);
          }
      }
    `;
        const result = await symbolExtractor.extractSymbols(javaCode, 'java');
        // Check symbols
        assert.ok(result.symbols.includes('UserManager'), 'Should extract class declaration');
        assert.ok(result.symbols.includes('users'), 'Should extract field declaration');
        assert.ok(result.symbols.includes('addUser'), 'Should extract method declaration');
        assert.ok(result.symbols.includes('findUserById'), 'Should extract method declaration');
        // Check imports
        assert.ok(result.imports.includes('java.util.List'), 'Should extract import');
        assert.ok(result.imports.includes('java.util.ArrayList'), 'Should extract import');
    });
    test('Language Detection from Path', () => {
        assert.strictEqual(symbolExtractor_1.SymbolExtractor.detectLanguageFromPath('/path/to/file.js'), 'javascript');
        assert.strictEqual(symbolExtractor_1.SymbolExtractor.detectLanguageFromPath('/path/to/file.ts'), 'typescript');
        assert.strictEqual(symbolExtractor_1.SymbolExtractor.detectLanguageFromPath('/path/to/file.py'), 'python');
        assert.strictEqual(symbolExtractor_1.SymbolExtractor.detectLanguageFromPath('/path/to/file.java'), 'java');
        assert.strictEqual(symbolExtractor_1.SymbolExtractor.detectLanguageFromPath('/path/to/file.cpp'), 'cpp');
        assert.strictEqual(symbolExtractor_1.SymbolExtractor.detectLanguageFromPath('/path/to/file.cs'), 'csharp');
        assert.strictEqual(symbolExtractor_1.SymbolExtractor.detectLanguageFromPath('/path/to/file.go'), 'go');
        assert.strictEqual(symbolExtractor_1.SymbolExtractor.detectLanguageFromPath('/path/to/file.rb'), 'ruby');
        assert.strictEqual(symbolExtractor_1.SymbolExtractor.detectLanguageFromPath('/path/to/file.php'), 'php');
        assert.strictEqual(symbolExtractor_1.SymbolExtractor.detectLanguageFromPath('/path/to/file.rs'), 'rust');
        assert.strictEqual(symbolExtractor_1.SymbolExtractor.detectLanguageFromPath('/path/to/file.swift'), 'swift');
        assert.strictEqual(symbolExtractor_1.SymbolExtractor.detectLanguageFromPath('/path/to/file.kt'), 'kotlin');
        assert.strictEqual(symbolExtractor_1.SymbolExtractor.detectLanguageFromPath('/path/to/file.html'), 'html');
        assert.strictEqual(symbolExtractor_1.SymbolExtractor.detectLanguageFromPath('/path/to/file.css'), 'css');
        assert.strictEqual(symbolExtractor_1.SymbolExtractor.detectLanguageFromPath('/path/to/file.json'), 'json');
        assert.strictEqual(symbolExtractor_1.SymbolExtractor.detectLanguageFromPath('/path/to/file.xml'), 'xml');
        assert.strictEqual(symbolExtractor_1.SymbolExtractor.detectLanguageFromPath('/path/to/file.yaml'), 'yaml');
        assert.strictEqual(symbolExtractor_1.SymbolExtractor.detectLanguageFromPath('/path/to/file.md'), 'markdown');
    });
});
//# sourceMappingURL=symbolExtractor.test.js.map
```


---

### File: `out/test/suite/index.js`

```javascript
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.run = run;
const glob_1 = __importDefault(require("glob"));
const mocha_1 = __importDefault(require("mocha"));
const path = __importStar(require("path"));
function run() {
    // Create the mocha test
    const mocha = new mocha_1.default({
        ui: 'tdd',
        color: true
    });
    const testsRoot = path.resolve(__dirname, '..');
    return new Promise((c, e) => {
        (0, glob_1.default)('**/**.test.js', { cwd: testsRoot }, (err, files) => {
            if (err) {
                return e(err);
            }
            // Add files to the test suite
            files.forEach((f) => {
                console.log(`Adding test file: ${f}`);
                mocha.addFile(path.resolve(testsRoot, f));
            });
            try {
                // Run the mocha test
                mocha.run((failures) => {
                    if (failures > 0) {
                        e(new Error(`${failures} tests failed.`));
                    }
                    else {
                        c();
                    }
                });
            }
            catch (err) {
                console.error(err);
                e(err);
            }
        });
    });
}
//# sourceMappingURL=index.js.map
```


---

### File: `out/test/suite/dynamicAgentSelection.test.js`

```javascript
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const assert = __importStar(require("assert"));
const dynamicAgentSelector_1 = require("../../agents/dynamicAgentSelector");
const types_1 = require("../../agents/types");
suite('Dynamic Agent Selection Test Suite', () => {
    let agentSelector;
    setup(() => {
        agentSelector = new dynamicAgentSelector_1.AgentSelector();
    });
    test('Should select appropriate agent based on task complexity', async () => {
        // Test simple task
        const simpleTask = {
            description: 'Format this code snippet',
            complexity: types_1.TaskComplexity.Simple,
            requiresContext: false,
            requiresTools: false
        };
        const simpleAgent = await agentSelector.selectAgent(simpleTask);
        assert.strictEqual(simpleAgent.name, 'SimpleAgent', 'Should select SimpleAgent for simple tasks');
        // Test moderate task
        const moderateTask = {
            description: 'Explain how this algorithm works',
            complexity: types_1.TaskComplexity.Moderate,
            requiresContext: true,
            requiresTools: false
        };
        const moderateAgent = await agentSelector.selectAgent(moderateTask);
        assert.strictEqual(moderateAgent.name, 'DevelopmentAgent', 'Should select DevelopmentAgent for moderate tasks');
        // Test complex task
        const complexTask = {
            description: 'Refactor this code to use the factory pattern',
            complexity: types_1.TaskComplexity.Complex,
            requiresContext: true,
            requiresTools: false
        };
        const complexAgent = await agentSelector.selectAgent(complexTask);
        assert.strictEqual(complexAgent.name, 'ArchitectAgent', 'Should select ArchitectAgent for complex tasks');
    });
    test('Should select agent with tool capabilities when tools are required', async () => {
        const taskRequiringTools = {
            description: 'Create a pull request for these changes',
            complexity: types_1.TaskComplexity.Moderate,
            requiresContext: true,
            requiresTools: true,
            requiredTools: ['github.createPullRequest']
        };
        const agent = await agentSelector.selectAgent(taskRequiringTools);
        assert.ok(agent.capabilities.includes('tools'), 'Selected agent should have tools capability');
        assert.strictEqual(agent.name, 'DevOpsAgent', 'Should select DevOpsAgent for tasks requiring GitHub tools');
    });
    test('Should select agent with context capabilities when context is required', async () => {
        const taskRequiringContext = {
            description: 'Explain the relationship between these classes',
            complexity: types_1.TaskComplexity.Moderate,
            requiresContext: true,
            requiresTools: false,
            contextScope: 'deep'
        };
        const agent = await agentSelector.selectAgent(taskRequiringContext);
        assert.ok(agent.capabilities.includes('context'), 'Selected agent should have context capability');
        assert.strictEqual(agent.name, 'DevelopmentAgent', 'Should select DevelopmentAgent for tasks requiring deep context');
    });
    test('Should select specialized agent for domain-specific tasks', async () => {
        const mlTask = {
            description: 'Optimize this machine learning model',
            complexity: types_1.TaskComplexity.Complex,
            requiresContext: true,
            requiresTools: false,
            domain: 'machine-learning'
        };
        const agent = await agentSelector.selectAgent(mlTask);
        assert.strictEqual(agent.name, 'MLAgent', 'Should select MLAgent for machine learning tasks');
        const webTask = {
            description: 'Create a responsive layout for this component',
            complexity: types_1.TaskComplexity.Moderate,
            requiresContext: true,
            requiresTools: false,
            domain: 'web-development'
        };
        const webAgent = await agentSelector.selectAgent(webTask);
        assert.strictEqual(webAgent.name, 'WebDevAgent', 'Should select WebDevAgent for web development tasks');
    });
    test('Should analyze task description to determine complexity when not specified', async () => {
        const implicitComplexTask = {
            description: 'Refactor this monolithic application into a microservices architecture',
            requiresContext: true,
            requiresTools: false
        };
        const agent = await agentSelector.selectAgent(implicitComplexTask);
        assert.strictEqual(agent.name, 'ArchitectAgent', 'Should infer complexity from description and select appropriate agent');
    });
    test('Should handle agent unavailability by selecting fallback agent', async () => {
        // Mock unavailable agent
        agentSelector.setAgentAvailability('ArchitectAgent', false);
        const complexTask = {
            description: 'Design a scalable system architecture',
            complexity: types_1.TaskComplexity.Complex,
            requiresContext: true,
            requiresTools: false
        };
        const agent = await agentSelector.selectAgent(complexTask);
        assert.notStrictEqual(agent.name, 'ArchitectAgent', 'Should not select unavailable agent');
        assert.strictEqual(agent.name, 'DevelopmentAgent', 'Should select fallback agent when preferred agent is unavailable');
    });
});
//# sourceMappingURL=dynamicAgentSelection.test.js.map
```


---

### File: `out/test/suite/dynamicAgentSelector.test.js`

```javascript
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const assert = __importStar(require("assert"));
const agentSelector_1 = require("../../agents/agentSelector");
const types_1 = require("../../agents/types");
suite('Dynamic Agent Selection Test Suite', () => {
    let agentSelector;
    setup(() => {
        agentSelector = new agentSelector_1.AgentSelector();
        // Add test agents to the selector
        agentSelector.registerAgent({
            name: 'SimpleAgent',
            type: types_1.AgentType.Simple,
            capabilities: ['code'],
            modelSize: types_1.ModelSize.Small,
            maxComplexity: types_1.TaskComplexity.Simple,
            systemPrompt: 'You are a simple coding assistant that helps with basic tasks.',
            available: true
        });
        agentSelector.registerAgent({
            name: 'DevelopmentAgent',
            type: types_1.AgentType.Development,
            capabilities: ['code', 'context', 'reasoning'],
            modelSize: types_1.ModelSize.Large,
            maxComplexity: types_1.TaskComplexity.Complex,
            systemPrompt: 'You are a development assistant that helps with coding tasks.',
            available: true
        });
        agentSelector.registerAgent({
            name: 'ArchitectAgent',
            type: types_1.AgentType.Architecture,
            capabilities: ['code', 'context', 'reasoning', 'architecture'],
            modelSize: types_1.ModelSize.XLarge,
            maxComplexity: types_1.TaskComplexity.VeryComplex,
            systemPrompt: 'You are an architecture assistant that helps with system design and architecture.',
            available: true
        });
        agentSelector.registerAgent({
            name: 'DevOpsAgent',
            type: types_1.AgentType.DevOps,
            capabilities: ['code', 'tools', 'context'],
            modelSize: types_1.ModelSize.Large,
            maxComplexity: types_1.TaskComplexity.Complex,
            specializations: ['github', 'docker', 'ci-cd'],
            systemPrompt: 'You are a DevOps assistant that helps with CI/CD, deployment, and infrastructure.',
            available: true
        });
        agentSelector.registerAgent({
            name: 'MLAgent',
            type: types_1.AgentType.ML,
            capabilities: ['code', 'context', 'reasoning'],
            modelSize: types_1.ModelSize.XLarge,
            maxComplexity: types_1.TaskComplexity.VeryComplex,
            specializations: ['machine-learning', 'data-science', 'neural-networks'],
            systemPrompt: 'You are a machine learning assistant that helps with ML models and algorithms.',
            available: true
        });
        agentSelector.registerAgent({
            name: 'WebDevAgent',
            type: types_1.AgentType.WebDev,
            capabilities: ['code', 'context'],
            modelSize: types_1.ModelSize.Medium,
            maxComplexity: types_1.TaskComplexity.Complex,
            specializations: ['web-development', 'frontend', 'backend'],
            systemPrompt: 'You are a web development assistant that helps with frontend and backend tasks.',
            available: true
        });
    });
    test('Should select appropriate agent based on task complexity', async () => {
        // Test simple task
        const simpleTask = {
            description: 'Format this code snippet',
            complexity: types_1.TaskComplexity.Simple,
            requiresContext: false,
            requiresTools: false
        };
        const simpleAgent = await agentSelector.selectAgent(simpleTask);
        assert.strictEqual(simpleAgent.name, 'SimpleAgent', 'Should select SimpleAgent for simple tasks');
        // Test moderate task
        const moderateTask = {
            description: 'Explain how this algorithm works',
            complexity: types_1.TaskComplexity.Moderate,
            requiresContext: true,
            requiresTools: false
        };
        const moderateAgent = await agentSelector.selectAgent(moderateTask);
        assert.strictEqual(moderateAgent.name, 'DevelopmentAgent', 'Should select DevelopmentAgent for moderate tasks');
        // Test complex task
        const complexTask = {
            description: 'Refactor this code to use the factory pattern',
            complexity: types_1.TaskComplexity.Complex,
            requiresContext: true,
            requiresTools: false
        };
        const complexAgent = await agentSelector.selectAgent(complexTask);
        assert.strictEqual(complexAgent.name, 'ArchitectAgent', 'Should select ArchitectAgent for complex tasks');
    });
    test('Should select agent with tool capabilities when tools are required', async () => {
        const taskRequiringTools = {
            description: 'Create a pull request for these changes',
            complexity: types_1.TaskComplexity.Moderate,
            requiresContext: true,
            requiresTools: true,
            requiredTools: ['github.createPullRequest']
        };
        const agent = await agentSelector.selectAgent(taskRequiringTools);
        assert.ok(agent.capabilities.includes('tools'), 'Selected agent should have tools capability');
        assert.strictEqual(agent.name, 'DevOpsAgent', 'Should select DevOpsAgent for tasks requiring GitHub tools');
    });
    test('Should select agent with context capabilities when context is required', async () => {
        const taskRequiringContext = {
            description: 'Explain the relationship between these classes',
            complexity: types_1.TaskComplexity.Moderate,
            requiresContext: true,
            requiresTools: false,
            contextScope: 'deep'
        };
        const agent = await agentSelector.selectAgent(taskRequiringContext);
        assert.ok(agent.capabilities.includes('context'), 'Selected agent should have context capability');
        assert.strictEqual(agent.name, 'DevelopmentAgent', 'Should select DevelopmentAgent for tasks requiring deep context');
    });
    test('Should select specialized agent for domain-specific tasks', async () => {
        const mlTask = {
            description: 'Optimize this machine learning model',
            complexity: types_1.TaskComplexity.Complex,
            requiresContext: true,
            requiresTools: false,
            domain: 'machine-learning'
        };
        const agent = await agentSelector.selectAgent(mlTask);
        assert.strictEqual(agent.name, 'MLAgent', 'Should select MLAgent for machine learning tasks');
        const webTask = {
            description: 'Create a responsive layout for this component',
            complexity: types_1.TaskComplexity.Moderate,
            requiresContext: true,
            requiresTools: false,
            domain: 'web-development'
        };
        const webAgent = await agentSelector.selectAgent(webTask);
        assert.strictEqual(webAgent.name, 'WebDevAgent', 'Should select WebDevAgent for web development tasks');
    });
    test('Should analyze task description to determine complexity when not specified', async () => {
        const implicitComplexTask = {
            description: 'Refactor this monolithic application into a microservices architecture',
            requiresContext: true,
            requiresTools: false
        };
        const agent = await agentSelector.selectAgent(implicitComplexTask);
        assert.strictEqual(agent.name, 'ArchitectAgent', 'Should infer complexity from description and select appropriate agent');
    });
    test('Should handle agent unavailability by selecting fallback agent', async () => {
        // Mock unavailable agent
        agentSelector.setAgentAvailability('ArchitectAgent', false);
        const complexTask = {
            description: 'Design a scalable system architecture',
            complexity: types_1.TaskComplexity.Complex,
            requiresContext: true,
            requiresTools: false
        };
        const agent = await agentSelector.selectAgent(complexTask);
        assert.notStrictEqual(agent.name, 'ArchitectAgent', 'Should not select unavailable agent');
        assert.strictEqual(agent.name, 'DevelopmentAgent', 'Should select fallback agent when preferred agent is unavailable');
    });
});
//# sourceMappingURL=dynamicAgentSelector.test.js.map
```


---

### File: `out/github-integration/githubRepoManager.js`

```javascript
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.GitHubRepoManager = void 0;
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const simpleGit = __importStar(require("simple-git"));
/**
 * Manager for GitHub repositories
 */
class GitHubRepoManager {
    /**
     * Create a new GitHub repository manager
     * @param options GitHub options
     */
    constructor(options) {
        this.options = options;
    }
    /**
     * Clone a repository
     * @param repoUrl Repository URL
     * @param targetDir Target directory
     * @returns Promise that resolves to the repository information
     */
    async cloneRepository(repoUrl, targetDir) {
        try {
            // Parse the repository URL to get the name
            const repoName = this.getRepoNameFromUrl(repoUrl);
            // Create the target directory if it doesn't exist
            if (!fs.existsSync(targetDir)) {
                fs.mkdirSync(targetDir, { recursive: true });
            }
            // Set the local path
            const localPath = path.join(targetDir, repoName);
            // Check if the repository already exists
            if (fs.existsSync(localPath)) {
                // Pull the latest changes
                const git = simpleGit.simpleGit(localPath);
                await git.pull();
            }
            else {
                // Clone the repository
                const git = simpleGit.simpleGit();
                const cloneOptions = {
                    '--depth': 1
                };
                // Add token if provided
                if (this.options.token) {
                    const tokenUrl = this.addTokenToUrl(repoUrl, this.options.token);
                    await git.clone(tokenUrl, localPath, cloneOptions);
                }
                else {
                    await git.clone(repoUrl, localPath, cloneOptions);
                }
            }
            // Get repository information
            const info = {
                name: repoName,
                localPath,
                hasMcpSchema: false,
                hasDockerfile: false
            };
            // Check for MCP schema file
            const schemaFiles = [
                'mcp-schema.json',
                'schema.json',
                'mcp.json',
                'mcp-schema.yaml',
                'schema.yaml',
                'mcp.yaml'
            ];
            for (const schemaFile of schemaFiles) {
                const schemaPath = path.join(localPath, schemaFile);
                if (fs.existsSync(schemaPath)) {
                    info.hasMcpSchema = true;
                    info.schemaPath = schemaPath;
                    break;
                }
            }
            // Check for Dockerfile
            const dockerfileFiles = [
                'Dockerfile',
                'docker/Dockerfile',
                '.docker/Dockerfile'
            ];
            for (const dockerfileFile of dockerfileFiles) {
                const dockerfilePath = path.join(localPath, dockerfileFile);
                if (fs.existsSync(dockerfilePath)) {
                    info.hasDockerfile = true;
                    info.dockerfilePath = dockerfilePath;
                    break;
                }
            }
            // Try to get description and version from package.json or pyproject.toml
            const packageJsonPath = path.join(localPath, 'package.json');
            const pyprojectTomlPath = path.join(localPath, 'pyproject.toml');
            if (fs.existsSync(packageJsonPath)) {
                const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
                info.description = packageJson.description;
                info.version = packageJson.version;
            }
            else if (fs.existsSync(pyprojectTomlPath)) {
                const pyprojectToml = fs.readFileSync(pyprojectTomlPath, 'utf8');
                // Try to parse the version from pyproject.toml
                const versionMatch = pyprojectToml.match(/version\s*=\s*["']([^"']+)["']/);
                if (versionMatch) {
                    info.version = versionMatch[1];
                }
                // Try to parse the description from pyproject.toml
                const descriptionMatch = pyprojectToml.match(/description\s*=\s*["']([^"']+)["']/);
                if (descriptionMatch) {
                    info.description = descriptionMatch[1];
                }
            }
            return info;
        }
        catch (error) {
            console.error('Error cloning repository:', error);
            throw error;
        }
    }
    /**
     * Get the repository name from a URL
     * @param repoUrl Repository URL
     * @returns Repository name
     */
    getRepoNameFromUrl(repoUrl) {
        // Remove .git extension if present
        const url = repoUrl.endsWith('.git') ? repoUrl.slice(0, -4) : repoUrl;
        // Get the last part of the URL
        const parts = url.split('/');
        return parts[parts.length - 1];
    }
    /**
     * Add a token to a URL
     * @param url URL
     * @param token Token
     * @returns URL with token
     */
    addTokenToUrl(url, token) {
        // Check if the URL is an HTTPS URL
        if (url.startsWith('https://')) {
            // Add the token to the URL
            return url.replace('https://', `https://${token}@`);
        }
        return url;
    }
}
exports.GitHubRepoManager = GitHubRepoManager;
//# sourceMappingURL=githubRepoManager.js.map
```


---

### File: `out/mcp/mcpTypes.js`

```javascript
"use strict";
/**
 * Types for MCP client and server management
 */
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=mcpTypes.js.map
```


---

### File: `out/mcp/mcpClient.js`

```javascript
"use strict";
/**
 * MCP Client
 *
 * Client for interacting with Model-Control-Protocol (MCP) tools.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MCPClient = void 0;
const axios_1 = __importDefault(require("axios"));
const vscode = __importStar(require("vscode"));
/**
 * MCP Client class
 */
class MCPClient {
    /**
     * Constructor
     * @param containerManager The container manager
     */
    constructor(containerManager) {
        this.containerManager = containerManager;
        this.outputChannel = vscode.window.createOutputChannel('MCP Client');
        this.toolSchemas = {};
        this.outputChannel.appendLine('MCP Client initialized');
    }
    /**
     * Initialize the MCP client
     */
    async initialize() {
        try {
            this.outputChannel.appendLine('Initializing MCP client');
            // Get active containers
            const containerStatus = this.containerManager.getContainerStatus();
            // Fetch schemas for running containers
            for (const containerName in containerStatus) {
                const container = containerStatus[containerName];
                if (container.status === 'running') {
                    try {
                        await this.fetchToolSchema(containerName);
                    }
                    catch (error) {
                        this.outputChannel.appendLine(`Error fetching schema for ${containerName}: ${error.message}`);
                    }
                }
            }
            this.outputChannel.appendLine('MCP client initialized');
        }
        catch (error) {
            this.outputChannel.appendLine(`Error initializing MCP client: ${error.message}`);
            throw error;
        }
    }
    /**
     * Fetch the schema for a tool
     * @param toolName The name of the tool
     * @returns The tool schema
     */
    async fetchToolSchema(toolName) {
        try {
            this.outputChannel.appendLine(`Fetching schema for tool: ${toolName}`);
            // Get container URL
            const url = this.containerManager.getContainerUrl(toolName);
            // Fetch schema
            const response = await axios_1.default.get(`${url}/schema`);
            const schema = response.data;
            // Validate schema
            if (!schema.name || !schema.functions || !Array.isArray(schema.functions)) {
                throw new Error(`Invalid schema for tool ${toolName}`);
            }
            // Store schema
            this.toolSchemas[toolName] = schema;
            this.outputChannel.appendLine(`Schema fetched for tool ${toolName}: ${schema.functions.length} functions available`);
            return schema;
        }
        catch (error) {
            this.outputChannel.appendLine(`Error fetching schema for tool ${toolName}: ${error.message}`);
            throw error;
        }
    }
    /**
     * Get the schema for a tool
     * @param toolName The name of the tool
     * @returns The tool schema
     */
    getToolSchema(toolName) {
        return this.toolSchemas[toolName];
    }
    /**
     * Get all available tools
     * @returns The available tools
     */
    getAvailableTools() {
        return Object.keys(this.toolSchemas);
    }
    /**
     * Get all tools with their schemas
     * @returns Array of tools with their schemas and server IDs
     */
    async getAllTools() {
        try {
            this.outputChannel.appendLine('Getting all tools');
            // Get active containers
            const containerStatus = this.containerManager.getContainerStatus();
            const tools = [];
            // Fetch schemas for running containers if not already fetched
            for (const containerId in containerStatus) {
                const container = containerStatus[containerId];
                if (container.status === 'running') {
                    try {
                        // Get or fetch schema
                        let schema = this.toolSchemas[containerId];
                        if (!schema) {
                            schema = await this.fetchToolSchema(containerId);
                        }
                        // Add to tools list
                        tools.push({
                            serverId: containerId,
                            tool: schema
                        });
                    }
                    catch (error) {
                        this.outputChannel.appendLine(`Error getting schema for ${containerId}: ${error.message}`);
                    }
                }
            }
            this.outputChannel.appendLine(`Found ${tools.length} tools`);
            return tools;
        }
        catch (error) {
            this.outputChannel.appendLine(`Error getting all tools: ${error.message}`);
            return [];
        }
    }
    /**
     * Call a function on a tool
     * @param toolName The name of the tool
     * @param functionName The name of the function
     * @param parameters The function parameters
     * @returns The function call result
     */
    async callFunction(toolName, functionName, parameters) {
        try {
            this.outputChannel.appendLine(`Calling function ${functionName} on tool ${toolName}`);
            // Check if tool is available
            if (!this.toolSchemas[toolName]) {
                // Try to fetch schema
                try {
                    await this.fetchToolSchema(toolName);
                }
                catch (error) {
                    throw new Error(`Tool ${toolName} is not available: ${error.message}`);
                }
            }
            // Check if function exists
            const functionSchema = this.toolSchemas[toolName].functions.find(f => f.name === functionName);
            if (!functionSchema) {
                throw new Error(`Function ${functionName} not found in tool ${toolName}`);
            }
            // Validate parameters
            this._validateParameters(parameters, functionSchema);
            // Get container URL
            const url = this.containerManager.getContainerUrl(toolName);
            // Call function
            const response = await axios_1.default.post(`${url}/invoke`, {
                function: functionName,
                parameters
            });
            const result = response.data;
            this.outputChannel.appendLine(`Function ${functionName} called successfully on tool ${toolName}`);
            return result;
        }
        catch (error) {
            this.outputChannel.appendLine(`Error calling function ${functionName} on tool ${toolName}: ${error.message}`);
            return {
                status: 'error',
                error: error.message
            };
        }
    }
    /**
     * Call a function on a tool with server ID
     * @param serverId The ID of the server
     * @param toolName The name of the tool
     * @param functionName The name of the function
     * @param parameters The function parameters
     * @returns The function call result
     */
    async callFunction(serverId, toolName, functionName, parameters) {
        try {
            this.outputChannel.appendLine(`Calling function ${functionName} on tool ${toolName} (server: ${serverId})`);
            // For now, we assume serverId is the same as toolName
            // In the future, we'll need to update this to support multiple servers
            return this.callFunction(toolName, functionName, parameters);
        }
        catch (error) {
            this.outputChannel.appendLine(`Error calling function ${functionName} on tool ${toolName} (server: ${serverId}): ${error.message}`);
            return {
                status: 'error',
                error: error.message
            };
        }
    }
    /**
     * Validate function parameters
     * @param parameters The parameters to validate
     * @param functionSchema The function schema
     */
    _validateParameters(parameters, functionSchema) {
        // Check required parameters
        for (const requiredParam of functionSchema.parameters.required) {
            if (parameters[requiredParam] === undefined) {
                throw new Error(`Missing required parameter: ${requiredParam}`);
            }
        }
        // Check parameter types
        for (const paramName in parameters) {
            const paramSchema = functionSchema.parameters.properties[paramName];
            if (!paramSchema) {
                throw new Error(`Unknown parameter: ${paramName}`);
            }
            // Basic type checking
            const paramValue = parameters[paramName];
            const paramType = paramSchema.type;
            if (paramType === 'string' && typeof paramValue !== 'string') {
                throw new Error(`Parameter ${paramName} should be a string`);
            }
            else if (paramType === 'number' && typeof paramValue !== 'number') {
                throw new Error(`Parameter ${paramName} should be a number`);
            }
            else if (paramType === 'boolean' && typeof paramValue !== 'boolean') {
                throw new Error(`Parameter ${paramName} should be a boolean`);
            }
            else if (paramType === 'array' && !Array.isArray(paramValue)) {
                throw new Error(`Parameter ${paramName} should be an array`);
            }
            else if (paramType === 'object' && (typeof paramValue !== 'object' || paramValue === null || Array.isArray(paramValue))) {
                throw new Error(`Parameter ${paramName} should be an object`);
            }
            // Check enum values
            if (paramSchema.enum && !paramSchema.enum.includes(paramValue)) {
                throw new Error(`Parameter ${paramName} should be one of: ${paramSchema.enum.join(', ')}`);
            }
        }
    }
    /**
     * Find a tool by name
     * @param toolName The name of the tool to find
     * @returns The tool with server ID if found, null otherwise
     */
    async findTool(toolName) {
        try {
            this.outputChannel.appendLine(`Finding tool: ${toolName}`);
            // Get all tools
            const tools = await this.getAllTools();
            // Find tool by name
            const tool = tools.find(t => t.tool.name.toLowerCase() === toolName.toLowerCase());
            if (tool) {
                this.outputChannel.appendLine(`Found tool ${toolName} on server ${tool.serverId}`);
                return tool;
            }
            this.outputChannel.appendLine(`Tool ${toolName} not found`);
            return null;
        }
        catch (error) {
            this.outputChannel.appendLine(`Error finding tool ${toolName}: ${error.message}`);
            return null;
        }
    }
    /**
     * Dispose of resources
     */
    dispose() {
        this.outputChannel.dispose();
    }
}
exports.MCPClient = MCPClient;
//# sourceMappingURL=mcpClient.js.map
```


---

### File: `out/mcp/mcpQwenBridge.js`

```javascript
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.McpQwenBridge = void 0;
const vscode = __importStar(require("vscode"));
const contextGatherer_1 = require("./contextGatherer");
/**
 * Bridge between MCP and Qwen
 * Handles converting MCP tools to Qwen tools and processing tool calls
 */
class McpQwenBridge {
    constructor(qwenClient, mcpClient) {
        this.qwenClient = qwenClient;
        this.mcpClient = mcpClient;
        this.outputChannel = vscode.window.createOutputChannel('MCP-Qwen Bridge');
        this.contextGatherer = new contextGatherer_1.ContextGatherer(mcpClient);
    }
    /**
     * Process a user message with MCP tools
     * @param message User message
     * @param options Options for processing
     * @returns Response from Qwen with tool results if applicable
     */
    async processMessage(message, options = {}) {
        try {
            this.outputChannel.appendLine(`Processing message: ${message.substring(0, 100)}...`);
            // Get available tools from MCP servers
            const mcpTools = await this.mcpClient.getAllTools();
            this.outputChannel.appendLine(`Found ${mcpTools.length} MCP tools`);
            // Convert MCP tools to Qwen tools
            const qwenTools = mcpTools.map(tool => this.convertToolToQwenFormat(tool));
            // Create messages array
            const messages = [];
            // Add system message if provided
            if (options.systemPrompt) {
                messages.push({
                    role: 'system',
                    content: options.systemPrompt
                });
            }
            // Add context messages if provided
            if (options.contextMessages && options.contextMessages.length > 0) {
                messages.push(...options.contextMessages);
            }
            // Gather context if enabled
            if (options.gatherContext !== false) {
                try {
                    const contextMessages = await this.contextGatherer.gatherContext(message);
                    if (contextMessages.length > 0) {
                        this.outputChannel.appendLine(`Adding ${contextMessages.length} context messages`);
                        messages.push(...contextMessages);
                    }
                }
                catch (error) {
                    this.outputChannel.appendLine(`Error gathering context: ${error}`);
                }
            }
            // Add user message
            messages.push({
                role: 'user',
                content: message
            });
            // Call Qwen API with tools
            const response = await this.qwenClient.chatWithTools(messages, {
                thinkingMode: options.thinkingMode || 'auto',
                thinkingBudget: options.thinkingBudget,
                temperature: options.temperature,
                maxTokens: options.maxTokens,
                modelName: options.modelName,
                tools: qwenTools
            });
            // Process tool calls if present
            if (response.tool_calls && response.tool_calls.length > 0) {
                return await this.processToolCallsAndGetFinalResponse(response, messages);
            }
            return response.text;
        }
        catch (error) {
            this.outputChannel.appendLine(`Error processing message: ${error}`);
            return `Error: ${error}`;
        }
    }
    /**
     * Process a user message with MCP tools using streaming
     * @param message User message
     * @param options Options for processing
     * @param onChunk Callback function to handle streaming chunks
     */
    async processMessageStream(message, options = {}, onChunk) {
        try {
            this.outputChannel.appendLine(`Processing message with streaming: ${message.substring(0, 100)}...`);
            // Get available tools from MCP servers
            const mcpTools = await this.mcpClient.getAllTools();
            this.outputChannel.appendLine(`Found ${mcpTools.length} MCP tools`);
            // Convert MCP tools to Qwen tools
            const qwenTools = mcpTools.map(tool => this.convertToolToQwenFormat(tool));
            // Create messages array
            const messages = [];
            // Add system message if provided
            if (options.systemPrompt) {
                messages.push({
                    role: 'system',
                    content: options.systemPrompt
                });
            }
            // Add context messages if provided
            if (options.contextMessages && options.contextMessages.length > 0) {
                messages.push(...options.contextMessages);
            }
            // Gather context if enabled
            if (options.gatherContext !== false) {
                try {
                    const contextMessages = await this.contextGatherer.gatherContext(message);
                    if (contextMessages.length > 0) {
                        this.outputChannel.appendLine(`Adding ${contextMessages.length} context messages`);
                        messages.push(...contextMessages);
                    }
                }
                catch (error) {
                    this.outputChannel.appendLine(`Error gathering context: ${error}`);
                }
            }
            // Add user message
            messages.push({
                role: 'user',
                content: message
            });
            // Accumulate the full response and tool calls
            let fullResponse = '';
            let toolCalls = [];
            // Call Qwen API with tools and streaming
            await this.qwenClient.chatStreamWithTools(messages, {
                thinkingMode: options.thinkingMode || 'auto',
                thinkingBudget: options.thinkingBudget,
                temperature: options.temperature,
                maxTokens: options.maxTokens,
                modelName: options.modelName,
                tools: qwenTools
            }, async (chunk, done, chunkToolCalls) => {
                // Accumulate the response
                fullResponse += chunk;
                // Update tool calls if present
                if (chunkToolCalls && chunkToolCalls.length > 0) {
                    toolCalls = chunkToolCalls;
                }
                // Pass to the original handler
                onChunk(chunk, false, toolCalls);
                // When streaming is complete, process tool calls if present
                if (done && toolCalls.length > 0) {
                    // Add assistant message with tool calls
                    messages.push({
                        role: 'assistant',
                        content: fullResponse,
                        tool_calls: toolCalls
                    });
                    // Process tool calls
                    await this.processToolCallsAndStreamFinalResponse(toolCalls, messages, onChunk);
                }
                else if (done) {
                    // Signal completion if no tool calls
                    onChunk('', true);
                }
            });
        }
        catch (error) {
            this.outputChannel.appendLine(`Error processing message with streaming: ${error}`);
            onChunk(`Error: ${error}`, true);
        }
    }
    /**
     * Process tool calls and get a final response
     * @param initialResponse Initial response with tool calls
     * @param messages Conversation messages
     * @returns Final response after tool execution
     */
    async processToolCallsAndGetFinalResponse(initialResponse, messages) {
        if (!initialResponse.tool_calls || initialResponse.tool_calls.length === 0) {
            return initialResponse.text;
        }
        this.outputChannel.appendLine(`Processing ${initialResponse.tool_calls.length} tool calls`);
        // Add assistant message with tool calls
        messages.push({
            role: 'assistant',
            content: initialResponse.text,
            tool_calls: initialResponse.tool_calls
        });
        // Process each tool call
        const toolResults = await Promise.all(initialResponse.tool_calls.map(async (toolCall) => {
            try {
                const result = await this.executeToolCall(toolCall);
                return {
                    tool_call_id: toolCall.id,
                    role: 'tool',
                    name: toolCall.function.name,
                    content: typeof result === 'string' ? result : JSON.stringify(result)
                };
            }
            catch (error) {
                return {
                    tool_call_id: toolCall.id,
                    role: 'tool',
                    name: toolCall.function.name,
                    content: `Error: ${error}`
                };
            }
        }));
        // Add tool results to messages
        messages.push(...toolResults);
        // Get final response from Qwen
        const finalResponse = await this.qwenClient.chat(messages);
        return finalResponse;
    }
    /**
     * Process tool calls and stream the final response
     * @param toolCalls Tool calls to process
     * @param messages Conversation messages
     * @param onChunk Callback function to handle streaming chunks
     */
    async processToolCallsAndStreamFinalResponse(toolCalls, messages, onChunk) {
        try {
            this.outputChannel.appendLine(`Processing ${toolCalls.length} tool calls for streaming response`);
            // Process each tool call
            const toolResults = await Promise.all(toolCalls.map(async (toolCall) => {
                try {
                    const result = await this.executeToolCall(toolCall);
                    return {
                        tool_call_id: toolCall.id,
                        role: 'tool',
                        name: toolCall.function.name,
                        content: typeof result === 'string' ? result : JSON.stringify(result)
                    };
                }
                catch (error) {
                    return {
                        tool_call_id: toolCall.id,
                        role: 'tool',
                        name: toolCall.function.name,
                        content: `Error: ${error}`
                    };
                }
            }));
            // Add tool results to messages
            messages.push(...toolResults);
            // Stream final response from Qwen
            await this.qwenClient.chatStream(messages, {}, (chunk, done) => {
                onChunk(chunk, done);
            });
        }
        catch (error) {
            this.outputChannel.appendLine(`Error processing tool calls for streaming: ${error}`);
            onChunk(`Error: ${error}`, true);
        }
    }
    /**
     * Execute a tool call
     * @param toolCall Tool call to execute
     * @returns Result of the tool call
     */
    async executeToolCall(toolCall) {
        try {
            this.outputChannel.appendLine(`Executing tool call: ${toolCall.function.name}`);
            // Parse the function name (format: serverId.toolName.functionName)
            const [serverId, toolName, functionName] = toolCall.function.name.split('.');
            if (!serverId || !toolName || !functionName) {
                throw new Error(`Invalid function name format: ${toolCall.function.name}`);
            }
            // Parse arguments
            let args;
            try {
                args = JSON.parse(toolCall.function.arguments);
            }
            catch (error) {
                throw new Error(`Invalid arguments: ${error}`);
            }
            // Call the function
            const result = await this.mcpClient.callFunction(serverId, toolName, functionName, args);
            // Check for errors
            if (result.status === 'error') {
                throw new Error(result.error || 'Unknown error');
            }
            this.outputChannel.appendLine(`Tool call executed successfully`);
            return result.result;
        }
        catch (error) {
            this.outputChannel.appendLine(`Error executing tool call: ${error}`);
            throw error;
        }
    }
    /**
     * Convert MCP tool to Qwen tool format
     * @param mcpTool MCP tool
     * @returns Qwen tool
     */
    convertToolToQwenFormat(mcpTool) {
        try {
            const { serverId, tool } = mcpTool;
            // Create a tool for each function in the MCP tool
            return {
                type: 'function',
                function: {
                    name: `${serverId}.${tool.name}`,
                    description: tool.description || `Tool provided by ${serverId}`,
                    parameters: {
                        type: 'object',
                        properties: this.convertParametersToQwenFormat(tool.parameters || []),
                        required: tool.parameters
                            ?.filter(param => param.required)
                            .map(param => param.name) || []
                    }
                }
            };
        }
        catch (error) {
            this.outputChannel.appendLine(`Error converting MCP tool to Qwen format: ${error}`);
            throw error;
        }
    }
    /**
     * Convert MCP parameters to Qwen format
     * @param parameters MCP parameters
     * @returns Qwen parameters
     */
    convertParametersToQwenFormat(parameters) {
        const result = {};
        for (const param of parameters) {
            result[param.name] = {
                type: this.mapMcpTypeToQwenType(param.type),
                description: param.description || `Parameter ${param.name}`
            };
            // Add enum if available
            if (param.enum && param.enum.length > 0) {
                result[param.name].enum = param.enum;
            }
        }
        return result;
    }
    /**
     * Map MCP type to Qwen type
     * @param mcpType MCP type
     * @returns Qwen type
     */
    mapMcpTypeToQwenType(mcpType) {
        // Convert MCP types to Qwen types
        switch (mcpType.toLowerCase()) {
            case 'string':
            case 'text':
            case 'char':
                return 'string';
            case 'integer':
            case 'int':
            case 'long':
            case 'short':
            case 'byte':
            case 'float':
            case 'double':
            case 'decimal':
            case 'number':
                return 'number';
            case 'boolean':
            case 'bool':
                return 'boolean';
            case 'array':
            case 'list':
            case 'collection':
                return 'array';
            case 'object':
            case 'map':
            case 'dict':
            case 'dictionary':
                return 'object';
            case 'null':
                return 'null';
            default:
                // Default to string for unknown types
                this.outputChannel.appendLine(`Unknown MCP type: ${mcpType}, defaulting to string`);
                return 'string';
        }
    }
    /**
     * Dispose of resources
     */
    dispose() {
        this.outputChannel.dispose();
        this.contextGatherer.dispose();
    }
}
exports.McpQwenBridge = McpQwenBridge;
//# sourceMappingURL=mcpQwenBridge.js.map
```


---

### File: `out/mcp/contextGatherer.js`

```javascript
"use strict";
/**
 * Context Gatherer for MCP Servers
 *
 * Gathers context from MCP servers to provide to Qwen
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContextGatherer = void 0;
const vscode = __importStar(require("vscode"));
/**
 * Context Gatherer class
 */
class ContextGatherer {
    /**
     * Constructor
     * @param mcpClient MCP client
     */
    constructor(mcpClient) {
        this.mcpClient = mcpClient;
        this.outputChannel = vscode.window.createOutputChannel('MCP Context Gatherer');
    }
    /**
     * Gather context from MCP servers
     * @param userMessage User message
     * @returns Context messages
     */
    async gatherContext(userMessage) {
        try {
            this.outputChannel.appendLine(`Gathering context for message: ${userMessage.substring(0, 100)}...`);
            const contextMessages = [];
            // Get available tools
            const tools = await this.mcpClient.getAllTools();
            // Get workspace context if available
            const workspaceContext = await this.getWorkspaceContext();
            if (workspaceContext) {
                contextMessages.push({
                    role: 'system',
                    content: `Workspace context:\n${workspaceContext}`
                });
            }
            // Get git context if available
            const gitContext = await this.getGitContext();
            if (gitContext) {
                contextMessages.push({
                    role: 'system',
                    content: `Git context:\n${gitContext}`
                });
            }
            // Get file context if available
            const fileContext = await this.getFileContext(userMessage);
            if (fileContext) {
                contextMessages.push({
                    role: 'system',
                    content: `File context:\n${fileContext}`
                });
            }
            this.outputChannel.appendLine(`Gathered ${contextMessages.length} context messages`);
            return contextMessages;
        }
        catch (error) {
            this.outputChannel.appendLine(`Error gathering context: ${error}`);
            return [];
        }
    }
    /**
     * Get workspace context
     * @returns Workspace context
     */
    async getWorkspaceContext() {
        try {
            // Check if we have a filesystem tool
            const filesystemTool = await this.mcpClient.findTool('filesystem');
            if (!filesystemTool) {
                return null;
            }
            // Get workspace folders
            const workspaceFolders = vscode.workspace.workspaceFolders;
            if (!workspaceFolders || workspaceFolders.length === 0) {
                return null;
            }
            // Get workspace root
            const workspaceRoot = workspaceFolders[0].uri.fsPath;
            // Get workspace structure
            const result = await this.mcpClient.callFunction(filesystemTool.serverId, 'filesystem', 'listDirectory', { path: workspaceRoot, recursive: false, maxDepth: 2 });
            if (result.status === 'error' || !result.result) {
                return null;
            }
            // Format workspace structure
            const files = result.result.files || [];
            const directories = result.result.directories || [];
            let context = `Workspace root: ${workspaceRoot}\n\n`;
            context += 'Directories:\n';
            context += directories.map((dir) => `- ${dir}`).join('\n');
            context += '\n\nFiles:\n';
            context += files.map((file) => `- ${file}`).join('\n');
            return context;
        }
        catch (error) {
            this.outputChannel.appendLine(`Error getting workspace context: ${error}`);
            return null;
        }
    }
    /**
     * Get git context
     * @returns Git context
     */
    async getGitContext() {
        try {
            // Check if we have a git tool
            const gitTool = await this.mcpClient.findTool('git');
            if (!gitTool) {
                return null;
            }
            // Get current branch
            const branchResult = await this.mcpClient.callFunction(gitTool.serverId, 'git', 'getCurrentBranch', {});
            if (branchResult.status === 'error' || !branchResult.result) {
                return null;
            }
            // Get status
            const statusResult = await this.mcpClient.callFunction(gitTool.serverId, 'git', 'getStatus', {});
            if (statusResult.status === 'error' || !statusResult.result) {
                return null;
            }
            // Format git context
            let context = `Current branch: ${branchResult.result}\n\n`;
            context += 'Git status:\n';
            const status = statusResult.result;
            if (status.modified && status.modified.length > 0) {
                context += 'Modified files:\n';
                context += status.modified.map((file) => `- ${file}`).join('\n');
                context += '\n\n';
            }
            if (status.added && status.added.length > 0) {
                context += 'Added files:\n';
                context += status.added.map((file) => `- ${file}`).join('\n');
                context += '\n\n';
            }
            if (status.deleted && status.deleted.length > 0) {
                context += 'Deleted files:\n';
                context += status.deleted.map((file) => `- ${file}`).join('\n');
                context += '\n\n';
            }
            return context;
        }
        catch (error) {
            this.outputChannel.appendLine(`Error getting git context: ${error}`);
            return null;
        }
    }
    /**
     * Get file context
     * @param userMessage User message
     * @returns File context
     */
    async getFileContext(userMessage) {
        try {
            // Check if we have a filesystem tool
            const filesystemTool = await this.mcpClient.findTool('filesystem');
            if (!filesystemTool) {
                return null;
            }
            // Get active editor
            const editor = vscode.window.activeTextEditor;
            if (!editor) {
                return null;
            }
            // Get file path
            const filePath = editor.document.uri.fsPath;
            // Get file content
            const result = await this.mcpClient.callFunction(filesystemTool.serverId, 'filesystem', 'readFile', { path: filePath });
            if (result.status === 'error' || !result.result) {
                return null;
            }
            // Get file content
            const content = result.result.content || '';
            // Get selection if any
            let selection = '';
            if (!editor.selection.isEmpty) {
                selection = editor.document.getText(editor.selection);
            }
            // Format file context
            let context = `Active file: ${filePath}\n\n`;
            if (selection) {
                context += 'Selected text:\n```\n';
                context += selection;
                context += '\n```\n\n';
            }
            // Only include file content if it's not too large
            if (content.length < 10000) {
                context += 'File content:\n```\n';
                context += content;
                context += '\n```';
            }
            else {
                context += 'File content is too large to include in context.';
            }
            return context;
        }
        catch (error) {
            this.outputChannel.appendLine(`Error getting file context: ${error}`);
            return null;
        }
    }
    /**
     * Dispose of resources
     */
    dispose() {
        this.outputChannel.dispose();
    }
}
exports.ContextGatherer = ContextGatherer;
//# sourceMappingURL=contextGatherer.js.map
```


---

### File: `out/context/fileIndexer.js`

```javascript
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileIndexer = void 0;
const vscode = __importStar(require("vscode"));
const symbolExtractor_1 = require("./symbolExtractor");
class FileIndexer {
    constructor(symbolExtractor, embeddingService, vectorStore) {
        this.symbolExtractor = symbolExtractor;
        this.embeddingService = embeddingService;
        this.vectorStore = vectorStore;
        // Create status bar item
        this.indexingStatus = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 100);
        // Set up file watcher
        this.fileWatcher = vscode.workspace.createFileSystemWatcher('**/*.*');
        this.fileWatcher.onDidChange(this.handleFileChange.bind(this));
        this.fileWatcher.onDidCreate(this.handleFileCreate.bind(this));
        this.fileWatcher.onDidDelete(this.handleFileDelete.bind(this));
    }
    /**
     * Index the entire workspace
     */
    async indexWorkspace() {
        this.indexingStatus.text = '$(sync~spin) Indexing workspace...';
        this.indexingStatus.show();
        try {
            // Expanded file pattern to include more languages
            const files = await vscode.workspace.findFiles('**/*.{js,ts,jsx,tsx,py,java,c,cpp,h,hpp,cs,go,rb,php,rs,swift,kt,html,css,scss,sass,json,yaml,yml,xml,md}', '{**/node_modules/**,**/dist/**,**/build/**,**/.git/**,**/venv/**,**/__pycache__/**}');
            let processedFiles = 0;
            const totalFiles = files.length;
            // Process files in batches to avoid blocking the UI
            const batchSize = 20;
            for (let i = 0; i < totalFiles; i += batchSize) {
                const batch = files.slice(i, i + batchSize);
                // Process batch in parallel
                await Promise.all(batch.map(file => this.indexFile(file)));
                processedFiles += batch.length;
                this.indexingStatus.text = `$(sync~spin) Indexing workspace... ${processedFiles}/${totalFiles}`;
                // Yield to the event loop to keep the UI responsive
                await new Promise(resolve => setTimeout(resolve, 0));
            }
            this.indexingStatus.text = `$(check) Workspace indexed (${totalFiles} files)`;
            setTimeout(() => {
                this.indexingStatus.hide();
            }, 3000);
        }
        catch (error) {
            this.indexingStatus.text = '$(error) Indexing failed';
            console.error('Error indexing workspace:', error);
        }
    }
    /**
     * Index a single file
     * @param uri File URI
     */
    async indexFile(uri) {
        try {
            // Get file path
            const filePath = uri.fsPath;
            // Try to detect language from file extension
            let language = symbolExtractor_1.SymbolExtractor.detectLanguageFromPath(filePath);
            // If we can't detect the language from the path, try to open the document
            if (!language) {
                try {
                    const document = await vscode.workspace.openTextDocument(uri);
                    language = document.languageId;
                }
                catch (e) {
                    // If we can't open the document, use a generic language
                    language = 'text';
                }
            }
            // Read file content
            let content;
            try {
                const document = await vscode.workspace.openTextDocument(uri);
                content = document.getText();
            }
            catch (e) {
                // If we can't open the document, skip this file
                console.warn(`Skipping file ${filePath}: Unable to read content`);
                return;
            }
            // Skip empty files or files that are too large
            if (content.length === 0) {
                console.log(`Skipping empty file: ${filePath}`);
                return;
            }
            if (content.length > 1000000) {
                console.log(`Skipping large file (${content.length} bytes): ${filePath}`);
                return;
            }
            // Skip binary files
            if (this.isBinaryContent(content)) {
                console.log(`Skipping binary file: ${filePath}`);
                return;
            }
            // Split file into chunks
            const chunks = this.chunkFile(content, filePath, language);
            // Process each chunk
            for (const chunk of chunks) {
                try {
                    // Extract symbols
                    const { symbols, imports, dependencies } = await this.symbolExtractor.extractSymbols(chunk.content, language);
                    chunk.symbols = symbols;
                    chunk.imports = imports;
                    // Generate embedding
                    chunk.embedding = await this.embeddingService.generateEmbedding(chunk.content);
                    // Add to vector store
                    await this.vectorStore.addChunk(chunk);
                }
                catch (chunkError) {
                    console.error(`Error processing chunk ${chunk.id}:`, chunkError);
                }
            }
        }
        catch (error) {
            console.error(`Error indexing file ${uri.fsPath}:`, error);
        }
    }
    /**
     * Check if content appears to be binary
     * @param content File content
     * @returns True if the content appears to be binary
     */
    isBinaryContent(content) {
        // Check for null bytes or a high percentage of non-printable characters
        if (content.includes('\0')) {
            return true;
        }
        // Check the first 1000 characters
        const sampleSize = Math.min(1000, content.length);
        const sample = content.substring(0, sampleSize);
        // Count non-printable characters
        let nonPrintableCount = 0;
        for (let i = 0; i < sample.length; i++) {
            const charCode = sample.charCodeAt(i);
            if ((charCode < 32 && charCode !== 9 && charCode !== 10 && charCode !== 13) || charCode > 126) {
                nonPrintableCount++;
            }
        }
        // If more than 10% of characters are non-printable, consider it binary
        return nonPrintableCount > sampleSize * 0.1;
    }
    /**
     * Split a file into chunks based on its content and language
     * @param content File content
     * @param filePath File path
     * @param language Language ID
     * @returns Array of code chunks
     */
    chunkFile(content, filePath, language) {
        const chunks = [];
        const lines = content.split('\n');
        // For very small files, use a single chunk
        if (lines.length <= 50) {
            chunks.push({
                id: `${filePath}:0-${lines.length}`,
                filePath,
                content,
                startLine: 0,
                endLine: lines.length,
                symbols: [],
                imports: [],
                language
            });
            return chunks;
        }
        // For medium-sized files, use a single chunk if it's not code
        if (lines.length <= 200 && this.isDataOrDocFile(language)) {
            chunks.push({
                id: `${filePath}:0-${lines.length}`,
                filePath,
                content,
                startLine: 0,
                endLine: lines.length,
                symbols: [],
                imports: [],
                language
            });
            return chunks;
        }
        // For larger files, use language-specific chunking
        switch (language) {
            case 'javascript':
            case 'typescript':
            case 'javascriptreact':
            case 'typescriptreact':
                return this.chunkJavaScriptFile(content, filePath, language, lines);
            case 'python':
                return this.chunkPythonFile(content, filePath, language, lines);
            case 'java':
            case 'csharp':
            case 'cpp':
            case 'c':
                return this.chunkCStyleFile(content, filePath, language, lines);
            default:
                return this.chunkGenericFile(content, filePath, language, lines);
        }
    }
    /**
     * Check if the file is a data or documentation file
     * @param language Language ID
     * @returns True if the file is a data or documentation file
     */
    isDataOrDocFile(language) {
        return ['json', 'yaml', 'xml', 'markdown', 'html', 'css', 'scss', 'sass'].includes(language);
    }
    /**
     * Chunk a JavaScript/TypeScript file
     */
    chunkJavaScriptFile(content, filePath, language, lines) {
        const chunks = [];
        let chunkStart = 0;
        let braceBalance = 0;
        let inFunction = false;
        let inClass = false;
        // Always include imports in the first chunk
        let importsEndLine = 0;
        for (let i = 0; i < Math.min(50, lines.length); i++) {
            if (lines[i].includes('import ') || lines[i].includes('require(')) {
                importsEndLine = i + 1;
            }
        }
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();
            // Track brace balance
            braceBalance += (line.match(/{/g) || []).length;
            braceBalance -= (line.match(/}/g) || []).length;
            // Detect function or class start
            if (!inFunction && !inClass) {
                if (line.includes('function ') || line.includes('=>') || line.includes('class ')) {
                    inFunction = line.includes('function ') || line.includes('=>');
                    inClass = line.includes('class ');
                }
            }
            // Check if we should end the current chunk
            const isBlockEnd = (braceBalance === 0 && (inFunction || inClass)) ||
                i === lines.length - 1;
            if (isBlockEnd || (i - chunkStart > 200)) {
                // Create a chunk
                const chunkEndLine = i + 1;
                const chunkContent = lines.slice(chunkStart, chunkEndLine).join('\n');
                // For the first chunk, include imports
                if (chunkStart === 0 && importsEndLine > 0 && chunkStart !== importsEndLine) {
                    const importsContent = lines.slice(0, importsEndLine).join('\n');
                    chunks.push({
                        id: `${filePath}:0-${importsEndLine}`,
                        filePath,
                        content: importsContent,
                        startLine: 0,
                        endLine: importsEndLine,
                        symbols: [],
                        imports: [],
                        language
                    });
                    // If the first chunk is just imports, continue to the next chunk
                    if (chunkEndLine <= importsEndLine) {
                        chunkStart = chunkEndLine;
                        inFunction = false;
                        inClass = false;
                        continue;
                    }
                }
                chunks.push({
                    id: `${filePath}:${chunkStart}-${chunkEndLine}`,
                    filePath,
                    content: chunkContent,
                    startLine: chunkStart,
                    endLine: chunkEndLine,
                    symbols: [],
                    imports: [],
                    language
                });
                chunkStart = chunkEndLine;
                inFunction = false;
                inClass = false;
            }
        }
        return chunks;
    }
    /**
     * Chunk a Python file
     */
    chunkPythonFile(content, filePath, language, lines) {
        const chunks = [];
        let chunkStart = 0;
        let indentLevel = 0;
        let inFunction = false;
        let inClass = false;
        // Always include imports in the first chunk
        let importsEndLine = 0;
        for (let i = 0; i < Math.min(50, lines.length); i++) {
            if (lines[i].includes('import ') || lines[i].includes('from ')) {
                importsEndLine = i + 1;
            }
        }
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            const trimmedLine = line.trim();
            // Skip empty lines and comments
            if (trimmedLine === '' || trimmedLine.startsWith('#')) {
                continue;
            }
            // Calculate indent level
            const currentIndent = line.length - line.trimStart().length;
            // Detect function or class start
            if (currentIndent === 0 && !inFunction && !inClass) {
                if (trimmedLine.startsWith('def ') || trimmedLine.startsWith('class ')) {
                    inFunction = trimmedLine.startsWith('def ');
                    inClass = trimmedLine.startsWith('class ');
                    indentLevel = currentIndent;
                }
            }
            // Check if we should end the current chunk
            const isBlockEnd = (currentIndent <= indentLevel && (inFunction || inClass) && i > chunkStart) ||
                i === lines.length - 1;
            if (isBlockEnd || (i - chunkStart > 200)) {
                // Create a chunk
                const chunkEndLine = i;
                const chunkContent = lines.slice(chunkStart, chunkEndLine).join('\n');
                // For the first chunk, include imports
                if (chunkStart === 0 && importsEndLine > 0 && chunkStart !== importsEndLine) {
                    const importsContent = lines.slice(0, importsEndLine).join('\n');
                    chunks.push({
                        id: `${filePath}:0-${importsEndLine}`,
                        filePath,
                        content: importsContent,
                        startLine: 0,
                        endLine: importsEndLine,
                        symbols: [],
                        imports: [],
                        language
                    });
                    // If the first chunk is just imports, continue to the next chunk
                    if (chunkEndLine <= importsEndLine) {
                        chunkStart = chunkEndLine;
                        inFunction = false;
                        inClass = false;
                        indentLevel = 0;
                        continue;
                    }
                }
                chunks.push({
                    id: `${filePath}:${chunkStart}-${chunkEndLine}`,
                    filePath,
                    content: chunkContent,
                    startLine: chunkStart,
                    endLine: chunkEndLine,
                    symbols: [],
                    imports: [],
                    language
                });
                chunkStart = chunkEndLine;
                inFunction = false;
                inClass = false;
                indentLevel = 0;
            }
        }
        // Handle the case where the file ends without a block end
        if (chunkStart < lines.length) {
            const chunkContent = lines.slice(chunkStart).join('\n');
            chunks.push({
                id: `${filePath}:${chunkStart}-${lines.length}`,
                filePath,
                content: chunkContent,
                startLine: chunkStart,
                endLine: lines.length,
                symbols: [],
                imports: [],
                language
            });
        }
        return chunks;
    }
    /**
     * Chunk a C-style file (Java, C#, C, C++)
     */
    chunkCStyleFile(content, filePath, language, lines) {
        const chunks = [];
        let chunkStart = 0;
        let braceBalance = 0;
        let inFunction = false;
        let inClass = false;
        // Always include imports/includes in the first chunk
        let importsEndLine = 0;
        for (let i = 0; i < Math.min(50, lines.length); i++) {
            if (lines[i].includes('import ') || lines[i].includes('#include ') ||
                lines[i].includes('using ') || lines[i].includes('package ')) {
                importsEndLine = i + 1;
            }
        }
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();
            // Track brace balance
            braceBalance += (line.match(/{/g) || []).length;
            braceBalance -= (line.match(/}/g) || []).length;
            // Detect function or class start
            if (!inFunction && !inClass && braceBalance === 0) {
                if ((line.includes('(') && line.includes(')') && !line.includes(';')) ||
                    line.includes('class ') || line.includes('interface ') ||
                    line.includes('struct ') || line.includes('enum ')) {
                    inFunction = line.includes('(') && line.includes(')') && !line.includes(';');
                    inClass = line.includes('class ') || line.includes('interface ') ||
                        line.includes('struct ') || line.includes('enum ');
                }
            }
            // Check if we should end the current chunk
            const isBlockEnd = (braceBalance === 0 && (inFunction || inClass) && i > chunkStart) ||
                i === lines.length - 1;
            if (isBlockEnd || (i - chunkStart > 200)) {
                // Create a chunk
                const chunkEndLine = i + 1;
                const chunkContent = lines.slice(chunkStart, chunkEndLine).join('\n');
                // For the first chunk, include imports
                if (chunkStart === 0 && importsEndLine > 0 && chunkStart !== importsEndLine) {
                    const importsContent = lines.slice(0, importsEndLine).join('\n');
                    chunks.push({
                        id: `${filePath}:0-${importsEndLine}`,
                        filePath,
                        content: importsContent,
                        startLine: 0,
                        endLine: importsEndLine,
                        symbols: [],
                        imports: [],
                        language
                    });
                    // If the first chunk is just imports, continue to the next chunk
                    if (chunkEndLine <= importsEndLine) {
                        chunkStart = chunkEndLine;
                        inFunction = false;
                        inClass = false;
                        braceBalance = 0;
                        continue;
                    }
                }
                chunks.push({
                    id: `${filePath}:${chunkStart}-${chunkEndLine}`,
                    filePath,
                    content: chunkContent,
                    startLine: chunkStart,
                    endLine: chunkEndLine,
                    symbols: [],
                    imports: [],
                    language
                });
                chunkStart = chunkEndLine;
                inFunction = false;
                inClass = false;
                braceBalance = 0;
            }
        }
        return chunks;
    }
    /**
     * Chunk a generic file (fallback for unsupported languages)
     */
    chunkGenericFile(content, filePath, language, lines) {
        const chunks = [];
        const maxChunkSize = 100; // lines
        // For data files, use larger chunks
        const chunkSize = this.isDataOrDocFile(language) ? 200 : maxChunkSize;
        for (let i = 0; i < lines.length; i += chunkSize) {
            const chunkEndLine = Math.min(i + chunkSize, lines.length);
            const chunkContent = lines.slice(i, chunkEndLine).join('\n');
            chunks.push({
                id: `${filePath}:${i}-${chunkEndLine}`,
                filePath,
                content: chunkContent,
                startLine: i,
                endLine: chunkEndLine,
                symbols: [],
                imports: [],
                language
            });
        }
        return chunks;
    }
    async handleFileChange(uri) {
        // Delete existing chunks for this file
        await this.deleteFileChunks(uri.fsPath);
        // Re-index the file
        await this.indexFile(uri);
    }
    async handleFileCreate(uri) {
        await this.indexFile(uri);
    }
    async handleFileDelete(uri) {
        await this.deleteFileChunks(uri.fsPath);
    }
    /**
     * Delete all chunks for a file
     * @param filePath File path
     */
    async deleteFileChunks(filePath) {
        try {
            // Get all chunks from the vector store
            const allChunks = await this.vectorStore.findSimilarChunks('', 10000);
            // Filter chunks for this file
            const fileChunks = allChunks.filter(chunk => chunk.filePath === filePath);
            // Delete each chunk
            for (const chunk of fileChunks) {
                await this.vectorStore.deleteChunk(chunk.id);
            }
            console.log(`Deleted ${fileChunks.length} chunks for file: ${filePath}`);
        }
        catch (error) {
            console.error(`Error deleting chunks for file ${filePath}:`, error);
        }
    }
    dispose() {
        this.fileWatcher.dispose();
        this.indexingStatus.dispose();
    }
}
exports.FileIndexer = FileIndexer;
//# sourceMappingURL=fileIndexer.js.map
```


---

### File: `out/context/types.js`

```javascript
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=types.js.map
```


---

### File: `out/context/contextComposer.js`

```javascript
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContextComposer = void 0;
const path = __importStar(require("path"));
class ContextComposer {
    constructor() {
        this.MAX_TOKENS_PER_CHUNK = 1000;
    }
    async composeContext(query, relevantChunks, tokenLimit = 4000) {
        // Sort chunks by relevance (assuming they're already sorted)
        // Group chunks by file
        const chunksByFile = {};
        for (const chunk of relevantChunks) {
            if (!chunksByFile[chunk.filePath]) {
                chunksByFile[chunk.filePath] = [];
            }
            chunksByFile[chunk.filePath].push(chunk);
        }
        // Sort chunks within each file by line number
        for (const filePath in chunksByFile) {
            chunksByFile[filePath].sort((a, b) => a.startLine - b.startLine);
        }
        // Compose context
        let context = `Query: ${query}\n\n`;
        let tokenCount = this.estimateTokens(context);
        // Add file contexts until we reach the token limit
        for (const filePath in chunksByFile) {
            const fileName = path.basename(filePath);
            const fileContext = `File: ${fileName} (${filePath})\n`;
            tokenCount += this.estimateTokens(fileContext);
            if (tokenCount > tokenLimit) {
                break;
            }
            context += fileContext;
            // Add chunks from this file
            for (const chunk of chunksByFile[filePath]) {
                const chunkHeader = `Lines ${chunk.startLine}-${chunk.endLine}:\n`;
                const chunkContent = chunk.content;
                const chunkTokens = this.estimateTokens(chunkHeader + chunkContent);
                if (tokenCount + chunkTokens > tokenLimit) {
                    // If adding this chunk would exceed the token limit, skip it
                    continue;
                }
                context += chunkHeader + chunkContent + '\n\n';
                tokenCount += chunkTokens;
            }
            context += '\n';
        }
        // Add a summary of symbols found in the context
        const allSymbols = new Set();
        const allImports = new Set();
        for (const chunk of relevantChunks) {
            chunk.symbols.forEach(symbol => allSymbols.add(symbol));
            chunk.imports.forEach(imp => allImports.add(imp));
        }
        const symbolSummary = `Symbols: ${Array.from(allSymbols).join(', ')}\n`;
        const importSummary = `Imports: ${Array.from(allImports).join(', ')}\n`;
        if (tokenCount + this.estimateTokens(symbolSummary + importSummary) <= tokenLimit) {
            context += '\nSummary:\n' + symbolSummary + importSummary;
        }
        return context;
    }
    estimateTokens(text) {
        // A very rough estimate: 1 token  4 characters
        return Math.ceil(text.length / 4);
    }
}
exports.ContextComposer = ContextComposer;
//# sourceMappingURL=contextComposer.js.map
```


---

### File: `out/context/vectorStore.js`

```javascript
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VectorStore = void 0;
class VectorStore {
    constructor(embeddingService) {
        this.chunks = [];
        this.embeddingService = embeddingService;
    }
    async addChunk(chunk) {
        // If the chunk doesn't have an embedding, generate one
        if (!chunk.embedding) {
            chunk.embedding = await this.embeddingService.generateEmbedding(chunk.content);
        }
        // Check if chunk already exists (by ID)
        const existingIndex = this.chunks.findIndex(c => c.id === chunk.id);
        if (existingIndex >= 0) {
            // Replace existing chunk
            this.chunks[existingIndex] = chunk;
        }
        else {
            // Add new chunk
            this.chunks.push(chunk);
        }
    }
    async findSimilarChunks(query, limit = 5) {
        // Generate embedding for the query
        const queryEmbedding = await this.embeddingService.generateEmbedding(query);
        // Find similar chunks
        return this.findSimilarChunksByEmbedding(queryEmbedding, limit);
    }
    async findSimilarChunksByEmbedding(embedding, limit = 5) {
        // Calculate cosine similarity for each chunk
        const chunksWithSimilarity = this.chunks.map(chunk => {
            const similarity = this.cosineSimilarity(embedding, chunk.embedding);
            return { chunk, similarity };
        });
        // Sort by similarity (descending)
        chunksWithSimilarity.sort((a, b) => b.similarity - a.similarity);
        // Return top N chunks
        return chunksWithSimilarity.slice(0, limit).map(item => item.chunk);
    }
    async deleteChunk(id) {
        this.chunks = this.chunks.filter(chunk => chunk.id !== id);
    }
    async clear() {
        this.chunks = [];
    }
    cosineSimilarity(a, b) {
        if (a.length !== b.length) {
            throw new Error('Vectors must have the same length');
        }
        let dotProduct = 0;
        let normA = 0;
        let normB = 0;
        for (let i = 0; i < a.length; i++) {
            dotProduct += a[i] * b[i];
            normA += a[i] * a[i];
            normB += b[i] * b[i];
        }
        return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
    }
}
exports.VectorStore = VectorStore;
//# sourceMappingURL=vectorStore.js.map
```


---

### File: `out/context/semanticSearch.js`

```javascript
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SemanticSearch = void 0;
class SemanticSearch {
    constructor(vectorStore, embeddingService) {
        this.vectorStore = vectorStore;
        this.embeddingService = embeddingService;
    }
    async search(query, limit = 10) {
        // Generate embedding for the query
        const queryEmbedding = await this.embeddingService.generateEmbedding(query);
        // Find similar chunks
        return this.vectorStore.findSimilarChunksByEmbedding(queryEmbedding, limit);
    }
    async searchBySymbol(symbol, limit = 10) {
        // First, try to find exact symbol matches
        const allChunks = await this.vectorStore.findSimilarChunks('', 1000);
        const exactMatches = allChunks.filter(chunk => chunk.symbols.includes(symbol) ||
            chunk.content.includes(`function ${symbol}`) ||
            chunk.content.includes(`class ${symbol}`) ||
            chunk.content.includes(`def ${symbol}`));
        if (exactMatches.length >= limit) {
            return exactMatches.slice(0, limit);
        }
        // If we don't have enough exact matches, supplement with semantic search
        const semanticMatches = await this.search(symbol, limit - exactMatches.length);
        // Combine results, removing duplicates
        const combinedResults = [...exactMatches];
        const existingIds = new Set(combinedResults.map(chunk => chunk.id));
        for (const match of semanticMatches) {
            if (!existingIds.has(match.id)) {
                combinedResults.push(match);
                existingIds.add(match.id);
            }
        }
        return combinedResults;
    }
}
exports.SemanticSearch = SemanticSearch;
//# sourceMappingURL=semanticSearch.js.map
```


---

### File: `out/context/symbolExtractor.js`

```javascript
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SymbolExtractor = void 0;
/**
 * Language-specific symbol extractor for code files.
 * Extracts symbols, imports, and dependencies from code content.
 */
class SymbolExtractor {
    /**
     * Detect language from file extension
     * @param filePath Path to the file
     * @returns Language ID or undefined if not detected
     */
    static detectLanguageFromPath(filePath) {
        const extension = filePath.substring(filePath.lastIndexOf('.')).toLowerCase();
        return SymbolExtractor.extensionToLanguage[extension];
    }
    /**
     * Extract symbols, imports, and dependencies from code content
     * @param content Code content
     * @param language Language ID
     * @returns Object containing symbols, imports, and dependencies
     */
    async extractSymbols(content, language) {
        const symbols = [];
        const imports = [];
        const dependencies = [];
        // Extract based on language
        switch (language) {
            // JavaScript family
            case 'javascript':
            case 'typescript':
            case 'javascriptreact':
            case 'typescriptreact':
                this.extractJavaScriptSymbols(content, symbols, imports, dependencies);
                break;
            // Python
            case 'python':
                this.extractPythonSymbols(content, symbols, imports, dependencies);
                break;
            // Java
            case 'java':
                this.extractJavaSymbols(content, symbols, imports, dependencies);
                break;
            // C/C++
            case 'c':
            case 'cpp':
                this.extractCppSymbols(content, symbols, imports, dependencies);
                break;
            // C#
            case 'csharp':
                this.extractCSharpSymbols(content, symbols, imports, dependencies);
                break;
            // Go
            case 'go':
                this.extractGoSymbols(content, symbols, imports, dependencies);
                break;
            // Ruby
            case 'ruby':
                this.extractRubySymbols(content, symbols, imports, dependencies);
                break;
            // PHP
            case 'php':
                this.extractPhpSymbols(content, symbols, imports, dependencies);
                break;
            // Rust
            case 'rust':
                this.extractRustSymbols(content, symbols, imports, dependencies);
                break;
            // Swift
            case 'swift':
                this.extractSwiftSymbols(content, symbols, imports, dependencies);
                break;
            // Kotlin
            case 'kotlin':
                this.extractKotlinSymbols(content, symbols, imports, dependencies);
                break;
            // HTML/CSS
            case 'html':
            case 'css':
            case 'scss':
            case 'sass':
                this.extractWebSymbols(content, symbols, imports, dependencies, language);
                break;
            // Data formats
            case 'json':
            case 'yaml':
            case 'xml':
                this.extractDataFormatSymbols(content, symbols, imports, dependencies, language);
                break;
            // Default fallback
            default:
                // Use regex-based fallback for unknown languages
                this.extractGenericSymbols(content, symbols, imports, dependencies);
        }
        // Remove duplicates
        return {
            symbols: [...new Set(symbols)],
            imports: [...new Set(imports)],
            dependencies: [...new Set(dependencies)]
        };
    }
    /**
     * Extract symbols from JavaScript/TypeScript code
     */
    extractJavaScriptSymbols(content, symbols, imports, dependencies) {
        // Extract function declarations (both regular and arrow functions)
        const functionRegex = /(?:function\s+([a-zA-Z_$][a-zA-Z0-9_$]*)|(?:const|let|var)\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\s*=\s*(?:async\s*)?\([^)]*\)\s*=>)/g;
        let match;
        while ((match = functionRegex.exec(content)) !== null) {
            if (match[1]) {
                symbols.push(match[1]);
            }
            else if (match[2]) {
                symbols.push(match[2]);
            }
        }
        // Extract class declarations
        const classRegex = /class\s+([a-zA-Z_$][a-zA-Z0-9_$]*)/g;
        while ((match = classRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract method declarations
        const methodRegex = /(?:async\s+)?([a-zA-Z_$][a-zA-Z0-9_$]*)\s*\([^)]*\)\s*{/g;
        while ((match = methodRegex.exec(content)) !== null) {
            // Filter out common keywords that might be matched
            const keywords = ['if', 'for', 'while', 'switch', 'catch'];
            if (!keywords.includes(match[1])) {
                symbols.push(match[1]);
            }
        }
        // Extract variable declarations
        const varRegex = /(?:const|let|var)\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\s*(?:[=;]|$)/g;
        while ((match = varRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract interface and type declarations (TypeScript)
        const typeRegex = /(?:interface|type)\s+([a-zA-Z_$][a-zA-Z0-9_$]*)/g;
        while ((match = typeRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract imports (ES modules)
        const importRegex = /import\s+(?:{([^}]*)}\s+from\s+['"]([^'"]+)['"]|.*?from\s+['"]([^'"]+)['"])/g;
        while ((match = importRegex.exec(content)) !== null) {
            // Extract the module path
            const modulePath = match[2] || match[3];
            if (modulePath) {
                imports.push(modulePath);
                dependencies.push(modulePath);
            }
            // Extract named imports if available
            if (match[1]) {
                const namedImports = match[1].split(',').map(s => s.trim());
                for (const namedImport of namedImports) {
                    // Handle "as" aliases
                    const importName = namedImport.split(' as ')[0].trim();
                    if (importName) {
                        symbols.push(importName);
                    }
                }
            }
        }
        // Extract CommonJS requires
        const requireRegex = /(?:const|let|var)\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\s*=\s*require\s*\(\s*['"]([^'"]+)['"]\s*\)/g;
        while ((match = requireRegex.exec(content)) !== null) {
            symbols.push(match[1]); // The variable name
            imports.push(match[2]); // The module path
            dependencies.push(match[2]);
        }
    }
    /**
     * Extract symbols from Python code
     */
    extractPythonSymbols(content, symbols, imports, dependencies) {
        // Extract function declarations
        const functionRegex = /def\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/g;
        let match;
        while ((match = functionRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract class declarations
        const classRegex = /class\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*(?:\(|:)/g;
        while ((match = classRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract variable assignments (global level)
        const varRegex = /^([A-Z_][A-Z0-9_]*)\s*=/gm;
        while ((match = varRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract imports - from X import Y
        const fromImportRegex = /from\s+([a-zA-Z0-9_.]+)\s+import\s+([^#\n]+)/g;
        while ((match = fromImportRegex.exec(content)) !== null) {
            const module = match[1];
            imports.push(module);
            dependencies.push(module);
            // Extract imported symbols
            const importedSymbols = match[2].split(',').map(s => s.trim());
            for (const importedSymbol of importedSymbols) {
                // Handle "as" aliases
                const symbolName = importedSymbol.split(' as ')[0].trim();
                if (symbolName && symbolName !== '*') {
                    symbols.push(symbolName);
                }
            }
        }
        // Extract imports - import X
        const importRegex = /import\s+([^#\n]+)/g;
        while ((match = importRegex.exec(content)) !== null) {
            const importedModules = match[1].split(',').map(s => s.trim());
            for (const importedModule of importedModules) {
                // Handle "as" aliases
                const moduleName = importedModule.split(' as ')[0].trim();
                if (moduleName) {
                    imports.push(moduleName);
                    dependencies.push(moduleName);
                    // Also add the module name as a symbol (since it can be used directly)
                    const alias = importedModule.includes(' as ')
                        ? importedModule.split(' as ')[1].trim()
                        : moduleName.split('.').pop() || '';
                    if (alias) {
                        symbols.push(alias);
                    }
                }
            }
        }
        // Extract decorated functions and classes
        const decoratorRegex = /@[^\n]+\s+(?:def|class)\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
        while ((match = decoratorRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
    }
    /**
     * Extract symbols from Java code
     */
    extractJavaSymbols(content, symbols, imports, dependencies) {
        // Extract class and interface declarations
        const classRegex = /(?:public|private|protected)?\s*(?:abstract|final)?\s*(?:class|interface|enum)\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
        let match;
        while ((match = classRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract method declarations
        const methodRegex = /(?:public|private|protected)?\s*(?:static|final|abstract)?\s*(?:<[^>]+>\s*)?(?:[a-zA-Z_][a-zA-Z0-9_.<>]*)\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/g;
        while ((match = methodRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract field declarations
        const fieldRegex = /(?:public|private|protected)?\s*(?:static|final)?\s*(?:[a-zA-Z_][a-zA-Z0-9_.<>]*)\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*(?:=|;)/g;
        while ((match = fieldRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract imports
        const importRegex = /import\s+([a-zA-Z0-9_.]+(?:\.[a-zA-Z0-9_*]+)*);/g;
        while ((match = importRegex.exec(content)) !== null) {
            imports.push(match[1]);
            dependencies.push(match[1]);
        }
        // Extract package declaration
        const packageRegex = /package\s+([a-zA-Z0-9_.]+);/g;
        while ((match = packageRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
    }
    /**
     * Extract symbols from C/C++ code
     */
    extractCppSymbols(content, symbols, imports, dependencies) {
        // Extract function declarations
        const functionRegex = /(?:(?:static|inline|extern|const)\s+)*(?:[a-zA-Z_][a-zA-Z0-9_:]*\s+)+([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/g;
        let match;
        while ((match = functionRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract class/struct/enum declarations
        const classRegex = /(?:class|struct|enum|union)\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
        while ((match = classRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract namespace declarations
        const namespaceRegex = /namespace\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
        while ((match = namespaceRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract #include directives
        const includeRegex = /#include\s+[<"]([^>"]+)[>"]/g;
        while ((match = includeRegex.exec(content)) !== null) {
            imports.push(match[1]);
            dependencies.push(match[1]);
        }
        // Extract typedefs
        const typedefRegex = /typedef\s+(?:[a-zA-Z_][a-zA-Z0-9_:]*\s+)+([a-zA-Z_][a-zA-Z0-9_]*)/g;
        while ((match = typedefRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract #define macros
        const defineRegex = /#define\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
        while ((match = defineRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
    }
    /**
     * Extract symbols from C# code
     */
    extractCSharpSymbols(content, symbols, imports, dependencies) {
        // Extract class, interface, struct, enum declarations
        const classRegex = /(?:public|private|protected|internal)?\s*(?:abstract|sealed|static)?\s*(?:class|interface|struct|enum|record)\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
        let match;
        while ((match = classRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract method declarations
        const methodRegex = /(?:public|private|protected|internal)?\s*(?:static|virtual|abstract|override|sealed)?\s*(?:[a-zA-Z_][a-zA-Z0-9_.<>]*)\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/g;
        while ((match = methodRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract property declarations
        const propertyRegex = /(?:public|private|protected|internal)?\s*(?:static|virtual|abstract|override|sealed)?\s*(?:[a-zA-Z_][a-zA-Z0-9_.<>]*)\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*\{/g;
        while ((match = propertyRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract using directives
        const usingRegex = /using\s+([a-zA-Z0-9_.]+);/g;
        while ((match = usingRegex.exec(content)) !== null) {
            imports.push(match[1]);
            dependencies.push(match[1]);
        }
        // Extract namespace declarations
        const namespaceRegex = /namespace\s+([a-zA-Z0-9_.]+)/g;
        while ((match = namespaceRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
    }
    /**
     * Extract symbols from Go code
     */
    extractGoSymbols(content, symbols, imports, dependencies) {
        // Extract function declarations
        const functionRegex = /func\s+(?:\([^)]*\)\s+)?([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/g;
        let match;
        while ((match = functionRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract type declarations
        const typeRegex = /type\s+([a-zA-Z_][a-zA-Z0-9_]*)\s+(?:struct|interface|[a-zA-Z_][a-zA-Z0-9_]*)/g;
        while ((match = typeRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract const declarations
        const constRegex = /const\s+([a-zA-Z_][a-zA-Z0-9_]*)\s+/g;
        while ((match = constRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract var declarations
        const varRegex = /var\s+([a-zA-Z_][a-zA-Z0-9_]*)\s+/g;
        while ((match = varRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract imports
        const importRegex = /import\s+(?:\(\s*((?:[^)]+))\s*\)|["']([^"']+)["'])/g;
        while ((match = importRegex.exec(content)) !== null) {
            if (match[1]) {
                // Multi-line import
                const importLines = match[1].split('\n');
                for (const line of importLines) {
                    const importMatch = line.match(/["']([^"']+)["']/);
                    if (importMatch) {
                        imports.push(importMatch[1]);
                        dependencies.push(importMatch[1]);
                    }
                }
            }
            else if (match[2]) {
                // Single import
                imports.push(match[2]);
                dependencies.push(match[2]);
            }
        }
        // Extract package declaration
        const packageRegex = /package\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
        while ((match = packageRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
    }
    /**
     * Extract symbols from Ruby code
     */
    extractRubySymbols(content, symbols, imports, dependencies) {
        // Extract class declarations
        const classRegex = /class\s+([A-Z][a-zA-Z0-9_]*)/g;
        let match;
        while ((match = classRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract module declarations
        const moduleRegex = /module\s+([A-Z][a-zA-Z0-9_]*)/g;
        while ((match = moduleRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract method declarations
        const methodRegex = /def\s+(?:self\.)?([a-zA-Z_][a-zA-Z0-9_?!]*)/g;
        while ((match = methodRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract constant declarations
        const constRegex = /([A-Z][A-Z0-9_]*)\s*=/g;
        while ((match = constRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract requires
        const requireRegex = /require\s+['"]([^'"]+)['"]/g;
        while ((match = requireRegex.exec(content)) !== null) {
            imports.push(match[1]);
            dependencies.push(match[1]);
        }
        // Extract includes
        const includeRegex = /include\s+([A-Z][a-zA-Z0-9_]*)/g;
        while ((match = includeRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
    }
    /**
     * Extract symbols from PHP code
     */
    extractPhpSymbols(content, symbols, imports, dependencies) {
        // Extract class declarations
        const classRegex = /class\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
        let match;
        while ((match = classRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract interface declarations
        const interfaceRegex = /interface\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
        while ((match = interfaceRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract function declarations
        const functionRegex = /function\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/g;
        while ((match = functionRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract method declarations
        const methodRegex = /(?:public|private|protected)?\s*(?:static)?\s*function\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/g;
        while ((match = methodRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract namespace declarations
        const namespaceRegex = /namespace\s+([a-zA-Z_][a-zA-Z0-9_\\]*)/g;
        while ((match = namespaceRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract use statements (imports)
        const useRegex = /use\s+([a-zA-Z_][a-zA-Z0-9_\\]*)/g;
        while ((match = useRegex.exec(content)) !== null) {
            imports.push(match[1]);
            dependencies.push(match[1]);
        }
        // Extract require/include statements
        const requireRegex = /(?:require|include)(?:_once)?\s*\(\s*['"]([^'"]+)['"]\s*\)/g;
        while ((match = requireRegex.exec(content)) !== null) {
            imports.push(match[1]);
            dependencies.push(match[1]);
        }
    }
    /**
     * Extract symbols from Rust code
     */
    extractRustSymbols(content, symbols, imports, dependencies) {
        // Extract function declarations
        const functionRegex = /fn\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*(?:<[^>]*>)?\s*\(/g;
        let match;
        while ((match = functionRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract struct declarations
        const structRegex = /struct\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
        while ((match = structRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract enum declarations
        const enumRegex = /enum\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
        while ((match = enumRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract trait declarations
        const traitRegex = /trait\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
        while ((match = traitRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract impl blocks
        const implRegex = /impl(?:<[^>]*>)?\s+(?:[^{]*\s+)?([a-zA-Z_][a-zA-Z0-9_]*)/g;
        while ((match = implRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract const declarations
        const constRegex = /const\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*:/g;
        while ((match = constRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract static declarations
        const staticRegex = /static\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*:/g;
        while ((match = staticRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract use statements (imports)
        const useRegex = /use\s+([a-zA-Z0-9_:{}]+);/g;
        while ((match = useRegex.exec(content)) !== null) {
            imports.push(match[1]);
            dependencies.push(match[1]);
        }
        // Extract mod declarations
        const modRegex = /mod\s+([a-zA-Z_][a-zA-Z0-9_]*);/g;
        while ((match = modRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
    }
    /**
     * Extract symbols from Swift code
     */
    extractSwiftSymbols(content, symbols, imports, dependencies) {
        // Extract class declarations
        const classRegex = /class\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
        let match;
        while ((match = classRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract struct declarations
        const structRegex = /struct\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
        while ((match = structRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract enum declarations
        const enumRegex = /enum\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
        while ((match = enumRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract protocol declarations
        const protocolRegex = /protocol\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
        while ((match = protocolRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract function declarations
        const functionRegex = /func\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*(?:<[^>]*>)?\s*\(/g;
        while ((match = functionRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract variable declarations
        const varRegex = /(?:var|let)\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*:/g;
        while ((match = varRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract import statements
        const importRegex = /import\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
        while ((match = importRegex.exec(content)) !== null) {
            imports.push(match[1]);
            dependencies.push(match[1]);
        }
        // Extract extension declarations
        const extensionRegex = /extension\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
        while ((match = extensionRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
    }
    /**
     * Extract symbols from Kotlin code
     */
    extractKotlinSymbols(content, symbols, imports, dependencies) {
        // Extract class declarations
        const classRegex = /class\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
        let match;
        while ((match = classRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract interface declarations
        const interfaceRegex = /interface\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
        while ((match = interfaceRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract function declarations
        const functionRegex = /fun\s+(?:<[^>]*>\s+)?([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/g;
        while ((match = functionRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract property declarations
        const propertyRegex = /(?:val|var)\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*(?::|=)/g;
        while ((match = propertyRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract object declarations
        const objectRegex = /object\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
        while ((match = objectRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract import statements
        const importRegex = /import\s+([a-zA-Z0-9_.]*(?:\.[a-zA-Z0-9_*]+)*)/g;
        while ((match = importRegex.exec(content)) !== null) {
            imports.push(match[1]);
            dependencies.push(match[1]);
        }
        // Extract package declaration
        const packageRegex = /package\s+([a-zA-Z0-9_.]+)/g;
        while ((match = packageRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
    }
    /**
     * Extract symbols from HTML/CSS/SCSS/SASS code
     */
    extractWebSymbols(content, symbols, imports, dependencies, language) {
        if (language === 'html') {
            // Extract IDs
            const idRegex = /id=["']([^"']+)["']/g;
            let match;
            while ((match = idRegex.exec(content)) !== null) {
                symbols.push(match[1]);
            }
            // Extract classes
            const classRegex = /class=["']([^"']+)["']/g;
            while ((match = classRegex.exec(content)) !== null) {
                const classes = match[1].split(/\s+/);
                for (const cls of classes) {
                    if (cls) {
                        symbols.push(cls);
                    }
                }
            }
            // Extract custom elements
            const customElementRegex = /<([a-z]+-[a-z-]+)/g;
            while ((match = customElementRegex.exec(content)) !== null) {
                symbols.push(match[1]);
            }
            // Extract script src and link href
            const linkRegex = /(?:src|href)=["']([^"']+)["']/g;
            while ((match = linkRegex.exec(content)) !== null) {
                imports.push(match[1]);
                dependencies.push(match[1]);
            }
        }
        else {
            // CSS/SCSS/SASS
            // Extract selectors
            const selectorRegex = /([.#][a-zA-Z_-][a-zA-Z0-9_-]*)/g;
            let match;
            while ((match = selectorRegex.exec(content)) !== null) {
                symbols.push(match[1]);
            }
            // Extract custom properties
            const customPropRegex = /(--[a-zA-Z0-9_-]+)\s*:/g;
            while ((match = customPropRegex.exec(content)) !== null) {
                symbols.push(match[1]);
            }
            // Extract @import statements
            const importRegex = /@import\s+["']([^"']+)["']/g;
            while ((match = importRegex.exec(content)) !== null) {
                imports.push(match[1]);
                dependencies.push(match[1]);
            }
            // Extract SCSS/SASS variables
            if (language === 'scss' || language === 'sass') {
                const varRegex = /\$([a-zA-Z_-][a-zA-Z0-9_-]*)\s*:/g;
                while ((match = varRegex.exec(content)) !== null) {
                    symbols.push('$' + match[1]);
                }
                // Extract mixins
                const mixinRegex = /@mixin\s+([a-zA-Z_-][a-zA-Z0-9_-]*)/g;
                while ((match = mixinRegex.exec(content)) !== null) {
                    symbols.push(match[1]);
                }
            }
        }
    }
    /**
     * Extract symbols from data formats (JSON, YAML, XML)
     */
    extractDataFormatSymbols(content, symbols, imports, dependencies, language) {
        if (language === 'json') {
            // Extract property names from JSON
            const propRegex = /"([a-zA-Z_][a-zA-Z0-9_]*)"\s*:/g;
            let match;
            while ((match = propRegex.exec(content)) !== null) {
                symbols.push(match[1]);
            }
        }
        else if (language === 'yaml') {
            // Extract keys from YAML
            const keyRegex = /^([a-zA-Z_][a-zA-Z0-9_]*)\s*:/gm;
            let match;
            while ((match = keyRegex.exec(content)) !== null) {
                symbols.push(match[1]);
            }
        }
        else if (language === 'xml') {
            // Extract tag names from XML
            const tagRegex = /<([a-zA-Z_][a-zA-Z0-9_:-]*)(?:\s|>|\/)/g;
            let match;
            while ((match = tagRegex.exec(content)) !== null) {
                symbols.push(match[1]);
            }
            // Extract attribute names
            const attrRegex = /\s([a-zA-Z_][a-zA-Z0-9_:-]*)=/g;
            while ((match = attrRegex.exec(content)) !== null) {
                symbols.push(match[1]);
            }
        }
    }
    /**
     * Generic symbol extraction for unsupported languages
     */
    extractGenericSymbols(content, symbols, imports, dependencies) {
        // Generic symbol extraction using regex
        // This is a fallback for languages we don't have specific parsers for
        // Extract words that look like symbols (camelCase, PascalCase, snake_case)
        const symbolRegex = /\b([a-zA-Z_][a-zA-Z0-9_]*)\b/g;
        let match;
        while ((match = symbolRegex.exec(content)) !== null) {
            // Filter out common keywords across languages
            const keywords = [
                // Common programming keywords
                'if', 'else', 'for', 'while', 'do', 'switch', 'case', 'break', 'continue',
                'return', 'function', 'class', 'struct', 'enum', 'interface', 'namespace',
                'public', 'private', 'protected', 'static', 'final', 'const', 'var', 'let',
                'void', 'int', 'float', 'double', 'string', 'bool', 'true', 'false', 'null',
                'this', 'super', 'new', 'delete', 'try', 'catch', 'finally', 'throw'
            ];
            if (!keywords.includes(match[1])) {
                // Prioritize symbols that look like identifiers
                // - PascalCase (class/type names)
                // - camelCase (method/variable names)
                // - snake_case (variable names in some languages)
                // - UPPER_CASE (constants)
                if (/^[A-Z][a-z0-9]+[A-Z]/.test(match[1]) || // PascalCase
                    /^[a-z]+[A-Z]/.test(match[1]) || // camelCase
                    match[1].includes('_') || // snake_case or UPPER_CASE
                    /^[A-Z][A-Z0-9_]+$/.test(match[1]) // UPPER_CASE constants
                ) {
                    symbols.push(match[1]);
                }
            }
        }
        // Try to extract imports based on common patterns across languages
        const importRegex = /(?:import|include|require|using|from|#include)\s+['"]?([a-zA-Z0-9_./\\<>]+)['"]?/g;
        while ((match = importRegex.exec(content)) !== null) {
            imports.push(match[1]);
            dependencies.push(match[1]);
        }
    }
}
exports.SymbolExtractor = SymbolExtractor;
// Map of file extensions to language IDs
SymbolExtractor.extensionToLanguage = {
    // JavaScript/TypeScript
    '.js': 'javascript',
    '.jsx': 'javascriptreact',
    '.ts': 'typescript',
    '.tsx': 'typescriptreact',
    // Python
    '.py': 'python',
    '.pyw': 'python',
    '.ipynb': 'python',
    // Java
    '.java': 'java',
    // C/C++
    '.c': 'c',
    '.cpp': 'cpp',
    '.cc': 'cpp',
    '.h': 'c',
    '.hpp': 'cpp',
    // C#
    '.cs': 'csharp',
    // Go
    '.go': 'go',
    // Ruby
    '.rb': 'ruby',
    // PHP
    '.php': 'php',
    // Rust
    '.rs': 'rust',
    // Swift
    '.swift': 'swift',
    // Kotlin
    '.kt': 'kotlin',
    // HTML/CSS
    '.html': 'html',
    '.css': 'css',
    '.scss': 'scss',
    '.sass': 'sass',
    // Other
    '.json': 'json',
    '.xml': 'xml',
    '.yaml': 'yaml',
    '.yml': 'yaml',
    '.md': 'markdown'
};
//# sourceMappingURL=symbolExtractor.js.map
```


---

### File: `out/context/dependencyGraph.js`

```javascript
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DependencyGraph = void 0;
class DependencyGraph {
    constructor() {
        this.nodes = new Map();
    }
    addChunk(chunk) {
        const nodeId = chunk.filePath;
        if (!this.nodes.has(nodeId)) {
            this.nodes.set(nodeId, {
                id: nodeId,
                filePath: chunk.filePath,
                symbols: [...chunk.symbols],
                imports: [...chunk.imports],
                dependencies: [],
                dependents: []
            });
        }
        else {
            // Update existing node
            const node = this.nodes.get(nodeId);
            chunk.symbols.forEach(symbol => {
                if (!node.symbols.includes(symbol)) {
                    node.symbols.push(symbol);
                }
            });
            chunk.imports.forEach(imp => {
                if (!node.imports.includes(imp)) {
                    node.imports.push(imp);
                }
            });
        }
    }
    buildGraph() {
        // Clear existing dependencies
        for (const node of this.nodes.values()) {
            node.dependencies = [];
            node.dependents = [];
        }
        // Build dependencies based on imports and symbols
        for (const [id, node] of this.nodes.entries()) {
            for (const [otherId, otherNode] of this.nodes.entries()) {
                if (id === otherId) {
                    continue;
                }
                // Check if this node imports symbols from the other node
                for (const imp of node.imports) {
                    if (otherNode.symbols.some(symbol => imp.includes(symbol))) {
                        if (!node.dependencies.includes(otherId)) {
                            node.dependencies.push(otherId);
                        }
                        if (!otherNode.dependents.includes(id)) {
                            otherNode.dependents.push(id);
                        }
                    }
                }
            }
        }
    }
    getRelatedFiles(filePath, depth = 1) {
        const node = this.nodes.get(filePath);
        if (!node) {
            return [];
        }
        const visited = new Set();
        const result = [];
        // Add direct dependencies
        this.traverseGraph(node, visited, result, depth, true);
        // Add direct dependents
        this.traverseGraph(node, visited, result, depth, false);
        return result;
    }
    traverseGraph(node, visited, result, depth, isDependency) {
        if (depth <= 0 || visited.has(node.id)) {
            return;
        }
        visited.add(node.id);
        if (node.id !== result[0]) { // Don't add the starting node
            result.push(node.id);
        }
        const nextNodes = isDependency ? node.dependencies : node.dependents;
        for (const nextId of nextNodes) {
            const nextNode = this.nodes.get(nextId);
            if (nextNode) {
                this.traverseGraph(nextNode, visited, result, depth - 1, isDependency);
            }
        }
    }
}
exports.DependencyGraph = DependencyGraph;
//# sourceMappingURL=dependencyGraph.js.map
```


---

### File: `out/context/persistentVectorStore.js`

```javascript
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.PersistentVectorStore = void 0;
const path = __importStar(require("path"));
const fs = __importStar(require("fs"));
const vscode = __importStar(require("vscode"));
const sqlite3 = __importStar(require("sqlite3"));
const sqlite_1 = require("sqlite");
const vectorStore_1 = require("./vectorStore");
/**
 * A vector store that persists embeddings to disk using SQLite
 */
class PersistentVectorStore extends vectorStore_1.VectorStore {
    /**
     * Create a new persistent vector store
     * @param embeddingService The embedding service to use
     * @param dbPath Path to the SQLite database file (optional, defaults to extension storage path)
     * @param autoSaveIntervalMs Interval in milliseconds to auto-save changes (optional, defaults to 60000)
     */
    constructor(embeddingService, dbPath, autoSaveIntervalMs = 60000) {
        super(embeddingService);
        this.db = null;
        this.autoSaveInterval = null;
        this.isDirty = false;
        this.isInitialized = false;
        // If no dbPath is provided, use the extension's storage path
        if (!dbPath) {
            const storagePath = this.getStoragePath();
            if (!storagePath) {
                throw new Error('Could not determine storage path for persistent vector store');
            }
            // Ensure the directory exists
            if (!fs.existsSync(storagePath)) {
                fs.mkdirSync(storagePath, { recursive: true });
            }
            this.dbPath = path.join(storagePath, 'vector-store.db');
        }
        else {
            this.dbPath = dbPath;
        }
        // Set up auto-save if interval is positive
        if (autoSaveIntervalMs > 0) {
            this.autoSaveInterval = setInterval(() => {
                if (this.isDirty) {
                    this.saveToDatabase().catch(error => {
                        console.error('Error auto-saving vector store:', error);
                    });
                }
            }, autoSaveIntervalMs);
        }
    }
    /**
     * Initialize the database
     */
    async initialize() {
        if (this.isInitialized) {
            return;
        }
        try {
            // Open the database
            this.db = await (0, sqlite_1.open)({
                filename: this.dbPath,
                driver: sqlite3.Database
            });
            // Create tables if they don't exist
            await this.db.exec(`
        CREATE TABLE IF NOT EXISTS chunks (
          id TEXT PRIMARY KEY,
          filePath TEXT NOT NULL,
          content TEXT NOT NULL,
          startLine INTEGER NOT NULL,
          endLine INTEGER NOT NULL,
          language TEXT NOT NULL,
          symbols TEXT,
          imports TEXT
        );
        
        CREATE TABLE IF NOT EXISTS embeddings (
          chunk_id TEXT PRIMARY KEY,
          embedding BLOB NOT NULL,
          FOREIGN KEY (chunk_id) REFERENCES chunks (id) ON DELETE CASCADE
        );
        
        CREATE INDEX IF NOT EXISTS idx_chunks_filePath ON chunks (filePath);
      `);
            // Load existing chunks from the database
            await this.loadFromDatabase();
            this.isInitialized = true;
        }
        catch (error) {
            console.error('Error initializing persistent vector store:', error);
            throw error;
        }
    }
    /**
     * Add a chunk to the vector store
     * @param chunk The chunk to add
     */
    async addChunk(chunk) {
        // Call the parent method to add the chunk to memory
        await super.addChunk(chunk);
        // Mark as dirty to trigger auto-save
        this.isDirty = true;
    }
    /**
     * Delete a chunk from the vector store
     * @param id The ID of the chunk to delete
     */
    async deleteChunk(id) {
        // Call the parent method to delete the chunk from memory
        await super.deleteChunk(id);
        // Delete from database if initialized
        if (this.db) {
            try {
                await this.db.run('DELETE FROM chunks WHERE id = ?', id);
                await this.db.run('DELETE FROM embeddings WHERE chunk_id = ?', id);
            }
            catch (error) {
                console.error(`Error deleting chunk ${id} from database:`, error);
            }
        }
        // Mark as dirty to trigger auto-save
        this.isDirty = true;
    }
    /**
     * Clear the vector store
     */
    async clear() {
        // Call the parent method to clear the in-memory store
        await super.clear();
        // Clear the database if initialized
        if (this.db) {
            try {
                await this.db.exec('DELETE FROM embeddings');
                await this.db.exec('DELETE FROM chunks');
            }
            catch (error) {
                console.error('Error clearing database:', error);
            }
        }
        // Mark as dirty to trigger auto-save
        this.isDirty = true;
    }
    /**
     * Save all chunks to the database
     */
    async saveToDatabase() {
        if (!this.db) {
            await this.initialize();
        }
        if (!this.db) {
            throw new Error('Database not initialized');
        }
        try {
            // Start a transaction
            await this.db.exec('BEGIN TRANSACTION');
            // Get all chunks
            const chunks = await this.getAllChunks();
            // Insert or update each chunk
            for (const chunk of chunks) {
                // Insert or replace the chunk
                await this.db.run(`INSERT OR REPLACE INTO chunks (id, filePath, content, startLine, endLine, language, symbols, imports)
           VALUES (?, ?, ?, ?, ?, ?, ?, ?)`, chunk.id, chunk.filePath, chunk.content, chunk.startLine, chunk.endLine, chunk.language, JSON.stringify(chunk.symbols), JSON.stringify(chunk.imports));
                // Insert or replace the embedding if it exists
                if (chunk.embedding) {
                    await this.db.run(`INSERT OR REPLACE INTO embeddings (chunk_id, embedding)
             VALUES (?, ?)`, chunk.id, Buffer.from(new Float32Array(chunk.embedding).buffer));
                }
            }
            // Commit the transaction
            await this.db.exec('COMMIT');
            // Reset dirty flag
            this.isDirty = false;
            console.log(`Saved ${chunks.length} chunks to database`);
        }
        catch (error) {
            // Rollback the transaction on error
            if (this.db) {
                await this.db.exec('ROLLBACK');
            }
            console.error('Error saving to database:', error);
            throw error;
        }
    }
    /**
     * Load chunks from the database
     */
    async loadFromDatabase() {
        if (!this.db) {
            throw new Error('Database not initialized');
        }
        try {
            // Get all chunks from the database
            const rows = await this.db.all(`
        SELECT c.id, c.filePath, c.content, c.startLine, c.endLine, c.language, c.symbols, c.imports, e.embedding
        FROM chunks c
        LEFT JOIN embeddings e ON c.id = e.chunk_id
      `);
            // Clear existing chunks
            await super.clear();
            // Add each chunk to the in-memory store
            for (const row of rows) {
                const chunk = {
                    id: row.id,
                    filePath: row.filePath,
                    content: row.content,
                    startLine: row.startLine,
                    endLine: row.endLine,
                    language: row.language,
                    symbols: row.symbols ? JSON.parse(row.symbols) : [],
                    imports: row.imports ? JSON.parse(row.imports) : []
                };
                // Add embedding if it exists
                if (row.embedding) {
                    const buffer = Buffer.from(row.embedding);
                    const float32Array = new Float32Array(buffer.buffer, buffer.byteOffset, buffer.byteLength / 4);
                    chunk.embedding = Array.from(float32Array);
                }
                // Add to in-memory store without saving to database
                await super.addChunk(chunk);
            }
            console.log(`Loaded ${rows.length} chunks from database`);
        }
        catch (error) {
            console.error('Error loading from database:', error);
            throw error;
        }
    }
    /**
     * Get the storage path for the extension
     */
    getStoragePath() {
        // Get the extension context
        const extension = vscode.extensions.getExtension('qwen-coder-assistant');
        if (extension) {
            return extension.extensionPath;
        }
        // Fallback to the workspace storage path
        if (vscode.workspace.workspaceFolders && vscode.workspace.workspaceFolders.length > 0) {
            return path.join(vscode.workspace.workspaceFolders[0].uri.fsPath, '.vscode');
        }
        return undefined;
    }
    /**
     * Dispose of resources
     */
    async dispose() {
        // Clear auto-save interval
        if (this.autoSaveInterval) {
            clearInterval(this.autoSaveInterval);
            this.autoSaveInterval = null;
        }
        // Save any pending changes
        if (this.isDirty && this.db) {
            try {
                await this.saveToDatabase();
            }
            catch (error) {
                console.error('Error saving vector store during disposal:', error);
            }
        }
        // Close the database
        if (this.db) {
            await this.db.close();
            this.db = null;
        }
    }
}
exports.PersistentVectorStore = PersistentVectorStore;
//# sourceMappingURL=persistentVectorStore.js.map
```


---

### File: `out/context/embeddingService.js`

```javascript
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddingService = void 0;
const axios_1 = __importDefault(require("axios"));
const configuration_1 = require("../configuration");
class EmbeddingService {
    constructor() {
        const config = (0, configuration_1.getConfiguration)();
        this.apiEndpoint = config.apiEndpoint;
        this.apiKey = config.apiKey;
    }
    async generateEmbedding(text) {
        try {
            const response = await axios_1.default.post(`${this.apiEndpoint}/embeddings`, {
                input: text,
                model: 'qwen3-embedding'
            }, {
                headers: {
                    'Authorization': `Bearer ${this.apiKey}`,
                    'Content-Type': 'application/json'
                }
            });
            return response.data.data[0].embedding;
        }
        catch (error) {
            console.error('Error generating embedding:', error);
            throw new Error('Failed to generate embedding');
        }
    }
    async generateBatchEmbeddings(texts) {
        try {
            const response = await axios_1.default.post(`${this.apiEndpoint}/embeddings`, {
                input: texts,
                model: 'qwen3-embedding'
            }, {
                headers: {
                    'Authorization': `Bearer ${this.apiKey}`,
                    'Content-Type': 'application/json'
                }
            });
            return response.data.data.map((item) => item.embedding);
        }
        catch (error) {
            console.error('Error generating batch embeddings:', error);
            throw new Error('Failed to generate batch embeddings');
        }
    }
}
exports.EmbeddingService = EmbeddingService;
//# sourceMappingURL=embeddingService.js.map
```


---

### File: `out/context/contextEngine.js`

```javascript
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContextEngine = void 0;
const vscode = __importStar(require("vscode"));
const contextComposer_1 = require("./contextComposer");
const dependencyGraph_1 = require("./dependencyGraph");
const embeddingService_1 = require("./embeddingService");
const fileIndexer_1 = require("./fileIndexer");
const semanticSearch_1 = require("./semanticSearch");
const symbolExtractor_1 = require("./symbolExtractor");
const vectorStore_1 = require("./vectorStore");
class ContextEngine {
    constructor() {
        this.isInitialized = false;
        this.embeddingService = new embeddingService_1.EmbeddingService();
        this.symbolExtractor = new symbolExtractor_1.SymbolExtractor();
        // Get configuration for context engine
        const config = getConfiguration().contextEngine;
        // Use persistent vector store if enabled in configuration
        if (config.persistEmbeddings) {
            console.log('Using persistent vector store for embeddings');
            this.vectorStore = new PersistentVectorStore(this.embeddingService, config.databasePath || undefined, config.autoSaveIntervalMs);
        }
        else {
            console.log('Using in-memory vector store for embeddings');
            this.vectorStore = new vectorStore_1.VectorStore(this.embeddingService);
        }
        this.contextComposer = new contextComposer_1.ContextComposer();
        this.dependencyGraph = new dependencyGraph_1.DependencyGraph();
        this.semanticSearch = new semanticSearch_1.SemanticSearch(this.vectorStore, this.embeddingService);
        this.fileIndexer = new fileIndexer_1.FileIndexer(this.symbolExtractor, this.embeddingService, this.vectorStore);
    }
    async initialize() {
        if (this.isInitialized) {
            return;
        }
        // Initialize the persistent vector store if needed
        if (this.vectorStore instanceof PersistentVectorStore) {
            console.log('Initializing persistent vector store');
            await this.vectorStore.initialize();
        }
        // Only index the workspace if the vector store is empty
        const existingChunks = await this.vectorStore.findSimilarChunks('', 10);
        if (existingChunks.length === 0) {
            console.log('Vector store is empty, indexing workspace');
            await this.fileIndexer.indexWorkspace();
        }
        else {
            console.log(`Found ${existingChunks.length} existing chunks in vector store, skipping indexing`);
        }
        // Build dependency graph
        const allChunks = await this.vectorStore.findSimilarChunks('', 10000);
        for (const chunk of allChunks) {
            this.dependencyGraph.addChunk(chunk);
        }
        this.dependencyGraph.buildGraph();
        this.isInitialized = true;
    }
    async getContext(query, tokenLimit = 4000) {
        if (!this.isInitialized) {
            await this.initialize();
        }
        // Find relevant chunks using semantic search
        const relevantChunks = await this.semanticSearch.search(query, 10);
        // Extract symbols from the query
        const symbols = this.extractSymbolsFromQuery(query);
        // If we found symbols, add chunks related to those symbols
        if (symbols.length > 0) {
            for (const symbol of symbols) {
                const symbolChunks = await this.semanticSearch.searchBySymbol(symbol, 5);
                // Add symbol chunks to relevant chunks, avoiding duplicates
                const existingIds = new Set(relevantChunks.map(chunk => chunk.id));
                for (const chunk of symbolChunks) {
                    if (!existingIds.has(chunk.id)) {
                        relevantChunks.push(chunk);
                        existingIds.add(chunk.id);
                    }
                }
            }
        }
        // Get the active editor file path
        const activeEditor = vscode.window.activeTextEditor;
        if (activeEditor) {
            const filePath = activeEditor.document.uri.fsPath;
            // Get related files from dependency graph
            const relatedFiles = this.dependencyGraph.getRelatedFiles(filePath, 1);
            // Add chunks from related files
            for (const relatedFile of relatedFiles) {
                const fileChunks = await this.getChunksForFile(relatedFile);
                // Add file chunks to relevant chunks, avoiding duplicates
                const existingIds = new Set(relevantChunks.map(chunk => chunk.id));
                for (const chunk of fileChunks) {
                    if (!existingIds.has(chunk.id)) {
                        relevantChunks.push(chunk);
                        existingIds.add(chunk.id);
                    }
                }
            }
        }
        // Compose context
        return this.contextComposer.composeContext(query, relevantChunks, tokenLimit);
    }
    async getContextForFile(filePath, tokenLimit = 4000) {
        if (!this.isInitialized) {
            await this.initialize();
        }
        // Get chunks for this file
        const fileChunks = await this.getChunksForFile(filePath);
        // Get related files from dependency graph
        const relatedFiles = this.dependencyGraph.getRelatedFiles(filePath, 1);
        // Add chunks from related files
        const allChunks = [...fileChunks];
        const existingIds = new Set(allChunks.map(chunk => chunk.id));
        for (const relatedFile of relatedFiles) {
            const relatedChunks = await this.getChunksForFile(relatedFile);
            for (const chunk of relatedChunks) {
                if (!existingIds.has(chunk.id)) {
                    allChunks.push(chunk);
                    existingIds.add(chunk.id);
                }
            }
        }
        // Compose context
        return this.contextComposer.composeContext(`File: ${filePath}`, allChunks, tokenLimit);
    }
    async getContextForSymbol(symbol, tokenLimit = 4000) {
        if (!this.isInitialized) {
            await this.initialize();
        }
        // Find chunks related to this symbol
        const symbolChunks = await this.semanticSearch.searchBySymbol(symbol, 10);
        // Compose context
        return this.contextComposer.composeContext(`Symbol: ${symbol}`, symbolChunks, tokenLimit);
    }
    async getChunksForFile(filePath) {
        // Find chunks for this file
        const allChunks = await this.vectorStore.findSimilarChunks('', 10000);
        return allChunks.filter(chunk => chunk.filePath === filePath);
    }
    extractSymbolsFromQuery(query) {
        // Extract potential symbols from the query
        // This is a simplified implementation
        const words = query.split(/\s+/);
        const symbols = [];
        for (const word of words) {
            // Clean up the word
            const cleanWord = word.replace(/[^\w]/g, '');
            // Check if it looks like a symbol (camelCase, PascalCase, snake_case)
            if (cleanWord.length > 0 &&
                (cleanWord.match(/[a-z][A-Z]/) || // camelCase
                    cleanWord.match(/^[A-Z][a-z]/) || // PascalCase
                    cleanWord.includes('_'))) { // snake_case
                symbols.push(cleanWord);
            }
        }
        return symbols;
    }
    async dispose() {
        // Dispose the file indexer
        this.fileIndexer.dispose();
        // Dispose the persistent vector store if needed
        if (this.vectorStore instanceof PersistentVectorStore) {
            console.log('Disposing persistent vector store');
            await this.vectorStore.dispose();
        }
    }
}
exports.ContextEngine = ContextEngine;
//# sourceMappingURL=contextEngine.js.map
```


---

### File: `out/container-manager/dockerContainerManager.js`

```javascript
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.DockerContainerManager = void 0;
const Docker = __importStar(require("dockerode"));
const path = __importStar(require("path"));
/**
 * Manager for Docker containers
 */
class DockerContainerManager {
    /**
     * Create a new Docker container manager
     * @param options Docker options
     */
    constructor(options) {
        this.options = options;
        this.docker = new Docker({
            socketPath: options.socketPath
        });
    }
    /**
     * Start a container from a Dockerfile
     * @param name Container name
     * @param dockerfilePath Path to the directory containing the Dockerfile
     * @param actualDockerfilePath Optional path to the actual Dockerfile if it's not in the root directory
     * @returns Promise that resolves to the container ID
     */
    async startContainer(name, dockerfilePath, actualDockerfilePath) {
        try {
            console.log(`Starting container for ${name} from ${dockerfilePath}`);
            // Determine the context and Dockerfile path
            let context = dockerfilePath;
            let dockerfile = 'Dockerfile';
            if (actualDockerfilePath) {
                // If the Dockerfile is not in the root directory, we need to adjust the paths
                const relativePath = path.relative(dockerfilePath, actualDockerfilePath);
                if (relativePath.includes('..')) {
                    // If the Dockerfile is outside the context, we need to use its directory as context
                    context = path.dirname(actualDockerfilePath);
                    dockerfile = path.basename(actualDockerfilePath);
                }
                else {
                    // If the Dockerfile is inside the context, we just need to specify its relative path
                    dockerfile = relativePath;
                }
            }
            console.log(`Building image with context: ${context}, dockerfile: ${dockerfile}`);
            // Build the image
            const stream = await this.docker.buildImage({
                context,
                src: [dockerfile]
            }, {
                t: `mcp-server-${name}`,
                dockerfile
            });
            // Wait for the build to complete
            await new Promise((resolve, reject) => {
                this.docker.modem.followProgress(stream, (err, res) => {
                    if (err) {
                        console.error('Error building image:', err);
                        reject(err);
                    }
                    else {
                        console.log('Image built successfully');
                        resolve(res);
                    }
                });
            });
            // Check if a container with the same name already exists
            const containers = await this.docker.listContainers({ all: true });
            const existingContainer = containers.find(c => c.Names.includes(`/mcp-server-${name}`));
            if (existingContainer) {
                console.log(`Container with name mcp-server-${name} already exists, removing it`);
                const container = this.docker.getContainer(existingContainer.Id);
                if (existingContainer.State === 'running') {
                    await container.stop();
                }
                await container.remove();
            }
            // Create the container
            console.log(`Creating container for ${name}`);
            const container = await this.docker.createContainer({
                Image: `mcp-server-${name}`,
                name: `mcp-server-${name}`,
                ExposedPorts: {
                    '8000/tcp': {}
                },
                HostConfig: {
                    PortBindings: {
                        '8000/tcp': [
                            {
                                HostPort: '0' // Let Docker assign a random port
                            }
                        ]
                    },
                    Memory: this.options.memory * 1024 * 1024, // Convert MB to bytes
                    NanoCpus: this.options.cpus * 1000000000, // Convert CPUs to nanoCPUs
                    RestartPolicy: {
                        Name: 'on-failure',
                        MaximumRetryCount: 3
                    }
                }
            });
            // Start the container
            console.log(`Starting container for ${name}`);
            await container.start();
            // Wait a moment to ensure the container is running
            await new Promise(resolve => setTimeout(resolve, 2000));
            // Check if the container is running
            const info = await container.inspect();
            if (!info.State.Running) {
                throw new Error(`Container failed to start: ${info.State.Error || 'Unknown error'}`);
            }
            console.log(`Container for ${name} started successfully with ID ${container.id}`);
            return container.id;
        }
        catch (error) {
            console.error('Error starting container:', error);
            throw error;
        }
    }
    /**
     * Stop a container
     * @param containerId Container ID
     * @returns Promise that resolves when the container is stopped
     */
    async stopContainer(containerId) {
        try {
            const container = this.docker.getContainer(containerId);
            await container.stop();
            await container.remove();
        }
        catch (error) {
            console.error('Error stopping container:', error);
            throw error;
        }
    }
    /**
     * Get the endpoint for a container
     * @param containerId Container ID
     * @returns Promise that resolves to the container endpoint
     */
    async getContainerEndpoint(containerId) {
        try {
            const container = this.docker.getContainer(containerId);
            const info = await container.inspect();
            // Get the host port
            const hostPort = info.NetworkSettings.Ports['8000/tcp'][0].HostPort;
            return `http://localhost:${hostPort}`;
        }
        catch (error) {
            console.error('Error getting container endpoint:', error);
            throw error;
        }
    }
    /**
     * Get the logs for a container
     * @param containerId Container ID
     * @returns Promise that resolves to the container logs
     */
    async getContainerLogs(containerId) {
        try {
            const container = this.docker.getContainer(containerId);
            const logs = await container.logs({
                stdout: true,
                stderr: true,
                tail: 100
            });
            return logs.toString();
        }
        catch (error) {
            console.error('Error getting container logs:', error);
            throw error;
        }
    }
    /**
     * Check if a container is running
     * @param containerId Container ID
     * @returns Promise that resolves to true if the container is running
     */
    async isContainerRunning(containerId) {
        try {
            const container = this.docker.getContainer(containerId);
            const info = await container.inspect();
            return info.State.Running;
        }
        catch (error) {
            console.error('Error checking if container is running:', error);
            return false;
        }
    }
}
exports.DockerContainerManager = DockerContainerManager;
//# sourceMappingURL=dockerContainerManager.js.map
```


---

### File: `out/mcp-client/types.js`

```javascript
"use strict";
/**
 * Types for MCP client and server management
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.McpServerType = exports.McpServerStatus = void 0;
/**
 * Status of an MCP server
 */
var McpServerStatus;
(function (McpServerStatus) {
    McpServerStatus["Running"] = "running";
    McpServerStatus["Stopped"] = "stopped";
    McpServerStatus["Starting"] = "starting";
    McpServerStatus["Stopping"] = "stopping";
    McpServerStatus["Error"] = "error";
    McpServerStatus["Unknown"] = "unknown";
})(McpServerStatus || (exports.McpServerStatus = McpServerStatus = {}));
/**
 * Type of MCP server
 */
var McpServerType;
(function (McpServerType) {
    McpServerType["Docker"] = "docker";
    McpServerType["Process"] = "process";
})(McpServerType || (exports.McpServerType = McpServerType = {}));
//# sourceMappingURL=types.js.map
```


---

### File: `out/mcp-client/serverHealthMonitor.js`

```javascript
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.ServerHealthMonitor = void 0;
const vscode = __importStar(require("vscode"));
const types_1 = require("./types");
/**
 * Monitor for MCP server health
 */
class ServerHealthMonitor {
    /**
     * Create a new server health monitor
     * @param serverManager MCP server manager
     * @param checkIntervalMs Interval between health checks in milliseconds (default: 60000)
     * @param autoRecoveryEnabled Whether to automatically recover unhealthy servers (default: true)
     */
    constructor(serverManager, checkIntervalMs = 60000, autoRecoveryEnabled = true) {
        this._onDidUpdateHealth = new vscode.EventEmitter();
        /**
         * Event that fires when a server's health is updated
         */
        this.onDidUpdateHealth = this._onDidUpdateHealth.event;
        this.serverManager = serverManager;
        this.checkIntervalMs = checkIntervalMs;
        this.autoRecoveryEnabled = autoRecoveryEnabled;
    }
    /**
     * Start monitoring server health
     */
    start() {
        // Stop any existing interval
        this.stop();
        // Start a new interval
        this.intervalId = setInterval(() => this.checkAllServersHealth(), this.checkIntervalMs);
        // Do an initial health check
        this.checkAllServersHealth();
    }
    /**
     * Stop monitoring server health
     */
    stop() {
        if (this.intervalId) {
            clearInterval(this.intervalId);
            this.intervalId = undefined;
        }
    }
    /**
     * Check the health of all running servers
     */
    async checkAllServersHealth() {
        const servers = this.serverManager.getServers();
        for (const server of servers) {
            if (server.status === types_1.McpServerStatus.Running) {
                await this.checkServerHealth(server.id);
            }
        }
    }
    /**
     * Check the health of a server
     * @param serverId Server ID
     */
    async checkServerHealth(serverId) {
        try {
            const isHealthy = await this.serverManager.checkServerHealth(serverId);
            const server = this.serverManager.getServer(serverId);
            if (!server) {
                return;
            }
            // Notify listeners
            this._onDidUpdateHealth.fire(serverId);
            // If the server is unhealthy and auto-recovery is enabled, try to recover it
            if (!isHealthy && this.autoRecoveryEnabled && server.status === types_1.McpServerStatus.Running) {
                await this.recoverServer(serverId);
            }
        }
        catch (error) {
            console.error(`Error checking health for server ${serverId}:`, error);
        }
    }
    /**
     * Recover an unhealthy server
     * @param serverId Server ID
     */
    async recoverServer(serverId) {
        try {
            const server = this.serverManager.getServer(serverId);
            if (!server) {
                return;
            }
            console.log(`Attempting to recover unhealthy server ${serverId}`);
            // Add log entry
            server.logs.push(`[${new Date().toISOString()}] Server is unhealthy, attempting recovery...`);
            // Restart the server
            await this.serverManager.restartServer(serverId);
            // Add log entry
            server.logs.push(`[${new Date().toISOString()}] Server recovery completed`);
            // Check health again after recovery
            setTimeout(() => this.checkServerHealth(serverId), 5000);
        }
        catch (error) {
            console.error(`Error recovering server ${serverId}:`, error);
            const server = this.serverManager.getServer(serverId);
            if (server) {
                server.logs.push(`[${new Date().toISOString()}] Error during server recovery: ${error}`);
            }
        }
    }
    /**
     * Set whether auto-recovery is enabled
     * @param enabled Whether auto-recovery is enabled
     */
    setAutoRecoveryEnabled(enabled) {
        this.autoRecoveryEnabled = enabled;
    }
    /**
     * Set the health check interval
     * @param intervalMs Interval between health checks in milliseconds
     */
    setCheckInterval(intervalMs) {
        this.checkIntervalMs = intervalMs;
        // Restart the interval with the new timing
        if (this.intervalId) {
            this.start();
        }
    }
    /**
     * Dispose of the health monitor
     */
    dispose() {
        this.stop();
        this._onDidUpdateHealth.dispose();
    }
}
exports.ServerHealthMonitor = ServerHealthMonitor;
//# sourceMappingURL=serverHealthMonitor.js.map
```


---

### File: `out/mcp-client/mcpClient.js`

```javascript
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.McpClient = void 0;
/**
 * Client for MCP servers
 */
class McpClient {
    /**
     * Create a new MCP client
     * @param serverManager MCP server manager
     * @param authManager Authentication manager (optional)
     */
    constructor(serverManager, authManager) {
        this.serverManager = serverManager;
        this.authManager = authManager;
    }
    /**
     * Get all available tools from all running servers
     * @returns Promise that resolves to an array of tools
     */
    async getAllTools() {
        const servers = this.serverManager.getServers();
        const tools = [];
        for (const server of servers) {
            if (server.status === 'running' && server.schema?.tools) {
                for (const tool of server.schema.tools) {
                    tools.push({
                        serverId: server.id,
                        tool
                    });
                }
            }
        }
        return tools;
    }
    /**
     * Invoke a tool
     * @param serverId Server ID
     * @param toolName Tool name
     * @param parameters Tool parameters
     * @returns Promise that resolves to the tool response
     */
    async invokeTool(serverId, toolName, parameters) {
        try {
            // Get the server
            const server = this.serverManager.getServer(serverId);
            if (!server) {
                return {
                    status: 'error',
                    error: `Server ${serverId} not found`
                };
            }
            // Check if the server is running
            if (server.status !== 'running') {
                return {
                    status: 'error',
                    error: `Server ${serverId} is not running`
                };
            }
            // Check if the server has a schema
            if (!server.schema) {
                return {
                    status: 'error',
                    error: `Server ${serverId} has no schema`
                };
            }
            // Find the tool in the schema
            const tool = server.schema.tools.find(t => t.name === toolName);
            if (!tool) {
                return {
                    status: 'error',
                    error: `Tool ${toolName} not found in server ${serverId}`
                };
            }
            // Validate parameters
            const validationResult = this.validateParameters(tool, parameters);
            if (validationResult.status === 'error') {
                return validationResult;
            }
            // Handle authentication if needed
            if (this.authManager && server.schema.authentication?.required) {
                try {
                    // Check if we have authentication configured
                    const hasAuth = await this.authManager.hasAuthConfig(serverId);
                    if (!hasAuth) {
                        // Prompt for authentication
                        await this.authManager.promptForAuthentication(server);
                    }
                    // Check if token needs refresh
                    const needsRefresh = await this.authManager.needsTokenRefresh(serverId);
                    if (needsRefresh) {
                        await this.authManager.refreshOAuthToken(serverId);
                    }
                }
                catch (authError) {
                    console.error(`Authentication error for server ${serverId}:`, authError);
                    return {
                        status: 'error',
                        error: `Authentication error: ${authError}`
                    };
                }
            }
            // Create the invocation
            const invocation = {
                tool: toolName,
                parameters
            };
            // Get authentication headers if available
            let authHeaders;
            if (this.authManager) {
                authHeaders = await this.authManager.getAuthHeaders(serverId);
            }
            // Invoke the tool with authentication headers
            return this.serverManager.invokeTool(serverId, invocation, authHeaders);
        }
        catch (error) {
            console.error(`Error invoking tool ${toolName} on server ${serverId}:`, error);
            return {
                status: 'error',
                error: `Error invoking tool: ${error}`
            };
        }
    }
    /**
     * Validate parameters against a tool's schema
     * @param tool Tool schema
     * @param parameters Parameters to validate
     * @returns Validation result
     */
    validateParameters(tool, parameters) {
        try {
            // Check for required parameters
            for (const param of tool.parameters) {
                if (param.required && parameters[param.name] === undefined) {
                    return {
                        status: 'error',
                        error: `Missing required parameter: ${param.name}`
                    };
                }
            }
            // Check parameter types (basic validation)
            for (const paramName in parameters) {
                const param = tool.parameters.find(p => p.name === paramName);
                if (!param) {
                    return {
                        status: 'error',
                        error: `Unknown parameter: ${paramName}`
                    };
                }
                // Basic type checking
                const value = parameters[paramName];
                if (param.type === 'string' && typeof value !== 'string') {
                    return {
                        status: 'error',
                        error: `Parameter ${paramName} should be a string`
                    };
                }
                else if (param.type === 'number' && typeof value !== 'number') {
                    return {
                        status: 'error',
                        error: `Parameter ${paramName} should be a number`
                    };
                }
                else if (param.type === 'boolean' && typeof value !== 'boolean') {
                    return {
                        status: 'error',
                        error: `Parameter ${paramName} should be a boolean`
                    };
                }
                else if (param.type === 'array' && !Array.isArray(value)) {
                    return {
                        status: 'error',
                        error: `Parameter ${paramName} should be an array`
                    };
                }
                else if (param.type === 'object' && (typeof value !== 'object' || value === null || Array.isArray(value))) {
                    return {
                        status: 'error',
                        error: `Parameter ${paramName} should be an object`
                    };
                }
            }
            return { status: 'success' };
        }
        catch (error) {
            console.error('Error validating parameters:', error);
            return {
                status: 'error',
                error: `Error validating parameters: ${error}`
            };
        }
    }
    /**
     * Find a tool by name
     * @param toolName Tool name
     * @returns Promise that resolves to the tool and server ID, or undefined if not found
     */
    async findTool(toolName) {
        const tools = await this.getAllTools();
        return tools.find(t => t.tool.name === toolName);
    }
    /**
     * Dispose of resources
     */
    dispose() {
        // Nothing to dispose
    }
}
exports.McpClient = McpClient;
//# sourceMappingURL=mcpClient.js.map
```


---

### File: `out/mcp-client/mcpServerManager.js`

```javascript
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.McpServerManager = void 0;
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const vscode = __importStar(require("vscode"));
const configuration_1 = require("../configuration");
const dockerContainerManager_1 = require("../container-manager/dockerContainerManager");
const githubRepoManager_1 = require("../github-integration/githubRepoManager");
const types_1 = require("./types");
/**
 * Manager for MCP servers
 */
class McpServerManager {
    /**
     * Create a new MCP server manager
     */
    constructor() {
        this.servers = new Map();
        this._onDidChangeServers = new vscode.EventEmitter();
        /**
         * Event that fires when the servers list changes
         */
        this.onDidChangeServers = this._onDidChangeServers.event;
        const config = (0, configuration_1.getConfiguration)();
        this.dockerManager = new dockerContainerManager_1.DockerContainerManager(config.mcpServers.dockerOptions);
        this.githubManager = new githubRepoManager_1.GitHubRepoManager(config.mcpServers.githubOptions);
        // Set up storage directory
        this.storageDir = this.getStorageDir(config.mcpServers.storagePath);
        this.configFile = path.join(this.storageDir, 'mcp-servers.json');
        // Create storage directory if it doesn't exist
        if (!fs.existsSync(this.storageDir)) {
            fs.mkdirSync(this.storageDir, { recursive: true });
        }
        // Load servers from config file
        this.loadServers();
    }
    /**
     * Get the storage directory
     * @param configPath Path from configuration
     * @returns Storage directory path
     */
    getStorageDir(configPath) {
        if (configPath) {
            return configPath;
        }
        // Use the extension's global storage path
        const context = vscode.extensions.getExtension('qwen-coder-assistant')?.extensionUri;
        if (context) {
            return path.join(context.fsPath, 'mcp-servers');
        }
        // Fallback to the workspace storage path
        if (vscode.workspace.workspaceFolders && vscode.workspace.workspaceFolders.length > 0) {
            return path.join(vscode.workspace.workspaceFolders[0].uri.fsPath, '.vscode', 'mcp-servers');
        }
        throw new Error('Could not determine storage directory for MCP servers');
    }
    /**
     * Load servers from config file
     */
    loadServers() {
        try {
            if (fs.existsSync(this.configFile)) {
                const data = fs.readFileSync(this.configFile, 'utf8');
                const servers = JSON.parse(data);
                // Reset status for all servers
                for (const server of servers) {
                    server.status = types_1.McpServerStatus.Stopped;
                    server.logs = server.logs || [];
                    this.servers.set(server.id, server);
                }
                this._onDidChangeServers.fire();
            }
        }
        catch (error) {
            console.error('Error loading MCP servers:', error);
            vscode.window.showErrorMessage(`Error loading MCP servers: ${error}`);
        }
    }
    /**
     * Save servers to config file
     */
    saveServers() {
        try {
            const servers = Array.from(this.servers.values());
            fs.writeFileSync(this.configFile, JSON.stringify(servers, null, 2), 'utf8');
        }
        catch (error) {
            console.error('Error saving MCP servers:', error);
            vscode.window.showErrorMessage(`Error saving MCP servers: ${error}`);
        }
    }
    /**
     * Get all servers
     * @returns Array of MCP servers
     */
    getServers() {
        return Array.from(this.servers.values());
    }
    /**
     * Get a server by ID
     * @param id Server ID
     * @returns MCP server or undefined if not found
     */
    getServer(id) {
        return this.servers.get(id);
    }
    /**
     * Add a new server from a GitHub repository
     * @param repoUrl GitHub repository URL
     * @returns Promise that resolves to the new server
     */
    async addServerFromGitHub(repoUrl) {
        try {
            // Clone the repository
            const repoInfo = await this.githubManager.cloneRepository(repoUrl, this.storageDir);
            // Check if the repository has a Dockerfile
            if (!repoInfo.hasDockerfile) {
                throw new Error('Repository does not contain a Dockerfile');
            }
            // Check if the repository has an MCP schema file
            if (!repoInfo.hasMcpSchema) {
                throw new Error('Repository does not contain an MCP schema file');
            }
            // Read the schema file
            const schemaData = fs.readFileSync(repoInfo.schemaPath, 'utf8');
            let schema;
            // Parse the schema file based on its extension
            if (repoInfo.schemaPath.endsWith('.json')) {
                schema = JSON.parse(schemaData);
            }
            else if (repoInfo.schemaPath.endsWith('.yaml') || repoInfo.schemaPath.endsWith('.yml')) {
                // For YAML files, we would need a YAML parser
                // This is a placeholder - in a real implementation, you would use a YAML parser
                throw new Error('YAML schema files are not yet supported');
            }
            else {
                throw new Error('Unsupported schema file format');
            }
            // Validate the schema
            if (!schema.name || !schema.description || !schema.tools || !Array.isArray(schema.tools)) {
                throw new Error('Invalid MCP schema: missing required fields (name, description, tools)');
            }
            // Create a new server
            const server = {
                id: repoInfo.name,
                name: schema.name || repoInfo.name,
                description: schema.description || repoInfo.description || '',
                repoUrl,
                version: repoInfo.version || schema.version || '0.0.1',
                status: types_1.McpServerStatus.Stopped,
                type: types_1.McpServerType.Docker,
                autoStart: false,
                schema,
                logs: [],
                localPath: repoInfo.localPath,
                dockerfilePath: repoInfo.dockerfilePath
            };
            // Add the server to the list
            this.servers.set(server.id, server);
            // Save the servers
            this.saveServers();
            // Notify listeners
            this._onDidChangeServers.fire();
            // Add log entry
            server.logs.push(`[${new Date().toISOString()}] Server added from GitHub repository: ${repoUrl}`);
            return server;
        }
        catch (error) {
            console.error('Error adding server from GitHub:', error);
            throw error;
        }
    }
    /**
     * Remove a server
     * @param id Server ID
     * @returns Promise that resolves when the server is removed
     */
    async removeServer(id) {
        const server = this.servers.get(id);
        if (!server) {
            throw new Error(`Server ${id} not found`);
        }
        // Stop the server if it's running
        if (server.status === types_1.McpServerStatus.Running) {
            await this.stopServer(id);
        }
        // Remove the server from the list
        this.servers.delete(id);
        // Save the servers
        this.saveServers();
        // Notify listeners
        this._onDidChangeServers.fire();
    }
    /**
     * Start a server
     * @param id Server ID
     * @returns Promise that resolves when the server is started
     */
    async startServer(id) {
        const server = this.servers.get(id);
        if (!server) {
            throw new Error(`Server ${id} not found`);
        }
        // Update server status
        server.status = types_1.McpServerStatus.Starting;
        server.error = undefined;
        this._onDidChangeServers.fire();
        try {
            // Start the server based on its type
            if (server.type === types_1.McpServerType.Docker) {
                // Get the repository path
                const repoPath = server.localPath || path.join(this.storageDir, server.id);
                // Start the Docker container
                const containerId = await this.dockerManager.startContainer(server.id, repoPath, server.dockerfilePath);
                // Update server information
                server.containerId = containerId;
                server.status = types_1.McpServerStatus.Running;
                server.lastStarted = new Date();
                server.endpoint = await this.dockerManager.getContainerEndpoint(containerId);
                server.healthStatus = 'unknown';
                server.lastHealthCheck = new Date();
                // Add log entry
                server.logs.push(`[${new Date().toISOString()}] Server started with endpoint ${server.endpoint}`);
                // Check server health
                try {
                    const isHealthy = await this.checkServerHealth(server.id);
                    server.healthStatus = isHealthy ? 'healthy' : 'unhealthy';
                    if (!isHealthy) {
                        server.logs.push(`[${new Date().toISOString()}] Warning: Server health check failed`);
                    }
                    else {
                        server.logs.push(`[${new Date().toISOString()}] Server health check passed`);
                    }
                }
                catch (healthError) {
                    server.logs.push(`[${new Date().toISOString()}] Error checking server health: ${healthError}`);
                    server.healthStatus = 'unknown';
                }
                // Save the servers
                this.saveServers();
                // Notify listeners
                this._onDidChangeServers.fire();
            }
            else {
                throw new Error(`Unsupported server type: ${server.type}`);
            }
        }
        catch (error) {
            console.error(`Error starting server ${id}:`, error);
            // Update server status
            server.status = types_1.McpServerStatus.Error;
            server.error = `${error}`;
            // Add log entry
            server.logs.push(`[${new Date().toISOString()}] Error starting server: ${error}`);
            // Save the servers
            this.saveServers();
            // Notify listeners
            this._onDidChangeServers.fire();
            throw error;
        }
    }
    /**
     * Stop a server
     * @param id Server ID
     * @returns Promise that resolves when the server is stopped
     */
    async stopServer(id) {
        const server = this.servers.get(id);
        if (!server) {
            throw new Error(`Server ${id} not found`);
        }
        // Update server status
        server.status = types_1.McpServerStatus.Stopping;
        this._onDidChangeServers.fire();
        try {
            // Stop the server based on its type
            if (server.type === types_1.McpServerType.Docker) {
                // Stop the Docker container
                if (server.containerId) {
                    await this.dockerManager.stopContainer(server.containerId);
                }
                // Update server information
                server.status = types_1.McpServerStatus.Stopped;
                server.lastStopped = new Date();
                server.endpoint = undefined;
                // Add log entry
                server.logs.push(`[${new Date().toISOString()}] Server stopped`);
                // Save the servers
                this.saveServers();
                // Notify listeners
                this._onDidChangeServers.fire();
            }
            else {
                throw new Error(`Unsupported server type: ${server.type}`);
            }
        }
        catch (error) {
            console.error(`Error stopping server ${id}:`, error);
            // Update server status
            server.status = types_1.McpServerStatus.Error;
            server.error = `${error}`;
            // Add log entry
            server.logs.push(`[${new Date().toISOString()}] Error stopping server: ${error}`);
            // Save the servers
            this.saveServers();
            // Notify listeners
            this._onDidChangeServers.fire();
            throw error;
        }
    }
    /**
     * Restart a server
     * @param id Server ID
     * @returns Promise that resolves when the server is restarted
     */
    async restartServer(id) {
        await this.stopServer(id);
        await this.startServer(id);
    }
    /**
     * Get the logs for a server
     * @param id Server ID
     * @returns Server logs
     */
    getServerLogs(id) {
        const server = this.servers.get(id);
        if (!server) {
            throw new Error(`Server ${id} not found`);
        }
        return server.logs;
    }
    /**
     * Invoke a tool on a server
     * @param serverId Server ID
     * @param invocation Tool invocation
     * @param authHeaders Optional authentication headers
     * @returns Promise that resolves to the tool response
     */
    async invokeTool(serverId, invocation, authHeaders) {
        const server = this.servers.get(serverId);
        if (!server) {
            return {
                status: 'error',
                error: `Server ${serverId} not found`
            };
        }
        if (server.status !== types_1.McpServerStatus.Running) {
            return {
                status: 'error',
                error: `Server ${serverId} is not running (current status: ${server.status})`
            };
        }
        if (!server.endpoint) {
            return {
                status: 'error',
                error: `Server ${serverId} has no endpoint`
            };
        }
        try {
            // Log the invocation
            server.logs.push(`[${new Date().toISOString()}] Invoking tool ${invocation.tool} with parameters: ${JSON.stringify(invocation.parameters)}`);
            // Check server health before invoking the tool
            const isHealthy = await this.checkServerHealth(serverId);
            if (!isHealthy) {
                server.logs.push(`[${new Date().toISOString()}] Warning: Server health check failed before tool invocation`);
            }
            // Determine the correct endpoint URL
            let endpointUrl = `${server.endpoint}/tools/${invocation.tool}`;
            // Some MCP servers use a different endpoint format
            if (server.schema?.apiVersion === 'v2') {
                endpointUrl = `${server.endpoint}/v2/tools/${invocation.tool}`;
            }
            else if (server.schema?.apiVersion === 'v1') {
                endpointUrl = `${server.endpoint}/v1/tools/${invocation.tool}`;
            }
            // Prepare headers
            const headers = {
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            };
            // Add authentication headers if provided
            if (authHeaders) {
                Object.assign(headers, authHeaders);
                server.logs.push(`[${new Date().toISOString()}] Using authentication for tool invocation`);
            }
            // Invoke the tool on the server
            const response = await fetch(endpointUrl, {
                method: 'POST',
                headers,
                body: JSON.stringify(invocation.parameters),
                timeout: 30000 // 30 second timeout
            });
            if (!response.ok) {
                const errorText = await response.text();
                server.logs.push(`[${new Date().toISOString()}] Error invoking tool ${invocation.tool}: ${errorText}`);
                // Check for authentication errors
                if (response.status === 401 || response.status === 403) {
                    return {
                        status: 'error',
                        error: `Authentication error: ${errorText}`
                    };
                }
                return {
                    status: 'error',
                    error: `Error invoking tool: ${errorText}`
                };
            }
            const result = await response.json();
            // Log the result (truncated if too large)
            const resultStr = JSON.stringify(result);
            const truncatedResult = resultStr.length > 500 ? resultStr.substring(0, 500) + '...' : resultStr;
            server.logs.push(`[${new Date().toISOString()}] Tool ${invocation.tool} invocation successful. Result: ${truncatedResult}`);
            // Save the servers to persist the logs
            this.saveServers();
            return {
                status: 'success',
                result
            };
        }
        catch (error) {
            console.error(`Error invoking tool ${invocation.tool} on server ${serverId}:`, error);
            // Log the error
            server.logs.push(`[${new Date().toISOString()}] Error invoking tool ${invocation.tool}: ${error}`);
            // Save the servers to persist the logs
            this.saveServers();
            return {
                status: 'error',
                error: `${error}`
            };
        }
    }
    /**
     * Start all auto-start servers
     * @returns Promise that resolves when all auto-start servers are started
     */
    async startAutoStartServers() {
        const config = (0, configuration_1.getConfiguration)();
        // Get the list of servers to auto-start
        const autoStartList = config.mcpServers.autoStartList;
        // If auto-start is disabled, return
        if (!config.mcpServers.autoStart || autoStartList.length === 0) {
            return;
        }
        // Start each server in the list
        for (const serverId of autoStartList) {
            const server = this.servers.get(serverId);
            if (server && server.status === types_1.McpServerStatus.Stopped) {
                try {
                    await this.startServer(serverId);
                }
                catch (error) {
                    console.error(`Error auto-starting server ${serverId}:`, error);
                }
            }
        }
    }
    /**
     * Check the health of a server
     * @param id Server ID
     * @returns Promise that resolves to true if the server is healthy
     */
    async checkServerHealth(id) {
        const server = this.servers.get(id);
        if (!server) {
            throw new Error(`Server ${id} not found`);
        }
        if (server.status !== types_1.McpServerStatus.Running) {
            return false;
        }
        if (!server.endpoint) {
            return false;
        }
        try {
            // Try to fetch the server's health endpoint
            const response = await fetch(`${server.endpoint}/health`, {
                method: 'GET',
                headers: {
                    'Accept': 'application/json'
                },
                timeout: 5000 // 5 second timeout
            });
            // Update server health status
            server.healthStatus = response.ok ? 'healthy' : 'unhealthy';
            server.lastHealthCheck = new Date();
            // Save the servers
            this.saveServers();
            return response.ok;
        }
        catch (error) {
            console.error(`Error checking server health for ${id}:`, error);
            // Update server health status
            server.healthStatus = 'unhealthy';
            server.lastHealthCheck = new Date();
            // Save the servers
            this.saveServers();
            return false;
        }
    }
    /**
     * Check the health of all running servers
     * @returns Promise that resolves when all servers have been checked
     */
    async checkAllServersHealth() {
        for (const server of this.servers.values()) {
            if (server.status === types_1.McpServerStatus.Running) {
                try {
                    await this.checkServerHealth(server.id);
                }
                catch (error) {
                    console.error(`Error checking server health for ${server.id}:`, error);
                }
            }
        }
    }
    /**
     * Dispose of resources
     */
    dispose() {
        // Stop all running servers
        for (const server of this.servers.values()) {
            if (server.status === types_1.McpServerStatus.Running) {
                try {
                    this.stopServer(server.id);
                }
                catch (error) {
                    console.error(`Error stopping server ${server.id} during disposal:`, error);
                }
            }
        }
        // Dispose of event emitter
        this._onDidChangeServers.dispose();
    }
}
exports.McpServerManager = McpServerManager;
//# sourceMappingURL=mcpServerManager.js.map
```


---

### File: `out/mcp-client/officialMcpServers.js`

```javascript
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OfficialMcpServersManager = exports.OFFICIAL_MCP_SERVERS = void 0;
/**
 * Official MCP server repository URLs
 */
exports.OFFICIAL_MCP_SERVERS = {
    GITHUB: 'https://github.com/modelcontextprotocol/mcp-server-github',
    DOCKER: 'https://github.com/modelcontextprotocol/mcp-server-docker',
    GIT: 'https://github.com/modelcontextprotocol/mcp-server-git',
    MEMORY: 'https://github.com/modelcontextprotocol/mcp-server-memory',
    FILESYSTEM: 'https://github.com/modelcontextprotocol/mcp-server-filesystem'
};
/**
 * Manager for official MCP servers
 */
class OfficialMcpServersManager {
    /**
     * Create a new official MCP servers manager
     * @param serverManager MCP server manager
     */
    constructor(serverManager) {
        this.serverManager = serverManager;
    }
    /**
     * Add the GitHub MCP server
     * @returns Promise that resolves to the server ID
     */
    async addGitHubServer() {
        try {
            const server = await this.serverManager.addServerFromGitHub(exports.OFFICIAL_MCP_SERVERS.GITHUB);
            return server.id;
        }
        catch (error) {
            console.error('Error adding GitHub MCP server:', error);
            throw new Error(`Failed to add GitHub MCP server: ${error}`);
        }
    }
    /**
     * Add the Docker MCP server
     * @returns Promise that resolves to the server ID
     */
    async addDockerServer() {
        try {
            const server = await this.serverManager.addServerFromGitHub(exports.OFFICIAL_MCP_SERVERS.DOCKER);
            return server.id;
        }
        catch (error) {
            console.error('Error adding Docker MCP server:', error);
            throw new Error(`Failed to add Docker MCP server: ${error}`);
        }
    }
    /**
     * Add the Git MCP server
     * @returns Promise that resolves to the server ID
     */
    async addGitServer() {
        try {
            const server = await this.serverManager.addServerFromGitHub(exports.OFFICIAL_MCP_SERVERS.GIT);
            return server.id;
        }
        catch (error) {
            console.error('Error adding Git MCP server:', error);
            throw new Error(`Failed to add Git MCP server: ${error}`);
        }
    }
    /**
     * Add the Memory MCP server
     * @returns Promise that resolves to the server ID
     */
    async addMemoryServer() {
        try {
            const server = await this.serverManager.addServerFromGitHub(exports.OFFICIAL_MCP_SERVERS.MEMORY);
            return server.id;
        }
        catch (error) {
            console.error('Error adding Memory MCP server:', error);
            throw new Error(`Failed to add Memory MCP server: ${error}`);
        }
    }
    /**
     * Add the Filesystem MCP server
     * @returns Promise that resolves to the server ID
     */
    async addFilesystemServer() {
        try {
            const server = await this.serverManager.addServerFromGitHub(exports.OFFICIAL_MCP_SERVERS.FILESYSTEM);
            return server.id;
        }
        catch (error) {
            console.error('Error adding Filesystem MCP server:', error);
            throw new Error(`Failed to add Filesystem MCP server: ${error}`);
        }
    }
    /**
     * Add all official MCP servers
     * @returns Promise that resolves to an array of server IDs
     */
    async addAllOfficialServers() {
        const serverIds = [];
        try {
            // Add GitHub server
            const githubId = await this.addGitHubServer();
            serverIds.push(githubId);
        }
        catch (error) {
            console.error('Error adding GitHub MCP server:', error);
        }
        try {
            // Add Docker server
            const dockerId = await this.addDockerServer();
            serverIds.push(dockerId);
        }
        catch (error) {
            console.error('Error adding Docker MCP server:', error);
        }
        try {
            // Add Git server
            const gitId = await this.addGitServer();
            serverIds.push(gitId);
        }
        catch (error) {
            console.error('Error adding Git MCP server:', error);
        }
        try {
            // Add Memory server
            const memoryId = await this.addMemoryServer();
            serverIds.push(memoryId);
        }
        catch (error) {
            console.error('Error adding Memory MCP server:', error);
        }
        try {
            // Add Filesystem server
            const filesystemId = await this.addFilesystemServer();
            serverIds.push(filesystemId);
        }
        catch (error) {
            console.error('Error adding Filesystem MCP server:', error);
        }
        return serverIds;
    }
    /**
     * Check if a server is an official MCP server
     * @param repoUrl Repository URL
     * @returns True if the server is an official MCP server
     */
    isOfficialMcpServer(repoUrl) {
        const officialUrls = Object.values(exports.OFFICIAL_MCP_SERVERS);
        return officialUrls.includes(repoUrl);
    }
    /**
     * Get the type of an official MCP server
     * @param repoUrl Repository URL
     * @returns Server type or undefined if not an official server
     */
    getOfficialServerType(repoUrl) {
        for (const [type, url] of Object.entries(exports.OFFICIAL_MCP_SERVERS)) {
            if (url === repoUrl) {
                return type.toLowerCase();
            }
        }
        return undefined;
    }
}
exports.OfficialMcpServersManager = OfficialMcpServersManager;
//# sourceMappingURL=officialMcpServers.js.map
```


---

### File: `out/mcp-client/updates/updateManager.js`

```javascript
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.UpdateManager = void 0;
const vscode = __importStar(require("vscode"));
const semver = __importStar(require("semver"));
/**
 * Update manager for MCP servers
 */
class UpdateManager {
    /**
     * Create a new update manager
     * @param serverManager MCP server manager
     * @param githubManager GitHub repository manager
     */
    constructor(serverManager, githubManager) {
        this.updateHistory = [];
        this._onDidCheckForUpdates = new vscode.EventEmitter();
        this._onDidUpdateServer = new vscode.EventEmitter();
        /**
         * Event that fires when updates are checked
         */
        this.onDidCheckForUpdates = this._onDidCheckForUpdates.event;
        /**
         * Event that fires when a server is updated
         */
        this.onDidUpdateServer = this._onDidUpdateServer.event;
        this.serverManager = serverManager;
        this.githubManager = githubManager;
    }
    /**
     * Dispose of resources
     */
    dispose() {
        this._onDidCheckForUpdates.dispose();
        this._onDidUpdateServer.dispose();
    }
    /**
     * Check for updates for all servers
     * @returns Promise that resolves to update information for all servers
     */
    async checkForUpdates() {
        const servers = this.serverManager.getServers();
        const updateInfos = [];
        for (const server of servers) {
            try {
                const updateInfo = await this.checkForServerUpdate(server.id);
                if (updateInfo) {
                    updateInfos.push(updateInfo);
                }
            }
            catch (error) {
                console.error(`Error checking for updates for server ${server.id}:`, error);
            }
        }
        // Notify listeners
        this._onDidCheckForUpdates.fire(updateInfos);
        return updateInfos;
    }
    /**
     * Check for updates for a server
     * @param serverId Server ID
     * @returns Promise that resolves to update information for the server
     */
    async checkForServerUpdate(serverId) {
        const server = this.serverManager.getServer(serverId);
        if (!server) {
            throw new Error(`Server ${serverId} not found`);
        }
        try {
            // Get the latest release from GitHub
            const repoInfo = this.parseGitHubUrl(server.repoUrl);
            if (!repoInfo) {
                throw new Error(`Invalid GitHub URL: ${server.repoUrl}`);
            }
            const latestRelease = await this.githubManager.getLatestRelease(repoInfo.owner, repoInfo.repo);
            if (!latestRelease) {
                return undefined;
            }
            // Check if an update is available
            const currentVersion = server.version;
            const latestVersion = latestRelease.tag_name.startsWith('v')
                ? latestRelease.tag_name.substring(1)
                : latestRelease.tag_name;
            const updateAvailable = this.isUpdateAvailable(currentVersion, latestVersion);
            // Create update information
            const updateInfo = {
                serverId: server.id,
                serverName: server.name,
                currentVersion,
                latestVersion,
                releaseUrl: latestRelease.html_url,
                releaseDate: latestRelease.published_at,
                releaseNotes: latestRelease.body || '',
                updateAvailable
            };
            return updateInfo;
        }
        catch (error) {
            console.error(`Error checking for updates for server ${serverId}:`, error);
            return undefined;
        }
    }
    /**
     * Update a server
     * @param serverId Server ID
     * @returns Promise that resolves when the server is updated
     */
    async updateServer(serverId) {
        const server = this.serverManager.getServer(serverId);
        if (!server) {
            throw new Error(`Server ${serverId} not found`);
        }
        // Check if an update is available
        const updateInfo = await this.checkForServerUpdate(serverId);
        if (!updateInfo || !updateInfo.updateAvailable) {
            throw new Error(`No update available for server ${serverId}`);
        }
        // Create an update history entry
        const historyEntry = {
            serverId: server.id,
            serverName: server.name,
            fromVersion: server.version,
            toVersion: updateInfo.latestVersion,
            updateDate: new Date().toISOString(),
            success: false
        };
        try {
            // Stop the server if it's running
            const wasRunning = server.status === 'running';
            if (wasRunning) {
                await this.serverManager.stopServer(serverId);
            }
            // Update the server
            await this.serverManager.updateServer(serverId);
            // Restart the server if it was running
            if (wasRunning) {
                await this.serverManager.startServer(serverId);
            }
            // Update the history entry
            historyEntry.success = true;
            // Add the entry to the update history
            this.updateHistory.push(historyEntry);
            // Notify listeners
            this._onDidUpdateServer.fire(historyEntry);
        }
        catch (error) {
            // Update the history entry
            historyEntry.success = false;
            historyEntry.errorMessage = `${error}`;
            // Add the entry to the update history
            this.updateHistory.push(historyEntry);
            // Notify listeners
            this._onDidUpdateServer.fire(historyEntry);
            // Re-throw the error
            throw error;
        }
    }
    /**
     * Get the update history
     * @returns Update history
     */
    getUpdateHistory() {
        return [...this.updateHistory];
    }
    /**
     * Get the update history for a server
     * @param serverId Server ID
     * @returns Update history for the server
     */
    getServerUpdateHistory(serverId) {
        return this.updateHistory.filter(entry => entry.serverId === serverId);
    }
    /**
     * Clear the update history
     */
    clearUpdateHistory() {
        this.updateHistory = [];
    }
    /**
     * Check if an update is available
     * @param currentVersion Current version
     * @param latestVersion Latest version
     * @returns True if an update is available
     */
    isUpdateAvailable(currentVersion, latestVersion) {
        try {
            // Clean the versions to ensure they are valid semver
            const cleanCurrentVersion = semver.valid(semver.coerce(currentVersion));
            const cleanLatestVersion = semver.valid(semver.coerce(latestVersion));
            if (!cleanCurrentVersion || !cleanLatestVersion) {
                // If we can't parse the versions, assume no update is available
                return false;
            }
            // Compare the versions
            return semver.gt(cleanLatestVersion, cleanCurrentVersion);
        }
        catch (error) {
            console.error('Error comparing versions:', error);
            return false;
        }
    }
    /**
     * Parse a GitHub URL
     * @param url GitHub URL
     * @returns Owner and repository
     */
    parseGitHubUrl(url) {
        try {
            // Parse the URL
            const parsedUrl = new URL(url);
            if (parsedUrl.hostname !== 'github.com') {
                return undefined;
            }
            // Extract the owner and repository
            const parts = parsedUrl.pathname.split('/').filter(part => part.length > 0);
            if (parts.length < 2) {
                return undefined;
            }
            return {
                owner: parts[0],
                repo: parts[1]
            };
        }
        catch (error) {
            console.error('Error parsing GitHub URL:', error);
            return undefined;
        }
    }
}
exports.UpdateManager = UpdateManager;
//# sourceMappingURL=updateManager.js.map
```


---

### File: `out/mcp-client/authentication/authManager.js`

```javascript
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuthManager = void 0;
const vscode = __importStar(require("vscode"));
/**
 * Authentication manager for MCP servers
 */
class AuthManager {
    /**
     * Create a new authentication manager
     * @param context Extension context
     */
    constructor(context) {
        this._onDidChangeAuth = new vscode.EventEmitter();
        /**
         * Event that fires when authentication changes for a server
         */
        this.onDidChangeAuth = this._onDidChangeAuth.event;
        this.secretStorage = context.secrets;
    }
    /**
     * Dispose of resources
     */
    dispose() {
        this._onDidChangeAuth.dispose();
    }
    /**
     * Get the authentication configuration for a server
     * @param serverId Server ID
     * @returns Promise that resolves to the authentication configuration
     */
    async getAuthConfig(serverId) {
        try {
            const authJson = await this.secretStorage.get(`${AuthManager.SECRET_STORAGE_PREFIX}${serverId}`);
            if (!authJson) {
                return undefined;
            }
            return JSON.parse(authJson);
        }
        catch (error) {
            console.error(`Error getting auth config for server ${serverId}:`, error);
            return undefined;
        }
    }
    /**
     * Set the authentication configuration for a server
     * @param serverId Server ID
     * @param config Authentication configuration
     * @returns Promise that resolves when the configuration is saved
     */
    async setAuthConfig(serverId, config) {
        try {
            await this.secretStorage.store(`${AuthManager.SECRET_STORAGE_PREFIX}${serverId}`, JSON.stringify(config));
            // Notify listeners
            this._onDidChangeAuth.fire(serverId);
        }
        catch (error) {
            console.error(`Error setting auth config for server ${serverId}:`, error);
            throw error;
        }
    }
    /**
     * Delete the authentication configuration for a server
     * @param serverId Server ID
     * @returns Promise that resolves when the configuration is deleted
     */
    async deleteAuthConfig(serverId) {
        try {
            await this.secretStorage.delete(`${AuthManager.SECRET_STORAGE_PREFIX}${serverId}`);
            // Notify listeners
            this._onDidChangeAuth.fire(serverId);
        }
        catch (error) {
            console.error(`Error deleting auth config for server ${serverId}:`, error);
            throw error;
        }
    }
    /**
     * Check if a server has authentication configured
     * @param serverId Server ID
     * @returns Promise that resolves to true if the server has authentication configured
     */
    async hasAuthConfig(serverId) {
        try {
            const authJson = await this.secretStorage.get(`${AuthManager.SECRET_STORAGE_PREFIX}${serverId}`);
            return !!authJson;
        }
        catch (error) {
            console.error(`Error checking auth config for server ${serverId}:`, error);
            return false;
        }
    }
    /**
     * Get authentication headers for a server
     * @param serverId Server ID
     * @returns Promise that resolves to the authentication headers
     */
    async getAuthHeaders(serverId) {
        try {
            const config = await this.getAuthConfig(serverId);
            if (!config) {
                return undefined;
            }
            switch (config.type) {
                case 'token':
                    return {
                        'Authorization': `Bearer ${config.token}`
                    };
                case 'basic':
                    const credentials = Buffer.from(`${config.username}:${config.password}`).toString('base64');
                    return {
                        'Authorization': `Basic ${credentials}`
                    };
                case 'api_key':
                    return {
                        [config.headerName || 'X-API-Key']: config.apiKey
                    };
                case 'oauth2':
                    return {
                        'Authorization': `Bearer ${config.accessToken}`
                    };
                default:
                    return undefined;
            }
        }
        catch (error) {
            console.error(`Error getting auth headers for server ${serverId}:`, error);
            return undefined;
        }
    }
    /**
     * Check if a token needs to be refreshed
     * @param serverId Server ID
     * @returns Promise that resolves to true if the token needs to be refreshed
     */
    async needsTokenRefresh(serverId) {
        try {
            const config = await this.getAuthConfig(serverId);
            if (!config || config.type !== 'oauth2' || !config.expiresAt) {
                return false;
            }
            // Check if the token expires in less than 5 minutes
            const expiresAt = new Date(config.expiresAt).getTime();
            const now = Date.now();
            const fiveMinutesMs = 5 * 60 * 1000;
            return expiresAt - now < fiveMinutesMs;
        }
        catch (error) {
            console.error(`Error checking token refresh for server ${serverId}:`, error);
            return false;
        }
    }
    /**
     * Refresh an OAuth2 token
     * @param serverId Server ID
     * @returns Promise that resolves when the token is refreshed
     */
    async refreshOAuthToken(serverId) {
        try {
            const config = await this.getAuthConfig(serverId);
            if (!config || config.type !== 'oauth2' || !config.refreshToken || !config.tokenUrl) {
                throw new Error('Invalid OAuth2 configuration');
            }
            // Prepare the request
            const params = new URLSearchParams();
            params.append('grant_type', 'refresh_token');
            params.append('refresh_token', config.refreshToken);
            if (config.clientId) {
                params.append('client_id', config.clientId);
            }
            if (config.clientSecret) {
                params.append('client_secret', config.clientSecret);
            }
            // Make the request
            const response = await fetch(config.tokenUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded'
                },
                body: params.toString()
            });
            if (!response.ok) {
                throw new Error(`Token refresh failed: ${response.statusText}`);
            }
            // Parse the response
            const data = await response.json();
            if (!data.access_token) {
                throw new Error('Token refresh response missing access_token');
            }
            // Update the configuration
            const updatedConfig = {
                ...config,
                accessToken: data.access_token,
                expiresAt: data.expires_in ? new Date(Date.now() + data.expires_in * 1000).toISOString() : undefined,
                refreshToken: data.refresh_token || config.refreshToken
            };
            // Save the updated configuration
            await this.setAuthConfig(serverId, updatedConfig);
        }
        catch (error) {
            console.error(`Error refreshing OAuth token for server ${serverId}:`, error);
            throw error;
        }
    }
    /**
     * Handle authentication for a server
     * @param server Server
     * @returns Promise that resolves when authentication is handled
     */
    async handleAuthentication(server) {
        try {
            // Check if the server requires authentication
            if (!server.schema?.authentication?.required) {
                return;
            }
            // Check if we have authentication configured
            const hasAuth = await this.hasAuthConfig(server.id);
            if (!hasAuth) {
                // Prompt the user to configure authentication
                const configureNow = 'Configure Now';
                const response = await vscode.window.showWarningMessage(`Server ${server.name} requires authentication. Would you like to configure it now?`, configureNow);
                if (response === configureNow) {
                    await this.promptForAuthentication(server);
                }
                else {
                    throw new Error('Authentication required but not configured');
                }
            }
            // Check if we need to refresh the token
            const needsRefresh = await this.needsTokenRefresh(server.id);
            if (needsRefresh) {
                await this.refreshOAuthToken(server.id);
            }
        }
        catch (error) {
            console.error(`Error handling authentication for server ${server.id}:`, error);
            throw error;
        }
    }
    /**
     * Prompt the user to configure authentication for a server
     * @param server Server
     * @returns Promise that resolves when authentication is configured
     */
    async promptForAuthentication(server) {
        try {
            // Check if the server has authentication information
            if (!server.schema?.authentication) {
                throw new Error('Server does not have authentication information');
            }
            const authType = server.schema.authentication.type;
            switch (authType) {
                case 'token':
                    await this.promptForTokenAuth(server);
                    break;
                case 'basic':
                    await this.promptForBasicAuth(server);
                    break;
                case 'api_key':
                    await this.promptForApiKeyAuth(server);
                    break;
                case 'oauth2':
                    await this.promptForOAuth2Auth(server);
                    break;
                default:
                    throw new Error(`Unsupported authentication type: ${authType}`);
            }
        }
        catch (error) {
            console.error(`Error prompting for authentication for server ${server.id}:`, error);
            throw error;
        }
    }
    /**
     * Prompt the user for token authentication
     * @param server Server
     * @returns Promise that resolves when authentication is configured
     */
    async promptForTokenAuth(server) {
        const token = await vscode.window.showInputBox({
            prompt: `Enter token for ${server.name}`,
            password: true,
            ignoreFocusOut: true
        });
        if (!token) {
            throw new Error('Token is required');
        }
        const config = {
            type: 'token',
            token
        };
        await this.setAuthConfig(server.id, config);
    }
    /**
     * Prompt the user for basic authentication
     * @param server Server
     * @returns Promise that resolves when authentication is configured
     */
    async promptForBasicAuth(server) {
        const username = await vscode.window.showInputBox({
            prompt: `Enter username for ${server.name}`,
            ignoreFocusOut: true
        });
        if (!username) {
            throw new Error('Username is required');
        }
        const password = await vscode.window.showInputBox({
            prompt: `Enter password for ${server.name}`,
            password: true,
            ignoreFocusOut: true
        });
        if (!password) {
            throw new Error('Password is required');
        }
        const config = {
            type: 'basic',
            username,
            password
        };
        await this.setAuthConfig(server.id, config);
    }
    /**
     * Prompt the user for API key authentication
     * @param server Server
     * @returns Promise that resolves when authentication is configured
     */
    async promptForApiKeyAuth(server) {
        const apiKey = await vscode.window.showInputBox({
            prompt: `Enter API key for ${server.name}`,
            password: true,
            ignoreFocusOut: true
        });
        if (!apiKey) {
            throw new Error('API key is required');
        }
        const headerName = await vscode.window.showInputBox({
            prompt: `Enter header name for API key (default: X-API-Key)`,
            value: 'X-API-Key',
            ignoreFocusOut: true
        });
        const config = {
            type: 'api_key',
            apiKey,
            headerName: headerName || 'X-API-Key'
        };
        await this.setAuthConfig(server.id, config);
    }
    /**
     * Prompt the user for OAuth2 authentication
     * @param server Server
     * @returns Promise that resolves when authentication is configured
     */
    async promptForOAuth2Auth(server) {
        // This is a simplified implementation
        // A real implementation would use the OAuth2 flow with a web view
        const clientId = await vscode.window.showInputBox({
            prompt: `Enter client ID for ${server.name}`,
            ignoreFocusOut: true
        });
        if (!clientId) {
            throw new Error('Client ID is required');
        }
        const clientSecret = await vscode.window.showInputBox({
            prompt: `Enter client secret for ${server.name}`,
            password: true,
            ignoreFocusOut: true
        });
        if (!clientSecret) {
            throw new Error('Client secret is required');
        }
        const authUrl = await vscode.window.showInputBox({
            prompt: `Enter authorization URL for ${server.name}`,
            ignoreFocusOut: true
        });
        if (!authUrl) {
            throw new Error('Authorization URL is required');
        }
        const tokenUrl = await vscode.window.showInputBox({
            prompt: `Enter token URL for ${server.name}`,
            ignoreFocusOut: true
        });
        if (!tokenUrl) {
            throw new Error('Token URL is required');
        }
        const scopes = await vscode.window.showInputBox({
            prompt: `Enter scopes for ${server.name} (space-separated)`,
            ignoreFocusOut: true
        });
        // In a real implementation, we would now start the OAuth2 flow
        // For now, we'll just store the configuration without the tokens
        const config = {
            type: 'oauth2',
            clientId,
            clientSecret,
            authUrl,
            tokenUrl,
            scopes: scopes?.split(' ') || [],
            accessToken: '',
            refreshToken: '',
            expiresAt: new Date(Date.now()).toISOString()
        };
        await this.setAuthConfig(server.id, config);
        // Show a message to the user
        vscode.window.showInformationMessage('OAuth2 configuration saved. You will need to authenticate the first time you use this server.');
    }
}
exports.AuthManager = AuthManager;
AuthManager.SECRET_STORAGE_PREFIX = 'qwen-coder-assistant.mcp-auth.';
//# sourceMappingURL=authManager.js.map
```


---

### File: `out/mcp-client/telemetry/telemetryManager.js`

```javascript
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.TelemetryManager = exports.TelemetryEventType = void 0;
const vscode = __importStar(require("vscode"));
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
/**
 * Telemetry event type
 */
var TelemetryEventType;
(function (TelemetryEventType) {
    TelemetryEventType["SERVER_START"] = "server_start";
    TelemetryEventType["SERVER_STOP"] = "server_stop";
    TelemetryEventType["SERVER_ERROR"] = "server_error";
    TelemetryEventType["TOOL_INVOCATION"] = "tool_invocation";
    TelemetryEventType["TOOL_ERROR"] = "tool_error";
    TelemetryEventType["HEALTH_CHECK"] = "health_check";
    TelemetryEventType["AUTHENTICATION"] = "authentication";
})(TelemetryEventType || (exports.TelemetryEventType = TelemetryEventType = {}));
/**
 * Telemetry manager for MCP servers
 */
class TelemetryManager {
    /**
     * Create a new telemetry manager
     * @param context Extension context
     * @param options Telemetry options
     */
    constructor(context, options = {}) {
        this.events = new Map();
        this.stats = new Map();
        this._onDidCollectTelemetry = new vscode.EventEmitter();
        /**
         * Event that fires when telemetry is collected
         */
        this.onDidCollectTelemetry = this._onDidCollectTelemetry.event;
        this.telemetryEnabled = options.telemetryEnabled !== false;
        this.telemetryDir = options.telemetryDir || path.join(context.globalStorageUri.fsPath, 'telemetry');
        this.maxEventsPerFile = options.maxEventsPerFile || 1000;
        // Create telemetry directory if it doesn't exist
        if (this.telemetryEnabled && !fs.existsSync(this.telemetryDir)) {
            fs.mkdirSync(this.telemetryDir, { recursive: true });
        }
        // Load existing telemetry data
        this.loadTelemetry();
        // Register the telemetry manager with the extension context
        context.subscriptions.push(this);
    }
    /**
     * Dispose of resources
     */
    dispose() {
        this._onDidCollectTelemetry.dispose();
        // Save telemetry data
        this.saveTelemetry();
    }
    /**
     * Track a server start event
     * @param server Server
     */
    trackServerStart(server) {
        if (!this.telemetryEnabled) {
            return;
        }
        const event = {
            type: TelemetryEventType.SERVER_START,
            timestamp: new Date().toISOString(),
            serverId: server.id,
            serverName: server.name,
            serverVersion: server.version
        };
        this.trackEvent(event);
        this.updateStats(server.id, stats => {
            stats.startCount++;
            stats.lastStarted = event.timestamp;
        });
    }
    /**
     * Track a server stop event
     * @param server Server
     * @param duration Duration in milliseconds
     */
    trackServerStop(server, duration) {
        if (!this.telemetryEnabled) {
            return;
        }
        const event = {
            type: TelemetryEventType.SERVER_STOP,
            timestamp: new Date().toISOString(),
            serverId: server.id,
            serverName: server.name,
            serverVersion: server.version,
            duration
        };
        this.trackEvent(event);
        this.updateStats(server.id, stats => {
            stats.stopCount++;
            stats.lastStopped = event.timestamp;
            stats.uptime += duration;
        });
    }
    /**
     * Track a server error event
     * @param server Server
     * @param errorMessage Error message
     */
    trackServerError(server, errorMessage) {
        if (!this.telemetryEnabled) {
            return;
        }
        const event = {
            type: TelemetryEventType.SERVER_ERROR,
            timestamp: new Date().toISOString(),
            serverId: server.id,
            serverName: server.name,
            serverVersion: server.version,
            errorMessage
        };
        this.trackEvent(event);
        this.updateStats(server.id, stats => {
            stats.errorCount++;
            stats.lastError = event.timestamp;
        });
    }
    /**
     * Track a tool invocation event
     * @param server Server
     * @param toolName Tool name
     * @param toolParameters Tool parameters
     * @param success Whether the invocation was successful
     * @param errorMessage Error message if the invocation failed
     * @param duration Duration in milliseconds
     */
    trackToolInvocation(server, toolName, toolParameters, success, errorMessage, duration) {
        if (!this.telemetryEnabled) {
            return;
        }
        const event = {
            type: success ? TelemetryEventType.TOOL_INVOCATION : TelemetryEventType.TOOL_ERROR,
            timestamp: new Date().toISOString(),
            serverId: server.id,
            serverName: server.name,
            serverVersion: server.version,
            toolName,
            toolParameters,
            success,
            errorMessage,
            duration
        };
        this.trackEvent(event);
        this.updateStats(server.id, stats => {
            if (success) {
                stats.toolInvocations++;
                stats.lastToolInvocation = event.timestamp;
            }
            else {
                stats.toolErrors++;
            }
            // Update tool usage
            stats.toolUsage[toolName] = (stats.toolUsage[toolName] || 0) + 1;
        });
    }
    /**
     * Track a health check event
     * @param server Server
     * @param healthStatus Health status
     */
    trackHealthCheck(server, healthStatus) {
        if (!this.telemetryEnabled) {
            return;
        }
        const event = {
            type: TelemetryEventType.HEALTH_CHECK,
            timestamp: new Date().toISOString(),
            serverId: server.id,
            serverName: server.name,
            serverVersion: server.version,
            healthStatus
        };
        this.trackEvent(event);
        this.updateStats(server.id, stats => {
            stats.healthChecks++;
            stats.lastHealthCheck = event.timestamp;
        });
    }
    /**
     * Track an authentication event
     * @param server Server
     * @param authType Authentication type
     * @param success Whether the authentication was successful
     * @param errorMessage Error message if the authentication failed
     */
    trackAuthentication(server, authType, success, errorMessage) {
        if (!this.telemetryEnabled) {
            return;
        }
        const event = {
            type: TelemetryEventType.AUTHENTICATION,
            timestamp: new Date().toISOString(),
            serverId: server.id,
            serverName: server.name,
            serverVersion: server.version,
            authType,
            success,
            errorMessage
        };
        this.trackEvent(event);
    }
    /**
     * Get usage statistics for all servers
     * @returns Server usage statistics
     */
    getUsageStats() {
        return Array.from(this.stats.values());
    }
    /**
     * Get usage statistics for a server
     * @param serverId Server ID
     * @returns Server usage statistics
     */
    getServerUsageStats(serverId) {
        return this.stats.get(serverId);
    }
    /**
     * Get telemetry events for a server
     * @param serverId Server ID
     * @param maxEvents Maximum number of events to return
     * @returns Telemetry events
     */
    getServerEvents(serverId, maxEvents = 100) {
        const events = this.events.get(serverId) || [];
        return events.slice(-maxEvents);
    }
    /**
     * Clear telemetry data for a server
     * @param serverId Server ID
     */
    clearServerTelemetry(serverId) {
        this.events.delete(serverId);
        this.stats.delete(serverId);
        // Delete telemetry files
        const eventsFilePath = this.getEventsFilePath(serverId);
        const statsFilePath = this.getStatsFilePath(serverId);
        if (fs.existsSync(eventsFilePath)) {
            fs.unlinkSync(eventsFilePath);
        }
        if (fs.existsSync(statsFilePath)) {
            fs.unlinkSync(statsFilePath);
        }
    }
    /**
     * Enable or disable telemetry
     * @param enabled Whether telemetry is enabled
     */
    setTelemetryEnabled(enabled) {
        this.telemetryEnabled = enabled;
        if (enabled) {
            // Create telemetry directory if it doesn't exist
            if (!fs.existsSync(this.telemetryDir)) {
                fs.mkdirSync(this.telemetryDir, { recursive: true });
            }
            // Load existing telemetry data
            this.loadTelemetry();
        }
        else {
            // Clear in-memory telemetry data
            this.events.clear();
            this.stats.clear();
        }
    }
    /**
     * Track a telemetry event
     * @param event Telemetry event
     */
    trackEvent(event) {
        // Add the event to the in-memory store
        const serverId = event.serverId;
        const serverEvents = this.events.get(serverId) || [];
        serverEvents.push(event);
        // Limit the number of events in memory
        if (serverEvents.length > this.maxEventsPerFile) {
            serverEvents.shift();
        }
        this.events.set(serverId, serverEvents);
        // Save the event to disk
        this.saveEvent(event);
        // Fire the event
        this._onDidCollectTelemetry.fire(event);
    }
    /**
     * Update server statistics
     * @param serverId Server ID
     * @param updater Function to update the statistics
     */
    updateStats(serverId, updater) {
        // Get or create the server stats
        const stats = this.stats.get(serverId) || {
            serverId,
            serverName: '',
            startCount: 0,
            stopCount: 0,
            errorCount: 0,
            toolInvocations: 0,
            toolErrors: 0,
            healthChecks: 0,
            uptime: 0,
            toolUsage: {}
        };
        // Update the stats
        updater(stats);
        // Store the updated stats
        this.stats.set(serverId, stats);
        // Save the stats to disk
        this.saveStats(serverId);
    }
    /**
     * Save a telemetry event to disk
     * @param event Telemetry event
     */
    saveEvent(event) {
        if (!this.telemetryEnabled) {
            return;
        }
        try {
            const serverId = event.serverId;
            const eventsFilePath = this.getEventsFilePath(serverId);
            // Append the event to the file
            const eventLine = JSON.stringify(event) + '\n';
            fs.appendFileSync(eventsFilePath, eventLine, 'utf8');
        }
        catch (error) {
            console.error(`Error saving telemetry event: ${error}`);
        }
    }
    /**
     * Save server statistics to disk
     * @param serverId Server ID
     */
    saveStats(serverId) {
        if (!this.telemetryEnabled) {
            return;
        }
        try {
            const stats = this.stats.get(serverId);
            if (!stats) {
                return;
            }
            const statsFilePath = this.getStatsFilePath(serverId);
            fs.writeFileSync(statsFilePath, JSON.stringify(stats, null, 2), 'utf8');
        }
        catch (error) {
            console.error(`Error saving telemetry stats: ${error}`);
        }
    }
    /**
     * Save all telemetry data to disk
     */
    saveTelemetry() {
        if (!this.telemetryEnabled) {
            return;
        }
        // Save all server stats
        for (const serverId of this.stats.keys()) {
            this.saveStats(serverId);
        }
    }
    /**
     * Load telemetry data from disk
     */
    loadTelemetry() {
        if (!this.telemetryEnabled || !fs.existsSync(this.telemetryDir)) {
            return;
        }
        try {
            // Get all server IDs from the telemetry directory
            const files = fs.readdirSync(this.telemetryDir);
            const statsFiles = files.filter(file => file.endsWith('.stats.json'));
            const serverIds = statsFiles.map(file => file.replace('.stats.json', ''));
            // Load stats for each server
            for (const serverId of serverIds) {
                this.loadStats(serverId);
                this.loadEvents(serverId);
            }
        }
        catch (error) {
            console.error(`Error loading telemetry data: ${error}`);
        }
    }
    /**
     * Load server statistics from disk
     * @param serverId Server ID
     */
    loadStats(serverId) {
        try {
            const statsFilePath = this.getStatsFilePath(serverId);
            if (!fs.existsSync(statsFilePath)) {
                return;
            }
            const statsJson = fs.readFileSync(statsFilePath, 'utf8');
            const stats = JSON.parse(statsJson);
            this.stats.set(serverId, stats);
        }
        catch (error) {
            console.error(`Error loading telemetry stats for ${serverId}: ${error}`);
        }
    }
    /**
     * Load telemetry events from disk
     * @param serverId Server ID
     */
    loadEvents(serverId) {
        try {
            const eventsFilePath = this.getEventsFilePath(serverId);
            if (!fs.existsSync(eventsFilePath)) {
                return;
            }
            const eventsContent = fs.readFileSync(eventsFilePath, 'utf8');
            const eventLines = eventsContent.split('\n').filter(line => line.trim().length > 0);
            const events = [];
            // Parse the most recent events
            const startIndex = Math.max(0, eventLines.length - this.maxEventsPerFile);
            for (let i = startIndex; i < eventLines.length; i++) {
                try {
                    const event = JSON.parse(eventLines[i]);
                    events.push(event);
                }
                catch (error) {
                    console.error(`Error parsing telemetry event: ${error}`);
                }
            }
            this.events.set(serverId, events);
        }
        catch (error) {
            console.error(`Error loading telemetry events for ${serverId}: ${error}`);
        }
    }
    /**
     * Get the events file path for a server
     * @param serverId Server ID
     * @returns Events file path
     */
    getEventsFilePath(serverId) {
        return path.join(this.telemetryDir, `${serverId}.events.jsonl`);
    }
    /**
     * Get the stats file path for a server
     * @param serverId Server ID
     * @returns Stats file path
     */
    getStatsFilePath(serverId) {
        return path.join(this.telemetryDir, `${serverId}.stats.json`);
    }
}
exports.TelemetryManager = TelemetryManager;
//# sourceMappingURL=telemetryManager.js.map
```


---

### File: `out/mcp-client/discovery/serverDiscovery.js`

```javascript
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.ServerDiscovery = void 0;
const vscode = __importStar(require("vscode"));
const os = __importStar(require("os"));
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const dns = __importStar(require("dns"));
/**
 * Server discovery for MCP servers
 */
class ServerDiscovery {
    /**
     * Create a new server discovery
     * @param serverManager MCP server manager
     * @param githubManager GitHub repository manager
     * @param options Server discovery options
     */
    constructor(serverManager, githubManager, options = {}) {
        this._onDidDiscoverServers = new vscode.EventEmitter();
        /**
         * Event that fires when servers are discovered
         */
        this.onDidDiscoverServers = this._onDidDiscoverServers.event;
        this.serverManager = serverManager;
        this.githubManager = githubManager;
        this.registryUrl = options.registryUrl || 'https://registry.modelcontextprotocol.io';
    }
    /**
     * Dispose of resources
     */
    dispose() {
        this._onDidDiscoverServers.dispose();
    }
    /**
     * Discover servers
     * @param options Discovery options
     * @returns Promise that resolves to the discovered servers
     */
    async discoverServers(options = {}) {
        const results = [];
        const maxResults = options.maxResults || 100;
        // Get installed servers
        const installedServers = this.serverManager.getServers();
        const installedRepoUrls = new Set(installedServers.map(server => server.repoUrl));
        // Discover servers from the registry
        if (options.includeRegistry !== false) {
            try {
                const registryResults = await this.discoverFromRegistry(options.searchQuery);
                for (const result of registryResults) {
                    // Check if the server is already installed
                    result.installed = installedRepoUrls.has(result.repoUrl);
                    if (result.installed) {
                        const server = installedServers.find(s => s.repoUrl === result.repoUrl);
                        if (server) {
                            result.serverId = server.id;
                        }
                    }
                    results.push(result);
                    // Check if we've reached the maximum number of results
                    if (results.length >= maxResults) {
                        break;
                    }
                }
            }
            catch (error) {
                console.error('Error discovering servers from registry:', error);
            }
        }
        // Discover servers from GitHub
        if (options.includeGitHub !== false && results.length < maxResults) {
            try {
                const githubResults = await this.discoverFromGitHub(options.searchQuery);
                for (const result of githubResults) {
                    // Check if the server is already installed
                    result.installed = installedRepoUrls.has(result.repoUrl);
                    if (result.installed) {
                        const server = installedServers.find(s => s.repoUrl === result.repoUrl);
                        if (server) {
                            result.serverId = server.id;
                        }
                    }
                    // Check if the result is already in the list
                    if (!results.some(r => r.repoUrl === result.repoUrl)) {
                        results.push(result);
                    }
                    // Check if we've reached the maximum number of results
                    if (results.length >= maxResults) {
                        break;
                    }
                }
            }
            catch (error) {
                console.error('Error discovering servers from GitHub:', error);
            }
        }
        // Discover servers from the local network
        if (options.includeNetwork !== false && results.length < maxResults) {
            try {
                const networkResults = await this.discoverFromNetwork();
                for (const result of networkResults) {
                    // Check if the result is already in the list
                    if (!results.some(r => r.repoUrl === result.repoUrl)) {
                        results.push(result);
                    }
                    // Check if we've reached the maximum number of results
                    if (results.length >= maxResults) {
                        break;
                    }
                }
            }
            catch (error) {
                console.error('Error discovering servers from network:', error);
            }
        }
        // Discover servers from the local filesystem
        if (options.includeLocal !== false && results.length < maxResults) {
            try {
                const localResults = await this.discoverFromLocal();
                for (const result of localResults) {
                    // Check if the server is already installed
                    result.installed = installedRepoUrls.has(result.repoUrl);
                    if (result.installed) {
                        const server = installedServers.find(s => s.repoUrl === result.repoUrl);
                        if (server) {
                            result.serverId = server.id;
                        }
                    }
                    // Check if the result is already in the list
                    if (!results.some(r => r.repoUrl === result.repoUrl)) {
                        results.push(result);
                    }
                    // Check if we've reached the maximum number of results
                    if (results.length >= maxResults) {
                        break;
                    }
                }
            }
            catch (error) {
                console.error('Error discovering servers from local filesystem:', error);
            }
        }
        // Filter results by search query if provided
        if (options.searchQuery) {
            const query = options.searchQuery.toLowerCase();
            const filteredResults = results.filter(result => {
                return (result.name.toLowerCase().includes(query) ||
                    result.description.toLowerCase().includes(query) ||
                    result.repoUrl.toLowerCase().includes(query));
            });
            // Notify listeners
            this._onDidDiscoverServers.fire(filteredResults);
            return filteredResults;
        }
        // Notify listeners
        this._onDidDiscoverServers.fire(results);
        return results;
    }
    /**
     * Discover servers from the MCP registry
     * @param searchQuery Search query
     * @returns Promise that resolves to the discovered servers
     */
    async discoverFromRegistry(searchQuery) {
        try {
            // Construct the registry URL
            let url = `${this.registryUrl}/api/servers`;
            if (searchQuery) {
                url += `?q=${encodeURIComponent(searchQuery)}`;
            }
            // Fetch the servers from the registry
            const response = await fetch(url, {
                method: 'GET',
                headers: {
                    'Accept': 'application/json'
                }
            });
            if (!response.ok) {
                throw new Error(`Error fetching servers from registry: ${response.statusText}`);
            }
            const data = await response.json();
            if (!Array.isArray(data)) {
                throw new Error('Invalid response from registry');
            }
            // Convert the registry data to discovery results
            return data.map(item => ({
                name: item.name,
                description: item.description,
                repoUrl: item.repoUrl,
                version: item.version,
                source: 'registry',
                official: item.official || false,
                installed: false
            }));
        }
        catch (error) {
            console.error('Error discovering servers from registry:', error);
            return [];
        }
    }
    /**
     * Discover servers from GitHub
     * @param searchQuery Search query
     * @returns Promise that resolves to the discovered servers
     */
    async discoverFromGitHub(searchQuery) {
        try {
            // Construct the search query
            const query = searchQuery
                ? `mcp-server ${searchQuery} in:name,description,readme`
                : 'mcp-server in:name,description,readme';
            // Search for repositories on GitHub
            const repositories = await this.githubManager.searchRepositories(query);
            // Convert the GitHub data to discovery results
            return repositories.map(repo => ({
                name: repo.name,
                description: repo.description || '',
                repoUrl: repo.html_url,
                version: '',
                source: 'github',
                official: repo.owner.login === 'modelcontextprotocol',
                installed: false
            }));
        }
        catch (error) {
            console.error('Error discovering servers from GitHub:', error);
            return [];
        }
    }
    /**
     * Discover servers from the local network
     * @returns Promise that resolves to the discovered servers
     */
    async discoverFromNetwork() {
        try {
            // This is a placeholder implementation
            // In a real implementation, you would use mDNS or a similar protocol to discover MCP servers on the local network
            // Get the local IP addresses
            const interfaces = os.networkInterfaces();
            const localIps = [];
            for (const name in interfaces) {
                const networkInterface = interfaces[name];
                if (!networkInterface) {
                    continue;
                }
                for (const iface of networkInterface) {
                    if (iface.family === 'IPv4' && !iface.internal) {
                        localIps.push(iface.address);
                    }
                }
            }
            // Scan the local network for MCP servers
            const results = [];
            // This is a simplified implementation that just checks a few common ports
            // In a real implementation, you would use a more sophisticated discovery mechanism
            const ports = [8080, 8081, 8082, 8083, 8084, 8085];
            for (const ip of localIps) {
                // Get the network prefix
                const parts = ip.split('.');
                const prefix = `${parts[0]}.${parts[1]}.${parts[2]}`;
                // Scan the local network
                for (let i = 1; i <= 10; i++) {
                    const targetIp = `${prefix}.${i}`;
                    // Skip the local IP
                    if (targetIp === ip) {
                        continue;
                    }
                    // Check if the host is reachable
                    try {
                        await new Promise((resolve, reject) => {
                            dns.lookup(targetIp, (err) => {
                                if (err) {
                                    reject(err);
                                }
                                else {
                                    resolve();
                                }
                            });
                        });
                        // Check common ports for MCP servers
                        for (const port of ports) {
                            try {
                                const url = `http://${targetIp}:${port}/health`;
                                const response = await fetch(url, {
                                    method: 'GET',
                                    headers: {
                                        'Accept': 'application/json'
                                    },
                                    timeout: 1000
                                });
                                if (response.ok) {
                                    // Try to get the server information
                                    const infoUrl = `http://${targetIp}:${port}/info`;
                                    const infoResponse = await fetch(infoUrl, {
                                        method: 'GET',
                                        headers: {
                                            'Accept': 'application/json'
                                        },
                                        timeout: 1000
                                    });
                                    if (infoResponse.ok) {
                                        const info = await infoResponse.json();
                                        results.push({
                                            name: info.name || `MCP Server at ${targetIp}:${port}`,
                                            description: info.description || 'Discovered on local network',
                                            repoUrl: info.repoUrl || `http://${targetIp}:${port}`,
                                            version: info.version || '',
                                            source: 'network',
                                            official: false,
                                            installed: false
                                        });
                                    }
                                    else {
                                        // Add a generic result
                                        results.push({
                                            name: `MCP Server at ${targetIp}:${port}`,
                                            description: 'Discovered on local network',
                                            repoUrl: `http://${targetIp}:${port}`,
                                            version: '',
                                            source: 'network',
                                            official: false,
                                            installed: false
                                        });
                                    }
                                }
                            }
                            catch (error) {
                                // Ignore errors - the server might not be running on this port
                            }
                        }
                    }
                    catch (error) {
                        // Ignore errors - the host might not be reachable
                    }
                }
            }
            return results;
        }
        catch (error) {
            console.error('Error discovering servers from network:', error);
            return [];
        }
    }
    /**
     * Discover servers from the local filesystem
     * @returns Promise that resolves to the discovered servers
     */
    async discoverFromLocal() {
        try {
            const results = [];
            // Check common directories for MCP servers
            const homeDir = os.homedir();
            const directories = [
                path.join(homeDir, 'mcp-servers'),
                path.join(homeDir, 'Documents', 'mcp-servers'),
                path.join(homeDir, 'Projects', 'mcp-servers'),
                path.join(homeDir, 'git', 'mcp-servers')
            ];
            for (const directory of directories) {
                if (!fs.existsSync(directory)) {
                    continue;
                }
                // Get all subdirectories
                const subdirs = fs.readdirSync(directory, { withFileTypes: true })
                    .filter(dirent => dirent.isDirectory())
                    .map(dirent => dirent.name);
                for (const subdir of subdirs) {
                    const serverDir = path.join(directory, subdir);
                    // Check if this is an MCP server
                    const schemaPath = path.join(serverDir, 'mcp.json');
                    if (!fs.existsSync(schemaPath)) {
                        continue;
                    }
                    try {
                        // Read the schema file
                        const schemaData = fs.readFileSync(schemaPath, 'utf8');
                        const schema = JSON.parse(schemaData);
                        // Check if this is a valid MCP schema
                        if (!schema.name || !schema.description || !schema.tools || !Array.isArray(schema.tools)) {
                            continue;
                        }
                        // Check if there's a package.json file with repository information
                        let repoUrl = '';
                        const packagePath = path.join(serverDir, 'package.json');
                        if (fs.existsSync(packagePath)) {
                            try {
                                const packageData = fs.readFileSync(packagePath, 'utf8');
                                const packageJson = JSON.parse(packageData);
                                if (packageJson.repository) {
                                    if (typeof packageJson.repository === 'string') {
                                        repoUrl = packageJson.repository;
                                    }
                                    else if (packageJson.repository.url) {
                                        repoUrl = packageJson.repository.url;
                                    }
                                }
                            }
                            catch (error) {
                                // Ignore errors reading package.json
                            }
                        }
                        // Add the result
                        results.push({
                            name: schema.name,
                            description: schema.description,
                            repoUrl: repoUrl || `file://${serverDir}`,
                            version: schema.version || '',
                            source: 'local',
                            official: false,
                            installed: false
                        });
                    }
                    catch (error) {
                        // Ignore errors reading the schema file
                    }
                }
            }
            return results;
        }
        catch (error) {
            console.error('Error discovering servers from local filesystem:', error);
            return [];
        }
    }
}
exports.ServerDiscovery = ServerDiscovery;
//# sourceMappingURL=serverDiscovery.js.map
```


---

### File: `out/mcp-client/logging/mcpLogger.js`

```javascript
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.McpLogger = exports.LogLevel = void 0;
const vscode = __importStar(require("vscode"));
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
/**
 * Log level
 */
var LogLevel;
(function (LogLevel) {
    LogLevel["DEBUG"] = "DEBUG";
    LogLevel["INFO"] = "INFO";
    LogLevel["WARNING"] = "WARNING";
    LogLevel["ERROR"] = "ERROR";
})(LogLevel || (exports.LogLevel = LogLevel = {}));
/**
 * Logger for MCP servers
 */
class McpLogger {
    /**
     * Create a new MCP logger
     * @param context Extension context
     * @param options Logger options
     */
    constructor(context, options = {}) {
        this._onDidLog = new vscode.EventEmitter();
        /**
         * Event that fires when a log entry is added
         */
        this.onDidLog = this._onDidLog.event;
        this.outputChannel = vscode.window.createOutputChannel('MCP Servers');
        this.logDir = options.logDir || path.join(context.globalStorageUri.fsPath, 'logs');
        this.maxLogSize = options.maxLogSize || 5 * 1024 * 1024; // 5 MB
        this.maxLogFiles = options.maxLogFiles || 10;
        this.logEnabled = options.logEnabled !== false;
        this.fileLogEnabled = options.fileLogEnabled !== false;
        // Create log directory if it doesn't exist
        if (this.fileLogEnabled && !fs.existsSync(this.logDir)) {
            fs.mkdirSync(this.logDir, { recursive: true });
        }
        // Register the logger with the extension context
        context.subscriptions.push(this);
    }
    /**
     * Dispose of resources
     */
    dispose() {
        this.outputChannel.dispose();
        this._onDidLog.dispose();
    }
    /**
     * Log a message
     * @param level Log level
     * @param serverId Server ID
     * @param message Message
     * @param data Additional data
     */
    log(level, serverId, message, data) {
        if (!this.logEnabled) {
            return;
        }
        const timestamp = new Date().toISOString();
        const entry = {
            timestamp,
            level,
            serverId,
            message,
            data
        };
        // Log to output channel
        this.logToOutputChannel(entry);
        // Log to file
        if (this.fileLogEnabled) {
            this.logToFile(entry);
        }
        // Fire event
        this._onDidLog.fire(entry);
    }
    /**
     * Log a debug message
     * @param serverId Server ID
     * @param message Message
     * @param data Additional data
     */
    debug(serverId, message, data) {
        this.log(LogLevel.DEBUG, serverId, message, data);
    }
    /**
     * Log an info message
     * @param serverId Server ID
     * @param message Message
     * @param data Additional data
     */
    info(serverId, message, data) {
        this.log(LogLevel.INFO, serverId, message, data);
    }
    /**
     * Log a warning message
     * @param serverId Server ID
     * @param message Message
     * @param data Additional data
     */
    warning(serverId, message, data) {
        this.log(LogLevel.WARNING, serverId, message, data);
    }
    /**
     * Log an error message
     * @param serverId Server ID
     * @param message Message
     * @param data Additional data
     */
    error(serverId, message, data) {
        this.log(LogLevel.ERROR, serverId, message, data);
    }
    /**
     * Show the log output channel
     */
    show() {
        this.outputChannel.show();
    }
    /**
     * Get the log file path for a server
     * @param serverId Server ID
     * @returns Log file path
     */
    getLogFilePath(serverId) {
        return path.join(this.logDir, `${serverId}.log`);
    }
    /**
     * Get the log entries for a server
     * @param serverId Server ID
     * @param maxEntries Maximum number of entries to return
     * @returns Log entries
     */
    getLogEntries(serverId, maxEntries = 100) {
        if (!this.fileLogEnabled) {
            return [];
        }
        const logFilePath = this.getLogFilePath(serverId);
        if (!fs.existsSync(logFilePath)) {
            return [];
        }
        try {
            const logContent = fs.readFileSync(logFilePath, 'utf8');
            const lines = logContent.split('\n').filter(line => line.trim().length > 0);
            const entries = [];
            // Parse the most recent entries
            const startIndex = Math.max(0, lines.length - maxEntries);
            for (let i = startIndex; i < lines.length; i++) {
                try {
                    const entry = JSON.parse(lines[i]);
                    entries.push(entry);
                }
                catch (error) {
                    console.error(`Error parsing log entry: ${error}`);
                }
            }
            return entries;
        }
        catch (error) {
            console.error(`Error reading log file: ${error}`);
            return [];
        }
    }
    /**
     * Clear the logs for a server
     * @param serverId Server ID
     */
    clearLogs(serverId) {
        if (!this.fileLogEnabled) {
            return;
        }
        const logFilePath = this.getLogFilePath(serverId);
        if (fs.existsSync(logFilePath)) {
            fs.writeFileSync(logFilePath, '', 'utf8');
        }
    }
    /**
     * Log to the output channel
     * @param entry Log entry
     */
    logToOutputChannel(entry) {
        const { timestamp, level, serverId, message, data } = entry;
        let logMessage = `[${timestamp}] [${level}] [${serverId}] ${message}`;
        if (data !== undefined) {
            try {
                const dataStr = typeof data === 'string' ? data : JSON.stringify(data, null, 2);
                logMessage += `\n${dataStr}`;
            }
            catch (error) {
                logMessage += `\n[Error serializing data: ${error}]`;
            }
        }
        this.outputChannel.appendLine(logMessage);
    }
    /**
     * Log to a file
     * @param entry Log entry
     */
    logToFile(entry) {
        const { serverId } = entry;
        const logFilePath = this.getLogFilePath(serverId);
        try {
            // Check if log rotation is needed
            this.rotateLogFileIfNeeded(logFilePath);
            // Append the log entry to the file
            const logLine = JSON.stringify(entry) + '\n';
            fs.appendFileSync(logFilePath, logLine, 'utf8');
        }
        catch (error) {
            console.error(`Error writing to log file: ${error}`);
            this.outputChannel.appendLine(`[ERROR] Failed to write to log file: ${error}`);
        }
    }
    /**
     * Rotate the log file if needed
     * @param logFilePath Log file path
     */
    rotateLogFileIfNeeded(logFilePath) {
        if (!fs.existsSync(logFilePath)) {
            return;
        }
        try {
            const stats = fs.statSync(logFilePath);
            if (stats.size >= this.maxLogSize) {
                this.rotateLogFile(logFilePath);
            }
        }
        catch (error) {
            console.error(`Error checking log file size: ${error}`);
        }
    }
    /**
     * Rotate the log file
     * @param logFilePath Log file path
     */
    rotateLogFile(logFilePath) {
        try {
            // Delete the oldest log file if we have reached the maximum number of log files
            const baseLogPath = logFilePath;
            const rotatedLogPath = (index) => `${baseLogPath}.${index}`;
            // Check if we need to delete the oldest log file
            if (fs.existsSync(rotatedLogPath(this.maxLogFiles - 1))) {
                fs.unlinkSync(rotatedLogPath(this.maxLogFiles - 1));
            }
            // Shift all existing rotated log files
            for (let i = this.maxLogFiles - 2; i >= 0; i--) {
                const currentPath = rotatedLogPath(i);
                const nextPath = rotatedLogPath(i + 1);
                if (fs.existsSync(currentPath)) {
                    fs.renameSync(currentPath, nextPath);
                }
            }
            // Rename the current log file
            fs.renameSync(baseLogPath, rotatedLogPath(0));
            // Create a new empty log file
            fs.writeFileSync(baseLogPath, '', 'utf8');
        }
        catch (error) {
            console.error(`Error rotating log file: ${error}`);
        }
    }
}
exports.McpLogger = McpLogger;
//# sourceMappingURL=mcpLogger.js.map
```


---

### File: `archive/vscode-extension/src/contextProvider.js`

```javascript
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.getEditorContext = getEditorContext;
exports.getProjectContext = getProjectContext;
exports.getContextForFile = getContextForFile;
exports.getContextForSymbol = getContextForSymbol;
exports.initializeContextEngine = initializeContextEngine;
exports.disposeContextEngine = disposeContextEngine;
const path = __importStar(require("path"));
const vscode = __importStar(require("vscode"));
const contextEngine_1 = require("./context/contextEngine");
// Create a singleton instance of the context engine
const contextEngine = new contextEngine_1.ContextEngine();
async function getEditorContext() {
    const editor = vscode.window.activeTextEditor;
    if (!editor) {
        return null;
    }
    const document = editor.document;
    const selection = editor.selection;
    const selectedText = document.getText(selection);
    const fullText = document.getText();
    const fileName = path.basename(document.fileName);
    const fileExtension = path.extname(document.fileName).substring(1);
    const language = document.languageId;
    // Get visible range text
    const visibleRanges = editor.visibleRanges;
    let visibleText = '';
    for (const range of visibleRanges) {
        visibleText += document.getText(range) + '\n';
    }
    return {
        selectedCode: selectedText,
        fullDocumentText: fullText,
        fileName,
        fileExtension,
        language,
        selection: selection.isEmpty ? null : selection,
        visibleRangeText: visibleText
    };
}
async function getProjectContext(query = '', maxTokens = 4000) {
    try {
        // Initialize the context engine if it hasn't been initialized yet
        if (!contextEngine) {
            return "Context engine not available";
        }
        // Get context from the context engine
        return await contextEngine.getContext(query, maxTokens);
    }
    catch (error) {
        console.error('Error getting project context:', error);
        return `Error getting project context: ${error instanceof Error ? error.message : String(error)}`;
    }
}
async function getContextForFile(filePath, maxTokens = 4000) {
    try {
        // Initialize the context engine if it hasn't been initialized yet
        if (!contextEngine) {
            return "Context engine not available";
        }
        // Get context for the file
        return await contextEngine.getContextForFile(filePath, maxTokens);
    }
    catch (error) {
        console.error('Error getting file context:', error);
        return `Error getting file context: ${error instanceof Error ? error.message : String(error)}`;
    }
}
async function getContextForSymbol(symbol, maxTokens = 4000) {
    try {
        // Initialize the context engine if it hasn't been initialized yet
        if (!contextEngine) {
            return "Context engine not available";
        }
        // Get context for the symbol
        return await contextEngine.getContextForSymbol(symbol, maxTokens);
    }
    catch (error) {
        console.error('Error getting symbol context:', error);
        return `Error getting symbol context: ${error instanceof Error ? error.message : String(error)}`;
    }
}
async function initializeContextEngine() {
    try {
        await contextEngine.initialize();
    }
    catch (error) {
        console.error('Error initializing context engine:', error);
    }
}
async function disposeContextEngine() {
    try {
        await contextEngine.dispose();
    }
    catch (error) {
        console.error('Error disposing context engine:', error);
    }
}
//# sourceMappingURL=contextProvider.js.map
```


---

### File: `archive/vscode-extension/src/qwenApi.js`

```javascript
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.QwenApiClient = void 0;
const axios_1 = __importDefault(require("axios"));
const cache_1 = require("./cache");
const errorHandler_1 = require("./errorHandler");
class QwenApiClient {
    constructor(config) {
        this.config = config;
        this.client = axios_1.default.create({
            baseURL: config.apiEndpoint,
            headers: config.apiKey ? {
                'Authorization': `Bearer ${config.apiKey}`,
                'Content-Type': 'application/json'
            } : {
                'Content-Type': 'application/json'
            }
        });
        this.cache = cache_1.ResponseCache.getInstance();
    }
    updateConfig(config) {
        this.config = config;
        this.client = axios_1.default.create({
            baseURL: config.apiEndpoint,
            headers: config.apiKey ? {
                'Authorization': `Bearer ${config.apiKey}`,
                'Content-Type': 'application/json'
            } : {
                'Content-Type': 'application/json'
            }
        });
        // Update cache configuration if provided
        if (config.cacheTTLMinutes && config.cacheMaxEntries) {
            this.cache.configure(config.cacheMaxEntries, config.cacheTTLMinutes);
        }
    }
    async generateCompletion(options) {
        // Check cache first (unless skipCache is true)
        if (!options.skipCache) {
            const cacheKey = (0, cache_1.generateCacheKey)(options.prompt, {
                systemPrompt: options.systemPrompt,
                maxTokens: options.maxTokens || this.config.maxTokens,
                temperature: options.temperature || this.config.temperature
            });
            const cachedResponse = this.cache.get(cacheKey);
            if (cachedResponse) {
                console.log('Using cached response for prompt:', options.prompt.substring(0, 50) + '...');
                return {
                    ...cachedResponse,
                    cached: true
                };
            }
        }
        try {
            // Set timeout for the request
            const timeoutMs = 30000; // 30 seconds timeout
            const response = await this.client.post('/chat/completions', {
                model: 'qwen3-coder',
                messages: [
                    ...(options.systemPrompt ? [{ role: 'system', content: options.systemPrompt }] : []),
                    { role: 'user', content: options.prompt }
                ],
                max_tokens: options.maxTokens || this.config.maxTokens,
                temperature: options.temperature || this.config.temperature
            }, { timeout: timeoutMs });
            const result = {
                text: response.data.choices[0].message.content,
                usage: response.data.usage
            };
            // Cache the response (unless skipCache is true)
            if (!options.skipCache) {
                const cacheKey = (0, cache_1.generateCacheKey)(options.prompt, {
                    systemPrompt: options.systemPrompt,
                    maxTokens: options.maxTokens || this.config.maxTokens,
                    temperature: options.temperature || this.config.temperature
                });
                this.cache.set(cacheKey, result);
            }
            return result;
        }
        catch (error) {
            // Use the error handler to process the error
            const errorDetails = errorHandler_1.ErrorHandler.processError(error);
            console.error(`Error calling Qwen API: ${errorDetails.type}`, error);
            // Throw a more informative error
            throw new Error(errorDetails.message);
        }
    }
    /**
     * Generate a streaming completion
     * @param options Request options
     * @param onChunk Callback function to handle streaming chunks
     */
    async generateStreamingCompletion(options, onChunk) {
        // Streaming responses can't be cached, so we don't check the cache
        try {
            // Set timeout for the request
            const timeoutMs = 60000; // 60 seconds timeout for streaming
            const response = await this.client.post('/chat/completions', {
                model: 'qwen3-coder',
                messages: [
                    ...(options.systemPrompt ? [{ role: 'system', content: options.systemPrompt }] : []),
                    { role: 'user', content: options.prompt }
                ],
                max_tokens: options.maxTokens || this.config.maxTokens,
                temperature: options.temperature || this.config.temperature,
                stream: true
            }, {
                timeout: timeoutMs,
                responseType: 'stream'
            });
            // Process the streaming response
            const stream = response.data;
            stream.on('data', (chunk) => {
                try {
                    const lines = chunk.toString().split('\n').filter(line => line.trim() !== '');
                    for (const line of lines) {
                        // Skip empty lines and "data: [DONE]" messages
                        if (!line || line === 'data: [DONE]') {
                            continue;
                        }
                        // Remove the "data: " prefix
                        const jsonStr = line.replace(/^data: /, '');
                        try {
                            const json = JSON.parse(jsonStr);
                            if (json.choices && json.choices[0] && json.choices[0].delta && json.choices[0].delta.content) {
                                const content = json.choices[0].delta.content;
                                onChunk(content, false);
                            }
                        }
                        catch (parseError) {
                            console.error('Error parsing streaming response JSON:', parseError);
                        }
                    }
                }
                catch (error) {
                    console.error('Error processing stream chunk:', error);
                }
            });
            stream.on('end', () => {
                onChunk('', true); // Signal that streaming is complete
            });
            stream.on('error', (error) => {
                const errorDetails = errorHandler_1.ErrorHandler.processError(error);
                console.error(`Error in stream: ${errorDetails.type}`, error);
                throw new Error(errorDetails.message);
            });
        }
        catch (error) {
            // Use the error handler to process the error
            const errorDetails = errorHandler_1.ErrorHandler.processError(error);
            console.error(`Error setting up streaming: ${errorDetails.type}`, error);
            // Signal error to the handler
            onChunk(`Error: ${errorDetails.message}`, true);
            // Throw a more informative error
            throw new Error(errorDetails.message);
        }
    }
    /**
     * Clear the response cache
     */
    clearCache() {
        this.cache.clear();
    }
}
exports.QwenApiClient = QwenApiClient;
//# sourceMappingURL=qwenApi.js.map
```


---

### File: `archive/vscode-extension/src/errorHandler.ts`

```typescript
import * as vscode from 'vscode';
import axios, { AxiosError } from 'axios';

export enum ErrorType {
  NetworkError = 'NetworkError',
  AuthenticationError = 'AuthenticationError',
  RateLimitError = 'RateLimitError',
  ServerError = 'ServerError',
  TimeoutError = 'TimeoutError',
  UnknownError = 'UnknownError'
}

export interface ErrorDetails {
  type: ErrorType;
  message: string;
  originalError?: Error;
  retryable: boolean;
  suggestedAction?: string;
}

/**
 * Handles API errors and provides user-friendly error messages
 */
export class ErrorHandler {
  /**
   * Process an error and return structured error details
   * @param error The error to process
   * @returns Structured error details
   */
  public static processError(error: unknown): ErrorDetails {
    // Default error details
    let errorDetails: ErrorDetails = {
      type: ErrorType.UnknownError,
      message: 'An unknown error occurred',
      originalError: error instanceof Error ? error : undefined,
      retryable: false
    };

    // Handle Axios errors
    if (axios.isAxiosError(error)) {
      errorDetails = this.processAxiosError(error);
    } 
    // Handle timeout errors
    else if (error instanceof Error && error.message.includes('timeout')) {
      errorDetails = {
        type: ErrorType.TimeoutError,
        message: 'The request timed out. The server might be overloaded.',
        originalError: error,
        retryable: true,
        suggestedAction: 'Try again later or check your internet connection.'
      };
    } 
    // Handle other errors
    else if (error instanceof Error) {
      errorDetails = {
        type: ErrorType.UnknownError,
        message: `Error: ${error.message}`,
        originalError: error,
        retryable: false
      };
    }

    return errorDetails;
  }

  /**
   * Process an Axios error and return structured error details
   * @param error The Axios error to process
   * @returns Structured error details
   */
  private static processAxiosError(error: AxiosError): ErrorDetails {
    // Network errors
    if (error.code === 'ECONNABORTED' || error.code === 'ECONNREFUSED' || error.code === 'ENOTFOUND') {
      return {
        type: ErrorType.NetworkError,
        message: 'Could not connect to the API. Please check your internet connection.',
        originalError: error,
        retryable: true,
        suggestedAction: 'Check your network connection and try again.'
      };
    }

    // Handle based on HTTP status code
    switch (error.response?.status) {
      case 401:
      case 403:
        return {
          type: ErrorType.AuthenticationError,
          message: 'Authentication failed. Please check your API key.',
          originalError: error,
          retryable: false,
          suggestedAction: 'Update your API key in the extension settings.'
        };
      case 429:
        return {
          type: ErrorType.RateLimitError,
          message: 'Rate limit exceeded. Too many requests in a short period.',
          originalError: error,
          retryable: true,
          suggestedAction: 'Wait a moment before trying again.'
        };
      case 500:
      case 502:
      case 503:
      case 504:
        return {
          type: ErrorType.ServerError,
          message: `Server error (${error.response.status}). The API service might be experiencing issues.`,
          originalError: error,
          retryable: true,
          suggestedAction: 'Try again later.'
        };
      default:
        // Try to extract error message from response if available
        let message = 'An error occurred while communicating with the API.';
        try {
          if (error.response?.data) {
            if (typeof error.response.data === 'string') {
              message = error.response.data;
            } else if (typeof error.response.data === 'object' && error.response.data.error) {
              message = error.response.data.error;
            }
          }
        } catch (e) {
          // Ignore parsing errors
        }

        return {
          type: ErrorType.UnknownError,
          message,
          originalError: error,
          retryable: false
        };
    }
  }

  /**
   * Display an error message to the user
   * @param error The error details to display
   */
  public static showErrorToUser(error: ErrorDetails): void {
    const message = `${error.message}${error.suggestedAction ? '\n\n' + error.suggestedAction : ''}`;
    
    // Show different types of notifications based on error type
    if (error.retryable) {
      vscode.window.showWarningMessage(message, 'Retry').then(selection => {
        if (selection === 'Retry') {
          // Emit an event that can be listened to for retrying the operation
          // This will be implemented when we add the retry functionality
        }
      });
    } else {
      vscode.window.showErrorMessage(message);
    }

    // Log the error for debugging
    console.error('API Error:', error.type, error.originalError);
  }

  /**
   * Handle an error by processing it and showing a message to the user
   * @param error The error to handle
   * @returns The processed error details
   */
  public static handleError(error: unknown): ErrorDetails {
    const errorDetails = this.processError(error);
    this.showErrorToUser(errorDetails);
    return errorDetails;
  }
}

```


---

### File: `archive/vscode-extension/src/commands.js`

```javascript
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.registerCommands = registerCommands;
const vscode = __importStar(require("vscode"));
const configuration_1 = require("./configuration");
const contextProvider_1 = require("./contextProvider");
const errorHandler_1 = require("./errorHandler");
const responseFormatter_1 = require("./responseFormatter");
function registerCommands(context, apiClient, agentCoordinator, mcpClient) {
    // Register the "Ask Qwen" command
    const askQwenCommand = vscode.commands.registerCommand('qwen-coder-assistant.askQwen', async () => {
        const userPrompt = await vscode.window.showInputBox({
            prompt: 'What would you like to ask Qwen?',
            placeHolder: 'E.g., How do I implement a binary search in JavaScript?'
        });
        if (!userPrompt) {
            return; // User cancelled
        }
        try {
            vscode.window.withProgress({
                location: vscode.ProgressLocation.Notification,
                title: 'Asking Qwen...',
                cancellable: false
            }, async (progress) => {
                progress.report({ increment: 0 });
                const editorContext = await (0, contextProvider_1.getEditorContext)();
                let prompt = userPrompt;
                if (editorContext) {
                    prompt += `\n\nContext:\nFile: ${editorContext.fileName}\nLanguage: ${editorContext.language}\n`;
                    if (editorContext.selectedCode) {
                        prompt += `\nSelected code:\n\`\`\`${editorContext.language}\n${editorContext.selectedCode}\n\`\`\``;
                    }
                }
                progress.report({ increment: 30, message: 'Retrieving code context...' });
                // Get relevant context from the context engine
                const codeContext = await (0, contextProvider_1.getProjectContext)(userPrompt);
                if (codeContext) {
                    prompt += `\n\nRelevant code context:\n${codeContext}`;
                }
                progress.report({ increment: 50 });
                const options = {
                    prompt,
                    systemPrompt: 'You are Qwen Coder, an AI assistant specialized in helping with programming tasks. Provide clear, concise, and accurate responses to coding questions. Include code examples when appropriate.'
                };
                // Check if streaming is enabled in configuration
                const config = (0, configuration_1.getConfiguration)();
                if (config.streamingEnabled) {
                    // Use streaming API
                    progress.report({ message: 'Streaming response...' });
                    // Variable to accumulate the full response for history
                    let fullResponse = '';
                    (0, responseFormatter_1.showStreamingResponseInPanel)(context, (streamHandler) => {
                        apiClient.generateStreamingCompletion(options, (chunk, done) => {
                            // Accumulate the response
                            fullResponse += chunk;
                            // Pass to the original handler
                            streamHandler(chunk, done);
                            // When streaming is complete, save to history
                            if (done) {
                                saveToHistory(context, prompt, fullResponse, options.systemPrompt);
                            }
                        }).catch(error => {
                            errorHandler_1.ErrorHandler.handleError(error);
                        });
                    });
                    progress.report({ increment: 100 });
                }
                else {
                    // Use non-streaming API
                    const response = await apiClient.generateCompletion(options);
                    progress.report({ increment: 100 });
                    // Save to conversation history
                    saveToHistory(context, prompt, response.text, options.systemPrompt);
                    // Show response in panel
                    (0, responseFormatter_1.showResponseInPanel)(response.text, context);
                }
            });
        }
        catch (error) {
            errorHandler_1.ErrorHandler.handleError(error);
        }
    });
    // Register the "Explain Code" command
    const explainCodeCommand = vscode.commands.registerCommand('qwen-coder-assistant.explainCode', async () => {
        const editorContext = await (0, contextProvider_1.getEditorContext)();
        if (!editorContext || !editorContext.selectedCode) {
            vscode.window.showInformationMessage('Please select some code to explain.');
            return;
        }
        try {
            vscode.window.withProgress({
                location: vscode.ProgressLocation.Notification,
                title: 'Explaining code...',
                cancellable: false
            }, async (progress) => {
                progress.report({ increment: 0 });
                const prompt = `Please explain the following code in detail:\n\`\`\`${editorContext.language}\n${editorContext.selectedCode}\n\`\`\``;
                const options = {
                    prompt,
                    systemPrompt: 'You are Qwen Coder, an AI assistant specialized in explaining code. Provide clear, detailed explanations of how the code works, its purpose, and any important patterns or concepts it demonstrates.'
                };
                progress.report({ increment: 50 });
                // Check if streaming is enabled in configuration
                const config = (0, configuration_1.getConfiguration)();
                if (config.streamingEnabled) {
                    // Use streaming API
                    progress.report({ message: 'Streaming response...' });
                    // Variable to accumulate the full response for history
                    let fullResponse = '';
                    (0, responseFormatter_1.showStreamingResponseInPanel)(context, (streamHandler) => {
                        apiClient.generateStreamingCompletion(options, (chunk, done) => {
                            // Accumulate the response
                            fullResponse += chunk;
                            // Pass to the original handler
                            streamHandler(chunk, done);
                            // When streaming is complete, save to history
                            if (done) {
                                saveToHistory(context, prompt, fullResponse, options.systemPrompt);
                            }
                        }).catch(error => {
                            errorHandler_1.ErrorHandler.handleError(error);
                        });
                    });
                    progress.report({ increment: 100 });
                }
                else {
                    // Use non-streaming API
                    const response = await apiClient.generateCompletion(options);
                    progress.report({ increment: 100 });
                    // Save to conversation history
                    saveToHistory(context, prompt, response.text, options.systemPrompt);
                    // Show response in panel
                    (0, responseFormatter_1.showResponseInPanel)(response.text, context);
                }
            });
        }
        catch (error) {
            errorHandler_1.ErrorHandler.handleError(error);
        }
    });
    // Register the "Generate Code" command
    const generateCodeCommand = vscode.commands.registerCommand('qwen-coder-assistant.generateCode', async () => {
        const userPrompt = await vscode.window.showInputBox({
            prompt: 'What code would you like to generate?',
            placeHolder: 'E.g., Write a function to sort an array of objects by a property'
        });
        if (!userPrompt) {
            return; // User cancelled
        }
        try {
            vscode.window.withProgress({
                location: vscode.ProgressLocation.Notification,
                title: 'Generating code...',
                cancellable: false
            }, async (progress) => {
                progress.report({ increment: 0 });
                const editorContext = await (0, contextProvider_1.getEditorContext)();
                let prompt = `Generate code for: ${userPrompt}`;
                if (editorContext) {
                    prompt += `\n\nContext:\nFile: ${editorContext.fileName}\nLanguage: ${editorContext.language}\n`;
                    if (editorContext.visibleRangeText) {
                        prompt += `\nSurrounding code:\n\`\`\`${editorContext.language}\n${editorContext.visibleRangeText}\n\`\`\``;
                    }
                }
                progress.report({ increment: 30 });
                // Get project context for better code generation
                progress.report({ message: 'Retrieving code context...' });
                const projectContext = await (0, contextProvider_1.getProjectContext)(userPrompt);
                if (projectContext) {
                    prompt += `\n\nProject context (relevant files):\n${projectContext}`;
                }
                progress.report({ increment: 50 });
                const options = {
                    prompt,
                    systemPrompt: 'You are Qwen Coder, an AI assistant specialized in generating high-quality code. Generate code that is efficient, well-documented, and follows best practices for the given language and context.'
                };
                // Check if streaming is enabled in configuration
                const config = (0, configuration_1.getConfiguration)();
                if (config.streamingEnabled) {
                    // Use streaming API
                    progress.report({ message: 'Streaming response...' });
                    // Variable to accumulate the full response for history
                    let fullResponse = '';
                    (0, responseFormatter_1.showStreamingResponseInPanel)(context, (streamHandler) => {
                        apiClient.generateStreamingCompletion(options, (chunk, done) => {
                            // Accumulate the response
                            fullResponse += chunk;
                            // Pass to the original handler
                            streamHandler(chunk, done);
                            // When streaming is complete, save to history
                            if (done) {
                                saveToHistory(context, prompt, fullResponse, options.systemPrompt);
                            }
                        }).catch(error => {
                            errorHandler_1.ErrorHandler.handleError(error);
                        });
                    });
                    progress.report({ increment: 100 });
                }
                else {
                    // Use non-streaming API
                    const response = await apiClient.generateCompletion(options);
                    progress.report({ increment: 100 });
                    // Save to conversation history
                    saveToHistory(context, prompt, response.text, options.systemPrompt);
                    // Show response in panel
                    (0, responseFormatter_1.showResponseInPanel)(response.text, context);
                }
            });
        }
        catch (error) {
            errorHandler_1.ErrorHandler.handleError(error);
        }
    });
    // Register the "Clear Cache" command
    const clearCacheCommand = vscode.commands.registerCommand('qwen-coder-assistant.clearCache', async () => {
        try {
            apiClient.clearCache();
            vscode.window.showInformationMessage('Qwen Coder cache cleared successfully.');
        }
        catch (error) {
            errorHandler_1.ErrorHandler.handleError(error);
        }
    });
    // Register the "Refactor Code" command
    const refactorCodeCommand = vscode.commands.registerCommand('qwen-coder-assistant.refactorCode', async () => {
        const editorContext = await (0, contextProvider_1.getEditorContext)();
        if (!editorContext || !editorContext.selectedCode) {
            vscode.window.showInformationMessage('Please select some code to refactor.');
            return;
        }
        try {
            vscode.window.withProgress({
                location: vscode.ProgressLocation.Notification,
                title: 'Refactoring code...',
                cancellable: false
            }, async (progress) => {
                progress.report({ increment: 0 });
                const prompt = `Please refactor the following code to improve its readability, efficiency, and maintainability. Provide the refactored code and explain the improvements made:\n\`\`\`${editorContext.language}\n${editorContext.selectedCode}\n\`\`\``;
                const options = {
                    prompt,
                    systemPrompt: 'You are Qwen Coder, an AI assistant specialized in refactoring code. Provide clean, efficient, and well-structured code that follows best practices and design patterns. Explain the improvements you made.'
                };
                progress.report({ increment: 50 });
                // Check if streaming is enabled in configuration
                const config = (0, configuration_1.getConfiguration)();
                if (config.streamingEnabled) {
                    // Use streaming API
                    progress.report({ message: 'Streaming response...' });
                    // Variable to accumulate the full response for history
                    let fullResponse = '';
                    (0, responseFormatter_1.showStreamingResponseInPanel)(context, (streamHandler) => {
                        apiClient.generateStreamingCompletion(options, (chunk, done) => {
                            // Accumulate the response
                            fullResponse += chunk;
                            // Pass to the original handler
                            streamHandler(chunk, done);
                            // When streaming is complete, save to history
                            if (done) {
                                saveToHistory(context, prompt, fullResponse, options.systemPrompt);
                            }
                        }).catch(error => {
                            errorHandler_1.ErrorHandler.handleError(error);
                        });
                    });
                    progress.report({ increment: 100 });
                }
                else {
                    // Use non-streaming API
                    const response = await apiClient.generateCompletion(options);
                    progress.report({ increment: 100 });
                    // Save to conversation history
                    saveToHistory(context, prompt, response.text, options.systemPrompt);
                    // Show response in panel
                    (0, responseFormatter_1.showResponseInPanel)(response.text, context);
                }
            });
        }
        catch (error) {
            errorHandler_1.ErrorHandler.handleError(error);
        }
    });
    // Register the "Document Code" command
    const documentCodeCommand = vscode.commands.registerCommand('qwen-coder-assistant.documentCode', async () => {
        const editorContext = await (0, contextProvider_1.getEditorContext)();
        if (!editorContext || !editorContext.selectedCode) {
            vscode.window.showInformationMessage('Please select some code to document.');
            return;
        }
        try {
            vscode.window.withProgress({
                location: vscode.ProgressLocation.Notification,
                title: 'Documenting code...',
                cancellable: false
            }, async (progress) => {
                progress.report({ increment: 0 });
                const prompt = `Please add comprehensive documentation to the following code. Include function/method descriptions, parameter explanations, return value details, and any other relevant documentation:\n\`\`\`${editorContext.language}\n${editorContext.selectedCode}\n\`\`\``;
                const options = {
                    prompt,
                    systemPrompt: 'You are Qwen Coder, an AI assistant specialized in documenting code. Provide clear, comprehensive documentation that follows the conventions of the given programming language. Include function/method descriptions, parameter explanations, return value details, and usage examples where appropriate.'
                };
                progress.report({ increment: 50 });
                // Check if streaming is enabled in configuration
                const config = (0, configuration_1.getConfiguration)();
                if (config.streamingEnabled) {
                    // Use streaming API
                    progress.report({ message: 'Streaming response...' });
                    // Variable to accumulate the full response for history
                    let fullResponse = '';
                    (0, responseFormatter_1.showStreamingResponseInPanel)(context, (streamHandler) => {
                        apiClient.generateStreamingCompletion(options, (chunk, done) => {
                            // Accumulate the response
                            fullResponse += chunk;
                            // Pass to the original handler
                            streamHandler(chunk, done);
                            // When streaming is complete, save to history
                            if (done) {
                                saveToHistory(context, prompt, fullResponse, options.systemPrompt);
                            }
                        }).catch(error => {
                            errorHandler_1.ErrorHandler.handleError(error);
                        });
                    });
                    progress.report({ increment: 100 });
                }
                else {
                    // Use non-streaming API
                    const response = await apiClient.generateCompletion(options);
                    progress.report({ increment: 100 });
                    // Save to conversation history
                    saveToHistory(context, prompt, response.text, options.systemPrompt);
                    // Show response in panel
                    (0, responseFormatter_1.showResponseInPanel)(response.text, context);
                }
            });
        }
        catch (error) {
            errorHandler_1.ErrorHandler.handleError(error);
        }
    });
    // Register the "Fix Issues" command
    const fixIssuesCommand = vscode.commands.registerCommand('qwen-coder-assistant.fixIssues', async () => {
        const editorContext = await (0, contextProvider_1.getEditorContext)();
        if (!editorContext || !editorContext.selectedCode) {
            vscode.window.showInformationMessage('Please select some code to fix.');
            return;
        }
        try {
            vscode.window.withProgress({
                location: vscode.ProgressLocation.Notification,
                title: 'Fixing code issues...',
                cancellable: false
            }, async (progress) => {
                progress.report({ increment: 0 });
                const prompt = `Please identify and fix any issues in the following code. This could include bugs, syntax errors, performance issues, or security vulnerabilities. Provide the fixed code and explain the issues that were addressed:\n\`\`\`${editorContext.language}\n${editorContext.selectedCode}\n\`\`\``;
                const options = {
                    prompt,
                    systemPrompt: 'You are Qwen Coder, an AI assistant specialized in identifying and fixing code issues. Look for bugs, syntax errors, performance issues, security vulnerabilities, and other problems. Provide the fixed code and explain the issues that were addressed.'
                };
                progress.report({ increment: 50 });
                // Check if streaming is enabled in configuration
                const config = (0, configuration_1.getConfiguration)();
                if (config.streamingEnabled) {
                    // Use streaming API
                    progress.report({ message: 'Streaming response...' });
                    // Variable to accumulate the full response for history
                    let fullResponse = '';
                    (0, responseFormatter_1.showStreamingResponseInPanel)(context, (streamHandler) => {
                        apiClient.generateStreamingCompletion(options, (chunk, done) => {
                            // Accumulate the response
                            fullResponse += chunk;
                            // Pass to the original handler
                            streamHandler(chunk, done);
                            // When streaming is complete, save to history
                            if (done) {
                                saveToHistory(context, prompt, fullResponse, options.systemPrompt);
                            }
                        }).catch(error => {
                            errorHandler_1.ErrorHandler.handleError(error);
                        });
                    });
                    progress.report({ increment: 100 });
                }
                else {
                    // Use non-streaming API
                    const response = await apiClient.generateCompletion(options);
                    progress.report({ increment: 100 });
                    // Save to conversation history
                    saveToHistory(context, prompt, response.text, options.systemPrompt);
                    // Show response in panel
                    (0, responseFormatter_1.showResponseInPanel)(response.text, context);
                }
            });
        }
        catch (error) {
            errorHandler_1.ErrorHandler.handleError(error);
        }
    });
    // Register the "Hierarchical Agent" command
    const hierarchicalAgentCommand = vscode.commands.registerCommand('qwen-coder-assistant.hierarchicalAgent', async () => {
        if (!agentCoordinator) {
            vscode.window.showErrorMessage('Hierarchical agent system is not available.');
            return;
        }
        const userPrompt = await vscode.window.showInputBox({
            prompt: 'What would you like the hierarchical agent system to do?',
            placeHolder: 'E.g., Implement a feature, refactor a module, create tests for a function'
        });
        if (!userPrompt) {
            return; // User cancelled
        }
        try {
            vscode.window.withProgress({
                location: vscode.ProgressLocation.Notification,
                title: 'Processing with hierarchical agent system...',
                cancellable: false
            }, async (progress) => {
                progress.report({ increment: 0 });
                // Create a webview panel to display the results
                const panel = vscode.window.createWebviewPanel('qwenCoderHierarchicalAgent', 'Hierarchical Agent', vscode.ViewColumn.One, {
                    enableScripts: true,
                    retainContextWhenHidden: true
                });
                // Show loading indicator
                panel.webview.html = getLoadingWebviewContent();
                progress.report({ increment: 30, message: 'Decomposing task...' });
                try {
                    // Process the request with the agent coordinator
                    progress.report({ increment: 50, message: 'Executing subtasks...' });
                    const response = await agentCoordinator.processRequest(userPrompt);
                    progress.report({ increment: 100, message: 'Aggregating results...' });
                    // Show the response in the panel
                    panel.webview.html = getWebviewContent(userPrompt, response);
                    // Save to conversation history
                    saveToHistory(context, userPrompt, response, 'Hierarchical Agent System');
                }
                catch (error) {
                    panel.webview.html = getErrorWebviewContent(userPrompt, error.message);
                    errorHandler_1.ErrorHandler.handleError(error);
                }
            });
        }
        catch (error) {
            errorHandler_1.ErrorHandler.handleError(error);
        }
    });
    // Register the "MCP Tool" command
    const mcpToolCommand = vscode.commands.registerCommand('qwen-coder-assistant.mcpTool', async () => {
        if (!mcpClient) {
            vscode.window.showErrorMessage('MCP tools are not available.');
            return;
        }
        try {
            // Get available tools
            const availableTools = mcpClient.getAvailableTools();
            if (availableTools.length === 0) {
                vscode.window.showInformationMessage('No MCP tools are currently available. Please start some tools first.');
                return;
            }
            // Let the user select a tool
            const selectedTool = await vscode.window.showQuickPick(availableTools, {
                placeHolder: 'Select an MCP tool to use'
            });
            if (!selectedTool) {
                return; // User cancelled
            }
            // Get the tool schema
            const toolSchema = mcpClient.getToolSchema(selectedTool);
            if (!toolSchema) {
                vscode.window.showErrorMessage(`Schema for tool ${selectedTool} is not available.`);
                return;
            }
            // Let the user select a function
            const functionItems = toolSchema.functions.map(func => ({
                label: func.name,
                description: func.description,
                detail: `Parameters: ${Object.keys(func.parameters.properties).join(', ')}`,
                function: func
            }));
            const selectedFunction = await vscode.window.showQuickPick(functionItems, {
                placeHolder: 'Select a function to call'
            });
            if (!selectedFunction) {
                return; // User cancelled
            }
            // Collect parameters for the function
            const parameters = {};
            for (const paramName of selectedFunction.function.parameters.required) {
                const paramSchema = selectedFunction.function.parameters.properties[paramName];
                const paramValue = await vscode.window.showInputBox({
                    prompt: `Enter value for ${paramName}`,
                    placeHolder: paramSchema.description
                });
                if (paramValue === undefined) {
                    return; // User cancelled
                }
                // Convert value to appropriate type
                if (paramSchema.type === 'number') {
                    parameters[paramName] = Number(paramValue);
                }
                else if (paramSchema.type === 'boolean') {
                    parameters[paramName] = paramValue.toLowerCase() === 'true';
                }
                else {
                    parameters[paramName] = paramValue;
                }
            }
            // Call the function
            vscode.window.withProgress({
                location: vscode.ProgressLocation.Notification,
                title: `Calling ${selectedFunction.label} on ${selectedTool}...`,
                cancellable: false
            }, async (progress) => {
                progress.report({ increment: 0 });
                const result = await mcpClient.callFunction(selectedTool, selectedFunction.label, parameters);
                progress.report({ increment: 100 });
                // Show the result
                if (result.status === 'success') {
                    // Create a webview panel to display the results
                    const panel = vscode.window.createWebviewPanel('qwenCoderMcpTool', `${selectedTool} - ${selectedFunction.label}`, vscode.ViewColumn.One, {
                        enableScripts: true,
                        retainContextWhenHidden: true
                    });
                    // Show the result
                    panel.webview.html = `<!DOCTYPE html>
          <html lang="en">
          <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>${selectedTool} - ${selectedFunction.label}</title>
            <style>
              body {
                font-family: var(--vscode-font-family);
                color: var(--vscode-editor-foreground);
                background-color: var(--vscode-editor-background);
                padding: 20px;
              }
              pre {
                background-color: var(--vscode-textCodeBlock-background);
                padding: 16px;
                border-radius: 4px;
                overflow: auto;
              }
            </style>
          </head>
          <body>
            <h1>${selectedTool} - ${selectedFunction.label}</h1>
            <h2>Parameters</h2>
            <pre>${JSON.stringify(parameters, null, 2)}</pre>
            <h2>Result</h2>
            <pre>${JSON.stringify(result.result, null, 2)}</pre>
          </body>
          </html>`;
                }
                else {
                    vscode.window.showErrorMessage(`Error calling function: ${result.error}`);
                }
            });
        }
        catch (error) {
            errorHandler_1.ErrorHandler.handleError(error);
        }
    });
    // Add commands to subscriptions
    context.subscriptions.push(askQwenCommand, explainCodeCommand, generateCodeCommand, refactorCodeCommand, documentCodeCommand, fixIssuesCommand, clearCacheCommand, hierarchicalAgentCommand, mcpToolCommand);
}
// Helper function to get loading webview content
function getLoadingWebviewContent() {
    return `<!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Processing Request</title>
    <style>
      body {
        font-family: var(--vscode-font-family);
        color: var(--vscode-editor-foreground);
        background-color: var(--vscode-editor-background);
        padding: 20px;
      }
      .loading {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 300px;
      }
      .spinner {
        width: 50px;
        height: 50px;
        border: 5px solid var(--vscode-button-background);
        border-radius: 50%;
        border-top-color: transparent;
        animation: spin 1s linear infinite;
        margin-bottom: 20px;
      }
      @keyframes spin {
        to { transform: rotate(360deg); }
      }
    </style>
  </head>
  <body>
    <div class="loading">
      <div class="spinner"></div>
      <h2>Processing your request...</h2>
      <p>The hierarchical agent system is working on your task.</p>
    </div>
  </body>
  </html>`;
}
// Helper function to get webview content
function getWebviewContent(request, response) {
    return `<!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Agent Response</title>
    <style>
      body {
        font-family: var(--vscode-font-family);
        color: var(--vscode-editor-foreground);
        background-color: var(--vscode-editor-background);
        padding: 20px;
        line-height: 1.5;
      }
      h1, h2, h3, h4, h5, h6 {
        color: var(--vscode-editor-foreground);
      }
      pre {
        background-color: var(--vscode-textCodeBlock-background);
        padding: 16px;
        border-radius: 4px;
        overflow: auto;
      }
      code {
        font-family: var(--vscode-editor-font-family);
        font-size: var(--vscode-editor-font-size);
      }
      .request {
        background-color: var(--vscode-input-background);
        padding: 10px;
        border-radius: 4px;
        margin-bottom: 20px;
        border-left: 4px solid var(--vscode-activityBarBadge-background);
      }
    </style>
  </head>
  <body>
    <div class="request">
      <strong>Your request:</strong> ${request}
    </div>
    <div class="response">
      ${markdownToHtml(response)}
    </div>
  </body>
  </html>`;
}
// Helper function to get error webview content
function getErrorWebviewContent(request, errorMessage) {
    return `<!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Error</title>
    <style>
      body {
        font-family: var(--vscode-font-family);
        color: var(--vscode-editor-foreground);
        background-color: var(--vscode-editor-background);
        padding: 20px;
      }
      .request {
        background-color: var(--vscode-input-background);
        padding: 10px;
        border-radius: 4px;
        margin-bottom: 20px;
        border-left: 4px solid var(--vscode-activityBarBadge-background);
      }
      .error {
        background-color: var(--vscode-inputValidation-errorBackground);
        color: var(--vscode-inputValidation-errorForeground);
        padding: 10px;
        border-radius: 4px;
        margin-bottom: 20px;
        border-left: 4px solid var(--vscode-errorForeground);
      }
    </style>
  </head>
  <body>
    <div class="request">
      <strong>Your request:</strong> ${request}
    </div>
    <div class="error">
      <strong>Error:</strong> ${errorMessage}
    </div>
    <p>Please try again with a more specific request or check the extension logs for more details.</p>
  </body>
  </html>`;
}
// Helper function to convert markdown to HTML
function markdownToHtml(markdown) {
    // This is a very simple markdown to HTML converter
    // In a real implementation, we would use a proper markdown parser
    // Replace headers
    let html = markdown
        .replace(/^### (.*$)/gim, '<h3>$1</h3>')
        .replace(/^## (.*$)/gim, '<h2>$1</h2>')
        .replace(/^# (.*$)/gim, '<h1>$1</h1>');
    // Replace code blocks
    html = html.replace(/```([a-z]*)\n([\s\S]*?)\n```/gim, '<pre><code class="language-$1">$2</code></pre>');
    // Replace inline code
    html = html.replace(/`([^`]+)`/gim, '<code>$1</code>');
    // Replace lists
    html = html.replace(/^\s*\*\s(.*$)/gim, '<ul><li>$1</li></ul>');
    html = html.replace(/^\s*\d+\.\s(.*$)/gim, '<ol><li>$1</li></ol>');
    // Replace paragraphs
    html = html.replace(/^\s*(\n)?([^\n]+)\n/gim, '<p>$2</p>');
    // Fix consecutive lists
    html = html.replace(/<\/ul>\s*<ul>/gim, '');
    html = html.replace(/<\/ol>\s*<ol>/gim, '');
    return html;
}
//# sourceMappingURL=commands.js.map
```


---

### File: `archive/vscode-extension/src/extension.js`

```javascript
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.activate = activate;
exports.deactivate = deactivate;
const vscode = __importStar(require("vscode"));
const agentCoordinator_1 = require("./agents/agentCoordinator");
const commands_1 = require("./commands");
const configuration_1 = require("./configuration");
const containerManager_1 = require("./containers/containerManager");
const contextProvider_1 = require("./contextProvider");
const conversationHistory_1 = require("./conversationHistory");
const mcpClient_1 = require("./mcp/mcpClient");
const mockQwenApi_1 = require("./mockQwenApi");
const qwenApi_1 = require("./qwenApi");
function activate(context) {
    console.log('Qwen Coder Assistant is now active!');
    // Initialize the API client
    const config = (0, configuration_1.getConfiguration)();
    // Use mock API client for development, real client for production
    const isDevelopment = process.env.NODE_ENV === 'development' || !config.apiKey;
    const apiClient = isDevelopment
        ? new mockQwenApi_1.MockQwenApiClient(config)
        : new qwenApi_1.QwenApiClient(config);
    // Add status bar item to show which API client is being used
    const statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right, 100);
    statusBarItem.text = isDevelopment ? '$(beaker) Qwen: Mock API' : '$(cloud) Qwen: Live API';
    statusBarItem.tooltip = isDevelopment
        ? 'Using Mock Qwen API (for development)'
        : 'Using Live Qwen API';
    statusBarItem.show();
    context.subscriptions.push(statusBarItem);
    // Initialize the container manager
    const containerManager = new containerManager_1.ContainerManager();
    context.subscriptions.push(containerManager);
    // Initialize the MCP client
    const mcpClient = new mcpClient_1.MCPClient(containerManager);
    context.subscriptions.push(mcpClient);
    // Initialize the agent coordinator
    const agentCoordinator = new agentCoordinator_1.AgentCoordinator();
    context.subscriptions.push(agentCoordinator);
    // Register commands
    (0, commands_1.registerCommands)(context, apiClient, agentCoordinator, mcpClient);
    // Register conversation history view
    (0, conversationHistory_1.registerConversationHistoryView)(context);
    // Initialize the context engine
    (0, contextProvider_1.initializeContextEngine)().catch(error => {
        console.error('Error initializing context engine:', error);
    });
    // Initialize the container manager
    containerManager.initialize().catch(error => {
        console.error('Error initializing container manager:', error);
    });
    // Initialize the MCP client after container manager is initialized
    containerManager.initialize().then(() => {
        mcpClient.initialize().catch(error => {
            console.error('Error initializing MCP client:', error);
        });
    }).catch(() => {
        // Container manager initialization failed, but we can still proceed
    });
    // Register configuration change listener
    context.subscriptions.push(vscode.workspace.onDidChangeConfiguration(event => {
        if (event.affectsConfiguration('qwen-coder-assistant')) {
            const newConfig = (0, configuration_1.getConfiguration)();
            const newIsDevelopment = process.env.NODE_ENV === 'development' || !newConfig.apiKey;
            // Update API client
            if (apiClient instanceof mockQwenApi_1.MockQwenApiClient) {
                apiClient.updateConfig(newConfig);
            }
            else if (apiClient instanceof qwenApi_1.QwenApiClient) {
                apiClient.updateConfig(newConfig);
            }
            // Update status bar
            statusBarItem.text = newIsDevelopment ? '$(beaker) Qwen: Mock API' : '$(cloud) Qwen: Live API';
            statusBarItem.tooltip = newIsDevelopment
                ? 'Using Mock Qwen API (for development)'
                : 'Using Live Qwen API';
        }
    }));
    // Register commands for container management
    context.subscriptions.push(vscode.commands.registerCommand('qwenCoder.showContainerStatus', () => {
        const containerStatus = containerManager.getContainerStatus();
        const statusItems = Object.entries(containerStatus).map(([name, info]) => ({
            label: `$(docker) ${name}`,
            description: info.status,
            detail: info.status === 'running' ? `URL: ${info.url}` : info.error || '',
            containerName: name,
            status: info.status
        }));
        vscode.window.showQuickPick(statusItems, {
            placeHolder: 'Select a container to manage',
            matchOnDescription: true,
            matchOnDetail: true
        }).then(selected => {
            if (selected) {
                if (selected.status === 'running') {
                    vscode.window.showQuickPick(['Stop', 'Restart', 'View Schema'], {
                        placeHolder: `Action for ${selected.containerName}`
                    }).then(action => {
                        if (action === 'Stop') {
                            containerManager.stopContainer(selected.containerName).catch(error => {
                                vscode.window.showErrorMessage(`Error stopping container: ${error.message}`);
                            });
                        }
                        else if (action === 'Restart') {
                            containerManager.stopContainer(selected.containerName)
                                .then(() => containerManager.startContainer(selected.containerName))
                                .catch(error => {
                                vscode.window.showErrorMessage(`Error restarting container: ${error.message}`);
                            });
                        }
                        else if (action === 'View Schema') {
                            mcpClient.fetchToolSchema(selected.containerName)
                                .then(schema => {
                                const schemaDoc = JSON.stringify(schema, null, 2);
                                vscode.workspace.openTextDocument({ content: schemaDoc, language: 'json' })
                                    .then(doc => vscode.window.showTextDocument(doc));
                            })
                                .catch(error => {
                                vscode.window.showErrorMessage(`Error fetching schema: ${error.message}`);
                            });
                        }
                    });
                }
                else {
                    vscode.window.showQuickPick(['Start', 'Remove'], {
                        placeHolder: `Action for ${selected.containerName}`
                    }).then(action => {
                        if (action === 'Start') {
                            containerManager.startContainer(selected.containerName).catch(error => {
                                vscode.window.showErrorMessage(`Error starting container: ${error.message}`);
                            });
                        }
                    });
                }
            }
        });
    }));
    // Register command for DevOps guidance
    context.subscriptions.push(vscode.commands.registerCommand('qwenCoder.devops', async () => {
        const request = await vscode.window.showInputBox({
            prompt: 'What DevOps task do you need help with?',
            placeHolder: 'e.g., Set up CI/CD pipeline, Create Docker container, Configure GitHub workflow'
        });
        if (request) {
            const panel = vscode.window.createWebviewPanel('qwenCoderDevOps', 'DevOps Guidance', vscode.ViewColumn.One, {
                enableScripts: true,
                retainContextWhenHidden: true
            });
            panel.webview.html = getLoadingWebviewContent();
            try {
                const response = await agentCoordinator.processRequest(request);
                panel.webview.html = getWebviewContent(request, response);
            }
            catch (error) {
                panel.webview.html = getErrorWebviewContent(request, error.message);
            }
        }
    }));
}
async function deactivate() {
    // Clean up resources when the extension is deactivated
    console.log('Qwen Coder Assistant is now deactivated!');
    // Dispose the context engine
    await (0, contextProvider_1.disposeContextEngine)();
}
// Helper functions for webview content
function getLoadingWebviewContent() {
    return `<!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DevOps Guidance</title>
    <style>
      body {
        font-family: var(--vscode-font-family);
        color: var(--vscode-editor-foreground);
        background-color: var(--vscode-editor-background);
        padding: 20px;
      }
      .loading {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 300px;
      }
      .spinner {
        width: 50px;
        height: 50px;
        border: 5px solid var(--vscode-button-background);
        border-radius: 50%;
        border-top-color: transparent;
        animation: spin 1s linear infinite;
        margin-bottom: 20px;
      }
      @keyframes spin {
        to { transform: rotate(360deg); }
      }
    </style>
  </head>
  <body>
    <div class="loading">
      <div class="spinner"></div>
      <h2>Processing your request...</h2>
      <p>The hierarchical agent system is working on your DevOps task.</p>
    </div>
  </body>
  </html>`;
}
function getWebviewContent(request, response) {
    return `<!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DevOps Guidance</title>
    <style>
      body {
        font-family: var(--vscode-font-family);
        color: var(--vscode-editor-foreground);
        background-color: var(--vscode-editor-background);
        padding: 20px;
        line-height: 1.5;
      }
      h1, h2, h3, h4, h5, h6 {
        color: var(--vscode-editor-foreground);
      }
      pre {
        background-color: var(--vscode-textCodeBlock-background);
        padding: 16px;
        border-radius: 4px;
        overflow: auto;
      }
      code {
        font-family: var(--vscode-editor-font-family);
        font-size: var(--vscode-editor-font-size);
      }
      .request {
        background-color: var(--vscode-input-background);
        padding: 10px;
        border-radius: 4px;
        margin-bottom: 20px;
        border-left: 4px solid var(--vscode-activityBarBadge-background);
      }
    </style>
  </head>
  <body>
    <div class="request">
      <strong>Your request:</strong> ${request}
    </div>
    <div class="response">
      ${markdownToHtml(response)}
    </div>
  </body>
  </html>`;
}
function getErrorWebviewContent(request, errorMessage) {
    return `<!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DevOps Guidance - Error</title>
    <style>
      body {
        font-family: var(--vscode-font-family);
        color: var(--vscode-editor-foreground);
        background-color: var(--vscode-editor-background);
        padding: 20px;
      }
      .request {
        background-color: var(--vscode-input-background);
        padding: 10px;
        border-radius: 4px;
        margin-bottom: 20px;
        border-left: 4px solid var(--vscode-activityBarBadge-background);
      }
      .error {
        background-color: var(--vscode-inputValidation-errorBackground);
        color: var(--vscode-inputValidation-errorForeground);
        padding: 10px;
        border-radius: 4px;
        margin-bottom: 20px;
        border-left: 4px solid var(--vscode-errorForeground);
      }
    </style>
  </head>
  <body>
    <div class="request">
      <strong>Your request:</strong> ${request}
    </div>
    <div class="error">
      <strong>Error:</strong> ${errorMessage}
    </div>
    <p>Please try again with a more specific request or check the extension logs for more details.</p>
  </body>
  </html>`;
}
function markdownToHtml(markdown) {
    // This is a very simple markdown to HTML converter
    // In a real implementation, we would use a proper markdown parser
    // Replace headers
    let html = markdown
        .replace(/^### (.*$)/gim, '<h3>$1</h3>')
        .replace(/^## (.*$)/gim, '<h2>$1</h2>')
        .replace(/^# (.*$)/gim, '<h1>$1</h1>');
    // Replace code blocks
    html = html.replace(/```([a-z]*)\n([\s\S]*?)\n```/gim, '<pre><code class="language-$1">$2</code></pre>');
    // Replace inline code
    html = html.replace(/`([^`]+)`/gim, '<code>$1</code>');
    // Replace lists
    html = html.replace(/^\s*\*\s(.*$)/gim, '<ul><li>$1</li></ul>');
    html = html.replace(/^\s*\d+\.\s(.*$)/gim, '<ol><li>$1</li></ol>');
    // Replace paragraphs
    html = html.replace(/^\s*(\n)?([^\n]+)\n/gim, '<p>$2</p>');
    // Fix consecutive lists
    html = html.replace(/<\/ul>\s*<ul>/gim, '');
    html = html.replace(/<\/ol>\s*<ol>/gim, '');
    return html;
}
//# sourceMappingURL=extension.js.map
```


---

### File: `archive/vscode-extension/src/responseFormatter.js`

```javascript
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatResponse = formatResponse;
exports.insertCodeIntoEditor = insertCodeIntoEditor;
exports.showResponseInPanel = showResponseInPanel;
exports.showStreamingResponseInPanel = showStreamingResponseInPanel;
const vscode = __importStar(require("vscode"));
function formatResponse(response) {
    // Extract code blocks from the response
    const codeBlockRegex = /```(\w+)?\n([\s\S]*?)```/g;
    const codeBlocks = [];
    let match;
    while ((match = codeBlockRegex.exec(response)) !== null) {
        const language = match[1] || 'text';
        const code = match[2];
        codeBlocks.push({ language, code });
    }
    return {
        markdown: response,
        codeBlocks
    };
}
function insertCodeIntoEditor(code, editor) {
    if (!editor) {
        editor = vscode.window.activeTextEditor;
        if (!editor) {
            vscode.window.showErrorMessage('No active editor found');
            return;
        }
    }
    const selection = editor.selection;
    editor.edit(editBuilder => {
        if (selection.isEmpty) {
            editBuilder.insert(selection.start, code);
        }
        else {
            editBuilder.replace(selection, code);
        }
    });
}
function showResponseInPanel(response, context) {
    // Import the QwenResponsePanel class to use its functionality
    const { QwenResponsePanel } = require('./webview/panel');
    // Create or show the panel
    const panel = QwenResponsePanel.createOrShow(context.extensionUri, 'Qwen Coder Response');
    // Set the content
    panel.setContent(response);
}
/**
 * Show a streaming response in a webview panel
 * @param context The extension context
 * @param onPanelReady Callback that receives the streaming handler function
 */
function showStreamingResponseInPanel(context, onPanelReady) {
    // Import the QwenResponsePanel class to use its functionality
    const { QwenResponsePanel } = require('./webview/panel');
    // Create or show the panel
    const panel = QwenResponsePanel.createOrShow(context.extensionUri, 'Qwen Coder Response (Streaming)');
    // Set initial empty content
    panel.setContent('');
    // Create a streaming handler function
    const streamHandler = (chunk, isComplete) => {
        panel.appendContent(chunk, isComplete);
    };
    // Call the callback with the streaming handler
    onPanelReady(streamHandler);
}
//# sourceMappingURL=responseFormatter.js.map
```


---

### File: `archive/vscode-extension/src/conversationHistory.js`

```javascript
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConversationTreeItem = exports.ConversationHistoryProvider = exports.ConversationHistoryManager = void 0;
exports.registerConversationHistoryView = registerConversationHistoryView;
exports.saveToHistory = saveToHistory;
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const vscode = __importStar(require("vscode"));
/**
 * Manages conversation history for the extension
 */
class ConversationHistoryManager {
    constructor(context) {
        this.conversations = [];
        this.MAX_HISTORY_ITEMS = 50;
        this.storageUri = context.globalStorageUri;
        this.loadConversations();
    }
    /**
     * Get the singleton instance of the conversation history manager
     */
    static getInstance(context) {
        if (!ConversationHistoryManager.instance) {
            ConversationHistoryManager.instance = new ConversationHistoryManager(context);
        }
        return ConversationHistoryManager.instance;
    }
    /**
     * Add a new conversation to the history
     */
    addConversation(prompt, response, systemPrompt) {
        // Generate a title from the prompt (first line or first few words)
        const title = this.generateTitle(prompt);
        // Create a new conversation entry
        const entry = {
            id: Date.now().toString(),
            title,
            timestamp: Date.now(),
            prompt,
            response,
            systemPrompt
        };
        // Add to the beginning of the array
        this.conversations.unshift(entry);
        // Limit the number of conversations
        if (this.conversations.length > this.MAX_HISTORY_ITEMS) {
            this.conversations = this.conversations.slice(0, this.MAX_HISTORY_ITEMS);
        }
        // Save the updated conversations
        this.saveConversations();
        return entry;
    }
    /**
     * Get all conversations
     */
    getConversations() {
        return [...this.conversations];
    }
    /**
     * Get a conversation by ID
     */
    getConversation(id) {
        return this.conversations.find(c => c.id === id);
    }
    /**
     * Delete a conversation by ID
     */
    deleteConversation(id) {
        const initialLength = this.conversations.length;
        this.conversations = this.conversations.filter(c => c.id !== id);
        if (this.conversations.length !== initialLength) {
            this.saveConversations();
            return true;
        }
        return false;
    }
    /**
     * Clear all conversations
     */
    clearConversations() {
        this.conversations = [];
        this.saveConversations();
    }
    /**
     * Generate a title from the prompt
     */
    generateTitle(prompt) {
        // Use the first line if it's short enough
        const firstLine = prompt.split('\n')[0].trim();
        if (firstLine.length <= 50) {
            return firstLine;
        }
        // Otherwise use the first few words
        return firstLine.substring(0, 47) + '...';
    }
    /**
     * Load conversations from storage
     */
    loadConversations() {
        try {
            if (!this.storageUri) {
                return;
            }
            // Create the storage directory if it doesn't exist
            const dirPath = this.storageUri.fsPath;
            if (!fs.existsSync(dirPath)) {
                fs.mkdirSync(dirPath, { recursive: true });
            }
            const filePath = path.join(dirPath, 'conversations.json');
            if (fs.existsSync(filePath)) {
                const data = fs.readFileSync(filePath, 'utf8');
                this.conversations = JSON.parse(data);
            }
        }
        catch (error) {
            console.error('Error loading conversations:', error);
            this.conversations = [];
        }
    }
    /**
     * Save conversations to storage
     */
    saveConversations() {
        try {
            if (!this.storageUri) {
                return;
            }
            // Create the storage directory if it doesn't exist
            const dirPath = this.storageUri.fsPath;
            if (!fs.existsSync(dirPath)) {
                fs.mkdirSync(dirPath, { recursive: true });
            }
            const filePath = path.join(dirPath, 'conversations.json');
            fs.writeFileSync(filePath, JSON.stringify(this.conversations, null, 2), 'utf8');
        }
        catch (error) {
            console.error('Error saving conversations:', error);
        }
    }
}
exports.ConversationHistoryManager = ConversationHistoryManager;
/**
 * Tree data provider for conversation history
 */
class ConversationHistoryProvider {
    constructor(historyManager) {
        this.historyManager = historyManager;
        this._onDidChangeTreeData = new vscode.EventEmitter();
        this.onDidChangeTreeData = this._onDidChangeTreeData.event;
    }
    refresh() {
        this._onDidChangeTreeData.fire();
    }
    getTreeItem(element) {
        return element;
    }
    getChildren(element) {
        if (element) {
            return Promise.resolve([]);
        }
        else {
            const conversations = this.historyManager.getConversations();
            return Promise.resolve(conversations.map(conversation => new ConversationTreeItem(conversation)));
        }
    }
}
exports.ConversationHistoryProvider = ConversationHistoryProvider;
/**
 * Tree item for a conversation
 */
class ConversationTreeItem extends vscode.TreeItem {
    constructor(conversation) {
        super(conversation.title, vscode.TreeItemCollapsibleState.None);
        this.conversation = conversation;
        // Format the date
        const date = new Date(conversation.timestamp);
        const formattedDate = date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
        this.tooltip = `${conversation.title}\n${formattedDate}`;
        this.description = formattedDate;
        this.contextValue = 'conversation';
        // Set the command to open the conversation
        this.command = {
            command: 'qwen-coder-assistant.openConversation',
            title: 'Open Conversation',
            arguments: [conversation]
        };
    }
}
exports.ConversationTreeItem = ConversationTreeItem;
/**
 * Register the conversation history view
 */
function registerConversationHistoryView(context) {
    // Create the history manager
    const historyManager = ConversationHistoryManager.getInstance(context);
    // Create the tree data provider
    const treeDataProvider = new ConversationHistoryProvider(historyManager);
    // Register the tree view
    const treeView = vscode.window.createTreeView('qwenConversationHistory', {
        treeDataProvider,
        showCollapseAll: false
    });
    // Register the refresh command
    const refreshCommand = vscode.commands.registerCommand('qwen-coder-assistant.refreshConversationHistory', () => {
        treeDataProvider.refresh();
    });
    // Register the open conversation command
    const openConversationCommand = vscode.commands.registerCommand('qwen-coder-assistant.openConversation', (conversation) => {
        // Import the QwenResponsePanel class to use its functionality
        const { QwenResponsePanel } = require('./webview/panel');
        // Create or show the panel
        const panel = QwenResponsePanel.createOrShow(context.extensionUri, `Conversation: ${conversation.title}`);
        // Format the conversation for display
        const content = `# ${conversation.title}\n\n## Prompt\n\n${conversation.prompt}\n\n## Response\n\n${conversation.response}`;
        // Set the content
        panel.setContent(content);
    });
    // Register the delete conversation command
    const deleteConversationCommand = vscode.commands.registerCommand('qwen-coder-assistant.deleteConversation', async (item) => {
        const result = await vscode.window.showWarningMessage(`Are you sure you want to delete the conversation "${item.conversation.title}"?`, { modal: true }, 'Delete');
        if (result === 'Delete') {
            historyManager.deleteConversation(item.conversation.id);
            treeDataProvider.refresh();
        }
    });
    // Register the clear all conversations command
    const clearConversationsCommand = vscode.commands.registerCommand('qwen-coder-assistant.clearConversations', async () => {
        const result = await vscode.window.showWarningMessage('Are you sure you want to clear all conversations? This cannot be undone.', { modal: true }, 'Clear All');
        if (result === 'Clear All') {
            historyManager.clearConversations();
            treeDataProvider.refresh();
        }
    });
    // Add to subscriptions
    context.subscriptions.push(treeView, refreshCommand, openConversationCommand, deleteConversationCommand, clearConversationsCommand);
}
/**
 * Save a conversation to history
 */
function saveToHistory(context, prompt, response, systemPrompt) {
    const historyManager = ConversationHistoryManager.getInstance(context);
    historyManager.addConversation(prompt, response, systemPrompt);
    // Refresh the tree view
    vscode.commands.executeCommand('qwen-coder-assistant.refreshConversationHistory');
}
//# sourceMappingURL=conversationHistory.js.map
```


---

### File: `archive/vscode-extension/src/extension.ts`

```typescript
import * as vscode from 'vscode';
import { AgentCoordinator } from './agents/agentCoordinator';
import { registerCommands } from './commands';
import { getConfiguration } from './configuration';
import { ContainerManager } from './containers/containerManager';
import { disposeContextEngine, initializeContextEngine } from './contextProvider';
import { registerConversationHistoryView } from './conversationHistory';
import { MCPClient } from './mcp/mcpClient';
import { MockQwenApiClient } from './mockQwenApi';
import { QwenApiClient } from './qwenApi';

export function activate(context: vscode.ExtensionContext) {
  console.log('Qwen Coder Assistant is now active!');

  // Initialize the API client
  const config = getConfiguration();

  // Use mock API client for development, real client for production
  const isDevelopment = process.env.NODE_ENV === 'development' || !config.apiKey;
  const apiClient = isDevelopment
    ? new MockQwenApiClient(config)
    : new QwenApiClient(config);

  // Add status bar item to show which API client is being used
  const statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right, 100);
  statusBarItem.text = isDevelopment ? '$(beaker) Qwen: Mock API' : '$(cloud) Qwen: Live API';
  statusBarItem.tooltip = isDevelopment
    ? 'Using Mock Qwen API (for development)'
    : 'Using Live Qwen API';
  statusBarItem.show();
  context.subscriptions.push(statusBarItem);

  // Initialize the container manager
  const containerManager = new ContainerManager();
  context.subscriptions.push(containerManager);

  // Initialize the MCP client
  const mcpClient = new MCPClient(containerManager);
  context.subscriptions.push(mcpClient);

  // Initialize the agent coordinator
  const agentCoordinator = new AgentCoordinator();
  context.subscriptions.push(agentCoordinator);

  // Register commands
  registerCommands(context, apiClient, agentCoordinator, mcpClient);

  // Register conversation history view
  registerConversationHistoryView(context);

  // Initialize the context engine
  initializeContextEngine().catch(error => {
    console.error('Error initializing context engine:', error);
  });

  // Initialize the container manager
  containerManager.initialize().catch(error => {
    console.error('Error initializing container manager:', error);
  });

  // Initialize the MCP client after container manager is initialized
  containerManager.initialize().then(() => {
    mcpClient.initialize().catch(error => {
      console.error('Error initializing MCP client:', error);
    });
  }).catch(() => {
    // Container manager initialization failed, but we can still proceed
  });

  // Register configuration change listener
  context.subscriptions.push(
    vscode.workspace.onDidChangeConfiguration(event => {
      if (event.affectsConfiguration('qwen-coder-assistant')) {
        const newConfig = getConfiguration();
        const newIsDevelopment = process.env.NODE_ENV === 'development' || !newConfig.apiKey;

        // Update API client
        if (apiClient instanceof MockQwenApiClient) {
          apiClient.updateConfig(newConfig);
        } else if (apiClient instanceof QwenApiClient) {
          apiClient.updateConfig(newConfig);
        }

        // Update status bar
        statusBarItem.text = newIsDevelopment ? '$(beaker) Qwen: Mock API' : '$(cloud) Qwen: Live API';
        statusBarItem.tooltip = newIsDevelopment
          ? 'Using Mock Qwen API (for development)'
          : 'Using Live Qwen API';
      }
    })
  );

  // Register commands for container management
  context.subscriptions.push(
    vscode.commands.registerCommand('qwenCoder.showContainerStatus', () => {
      const containerStatus = containerManager.getContainerStatus();
      const statusItems = Object.entries(containerStatus).map(([name, info]) => ({
        label: `$(docker) ${name}`,
        description: info.status,
        detail: info.status === 'running' ? `URL: ${info.url}` : info.error || '',
        containerName: name,
        status: info.status
      }));

      vscode.window.showQuickPick(statusItems, {
        placeHolder: 'Select a container to manage',
        matchOnDescription: true,
        matchOnDetail: true
      }).then(selected => {
        if (selected) {
          if (selected.status === 'running') {
            vscode.window.showQuickPick(['Stop', 'Restart', 'View Schema'], {
              placeHolder: `Action for ${selected.containerName}`
            }).then(action => {
              if (action === 'Stop') {
                containerManager.stopContainer(selected.containerName).catch(error => {
                  vscode.window.showErrorMessage(`Error stopping container: ${error.message}`);
                });
              } else if (action === 'Restart') {
                containerManager.stopContainer(selected.containerName)
                  .then(() => containerManager.startContainer(selected.containerName))
                  .catch(error => {
                    vscode.window.showErrorMessage(`Error restarting container: ${error.message}`);
                  });
              } else if (action === 'View Schema') {
                mcpClient.fetchToolSchema(selected.containerName)
                  .then(schema => {
                    const schemaDoc = JSON.stringify(schema, null, 2);
                    vscode.workspace.openTextDocument({ content: schemaDoc, language: 'json' })
                      .then(doc => vscode.window.showTextDocument(doc));
                  })
                  .catch(error => {
                    vscode.window.showErrorMessage(`Error fetching schema: ${error.message}`);
                  });
              }
            });
          } else {
            vscode.window.showQuickPick(['Start', 'Remove'], {
              placeHolder: `Action for ${selected.containerName}`
            }).then(action => {
              if (action === 'Start') {
                containerManager.startContainer(selected.containerName).catch(error => {
                  vscode.window.showErrorMessage(`Error starting container: ${error.message}`);
                });
              }
            });
          }
        }
      });
    })
  );

  // Register command for DevOps guidance
  context.subscriptions.push(
    vscode.commands.registerCommand('qwenCoder.devops', async () => {
      const request = await vscode.window.showInputBox({
        prompt: 'What DevOps task do you need help with?',
        placeHolder: 'e.g., Set up CI/CD pipeline, Create Docker container, Configure GitHub workflow'
      });

      if (request) {
        const panel = vscode.window.createWebviewPanel(
          'qwenCoderDevOps',
          'DevOps Guidance',
          vscode.ViewColumn.One,
          {
            enableScripts: true,
            retainContextWhenHidden: true
          }
        );

        panel.webview.html = getLoadingWebviewContent();

        try {
          const response = await agentCoordinator.processRequest(request);
          panel.webview.html = getWebviewContent(request, response);
        } catch (error) {
          panel.webview.html = getErrorWebviewContent(request, error.message);
        }
      }
    })
  );
}

export async function deactivate() {
  // Clean up resources when the extension is deactivated
  console.log('Qwen Coder Assistant is now deactivated!');

  // Dispose the context engine
  await disposeContextEngine();
}

// Helper functions for webview content
function getLoadingWebviewContent(): string {
  return `<!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DevOps Guidance</title>
    <style>
      body {
        font-family: var(--vscode-font-family);
        color: var(--vscode-editor-foreground);
        background-color: var(--vscode-editor-background);
        padding: 20px;
      }
      .loading {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 300px;
      }
      .spinner {
        width: 50px;
        height: 50px;
        border: 5px solid var(--vscode-button-background);
        border-radius: 50%;
        border-top-color: transparent;
        animation: spin 1s linear infinite;
        margin-bottom: 20px;
      }
      @keyframes spin {
        to { transform: rotate(360deg); }
      }
    </style>
  </head>
  <body>
    <div class="loading">
      <div class="spinner"></div>
      <h2>Processing your request...</h2>
      <p>The hierarchical agent system is working on your DevOps task.</p>
    </div>
  </body>
  </html>`;
}

function getWebviewContent(request: string, response: string): string {
  return `<!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DevOps Guidance</title>
    <style>
      body {
        font-family: var(--vscode-font-family);
        color: var(--vscode-editor-foreground);
        background-color: var(--vscode-editor-background);
        padding: 20px;
        line-height: 1.5;
      }
      h1, h2, h3, h4, h5, h6 {
        color: var(--vscode-editor-foreground);
      }
      pre {
        background-color: var(--vscode-textCodeBlock-background);
        padding: 16px;
        border-radius: 4px;
        overflow: auto;
      }
      code {
        font-family: var(--vscode-editor-font-family);
        font-size: var(--vscode-editor-font-size);
      }
      .request {
        background-color: var(--vscode-input-background);
        padding: 10px;
        border-radius: 4px;
        margin-bottom: 20px;
        border-left: 4px solid var(--vscode-activityBarBadge-background);
      }
    </style>
  </head>
  <body>
    <div class="request">
      <strong>Your request:</strong> ${request}
    </div>
    <div class="response">
      ${markdownToHtml(response)}
    </div>
  </body>
  </html>`;
}

function getErrorWebviewContent(request: string, errorMessage: string): string {
  return `<!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DevOps Guidance - Error</title>
    <style>
      body {
        font-family: var(--vscode-font-family);
        color: var(--vscode-editor-foreground);
        background-color: var(--vscode-editor-background);
        padding: 20px;
      }
      .request {
        background-color: var(--vscode-input-background);
        padding: 10px;
        border-radius: 4px;
        margin-bottom: 20px;
        border-left: 4px solid var(--vscode-activityBarBadge-background);
      }
      .error {
        background-color: var(--vscode-inputValidation-errorBackground);
        color: var(--vscode-inputValidation-errorForeground);
        padding: 10px;
        border-radius: 4px;
        margin-bottom: 20px;
        border-left: 4px solid var(--vscode-errorForeground);
      }
    </style>
  </head>
  <body>
    <div class="request">
      <strong>Your request:</strong> ${request}
    </div>
    <div class="error">
      <strong>Error:</strong> ${errorMessage}
    </div>
    <p>Please try again with a more specific request or check the extension logs for more details.</p>
  </body>
  </html>`;
}

function markdownToHtml(markdown: string): string {
  // This is a very simple markdown to HTML converter
  // In a real implementation, we would use a proper markdown parser

  // Replace headers
  let html = markdown
    .replace(/^### (.*$)/gim, '<h3>$1</h3>')
    .replace(/^## (.*$)/gim, '<h2>$1</h2>')
    .replace(/^# (.*$)/gim, '<h1>$1</h1>');

  // Replace code blocks
  html = html.replace(/```([a-z]*)\n([\s\S]*?)\n```/gim, '<pre><code class="language-$1">$2</code></pre>');

  // Replace inline code
  html = html.replace(/`([^`]+)`/gim, '<code>$1</code>');

  // Replace lists
  html = html.replace(/^\s*\*\s(.*$)/gim, '<ul><li>$1</li></ul>');
  html = html.replace(/^\s*\d+\.\s(.*$)/gim, '<ol><li>$1</li></ol>');

  // Replace paragraphs
  html = html.replace(/^\s*(\n)?([^\n]+)\n/gim, '<p>$2</p>');

  // Fix consecutive lists
  html = html.replace(/<\/ul>\s*<ul>/gim, '');
  html = html.replace(/<\/ol>\s*<ol>/gim, '');

  return html;
}

```


---

### File: `archive/vscode-extension/src/configuration.ts`

```typescript
import * as vscode from 'vscode';

export interface ContextEngineConfig {
  persistEmbeddings: boolean;
  databasePath: string;
  autoSaveIntervalMs: number;
}

export interface QwenCoderConfig {
  apiEndpoint: string;
  apiKey: string;
  maxTokens: number;
  temperature: number;
  cacheEnabled: boolean;
  cacheTTLMinutes: number;
  cacheMaxEntries: number;
  streamingEnabled: boolean;
  contextEngine: ContextEngineConfig;
}

export function getConfiguration(): QwenCoderConfig {
  const config = vscode.workspace.getConfiguration('qwen-coder-assistant');

  return {
    apiEndpoint: config.get<string>('apiEndpoint') || 'http://localhost:8000/v1',
    apiKey: config.get<string>('apiKey') || '',
    maxTokens: config.get<number>('maxTokens') || 2048,
    temperature: config.get<number>('temperature') || 0.7,
    cacheEnabled: config.get<boolean>('cacheEnabled') !== false, // Default to true
    cacheTTLMinutes: config.get<number>('cacheTTLMinutes') || 30,
    cacheMaxEntries: config.get<number>('cacheMaxEntries') || 100,
    streamingEnabled: config.get<boolean>('streamingEnabled') !== false, // Default to true
    contextEngine: {
      persistEmbeddings: config.get<boolean>('contextEngine.persistEmbeddings') !== false, // Default to true
      databasePath: config.get<string>('contextEngine.databasePath') || '',
      autoSaveIntervalMs: config.get<number>('contextEngine.autoSaveIntervalMs') || 60000
    }
  };
}

// Listen for configuration changes
export function registerConfigurationListener(callback: (config: QwenCoderConfig) => void): vscode.Disposable {
  return vscode.workspace.onDidChangeConfiguration(event => {
    if (event.affectsConfiguration('qwen-coder-assistant')) {
      callback(getConfiguration());
    }
  });
}

```


---

### File: `archive/vscode-extension/src/conversationHistory.ts`

```typescript
import * as fs from 'fs';
import * as path from 'path';
import * as vscode from 'vscode';

/**
 * Represents a conversation entry in the history
 */
export interface ConversationEntry {
  id: string;
  title: string;
  timestamp: number;
  prompt: string;
  response: string;
  systemPrompt?: string;
}

/**
 * Manages conversation history for the extension
 */
export class ConversationHistoryManager {
  private static instance: ConversationHistoryManager;
  private conversations: ConversationEntry[] = [];
  private storageUri?: vscode.Uri;
  private readonly MAX_HISTORY_ITEMS = 50;

  private constructor(context: vscode.ExtensionContext) {
    this.storageUri = context.globalStorageUri;
    this.loadConversations();
  }

  /**
   * Get the singleton instance of the conversation history manager
   */
  public static getInstance(context: vscode.ExtensionContext): ConversationHistoryManager {
    if (!ConversationHistoryManager.instance) {
      ConversationHistoryManager.instance = new ConversationHistoryManager(context);
    }
    return ConversationHistoryManager.instance;
  }

  /**
   * Add a new conversation to the history
   */
  public addConversation(prompt: string, response: string, systemPrompt?: string): ConversationEntry {
    // Generate a title from the prompt (first line or first few words)
    const title = this.generateTitle(prompt);

    // Create a new conversation entry
    const entry: ConversationEntry = {
      id: Date.now().toString(),
      title,
      timestamp: Date.now(),
      prompt,
      response,
      systemPrompt
    };

    // Add to the beginning of the array
    this.conversations.unshift(entry);

    // Limit the number of conversations
    if (this.conversations.length > this.MAX_HISTORY_ITEMS) {
      this.conversations = this.conversations.slice(0, this.MAX_HISTORY_ITEMS);
    }

    // Save the updated conversations
    this.saveConversations();

    return entry;
  }

  /**
   * Get all conversations
   */
  public getConversations(): ConversationEntry[] {
    return [...this.conversations];
  }

  /**
   * Get a conversation by ID
   */
  public getConversation(id: string): ConversationEntry | undefined {
    return this.conversations.find(c => c.id === id);
  }

  /**
   * Delete a conversation by ID
   */
  public deleteConversation(id: string): boolean {
    const initialLength = this.conversations.length;
    this.conversations = this.conversations.filter(c => c.id !== id);

    if (this.conversations.length !== initialLength) {
      this.saveConversations();
      return true;
    }

    return false;
  }

  /**
   * Clear all conversations
   */
  public clearConversations(): void {
    this.conversations = [];
    this.saveConversations();
  }

  /**
   * Generate a title from the prompt
   */
  private generateTitle(prompt: string): string {
    // Use the first line if it's short enough
    const firstLine = prompt.split('\n')[0].trim();
    if (firstLine.length <= 50) {
      return firstLine;
    }

    // Otherwise use the first few words
    return firstLine.substring(0, 47) + '...';
  }

  /**
   * Load conversations from storage
   */
  private loadConversations(): void {
    try {
      if (!this.storageUri) {
        return;
      }

      // Create the storage directory if it doesn't exist
      const dirPath = this.storageUri.fsPath;
      if (!fs.existsSync(dirPath)) {
        fs.mkdirSync(dirPath, { recursive: true });
      }

      const filePath = path.join(dirPath, 'conversations.json');
      if (fs.existsSync(filePath)) {
        const data = fs.readFileSync(filePath, 'utf8');
        this.conversations = JSON.parse(data);
      }
    } catch (error) {
      console.error('Error loading conversations:', error);
      this.conversations = [];
    }
  }

  /**
   * Save conversations to storage
   */
  private saveConversations(): void {
    try {
      if (!this.storageUri) {
        return;
      }

      // Create the storage directory if it doesn't exist
      const dirPath = this.storageUri.fsPath;
      if (!fs.existsSync(dirPath)) {
        fs.mkdirSync(dirPath, { recursive: true });
      }

      const filePath = path.join(dirPath, 'conversations.json');
      fs.writeFileSync(filePath, JSON.stringify(this.conversations, null, 2), 'utf8');
    } catch (error) {
      console.error('Error saving conversations:', error);
    }
  }
}

/**
 * Tree data provider for conversation history
 */
export class ConversationHistoryProvider implements vscode.TreeDataProvider<ConversationTreeItem> {
  private _onDidChangeTreeData: vscode.EventEmitter<ConversationTreeItem | undefined | null | void> = new vscode.EventEmitter<ConversationTreeItem | undefined | null | void>();
  readonly onDidChangeTreeData: vscode.Event<ConversationTreeItem | undefined | null | void> = this._onDidChangeTreeData.event;

  constructor(private historyManager: ConversationHistoryManager) {}

  refresh(): void {
    this._onDidChangeTreeData.fire();
  }

  getTreeItem(element: ConversationTreeItem): vscode.TreeItem {
    return element;
  }

  getChildren(element?: ConversationTreeItem): Thenable<ConversationTreeItem[]> {
    if (element) {
      return Promise.resolve([]);
    } else {
      const conversations = this.historyManager.getConversations();
      return Promise.resolve(
        conversations.map(conversation => new ConversationTreeItem(conversation))
      );
    }
  }
}

/**
 * Tree item for a conversation
 */
export class ConversationTreeItem extends vscode.TreeItem {
  constructor(public readonly conversation: ConversationEntry) {
    super(conversation.title, vscode.TreeItemCollapsibleState.None);

    // Format the date
    const date = new Date(conversation.timestamp);
    const formattedDate = date.toLocaleDateString() + ' ' + date.toLocaleTimeString();

    this.tooltip = `${conversation.title}\n${formattedDate}`;
    this.description = formattedDate;
    this.contextValue = 'conversation';

    // Set the command to open the conversation
    this.command = {
      command: 'qwen-coder-assistant.openConversation',
      title: 'Open Conversation',
      arguments: [conversation]
    };
  }
}

/**
 * Register the conversation history view
 */
export function registerConversationHistoryView(context: vscode.ExtensionContext): void {
  // Create the history manager
  const historyManager = ConversationHistoryManager.getInstance(context);

  // Create the tree data provider
  const treeDataProvider = new ConversationHistoryProvider(historyManager);

  // Register the tree view
  const treeView = vscode.window.createTreeView('qwenConversationHistory', {
    treeDataProvider,
    showCollapseAll: false
  });

  // Register the refresh command
  const refreshCommand = vscode.commands.registerCommand(
    'qwen-coder-assistant.refreshConversationHistory',
    () => {
      treeDataProvider.refresh();
    }
  );

  // Register the open conversation command
  const openConversationCommand = vscode.commands.registerCommand(
    'qwen-coder-assistant.openConversation',
    (conversation: ConversationEntry) => {
      // Import the QwenResponsePanel class to use its functionality
      const { QwenResponsePanel } = require('./webview/panel');

      // Create or show the panel
      const panel = QwenResponsePanel.createOrShow(
        context.extensionUri,
        `Conversation: ${conversation.title}`
      );

      // Format the conversation for display
      const content = `# ${conversation.title}\n\n## Prompt\n\n${conversation.prompt}\n\n## Response\n\n${conversation.response}`;

      // Set the content
      panel.setContent(content);
    }
  );

  // Register the delete conversation command
  const deleteConversationCommand = vscode.commands.registerCommand(
    'qwen-coder-assistant.deleteConversation',
    async (item: ConversationTreeItem) => {
      const result = await vscode.window.showWarningMessage(
        `Are you sure you want to delete the conversation "${item.conversation.title}"?`,
        { modal: true },
        'Delete'
      );

      if (result === 'Delete') {
        historyManager.deleteConversation(item.conversation.id);
        treeDataProvider.refresh();
      }
    }
  );

  // Register the clear all conversations command
  const clearConversationsCommand = vscode.commands.registerCommand(
    'qwen-coder-assistant.clearConversations',
    async () => {
      const result = await vscode.window.showWarningMessage(
        'Are you sure you want to clear all conversations? This cannot be undone.',
        { modal: true },
        'Clear All'
      );

      if (result === 'Clear All') {
        historyManager.clearConversations();
        treeDataProvider.refresh();
      }
    }
  );

  // Add to subscriptions
  context.subscriptions.push(
    treeView,
    refreshCommand,
    openConversationCommand,
    deleteConversationCommand,
    clearConversationsCommand
  );
}

/**
 * Save a conversation to history
 */
export function saveToHistory(
  context: vscode.ExtensionContext,
  prompt: string,
  response: string,
  systemPrompt?: string
): void {
  const historyManager = ConversationHistoryManager.getInstance(context);
  historyManager.addConversation(prompt, response, systemPrompt);

  // Refresh the tree view
  vscode.commands.executeCommand('qwen-coder-assistant.refreshConversationHistory');
}

```


---

### File: `archive/vscode-extension/src/commands.ts`

```typescript
import * as vscode from 'vscode';
import { getConfiguration } from './configuration';
import { getEditorContext, getProjectContext } from './contextProvider';
import { ErrorHandler } from './errorHandler';
import { QwenApiClient, QwenRequestOptions } from './qwenApi';
import { showResponseInPanel, showStreamingResponseInPanel } from './responseFormatter';

export function registerCommands(
  context: vscode.ExtensionContext,
  apiClient: QwenApiClient,
  agentCoordinator?: AgentCoordinator,
  mcpClient?: MCPClient
): void {
  // Register the "Ask Qwen" command
  const askQwenCommand = vscode.commands.registerCommand('qwen-coder-assistant.askQwen', async () => {
    const userPrompt = await vscode.window.showInputBox({
      prompt: 'What would you like to ask Qwen?',
      placeHolder: 'E.g., How do I implement a binary search in JavaScript?'
    });

    if (!userPrompt) {
      return; // User cancelled
    }

    try {
      vscode.window.withProgress({
        location: vscode.ProgressLocation.Notification,
        title: 'Asking Qwen...',
        cancellable: false
      }, async (progress) => {
        progress.report({ increment: 0 });

        const editorContext = await getEditorContext();

        let prompt = userPrompt;
        if (editorContext) {
          prompt += `\n\nContext:\nFile: ${editorContext.fileName}\nLanguage: ${editorContext.language}\n`;

          if (editorContext.selectedCode) {
            prompt += `\nSelected code:\n\`\`\`${editorContext.language}\n${editorContext.selectedCode}\n\`\`\``;
          }
        }

        progress.report({ increment: 30, message: 'Retrieving code context...' });

        // Get relevant context from the context engine
        const codeContext = await getProjectContext(userPrompt);
        if (codeContext) {
          prompt += `\n\nRelevant code context:\n${codeContext}`;
        }

        progress.report({ increment: 50 });

        const options: QwenRequestOptions = {
          prompt,
          systemPrompt: 'You are Qwen Coder, an AI assistant specialized in helping with programming tasks. Provide clear, concise, and accurate responses to coding questions. Include code examples when appropriate.'
        };

        // Check if streaming is enabled in configuration
        const config = getConfiguration();
        if (config.streamingEnabled) {
          // Use streaming API
          progress.report({ message: 'Streaming response...' });

          // Variable to accumulate the full response for history
          let fullResponse = '';

          showStreamingResponseInPanel(context, (streamHandler) => {
            apiClient.generateStreamingCompletion(options, (chunk, done) => {
              // Accumulate the response
              fullResponse += chunk;

              // Pass to the original handler
              streamHandler(chunk, done);

              // When streaming is complete, save to history
              if (done) {
                saveToHistory(context, prompt, fullResponse, options.systemPrompt);
              }
            }).catch(error => {
              ErrorHandler.handleError(error);
            });
          });

          progress.report({ increment: 100 });
        } else {
          // Use non-streaming API
          const response = await apiClient.generateCompletion(options);
          progress.report({ increment: 100 });

          // Save to conversation history
          saveToHistory(context, prompt, response.text, options.systemPrompt);

          // Show response in panel
          showResponseInPanel(response.text, context);
        }
      });
    } catch (error) {
      ErrorHandler.handleError(error);
    }
  });

  // Register the "Explain Code" command
  const explainCodeCommand = vscode.commands.registerCommand('qwen-coder-assistant.explainCode', async () => {
    const editorContext = await getEditorContext();

    if (!editorContext || !editorContext.selectedCode) {
      vscode.window.showInformationMessage('Please select some code to explain.');
      return;
    }

    try {
      vscode.window.withProgress({
        location: vscode.ProgressLocation.Notification,
        title: 'Explaining code...',
        cancellable: false
      }, async (progress) => {
        progress.report({ increment: 0 });

        const prompt = `Please explain the following code in detail:\n\`\`\`${editorContext.language}\n${editorContext.selectedCode}\n\`\`\``;

        const options: QwenRequestOptions = {
          prompt,
          systemPrompt: 'You are Qwen Coder, an AI assistant specialized in explaining code. Provide clear, detailed explanations of how the code works, its purpose, and any important patterns or concepts it demonstrates.'
        };

        progress.report({ increment: 50 });

        // Check if streaming is enabled in configuration
        const config = getConfiguration();
        if (config.streamingEnabled) {
          // Use streaming API
          progress.report({ message: 'Streaming response...' });

          // Variable to accumulate the full response for history
          let fullResponse = '';

          showStreamingResponseInPanel(context, (streamHandler) => {
            apiClient.generateStreamingCompletion(options, (chunk, done) => {
              // Accumulate the response
              fullResponse += chunk;

              // Pass to the original handler
              streamHandler(chunk, done);

              // When streaming is complete, save to history
              if (done) {
                saveToHistory(context, prompt, fullResponse, options.systemPrompt);
              }
            }).catch(error => {
              ErrorHandler.handleError(error);
            });
          });

          progress.report({ increment: 100 });
        } else {
          // Use non-streaming API
          const response = await apiClient.generateCompletion(options);
          progress.report({ increment: 100 });

          // Save to conversation history
          saveToHistory(context, prompt, response.text, options.systemPrompt);

          // Show response in panel
          showResponseInPanel(response.text, context);
        }
      });
    } catch (error) {
      ErrorHandler.handleError(error);
    }
  });

  // Register the "Generate Code" command
  const generateCodeCommand = vscode.commands.registerCommand('qwen-coder-assistant.generateCode', async () => {
    const userPrompt = await vscode.window.showInputBox({
      prompt: 'What code would you like to generate?',
      placeHolder: 'E.g., Write a function to sort an array of objects by a property'
    });

    if (!userPrompt) {
      return; // User cancelled
    }

    try {
      vscode.window.withProgress({
        location: vscode.ProgressLocation.Notification,
        title: 'Generating code...',
        cancellable: false
      }, async (progress) => {
        progress.report({ increment: 0 });

        const editorContext = await getEditorContext();

        let prompt = `Generate code for: ${userPrompt}`;
        if (editorContext) {
          prompt += `\n\nContext:\nFile: ${editorContext.fileName}\nLanguage: ${editorContext.language}\n`;

          if (editorContext.visibleRangeText) {
            prompt += `\nSurrounding code:\n\`\`\`${editorContext.language}\n${editorContext.visibleRangeText}\n\`\`\``;
          }
        }

        progress.report({ increment: 30 });

        // Get project context for better code generation
        progress.report({ message: 'Retrieving code context...' });
        const projectContext = await getProjectContext(userPrompt);
        if (projectContext) {
          prompt += `\n\nProject context (relevant files):\n${projectContext}`;
        }

        progress.report({ increment: 50 });

        const options: QwenRequestOptions = {
          prompt,
          systemPrompt: 'You are Qwen Coder, an AI assistant specialized in generating high-quality code. Generate code that is efficient, well-documented, and follows best practices for the given language and context.'
        };

        // Check if streaming is enabled in configuration
        const config = getConfiguration();
        if (config.streamingEnabled) {
          // Use streaming API
          progress.report({ message: 'Streaming response...' });

          // Variable to accumulate the full response for history
          let fullResponse = '';

          showStreamingResponseInPanel(context, (streamHandler) => {
            apiClient.generateStreamingCompletion(options, (chunk, done) => {
              // Accumulate the response
              fullResponse += chunk;

              // Pass to the original handler
              streamHandler(chunk, done);

              // When streaming is complete, save to history
              if (done) {
                saveToHistory(context, prompt, fullResponse, options.systemPrompt);
              }
            }).catch(error => {
              ErrorHandler.handleError(error);
            });
          });

          progress.report({ increment: 100 });
        } else {
          // Use non-streaming API
          const response = await apiClient.generateCompletion(options);
          progress.report({ increment: 100 });

          // Save to conversation history
          saveToHistory(context, prompt, response.text, options.systemPrompt);

          // Show response in panel
          showResponseInPanel(response.text, context);
        }
      });
    } catch (error) {
      ErrorHandler.handleError(error);
    }
  });

  // Register the "Clear Cache" command
  const clearCacheCommand = vscode.commands.registerCommand('qwen-coder-assistant.clearCache', async () => {
    try {
      apiClient.clearCache();
      vscode.window.showInformationMessage('Qwen Coder cache cleared successfully.');
    } catch (error) {
      ErrorHandler.handleError(error);
    }
  });

  // Register the "Refactor Code" command
  const refactorCodeCommand = vscode.commands.registerCommand('qwen-coder-assistant.refactorCode', async () => {
    const editorContext = await getEditorContext();

    if (!editorContext || !editorContext.selectedCode) {
      vscode.window.showInformationMessage('Please select some code to refactor.');
      return;
    }

    try {
      vscode.window.withProgress({
        location: vscode.ProgressLocation.Notification,
        title: 'Refactoring code...',
        cancellable: false
      }, async (progress) => {
        progress.report({ increment: 0 });

        const prompt = `Please refactor the following code to improve its readability, efficiency, and maintainability. Provide the refactored code and explain the improvements made:\n\`\`\`${editorContext.language}\n${editorContext.selectedCode}\n\`\`\``;

        const options: QwenRequestOptions = {
          prompt,
          systemPrompt: 'You are Qwen Coder, an AI assistant specialized in refactoring code. Provide clean, efficient, and well-structured code that follows best practices and design patterns. Explain the improvements you made.'
        };

        progress.report({ increment: 50 });

        // Check if streaming is enabled in configuration
        const config = getConfiguration();
        if (config.streamingEnabled) {
          // Use streaming API
          progress.report({ message: 'Streaming response...' });

          // Variable to accumulate the full response for history
          let fullResponse = '';

          showStreamingResponseInPanel(context, (streamHandler) => {
            apiClient.generateStreamingCompletion(options, (chunk, done) => {
              // Accumulate the response
              fullResponse += chunk;

              // Pass to the original handler
              streamHandler(chunk, done);

              // When streaming is complete, save to history
              if (done) {
                saveToHistory(context, prompt, fullResponse, options.systemPrompt);
              }
            }).catch(error => {
              ErrorHandler.handleError(error);
            });
          });

          progress.report({ increment: 100 });
        } else {
          // Use non-streaming API
          const response = await apiClient.generateCompletion(options);
          progress.report({ increment: 100 });

          // Save to conversation history
          saveToHistory(context, prompt, response.text, options.systemPrompt);

          // Show response in panel
          showResponseInPanel(response.text, context);
        }
      });
    } catch (error) {
      ErrorHandler.handleError(error);
    }
  });

  // Register the "Document Code" command
  const documentCodeCommand = vscode.commands.registerCommand('qwen-coder-assistant.documentCode', async () => {
    const editorContext = await getEditorContext();

    if (!editorContext || !editorContext.selectedCode) {
      vscode.window.showInformationMessage('Please select some code to document.');
      return;
    }

    try {
      vscode.window.withProgress({
        location: vscode.ProgressLocation.Notification,
        title: 'Documenting code...',
        cancellable: false
      }, async (progress) => {
        progress.report({ increment: 0 });

        const prompt = `Please add comprehensive documentation to the following code. Include function/method descriptions, parameter explanations, return value details, and any other relevant documentation:\n\`\`\`${editorContext.language}\n${editorContext.selectedCode}\n\`\`\``;

        const options: QwenRequestOptions = {
          prompt,
          systemPrompt: 'You are Qwen Coder, an AI assistant specialized in documenting code. Provide clear, comprehensive documentation that follows the conventions of the given programming language. Include function/method descriptions, parameter explanations, return value details, and usage examples where appropriate.'
        };

        progress.report({ increment: 50 });

        // Check if streaming is enabled in configuration
        const config = getConfiguration();
        if (config.streamingEnabled) {
          // Use streaming API
          progress.report({ message: 'Streaming response...' });

          // Variable to accumulate the full response for history
          let fullResponse = '';

          showStreamingResponseInPanel(context, (streamHandler) => {
            apiClient.generateStreamingCompletion(options, (chunk, done) => {
              // Accumulate the response
              fullResponse += chunk;

              // Pass to the original handler
              streamHandler(chunk, done);

              // When streaming is complete, save to history
              if (done) {
                saveToHistory(context, prompt, fullResponse, options.systemPrompt);
              }
            }).catch(error => {
              ErrorHandler.handleError(error);
            });
          });

          progress.report({ increment: 100 });
        } else {
          // Use non-streaming API
          const response = await apiClient.generateCompletion(options);
          progress.report({ increment: 100 });

          // Save to conversation history
          saveToHistory(context, prompt, response.text, options.systemPrompt);

          // Show response in panel
          showResponseInPanel(response.text, context);
        }
      });
    } catch (error) {
      ErrorHandler.handleError(error);
    }
  });

  // Register the "Fix Issues" command
  const fixIssuesCommand = vscode.commands.registerCommand('qwen-coder-assistant.fixIssues', async () => {
    const editorContext = await getEditorContext();

    if (!editorContext || !editorContext.selectedCode) {
      vscode.window.showInformationMessage('Please select some code to fix.');
      return;
    }

    try {
      vscode.window.withProgress({
        location: vscode.ProgressLocation.Notification,
        title: 'Fixing code issues...',
        cancellable: false
      }, async (progress) => {
        progress.report({ increment: 0 });

        const prompt = `Please identify and fix any issues in the following code. This could include bugs, syntax errors, performance issues, or security vulnerabilities. Provide the fixed code and explain the issues that were addressed:\n\`\`\`${editorContext.language}\n${editorContext.selectedCode}\n\`\`\``;

        const options: QwenRequestOptions = {
          prompt,
          systemPrompt: 'You are Qwen Coder, an AI assistant specialized in identifying and fixing code issues. Look for bugs, syntax errors, performance issues, security vulnerabilities, and other problems. Provide the fixed code and explain the issues that were addressed.'
        };

        progress.report({ increment: 50 });

        // Check if streaming is enabled in configuration
        const config = getConfiguration();
        if (config.streamingEnabled) {
          // Use streaming API
          progress.report({ message: 'Streaming response...' });

          // Variable to accumulate the full response for history
          let fullResponse = '';

          showStreamingResponseInPanel(context, (streamHandler) => {
            apiClient.generateStreamingCompletion(options, (chunk, done) => {
              // Accumulate the response
              fullResponse += chunk;

              // Pass to the original handler
              streamHandler(chunk, done);

              // When streaming is complete, save to history
              if (done) {
                saveToHistory(context, prompt, fullResponse, options.systemPrompt);
              }
            }).catch(error => {
              ErrorHandler.handleError(error);
            });
          });

          progress.report({ increment: 100 });
        } else {
          // Use non-streaming API
          const response = await apiClient.generateCompletion(options);
          progress.report({ increment: 100 });

          // Save to conversation history
          saveToHistory(context, prompt, response.text, options.systemPrompt);

          // Show response in panel
          showResponseInPanel(response.text, context);
        }
      });
    } catch (error) {
      ErrorHandler.handleError(error);
    }
  });

  // Register the "Hierarchical Agent" command
  const hierarchicalAgentCommand = vscode.commands.registerCommand('qwen-coder-assistant.hierarchicalAgent', async () => {
    if (!agentCoordinator) {
      vscode.window.showErrorMessage('Hierarchical agent system is not available.');
      return;
    }

    const userPrompt = await vscode.window.showInputBox({
      prompt: 'What would you like the hierarchical agent system to do?',
      placeHolder: 'E.g., Implement a feature, refactor a module, create tests for a function'
    });

    if (!userPrompt) {
      return; // User cancelled
    }

    try {
      vscode.window.withProgress({
        location: vscode.ProgressLocation.Notification,
        title: 'Processing with hierarchical agent system...',
        cancellable: false
      }, async (progress) => {
        progress.report({ increment: 0 });

        // Create a webview panel to display the results
        const panel = vscode.window.createWebviewPanel(
          'qwenCoderHierarchicalAgent',
          'Hierarchical Agent',
          vscode.ViewColumn.One,
          {
            enableScripts: true,
            retainContextWhenHidden: true
          }
        );

        // Show loading indicator
        panel.webview.html = getLoadingWebviewContent();

        progress.report({ increment: 30, message: 'Decomposing task...' });

        try {
          // Process the request with the agent coordinator
          progress.report({ increment: 50, message: 'Executing subtasks...' });
          const response = await agentCoordinator.processRequest(userPrompt);

          progress.report({ increment: 100, message: 'Aggregating results...' });

          // Show the response in the panel
          panel.webview.html = getWebviewContent(userPrompt, response);

          // Save to conversation history
          saveToHistory(context, userPrompt, response, 'Hierarchical Agent System');
        } catch (error) {
          panel.webview.html = getErrorWebviewContent(userPrompt, error.message);
          ErrorHandler.handleError(error);
        }
      });
    } catch (error) {
      ErrorHandler.handleError(error);
    }
  });

  // Register the "MCP Tool" command
  const mcpToolCommand = vscode.commands.registerCommand('qwen-coder-assistant.mcpTool', async () => {
    if (!mcpClient) {
      vscode.window.showErrorMessage('MCP tools are not available.');
      return;
    }

    try {
      // Get available tools
      const availableTools = mcpClient.getAvailableTools();

      if (availableTools.length === 0) {
        vscode.window.showInformationMessage('No MCP tools are currently available. Please start some tools first.');
        return;
      }

      // Let the user select a tool
      const selectedTool = await vscode.window.showQuickPick(availableTools, {
        placeHolder: 'Select an MCP tool to use'
      });

      if (!selectedTool) {
        return; // User cancelled
      }

      // Get the tool schema
      const toolSchema = mcpClient.getToolSchema(selectedTool);

      if (!toolSchema) {
        vscode.window.showErrorMessage(`Schema for tool ${selectedTool} is not available.`);
        return;
      }

      // Let the user select a function
      const functionItems = toolSchema.functions.map(func => ({
        label: func.name,
        description: func.description,
        detail: `Parameters: ${Object.keys(func.parameters.properties).join(', ')}`,
        function: func
      }));

      const selectedFunction = await vscode.window.showQuickPick(functionItems, {
        placeHolder: 'Select a function to call'
      });

      if (!selectedFunction) {
        return; // User cancelled
      }

      // Collect parameters for the function
      const parameters: Record<string, any> = {};

      for (const paramName of selectedFunction.function.parameters.required) {
        const paramSchema = selectedFunction.function.parameters.properties[paramName];

        const paramValue = await vscode.window.showInputBox({
          prompt: `Enter value for ${paramName}`,
          placeHolder: paramSchema.description
        });

        if (paramValue === undefined) {
          return; // User cancelled
        }

        // Convert value to appropriate type
        if (paramSchema.type === 'number') {
          parameters[paramName] = Number(paramValue);
        } else if (paramSchema.type === 'boolean') {
          parameters[paramName] = paramValue.toLowerCase() === 'true';
        } else {
          parameters[paramName] = paramValue;
        }
      }

      // Call the function
      vscode.window.withProgress({
        location: vscode.ProgressLocation.Notification,
        title: `Calling ${selectedFunction.label} on ${selectedTool}...`,
        cancellable: false
      }, async (progress) => {
        progress.report({ increment: 0 });

        const result = await mcpClient.callFunction(selectedTool, selectedFunction.label, parameters);

        progress.report({ increment: 100 });

        // Show the result
        if (result.status === 'success') {
          // Create a webview panel to display the results
          const panel = vscode.window.createWebviewPanel(
            'qwenCoderMcpTool',
            `${selectedTool} - ${selectedFunction.label}`,
            vscode.ViewColumn.One,
            {
              enableScripts: true,
              retainContextWhenHidden: true
            }
          );

          // Show the result
          panel.webview.html = `<!DOCTYPE html>
          <html lang="en">
          <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>${selectedTool} - ${selectedFunction.label}</title>
            <style>
              body {
                font-family: var(--vscode-font-family);
                color: var(--vscode-editor-foreground);
                background-color: var(--vscode-editor-background);
                padding: 20px;
              }
              pre {
                background-color: var(--vscode-textCodeBlock-background);
                padding: 16px;
                border-radius: 4px;
                overflow: auto;
              }
            </style>
          </head>
          <body>
            <h1>${selectedTool} - ${selectedFunction.label}</h1>
            <h2>Parameters</h2>
            <pre>${JSON.stringify(parameters, null, 2)}</pre>
            <h2>Result</h2>
            <pre>${JSON.stringify(result.result, null, 2)}</pre>
          </body>
          </html>`;
        } else {
          vscode.window.showErrorMessage(`Error calling function: ${result.error}`);
        }
      });
    } catch (error) {
      ErrorHandler.handleError(error);
    }
  });

  // Add commands to subscriptions
  context.subscriptions.push(
    askQwenCommand,
    explainCodeCommand,
    generateCodeCommand,
    refactorCodeCommand,
    documentCodeCommand,
    fixIssuesCommand,
    clearCacheCommand,
    hierarchicalAgentCommand,
    mcpToolCommand
  );
}

// Helper function to get loading webview content
function getLoadingWebviewContent(): string {
  return `<!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Processing Request</title>
    <style>
      body {
        font-family: var(--vscode-font-family);
        color: var(--vscode-editor-foreground);
        background-color: var(--vscode-editor-background);
        padding: 20px;
      }
      .loading {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 300px;
      }
      .spinner {
        width: 50px;
        height: 50px;
        border: 5px solid var(--vscode-button-background);
        border-radius: 50%;
        border-top-color: transparent;
        animation: spin 1s linear infinite;
        margin-bottom: 20px;
      }
      @keyframes spin {
        to { transform: rotate(360deg); }
      }
    </style>
  </head>
  <body>
    <div class="loading">
      <div class="spinner"></div>
      <h2>Processing your request...</h2>
      <p>The hierarchical agent system is working on your task.</p>
    </div>
  </body>
  </html>`;
}

// Helper function to get webview content
function getWebviewContent(request: string, response: string): string {
  return `<!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Agent Response</title>
    <style>
      body {
        font-family: var(--vscode-font-family);
        color: var(--vscode-editor-foreground);
        background-color: var(--vscode-editor-background);
        padding: 20px;
        line-height: 1.5;
      }
      h1, h2, h3, h4, h5, h6 {
        color: var(--vscode-editor-foreground);
      }
      pre {
        background-color: var(--vscode-textCodeBlock-background);
        padding: 16px;
        border-radius: 4px;
        overflow: auto;
      }
      code {
        font-family: var(--vscode-editor-font-family);
        font-size: var(--vscode-editor-font-size);
      }
      .request {
        background-color: var(--vscode-input-background);
        padding: 10px;
        border-radius: 4px;
        margin-bottom: 20px;
        border-left: 4px solid var(--vscode-activityBarBadge-background);
      }
    </style>
  </head>
  <body>
    <div class="request">
      <strong>Your request:</strong> ${request}
    </div>
    <div class="response">
      ${markdownToHtml(response)}
    </div>
  </body>
  </html>`;
}

// Helper function to get error webview content
function getErrorWebviewContent(request: string, errorMessage: string): string {
  return `<!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Error</title>
    <style>
      body {
        font-family: var(--vscode-font-family);
        color: var(--vscode-editor-foreground);
        background-color: var(--vscode-editor-background);
        padding: 20px;
      }
      .request {
        background-color: var(--vscode-input-background);
        padding: 10px;
        border-radius: 4px;
        margin-bottom: 20px;
        border-left: 4px solid var(--vscode-activityBarBadge-background);
      }
      .error {
        background-color: var(--vscode-inputValidation-errorBackground);
        color: var(--vscode-inputValidation-errorForeground);
        padding: 10px;
        border-radius: 4px;
        margin-bottom: 20px;
        border-left: 4px solid var(--vscode-errorForeground);
      }
    </style>
  </head>
  <body>
    <div class="request">
      <strong>Your request:</strong> ${request}
    </div>
    <div class="error">
      <strong>Error:</strong> ${errorMessage}
    </div>
    <p>Please try again with a more specific request or check the extension logs for more details.</p>
  </body>
  </html>`;
}

// Helper function to convert markdown to HTML
function markdownToHtml(markdown: string): string {
  // This is a very simple markdown to HTML converter
  // In a real implementation, we would use a proper markdown parser

  // Replace headers
  let html = markdown
    .replace(/^### (.*$)/gim, '<h3>$1</h3>')
    .replace(/^## (.*$)/gim, '<h2>$1</h2>')
    .replace(/^# (.*$)/gim, '<h1>$1</h1>');

  // Replace code blocks
  html = html.replace(/```([a-z]*)\n([\s\S]*?)\n```/gim, '<pre><code class="language-$1">$2</code></pre>');

  // Replace inline code
  html = html.replace(/`([^`]+)`/gim, '<code>$1</code>');

  // Replace lists
  html = html.replace(/^\s*\*\s(.*$)/gim, '<ul><li>$1</li></ul>');
  html = html.replace(/^\s*\d+\.\s(.*$)/gim, '<ol><li>$1</li></ol>');

  // Replace paragraphs
  html = html.replace(/^\s*(\n)?([^\n]+)\n/gim, '<p>$2</p>');

  // Fix consecutive lists
  html = html.replace(/<\/ul>\s*<ul>/gim, '');
  html = html.replace(/<\/ol>\s*<ol>/gim, '');

  return html;
}

```


---

### File: `archive/vscode-extension/src/contextProvider.ts`

```typescript
import * as path from 'path';
import * as vscode from 'vscode';
import { ContextEngine } from './context/contextEngine';

// Create a singleton instance of the context engine
const contextEngine = new ContextEngine();

export interface CodeContext {
  selectedCode: string;
  fullDocumentText: string;
  fileName: string;
  fileExtension: string;
  language: string;
  selection: vscode.Selection | null;
  visibleRangeText: string;
  projectContext?: string;
}

export async function getEditorContext(): Promise<CodeContext | null> {
  const editor = vscode.window.activeTextEditor;
  if (!editor) {
    return null;
  }

  const document = editor.document;
  const selection = editor.selection;
  const selectedText = document.getText(selection);
  const fullText = document.getText();
  const fileName = path.basename(document.fileName);
  const fileExtension = path.extname(document.fileName).substring(1);
  const language = document.languageId;

  // Get visible range text
  const visibleRanges = editor.visibleRanges;
  let visibleText = '';
  for (const range of visibleRanges) {
    visibleText += document.getText(range) + '\n';
  }

  return {
    selectedCode: selectedText,
    fullDocumentText: fullText,
    fileName,
    fileExtension,
    language,
    selection: selection.isEmpty ? null : selection,
    visibleRangeText: visibleText
  };
}

export async function getProjectContext(query: string = '', maxTokens: number = 4000): Promise<string> {
  try {
    // Initialize the context engine if it hasn't been initialized yet
    if (!contextEngine) {
      return "Context engine not available";
    }

    // Get context from the context engine
    return await contextEngine.getContext(query, maxTokens);
  } catch (error) {
    console.error('Error getting project context:', error);
    return `Error getting project context: ${error instanceof Error ? error.message : String(error)}`;
  }
}

export async function getContextForFile(filePath: string, maxTokens: number = 4000): Promise<string> {
  try {
    // Initialize the context engine if it hasn't been initialized yet
    if (!contextEngine) {
      return "Context engine not available";
    }

    // Get context for the file
    return await contextEngine.getContextForFile(filePath, maxTokens);
  } catch (error) {
    console.error('Error getting file context:', error);
    return `Error getting file context: ${error instanceof Error ? error.message : String(error)}`;
  }
}

export async function getContextForSymbol(symbol: string, maxTokens: number = 4000): Promise<string> {
  try {
    // Initialize the context engine if it hasn't been initialized yet
    if (!contextEngine) {
      return "Context engine not available";
    }

    // Get context for the symbol
    return await contextEngine.getContextForSymbol(symbol, maxTokens);
  } catch (error) {
    console.error('Error getting symbol context:', error);
    return `Error getting symbol context: ${error instanceof Error ? error.message : String(error)}`;
  }
}

export async function initializeContextEngine(): Promise<void> {
  try {
    await contextEngine.initialize();
  } catch (error) {
    console.error('Error initializing context engine:', error);
  }
}

export async function disposeContextEngine(): Promise<void> {
  try {
    await contextEngine.dispose();
  } catch (error) {
    console.error('Error disposing context engine:', error);
  }
}

```


---

### File: `archive/vscode-extension/src/responseFormatter.ts`

```typescript
import * as vscode from 'vscode';

export interface FormattedResponse {
  markdown: string;
  codeBlocks: { language: string; code: string }[];
}

export function formatResponse(response: string): FormattedResponse {
  // Extract code blocks from the response
  const codeBlockRegex = /```(\w+)?\n([\s\S]*?)```/g;
  const codeBlocks: { language: string; code: string }[] = [];

  let match;
  while ((match = codeBlockRegex.exec(response)) !== null) {
    const language = match[1] || 'text';
    const code = match[2];
    codeBlocks.push({ language, code });
  }

  return {
    markdown: response,
    codeBlocks
  };
}

export function insertCodeIntoEditor(code: string, editor?: vscode.TextEditor): void {
  if (!editor) {
    editor = vscode.window.activeTextEditor;
    if (!editor) {
      vscode.window.showErrorMessage('No active editor found');
      return;
    }
  }

  const selection = editor.selection;
  editor.edit(editBuilder => {
    if (selection.isEmpty) {
      editBuilder.insert(selection.start, code);
    } else {
      editBuilder.replace(selection, code);
    }
  });
}

export function showResponseInPanel(response: string, context: vscode.ExtensionContext): void {
  // Import the QwenResponsePanel class to use its functionality
  const { QwenResponsePanel } = require('./webview/panel');

  // Create or show the panel
  const panel = QwenResponsePanel.createOrShow(context.extensionUri, 'Qwen Coder Response');

  // Set the content
  panel.setContent(response);
}

/**
 * Show a streaming response in a webview panel
 * @param context The extension context
 * @param onPanelReady Callback that receives the streaming handler function
 */
export function showStreamingResponseInPanel(
  context: vscode.ExtensionContext,
  onPanelReady: (streamHandler: (chunk: string, isComplete: boolean) => void) => void
): void {
  // Import the QwenResponsePanel class to use its functionality
  const { QwenResponsePanel } = require('./webview/panel');

  // Create or show the panel
  const panel = QwenResponsePanel.createOrShow(context.extensionUri, 'Qwen Coder Response (Streaming)');

  // Set initial empty content
  panel.setContent('');

  // Create a streaming handler function
  const streamHandler = (chunk: string, isComplete: boolean) => {
    panel.appendContent(chunk, isComplete);
  };

  // Call the callback with the streaming handler
  onPanelReady(streamHandler);
}



```


---

### File: `archive/vscode-extension/src/mockQwenApi.ts`

```typescript
import { generateCacheKey } from './cache';
import { QwenCoderConfig } from './configuration';
import { QwenApiClient, QwenRequestOptions, QwenResponse } from './qwenApi';

/**
 * A mock implementation of the QwenApiClient for testing and development
 * without requiring an actual API endpoint.
 */
export class MockQwenApiClient extends QwenApiClient {

  constructor(config: QwenCoderConfig) {
    super(config);
  }

  /**
   * Override the updateConfig method to update the cache configuration
   */
  public updateConfig(config: QwenCoderConfig): void {
    super.updateConfig(config);
  }

  /**
   * Override the generateCompletion method to return mock responses
   */
  public async generateCompletion(options: QwenRequestOptions): Promise<QwenResponse> {
    // Check cache first (unless skipCache is true or cacheEnabled is false)
    if (!options.skipCache && this.config.cacheEnabled) {
      const cacheKey = generateCacheKey(options.prompt, {
        systemPrompt: options.systemPrompt,
        maxTokens: options.maxTokens || this.config.maxTokens,
        temperature: options.temperature || this.config.temperature
      });

      const cachedResponse = this.cache.get<QwenResponse>(cacheKey);
      if (cachedResponse) {
        console.log('Using cached mock response for prompt:', options.prompt.substring(0, 50) + '...');
        return {
          ...cachedResponse,
          cached: true
        };
      }
    }

    // Simulate API delay
    await new Promise(resolve => setTimeout(resolve, 1000));

    // Generate a mock response based on the prompt
    const prompt = options.prompt.toLowerCase();
    let response = '';

    if (prompt.includes('explain')) {
      response = this.generateExplanationResponse(prompt);
    } else if (prompt.includes('generate') || prompt.includes('write')) {
      response = this.generateCodeResponse(prompt);
    } else {
      response = this.generateGeneralResponse(prompt);
    }

    const result: QwenResponse = {
      text: response,
      usage: {
        promptTokens: options.prompt.length,
        completionTokens: response.length,
        totalTokens: options.prompt.length + response.length
      }
    };

    // Cache the response (unless skipCache is true or cacheEnabled is false)
    if (!options.skipCache && this.config.cacheEnabled) {
      const cacheKey = generateCacheKey(options.prompt, {
        systemPrompt: options.systemPrompt,
        maxTokens: options.maxTokens || this.config.maxTokens,
        temperature: options.temperature || this.config.temperature
      });

      this.cache.set(cacheKey, result);
    }

    return result;
  }

  private generateExplanationResponse(prompt: string): string {
    return `# Code Explanation

This code appears to be ${prompt.includes('javascript') ? 'JavaScript' : prompt.includes('python') ? 'Python' : 'a programming language'} code that performs some operations.

## Key Components:

1. **Initialization**: The code sets up initial variables and configurations.
2. **Processing**: It processes data through several steps.
3. **Output**: Finally, it returns or displays the results.

## How It Works:

The code follows a typical pattern where it:
1. Takes input
2. Transforms the input through algorithms
3. Produces output based on the transformation

## Best Practices:

The code demonstrates several good practices:
- Clear variable naming
- Proper error handling
- Efficient algorithm implementation

Would you like me to explain any specific part in more detail?`;
  }

  private generateCodeResponse(prompt: string): string {
    const language = prompt.includes('javascript') || prompt.includes('js') ? 'javascript' :
                    prompt.includes('typescript') || prompt.includes('ts') ? 'typescript' :
                    prompt.includes('python') || prompt.includes('py') ? 'python' : 'javascript';

    if (language === 'javascript' || language === 'typescript') {
      return `# Generated Code

Here's a ${language} implementation for your request:

\`\`\`${language}
/**
 * A utility function that performs the requested operation
 * @param {Array} data - The input data to process
 * @param {Object} options - Configuration options
 * @returns {Array} - The processed results
 */
function processData(data, options = {}) {
  // Default options
  const config = {
    sortBy: 'name',
    filterEmpty: true,
    maxResults: 100,
    ...options
  };

  // Input validation
  if (!Array.isArray(data)) {
    throw new Error('Input must be an array');
  }

  // Filter out empty items if configured
  let results = config.filterEmpty
    ? data.filter(item => item && Object.keys(item).length > 0)
    : [...data];

  // Sort the results if needed
  if (config.sortBy) {
    results.sort((a, b) => {
      if (a[config.sortBy] < b[config.sortBy]) return -1;
      if (a[config.sortBy] > b[config.sortBy]) return 1;
      return 0;
    });
  }

  // Limit the number of results
  if (config.maxResults && results.length > config.maxResults) {
    results = results.slice(0, config.maxResults);
  }

  return results;
}

// Example usage
const sampleData = [
  { name: 'Item 3', value: 30 },
  { name: 'Item 1', value: 10 },
  { name: 'Item 2', value: 20 },
  {},  // Empty object
  { name: 'Item 4', value: 40 }
];

const result = processData(sampleData, {
  sortBy: 'value',
  maxResults: 3
});

console.log(result);
\`\`\`

This implementation includes:
- Flexible configuration options
- Input validation
- Sorting and filtering capabilities
- Example usage

You can customize the function parameters and behavior based on your specific requirements.`;
    } else if (language === 'python') {
      return `# Generated Code

Here's a Python implementation for your request:

\`\`\`python
from typing import List, Dict, Any, Optional
import copy

def process_data(data: List[Dict[str, Any]],
                 sort_by: Optional[str] = 'name',
                 filter_empty: bool = True,
                 max_results: Optional[int] = 100) -> List[Dict[str, Any]]:
    """
    Process a list of dictionaries based on the provided options.

    Args:
        data: List of dictionaries to process
        sort_by: Key to sort by (None for no sorting)
        filter_empty: Whether to filter out empty dictionaries
        max_results: Maximum number of results to return (None for all)

    Returns:
        Processed list of dictionaries
    """
    # Input validation
    if not isinstance(data, list):
        raise TypeError("Input must be a list")

    # Create a copy to avoid modifying the original
    results = copy.deepcopy(data)

    # Filter out empty items if configured
    if filter_empty:
        results = [item for item in results if item and len(item) > 0]

    # Sort the results if needed
    if sort_by is not None:
        results.sort(key=lambda x: x.get(sort_by, None))

    # Limit the number of results
    if max_results is not None and len(results) > max_results:
        results = results[:max_results]

    return results

# Example usage
if __name__ == "__main__":
    sample_data = [
        {"name": "Item 3", "value": 30},
        {"name": "Item 1", "value": 10},
        {"name": "Item 2", "value": 20},
        {},  # Empty dictionary
        {"name": "Item 4", "value": 40}
    ]

    result = process_data(
        data=sample_data,
        sort_by="value",
        max_results=3
    )

    print(result)
\`\`\`

This implementation includes:
- Type hints for better code quality
- Docstring with parameter descriptions
- Input validation
- Deep copying to prevent modifying the original data
- Sorting and filtering capabilities
- Example usage

You can adjust the function parameters and behavior based on your specific requirements.`;
    } else {
      return `# Generated Code

I'm not sure which programming language you prefer, so here's a pseudocode implementation:

\`\`\`
function ProcessData(data, options)
    // Set default options
    if options.sortBy is undefined then options.sortBy = "name"
    if options.filterEmpty is undefined then options.filterEmpty = true
    if options.maxResults is undefined then options.maxResults = 100

    // Validate input
    if data is not a list/array then
        throw Error("Input must be an array/list")
    end if

    // Create a copy of the data
    results = copy(data)

    // Filter empty items if needed
    if options.filterEmpty then
        results = filter(results, item => item is not empty)
    end if

    // Sort if needed
    if options.sortBy is not null then
        results = sort(results by options.sortBy)
    end if

    // Limit results
    if options.maxResults is not null and length(results) > options.maxResults then
        results = first options.maxResults items from results
    end if

    return results
end function
\`\`\`

Let me know which programming language you'd prefer, and I can provide a more specific implementation.`;
    }
  }

  private generateGeneralResponse(_prompt: string): string {
    return `# Response

Thank you for your question! Here's what I can tell you:

The concept you're asking about is fundamental in software development. Let me break it down:

## Key Points:

1. **Understanding the Basics**:
   It's important to grasp the fundamental concepts before diving into implementation details.

2. **Best Practices**:
   - Write clean, maintainable code
   - Document your work thoroughly
   - Test your code regularly
   - Follow established patterns and conventions

3. **Common Approaches**:
   There are several ways to tackle this problem, each with its own advantages:
   - Method A: Simple but may not scale well
   - Method B: More complex but highly efficient
   - Method C: Balanced approach for most use cases

## Example:

Here's a simplified example to illustrate:

\`\`\`javascript
function demonstrateConcept(input) {
  // Validate input
  if (!input) {
    return null;
  }

  // Process the input
  const result = input.map(item => {
    return {
      ...item,
      processed: true,
      timestamp: Date.now()
    };
  });

  return result;
}
\`\`\`

## Further Learning:

If you'd like to explore this topic further, I recommend:
- Reading the official documentation
- Practicing with small projects
- Joining community discussions

Is there a specific aspect you'd like me to elaborate on?`;
  }

  /**
   * Override the generateStreamingCompletion method to simulate streaming responses
   */
  public async generateStreamingCompletion(
    options: QwenRequestOptions,
    onChunk: StreamingResponseHandler
  ): Promise<void> {
    try {
      // Generate a complete response first
      const prompt = options.prompt.toLowerCase();
      let fullResponse = '';

      if (prompt.includes('explain')) {
        fullResponse = this.generateExplanationResponse(prompt);
      } else if (prompt.includes('generate') || prompt.includes('write')) {
        fullResponse = this.generateCodeResponse(prompt);
      } else {
        fullResponse = this.generateGeneralResponse(prompt);
      }

      // Simulate streaming by sending chunks with delays
      const chunks = this.chunkResponse(fullResponse);

      for (let i = 0; i < chunks.length; i++) {
        // Simulate network delay
        await new Promise(resolve => setTimeout(resolve, 100));

        // Send the chunk
        const isLast = i === chunks.length - 1;
        onChunk(chunks[i], isLast);

        // If we're simulating an error, break early
        if (prompt.includes('error') && i > chunks.length / 2) {
          onChunk('\n\nError: Simulated streaming error for testing purposes', true);
          break;
        }
      }
    } catch (error) {
      console.error('Error in mock streaming:', error);
      onChunk(`Error: ${error instanceof Error ? error.message : String(error)}`, true);
    }
  }

  /**
   * Split a response into chunks for simulated streaming
   */
  private chunkResponse(response: string): string[] {
    // Split by sentences or line breaks for more natural chunking
    const chunks: string[] = [];
    const sentences = response.split(/(?<=\.|\?|\!|\n)\s+/);

    // Group sentences into reasonable chunks
    let currentChunk = '';
    for (const sentence of sentences) {
      currentChunk += sentence + ' ';

      // When chunk gets big enough, add it to chunks array
      if (currentChunk.length > 30) {
        chunks.push(currentChunk.trim());
        currentChunk = '';
      }
    }

    // Add any remaining content
    if (currentChunk.trim()) {
      chunks.push(currentChunk.trim());
    }

    return chunks;
  }
}

```


---

### File: `archive/vscode-extension/src/mockQwenApi.js`

```javascript
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MockQwenApiClient = void 0;
const cache_1 = require("./cache");
const qwenApi_1 = require("./qwenApi");
/**
 * A mock implementation of the QwenApiClient for testing and development
 * without requiring an actual API endpoint.
 */
class MockQwenApiClient extends qwenApi_1.QwenApiClient {
    constructor(config) {
        super(config);
    }
    /**
     * Override the updateConfig method to update the cache configuration
     */
    updateConfig(config) {
        super.updateConfig(config);
    }
    /**
     * Override the generateCompletion method to return mock responses
     */
    async generateCompletion(options) {
        // Check cache first (unless skipCache is true or cacheEnabled is false)
        if (!options.skipCache && this.config.cacheEnabled) {
            const cacheKey = (0, cache_1.generateCacheKey)(options.prompt, {
                systemPrompt: options.systemPrompt,
                maxTokens: options.maxTokens || this.config.maxTokens,
                temperature: options.temperature || this.config.temperature
            });
            const cachedResponse = this.cache.get(cacheKey);
            if (cachedResponse) {
                console.log('Using cached mock response for prompt:', options.prompt.substring(0, 50) + '...');
                return {
                    ...cachedResponse,
                    cached: true
                };
            }
        }
        // Simulate API delay
        await new Promise(resolve => setTimeout(resolve, 1000));
        // Generate a mock response based on the prompt
        const prompt = options.prompt.toLowerCase();
        let response = '';
        if (prompt.includes('explain')) {
            response = this.generateExplanationResponse(prompt);
        }
        else if (prompt.includes('generate') || prompt.includes('write')) {
            response = this.generateCodeResponse(prompt);
        }
        else {
            response = this.generateGeneralResponse(prompt);
        }
        const result = {
            text: response,
            usage: {
                promptTokens: options.prompt.length,
                completionTokens: response.length,
                totalTokens: options.prompt.length + response.length
            }
        };
        // Cache the response (unless skipCache is true or cacheEnabled is false)
        if (!options.skipCache && this.config.cacheEnabled) {
            const cacheKey = (0, cache_1.generateCacheKey)(options.prompt, {
                systemPrompt: options.systemPrompt,
                maxTokens: options.maxTokens || this.config.maxTokens,
                temperature: options.temperature || this.config.temperature
            });
            this.cache.set(cacheKey, result);
        }
        return result;
    }
    generateExplanationResponse(prompt) {
        return `# Code Explanation

This code appears to be ${prompt.includes('javascript') ? 'JavaScript' : prompt.includes('python') ? 'Python' : 'a programming language'} code that performs some operations.

## Key Components:

1. **Initialization**: The code sets up initial variables and configurations.
2. **Processing**: It processes data through several steps.
3. **Output**: Finally, it returns or displays the results.

## How It Works:

The code follows a typical pattern where it:
1. Takes input
2. Transforms the input through algorithms
3. Produces output based on the transformation

## Best Practices:

The code demonstrates several good practices:
- Clear variable naming
- Proper error handling
- Efficient algorithm implementation

Would you like me to explain any specific part in more detail?`;
    }
    generateCodeResponse(prompt) {
        const language = prompt.includes('javascript') || prompt.includes('js') ? 'javascript' :
            prompt.includes('typescript') || prompt.includes('ts') ? 'typescript' :
                prompt.includes('python') || prompt.includes('py') ? 'python' : 'javascript';
        if (language === 'javascript' || language === 'typescript') {
            return `# Generated Code

Here's a ${language} implementation for your request:

\`\`\`${language}
/**
 * A utility function that performs the requested operation
 * @param {Array} data - The input data to process
 * @param {Object} options - Configuration options
 * @returns {Array} - The processed results
 */
function processData(data, options = {}) {
  // Default options
  const config = {
    sortBy: 'name',
    filterEmpty: true,
    maxResults: 100,
    ...options
  };

  // Input validation
  if (!Array.isArray(data)) {
    throw new Error('Input must be an array');
  }

  // Filter out empty items if configured
  let results = config.filterEmpty
    ? data.filter(item => item && Object.keys(item).length > 0)
    : [...data];

  // Sort the results if needed
  if (config.sortBy) {
    results.sort((a, b) => {
      if (a[config.sortBy] < b[config.sortBy]) return -1;
      if (a[config.sortBy] > b[config.sortBy]) return 1;
      return 0;
    });
  }

  // Limit the number of results
  if (config.maxResults && results.length > config.maxResults) {
    results = results.slice(0, config.maxResults);
  }

  return results;
}

// Example usage
const sampleData = [
  { name: 'Item 3', value: 30 },
  { name: 'Item 1', value: 10 },
  { name: 'Item 2', value: 20 },
  {},  // Empty object
  { name: 'Item 4', value: 40 }
];

const result = processData(sampleData, {
  sortBy: 'value',
  maxResults: 3
});

console.log(result);
\`\`\`

This implementation includes:
- Flexible configuration options
- Input validation
- Sorting and filtering capabilities
- Example usage

You can customize the function parameters and behavior based on your specific requirements.`;
        }
        else if (language === 'python') {
            return `# Generated Code

Here's a Python implementation for your request:

\`\`\`python
from typing import List, Dict, Any, Optional
import copy

def process_data(data: List[Dict[str, Any]],
                 sort_by: Optional[str] = 'name',
                 filter_empty: bool = True,
                 max_results: Optional[int] = 100) -> List[Dict[str, Any]]:
    """
    Process a list of dictionaries based on the provided options.

    Args:
        data: List of dictionaries to process
        sort_by: Key to sort by (None for no sorting)
        filter_empty: Whether to filter out empty dictionaries
        max_results: Maximum number of results to return (None for all)

    Returns:
        Processed list of dictionaries
    """
    # Input validation
    if not isinstance(data, list):
        raise TypeError("Input must be a list")

    # Create a copy to avoid modifying the original
    results = copy.deepcopy(data)

    # Filter out empty items if configured
    if filter_empty:
        results = [item for item in results if item and len(item) > 0]

    # Sort the results if needed
    if sort_by is not None:
        results.sort(key=lambda x: x.get(sort_by, None))

    # Limit the number of results
    if max_results is not None and len(results) > max_results:
        results = results[:max_results]

    return results

# Example usage
if __name__ == "__main__":
    sample_data = [
        {"name": "Item 3", "value": 30},
        {"name": "Item 1", "value": 10},
        {"name": "Item 2", "value": 20},
        {},  # Empty dictionary
        {"name": "Item 4", "value": 40}
    ]

    result = process_data(
        data=sample_data,
        sort_by="value",
        max_results=3
    )

    print(result)
\`\`\`

This implementation includes:
- Type hints for better code quality
- Docstring with parameter descriptions
- Input validation
- Deep copying to prevent modifying the original data
- Sorting and filtering capabilities
- Example usage

You can adjust the function parameters and behavior based on your specific requirements.`;
        }
        else {
            return `# Generated Code

I'm not sure which programming language you prefer, so here's a pseudocode implementation:

\`\`\`
function ProcessData(data, options)
    // Set default options
    if options.sortBy is undefined then options.sortBy = "name"
    if options.filterEmpty is undefined then options.filterEmpty = true
    if options.maxResults is undefined then options.maxResults = 100

    // Validate input
    if data is not a list/array then
        throw Error("Input must be an array/list")
    end if

    // Create a copy of the data
    results = copy(data)

    // Filter empty items if needed
    if options.filterEmpty then
        results = filter(results, item => item is not empty)
    end if

    // Sort if needed
    if options.sortBy is not null then
        results = sort(results by options.sortBy)
    end if

    // Limit results
    if options.maxResults is not null and length(results) > options.maxResults then
        results = first options.maxResults items from results
    end if

    return results
end function
\`\`\`

Let me know which programming language you'd prefer, and I can provide a more specific implementation.`;
        }
    }
    generateGeneralResponse(_prompt) {
        return `# Response

Thank you for your question! Here's what I can tell you:

The concept you're asking about is fundamental in software development. Let me break it down:

## Key Points:

1. **Understanding the Basics**:
   It's important to grasp the fundamental concepts before diving into implementation details.

2. **Best Practices**:
   - Write clean, maintainable code
   - Document your work thoroughly
   - Test your code regularly
   - Follow established patterns and conventions

3. **Common Approaches**:
   There are several ways to tackle this problem, each with its own advantages:
   - Method A: Simple but may not scale well
   - Method B: More complex but highly efficient
   - Method C: Balanced approach for most use cases

## Example:

Here's a simplified example to illustrate:

\`\`\`javascript
function demonstrateConcept(input) {
  // Validate input
  if (!input) {
    return null;
  }

  // Process the input
  const result = input.map(item => {
    return {
      ...item,
      processed: true,
      timestamp: Date.now()
    };
  });

  return result;
}
\`\`\`

## Further Learning:

If you'd like to explore this topic further, I recommend:
- Reading the official documentation
- Practicing with small projects
- Joining community discussions

Is there a specific aspect you'd like me to elaborate on?`;
    }
    /**
     * Override the generateStreamingCompletion method to simulate streaming responses
     */
    async generateStreamingCompletion(options, onChunk) {
        try {
            // Generate a complete response first
            const prompt = options.prompt.toLowerCase();
            let fullResponse = '';
            if (prompt.includes('explain')) {
                fullResponse = this.generateExplanationResponse(prompt);
            }
            else if (prompt.includes('generate') || prompt.includes('write')) {
                fullResponse = this.generateCodeResponse(prompt);
            }
            else {
                fullResponse = this.generateGeneralResponse(prompt);
            }
            // Simulate streaming by sending chunks with delays
            const chunks = this.chunkResponse(fullResponse);
            for (let i = 0; i < chunks.length; i++) {
                // Simulate network delay
                await new Promise(resolve => setTimeout(resolve, 100));
                // Send the chunk
                const isLast = i === chunks.length - 1;
                onChunk(chunks[i], isLast);
                // If we're simulating an error, break early
                if (prompt.includes('error') && i > chunks.length / 2) {
                    onChunk('\n\nError: Simulated streaming error for testing purposes', true);
                    break;
                }
            }
        }
        catch (error) {
            console.error('Error in mock streaming:', error);
            onChunk(`Error: ${error instanceof Error ? error.message : String(error)}`, true);
        }
    }
    /**
     * Split a response into chunks for simulated streaming
     */
    chunkResponse(response) {
        // Split by sentences or line breaks for more natural chunking
        const chunks = [];
        const sentences = response.split(/(?<=\.|\?|\!|\n)\s+/);
        // Group sentences into reasonable chunks
        let currentChunk = '';
        for (const sentence of sentences) {
            currentChunk += sentence + ' ';
            // When chunk gets big enough, add it to chunks array
            if (currentChunk.length > 30) {
                chunks.push(currentChunk.trim());
                currentChunk = '';
            }
        }
        // Add any remaining content
        if (currentChunk.trim()) {
            chunks.push(currentChunk.trim());
        }
        return chunks;
    }
}
exports.MockQwenApiClient = MockQwenApiClient;
//# sourceMappingURL=mockQwenApi.js.map
```


---

### File: `archive/vscode-extension/src/qwenApi.ts`

```typescript
import axios, { AxiosInstance } from 'axios';
import { ResponseCache, generateCacheKey } from './cache';
import { QwenCoderConfig } from './configuration';
import { ErrorHandler } from './errorHandler';

export interface QwenRequestOptions {
  prompt: string;
  maxTokens?: number;
  temperature?: number;
  systemPrompt?: string;
  skipCache?: boolean;
  stream?: boolean;
}

export interface QwenResponse {
  text: string;
  usage?: {
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
  };
  cached?: boolean;
}

export type StreamingResponseHandler = (chunk: string, done: boolean) => void;

export class QwenApiClient {
  private client: AxiosInstance;
  protected config: QwenCoderConfig;
  protected cache: ResponseCache;

  constructor(config: QwenCoderConfig) {
    this.config = config;
    this.client = axios.create({
      baseURL: config.apiEndpoint,
      headers: config.apiKey ? {
        'Authorization': `Bearer ${config.apiKey}`,
        'Content-Type': 'application/json'
      } : {
        'Content-Type': 'application/json'
      }
    });
    this.cache = ResponseCache.getInstance();
  }

  public updateConfig(config: QwenCoderConfig): void {
    this.config = config;
    this.client = axios.create({
      baseURL: config.apiEndpoint,
      headers: config.apiKey ? {
        'Authorization': `Bearer ${config.apiKey}`,
        'Content-Type': 'application/json'
      } : {
        'Content-Type': 'application/json'
      }
    });

    // Update cache configuration if provided
    if (config.cacheTTLMinutes && config.cacheMaxEntries) {
      this.cache.configure(config.cacheMaxEntries, config.cacheTTLMinutes);
    }
  }

  public async generateCompletion(options: QwenRequestOptions): Promise<QwenResponse> {
    // Check cache first (unless skipCache is true)
    if (!options.skipCache) {
      const cacheKey = generateCacheKey(options.prompt, {
        systemPrompt: options.systemPrompt,
        maxTokens: options.maxTokens || this.config.maxTokens,
        temperature: options.temperature || this.config.temperature
      });

      const cachedResponse = this.cache.get<QwenResponse>(cacheKey);
      if (cachedResponse) {
        console.log('Using cached response for prompt:', options.prompt.substring(0, 50) + '...');
        return {
          ...cachedResponse,
          cached: true
        };
      }
    }

    try {
      // Set timeout for the request
      const timeoutMs = 30000; // 30 seconds timeout
      const response = await this.client.post('/chat/completions', {
        model: 'qwen3-coder',
        messages: [
          ...(options.systemPrompt ? [{ role: 'system', content: options.systemPrompt }] : []),
          { role: 'user', content: options.prompt }
        ],
        max_tokens: options.maxTokens || this.config.maxTokens,
        temperature: options.temperature || this.config.temperature
      }, { timeout: timeoutMs });

      const result: QwenResponse = {
        text: response.data.choices[0].message.content,
        usage: response.data.usage
      };

      // Cache the response (unless skipCache is true)
      if (!options.skipCache) {
        const cacheKey = generateCacheKey(options.prompt, {
          systemPrompt: options.systemPrompt,
          maxTokens: options.maxTokens || this.config.maxTokens,
          temperature: options.temperature || this.config.temperature
        });

        this.cache.set(cacheKey, result);
      }

      return result;
    } catch (error) {
      // Use the error handler to process the error
      const errorDetails = ErrorHandler.processError(error);
      console.error(`Error calling Qwen API: ${errorDetails.type}`, error);

      // Throw a more informative error
      throw new Error(errorDetails.message);
    }
  }

  /**
   * Generate a streaming completion
   * @param options Request options
   * @param onChunk Callback function to handle streaming chunks
   */
  public async generateStreamingCompletion(
    options: QwenRequestOptions,
    onChunk: StreamingResponseHandler
  ): Promise<void> {
    // Streaming responses can't be cached, so we don't check the cache

    try {
      // Set timeout for the request
      const timeoutMs = 60000; // 60 seconds timeout for streaming

      const response = await this.client.post('/chat/completions', {
        model: 'qwen3-coder',
        messages: [
          ...(options.systemPrompt ? [{ role: 'system', content: options.systemPrompt }] : []),
          { role: 'user', content: options.prompt }
        ],
        max_tokens: options.maxTokens || this.config.maxTokens,
        temperature: options.temperature || this.config.temperature,
        stream: true
      }, {
        timeout: timeoutMs,
        responseType: 'stream'
      });

      // Process the streaming response
      const stream = response.data;

      stream.on('data', (chunk: Buffer) => {
        try {
          const lines = chunk.toString().split('\n').filter(line => line.trim() !== '');

          for (const line of lines) {
            // Skip empty lines and "data: [DONE]" messages
            if (!line || line === 'data: [DONE]') {continue;}

            // Remove the "data: " prefix
            const jsonStr = line.replace(/^data: /, '');

            try {
              const json = JSON.parse(jsonStr);
              if (json.choices && json.choices[0] && json.choices[0].delta && json.choices[0].delta.content) {
                const content = json.choices[0].delta.content;
                onChunk(content, false);
              }
            } catch (parseError) {
              console.error('Error parsing streaming response JSON:', parseError);
            }
          }
        } catch (error) {
          console.error('Error processing stream chunk:', error);
        }
      });

      stream.on('end', () => {
        onChunk('', true); // Signal that streaming is complete
      });

      stream.on('error', (error: Error) => {
        const errorDetails = ErrorHandler.processError(error);
        console.error(`Error in stream: ${errorDetails.type}`, error);
        throw new Error(errorDetails.message);
      });
    } catch (error) {
      // Use the error handler to process the error
      const errorDetails = ErrorHandler.processError(error);
      console.error(`Error setting up streaming: ${errorDetails.type}`, error);

      // Signal error to the handler
      onChunk(`Error: ${errorDetails.message}`, true);

      // Throw a more informative error
      throw new Error(errorDetails.message);
    }
  }

  /**
   * Clear the response cache
   */
  public clearCache(): void {
    this.cache.clear();
  }
}

```


---

### File: `archive/vscode-extension/src/cache.ts`

```typescript
/**
 * A simple cache implementation for storing API responses
 */
export class ResponseCache {
  private static instance: ResponseCache;
  private cache: Map<string, CacheEntry>;
  private maxEntries: number;
  private ttl: number; // Time to live in milliseconds

  private constructor(maxEntries: number = 100, ttlMinutes: number = 30) {
    this.cache = new Map();
    this.maxEntries = maxEntries;
    this.ttl = ttlMinutes * 60 * 1000;
  }

  /**
   * Get the singleton instance of the cache
   */
  public static getInstance(): ResponseCache {
    if (!ResponseCache.instance) {
      ResponseCache.instance = new ResponseCache();
    }
    return ResponseCache.instance;
  }

  /**
   * Set cache configuration
   * @param maxEntries Maximum number of entries to store
   * @param ttlMinutes Time to live in minutes
   */
  public configure(maxEntries: number, ttlMinutes: number): void {
    this.maxEntries = maxEntries;
    this.ttl = ttlMinutes * 60 * 1000;
    this.cleanup();
  }

  /**
   * Get a value from the cache
   * @param key Cache key
   * @returns The cached value or undefined if not found or expired
   */
  public get<T>(key: string): T | undefined {
    const entry = this.cache.get(key);
    
    if (!entry) {
      return undefined;
    }
    
    // Check if entry has expired
    if (Date.now() > entry.expiry) {
      this.cache.delete(key);
      return undefined;
    }
    
    // Update access time
    entry.lastAccessed = Date.now();
    
    return entry.value as T;
  }

  /**
   * Set a value in the cache
   * @param key Cache key
   * @param value Value to cache
   */
  public set<T>(key: string, value: T): void {
    // If cache is full, remove least recently used entry
    if (this.cache.size >= this.maxEntries) {
      this.removeLRU();
    }
    
    this.cache.set(key, {
      value,
      expiry: Date.now() + this.ttl,
      lastAccessed: Date.now()
    });
  }

  /**
   * Check if a key exists in the cache and is not expired
   * @param key Cache key
   * @returns True if the key exists and is not expired
   */
  public has(key: string): boolean {
    const entry = this.cache.get(key);
    
    if (!entry) {
      return false;
    }
    
    // Check if entry has expired
    if (Date.now() > entry.expiry) {
      this.cache.delete(key);
      return false;
    }
    
    return true;
  }

  /**
   * Remove a key from the cache
   * @param key Cache key
   */
  public delete(key: string): void {
    this.cache.delete(key);
  }

  /**
   * Clear the entire cache
   */
  public clear(): void {
    this.cache.clear();
  }

  /**
   * Get the number of entries in the cache
   */
  public size(): number {
    return this.cache.size;
  }

  /**
   * Remove expired entries from the cache
   */
  public cleanup(): void {
    const now = Date.now();
    for (const [key, entry] of this.cache.entries()) {
      if (now > entry.expiry) {
        this.cache.delete(key);
      }
    }
  }

  /**
   * Remove the least recently used entry from the cache
   */
  private removeLRU(): void {
    let oldest: string | null = null;
    let oldestTime = Date.now();
    
    for (const [key, entry] of this.cache.entries()) {
      if (entry.lastAccessed < oldestTime) {
        oldest = key;
        oldestTime = entry.lastAccessed;
      }
    }
    
    if (oldest) {
      this.cache.delete(oldest);
    }
  }
}

interface CacheEntry {
  value: unknown;
  expiry: number;
  lastAccessed: number;
}

/**
 * Generate a cache key from a request
 * @param prompt The prompt text
 * @param options Additional options that affect the response
 * @returns A string key for caching
 */
export function generateCacheKey(prompt: string, options: Record<string, any> = {}): string {
  // Create a stable representation of the options
  const optionsStr = Object.keys(options)
    .sort()
    .map(key => `${key}:${JSON.stringify(options[key])}`)
    .join('|');
  
  // Combine prompt and options into a single key
  return `${prompt}|${optionsStr}`;
}

```


---

### File: `archive/vscode-extension/src/configuration.js`

```javascript
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.getConfiguration = getConfiguration;
exports.registerConfigurationListener = registerConfigurationListener;
const vscode = __importStar(require("vscode"));
function getConfiguration() {
    const config = vscode.workspace.getConfiguration('qwen-coder-assistant');
    return {
        apiEndpoint: config.get('apiEndpoint') || 'http://localhost:8000/v1',
        apiKey: config.get('apiKey') || '',
        maxTokens: config.get('maxTokens') || 2048,
        temperature: config.get('temperature') || 0.7,
        cacheEnabled: config.get('cacheEnabled') !== false, // Default to true
        cacheTTLMinutes: config.get('cacheTTLMinutes') || 30,
        cacheMaxEntries: config.get('cacheMaxEntries') || 100,
        streamingEnabled: config.get('streamingEnabled') !== false, // Default to true
        contextEngine: {
            persistEmbeddings: config.get('contextEngine.persistEmbeddings') !== false, // Default to true
            databasePath: config.get('contextEngine.databasePath') || '',
            autoSaveIntervalMs: config.get('contextEngine.autoSaveIntervalMs') || 60000
        }
    };
}
// Listen for configuration changes
function registerConfigurationListener(callback) {
    return vscode.workspace.onDidChangeConfiguration(event => {
        if (event.affectsConfiguration('qwen-coder-assistant')) {
            callback(getConfiguration());
        }
    });
}
//# sourceMappingURL=configuration.js.map
```


---

### File: `archive/vscode-extension/src/cache.js`

```javascript
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResponseCache = void 0;
exports.generateCacheKey = generateCacheKey;
/**
 * A simple cache implementation for storing API responses
 */
class ResponseCache {
    constructor(maxEntries = 100, ttlMinutes = 30) {
        this.cache = new Map();
        this.maxEntries = maxEntries;
        this.ttl = ttlMinutes * 60 * 1000;
    }
    /**
     * Get the singleton instance of the cache
     */
    static getInstance() {
        if (!ResponseCache.instance) {
            ResponseCache.instance = new ResponseCache();
        }
        return ResponseCache.instance;
    }
    /**
     * Set cache configuration
     * @param maxEntries Maximum number of entries to store
     * @param ttlMinutes Time to live in minutes
     */
    configure(maxEntries, ttlMinutes) {
        this.maxEntries = maxEntries;
        this.ttl = ttlMinutes * 60 * 1000;
        this.cleanup();
    }
    /**
     * Get a value from the cache
     * @param key Cache key
     * @returns The cached value or undefined if not found or expired
     */
    get(key) {
        const entry = this.cache.get(key);
        if (!entry) {
            return undefined;
        }
        // Check if entry has expired
        if (Date.now() > entry.expiry) {
            this.cache.delete(key);
            return undefined;
        }
        // Update access time
        entry.lastAccessed = Date.now();
        return entry.value;
    }
    /**
     * Set a value in the cache
     * @param key Cache key
     * @param value Value to cache
     */
    set(key, value) {
        // If cache is full, remove least recently used entry
        if (this.cache.size >= this.maxEntries) {
            this.removeLRU();
        }
        this.cache.set(key, {
            value,
            expiry: Date.now() + this.ttl,
            lastAccessed: Date.now()
        });
    }
    /**
     * Check if a key exists in the cache and is not expired
     * @param key Cache key
     * @returns True if the key exists and is not expired
     */
    has(key) {
        const entry = this.cache.get(key);
        if (!entry) {
            return false;
        }
        // Check if entry has expired
        if (Date.now() > entry.expiry) {
            this.cache.delete(key);
            return false;
        }
        return true;
    }
    /**
     * Remove a key from the cache
     * @param key Cache key
     */
    delete(key) {
        this.cache.delete(key);
    }
    /**
     * Clear the entire cache
     */
    clear() {
        this.cache.clear();
    }
    /**
     * Get the number of entries in the cache
     */
    size() {
        return this.cache.size;
    }
    /**
     * Remove expired entries from the cache
     */
    cleanup() {
        const now = Date.now();
        for (const [key, entry] of this.cache.entries()) {
            if (now > entry.expiry) {
                this.cache.delete(key);
            }
        }
    }
    /**
     * Remove the least recently used entry from the cache
     */
    removeLRU() {
        let oldest = null;
        let oldestTime = Date.now();
        for (const [key, entry] of this.cache.entries()) {
            if (entry.lastAccessed < oldestTime) {
                oldest = key;
                oldestTime = entry.lastAccessed;
            }
        }
        if (oldest) {
            this.cache.delete(oldest);
        }
    }
}
exports.ResponseCache = ResponseCache;
/**
 * Generate a cache key from a request
 * @param prompt The prompt text
 * @param options Additional options that affect the response
 * @returns A string key for caching
 */
function generateCacheKey(prompt, options = {}) {
    // Create a stable representation of the options
    const optionsStr = Object.keys(options)
        .sort()
        .map(key => `${key}:${JSON.stringify(options[key])}`)
        .join('|');
    // Combine prompt and options into a single key
    return `${prompt}|${optionsStr}`;
}
//# sourceMappingURL=cache.js.map
```


---

### File: `archive/vscode-extension/src/errorHandler.js`

```javascript
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ErrorHandler = exports.ErrorType = void 0;
const vscode = __importStar(require("vscode"));
const axios_1 = __importDefault(require("axios"));
var ErrorType;
(function (ErrorType) {
    ErrorType["NetworkError"] = "NetworkError";
    ErrorType["AuthenticationError"] = "AuthenticationError";
    ErrorType["RateLimitError"] = "RateLimitError";
    ErrorType["ServerError"] = "ServerError";
    ErrorType["TimeoutError"] = "TimeoutError";
    ErrorType["UnknownError"] = "UnknownError";
})(ErrorType || (exports.ErrorType = ErrorType = {}));
/**
 * Handles API errors and provides user-friendly error messages
 */
class ErrorHandler {
    /**
     * Process an error and return structured error details
     * @param error The error to process
     * @returns Structured error details
     */
    static processError(error) {
        // Default error details
        let errorDetails = {
            type: ErrorType.UnknownError,
            message: 'An unknown error occurred',
            originalError: error instanceof Error ? error : undefined,
            retryable: false
        };
        // Handle Axios errors
        if (axios_1.default.isAxiosError(error)) {
            errorDetails = this.processAxiosError(error);
        }
        // Handle timeout errors
        else if (error instanceof Error && error.message.includes('timeout')) {
            errorDetails = {
                type: ErrorType.TimeoutError,
                message: 'The request timed out. The server might be overloaded.',
                originalError: error,
                retryable: true,
                suggestedAction: 'Try again later or check your internet connection.'
            };
        }
        // Handle other errors
        else if (error instanceof Error) {
            errorDetails = {
                type: ErrorType.UnknownError,
                message: `Error: ${error.message}`,
                originalError: error,
                retryable: false
            };
        }
        return errorDetails;
    }
    /**
     * Process an Axios error and return structured error details
     * @param error The Axios error to process
     * @returns Structured error details
     */
    static processAxiosError(error) {
        // Network errors
        if (error.code === 'ECONNABORTED' || error.code === 'ECONNREFUSED' || error.code === 'ENOTFOUND') {
            return {
                type: ErrorType.NetworkError,
                message: 'Could not connect to the API. Please check your internet connection.',
                originalError: error,
                retryable: true,
                suggestedAction: 'Check your network connection and try again.'
            };
        }
        // Handle based on HTTP status code
        switch (error.response?.status) {
            case 401:
            case 403:
                return {
                    type: ErrorType.AuthenticationError,
                    message: 'Authentication failed. Please check your API key.',
                    originalError: error,
                    retryable: false,
                    suggestedAction: 'Update your API key in the extension settings.'
                };
            case 429:
                return {
                    type: ErrorType.RateLimitError,
                    message: 'Rate limit exceeded. Too many requests in a short period.',
                    originalError: error,
                    retryable: true,
                    suggestedAction: 'Wait a moment before trying again.'
                };
            case 500:
            case 502:
            case 503:
            case 504:
                return {
                    type: ErrorType.ServerError,
                    message: `Server error (${error.response.status}). The API service might be experiencing issues.`,
                    originalError: error,
                    retryable: true,
                    suggestedAction: 'Try again later.'
                };
            default:
                // Try to extract error message from response if available
                let message = 'An error occurred while communicating with the API.';
                try {
                    if (error.response?.data) {
                        if (typeof error.response.data === 'string') {
                            message = error.response.data;
                        }
                        else if (typeof error.response.data === 'object' && error.response.data.error) {
                            message = error.response.data.error;
                        }
                    }
                }
                catch (e) {
                    // Ignore parsing errors
                }
                return {
                    type: ErrorType.UnknownError,
                    message,
                    originalError: error,
                    retryable: false
                };
        }
    }
    /**
     * Display an error message to the user
     * @param error The error details to display
     */
    static showErrorToUser(error) {
        const message = `${error.message}${error.suggestedAction ? '\n\n' + error.suggestedAction : ''}`;
        // Show different types of notifications based on error type
        if (error.retryable) {
            vscode.window.showWarningMessage(message, 'Retry').then(selection => {
                if (selection === 'Retry') {
                    // Emit an event that can be listened to for retrying the operation
                    // This will be implemented when we add the retry functionality
                }
            });
        }
        else {
            vscode.window.showErrorMessage(message);
        }
        // Log the error for debugging
        console.error('API Error:', error.type, error.originalError);
    }
    /**
     * Handle an error by processing it and showing a message to the user
     * @param error The error to handle
     * @returns The processed error details
     */
    static handleError(error) {
        const errorDetails = this.processError(error);
        this.showErrorToUser(errorDetails);
        return errorDetails;
    }
}
exports.ErrorHandler = ErrorHandler;
//# sourceMappingURL=errorHandler.js.map
```


---

### File: `archive/vscode-extension/src/webview/panel.js`

```javascript
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.QwenResponsePanel = void 0;
const vscode = __importStar(require("vscode"));
const responseFormatter_1 = require("../responseFormatter");
class QwenResponsePanel {
    static createOrShow(extensionUri, title = 'Qwen Coder Response') {
        const column = vscode.window.activeTextEditor
            ? vscode.window.activeTextEditor.viewColumn
            : undefined;
        // If we already have a panel, show it
        if (QwenResponsePanel.currentPanel) {
            QwenResponsePanel.currentPanel._panel.reveal(column);
            QwenResponsePanel.currentPanel._panel.title = title;
            return QwenResponsePanel.currentPanel;
        }
        // Otherwise, create a new panel
        const panel = vscode.window.createWebviewPanel('qwenResponse', title, column || vscode.ViewColumn.Beside, {
            enableScripts: true,
            localResourceRoots: [
                vscode.Uri.joinPath(extensionUri, 'media')
            ],
            retainContextWhenHidden: true
        });
        QwenResponsePanel.currentPanel = new QwenResponsePanel(panel, extensionUri);
        return QwenResponsePanel.currentPanel;
    }
    constructor(panel, extensionUri) {
        this._disposables = [];
        this._panel = panel;
        this._extensionUri = extensionUri;
        // Set the webview's initial html content
        this._update('');
        // Listen for when the panel is disposed
        // This happens when the user closes the panel or when the panel is closed programmatically
        this._panel.onDidDispose(() => this.dispose(), null, this._disposables);
        // Handle messages from the webview
        this._panel.webview.onDidReceiveMessage(message => {
            switch (message.command) {
                case 'copy':
                    vscode.env.clipboard.writeText(message.text);
                    vscode.window.showInformationMessage('Code copied to clipboard');
                    break;
                case 'insert':
                    (0, responseFormatter_1.insertCodeIntoEditor)(message.text);
                    vscode.window.showInformationMessage('Code inserted into editor');
                    break;
            }
        }, null, this._disposables);
    }
    dispose() {
        QwenResponsePanel.currentPanel = undefined;
        // Clean up our resources
        this._panel.dispose();
        while (this._disposables.length) {
            const x = this._disposables.pop();
            if (x) {
                x.dispose();
            }
        }
    }
    setContent(content) {
        this._update(content);
    }
    /**
     * Append content to the existing content (for streaming)
     * @param chunk The content chunk to append
     * @param isComplete Whether this is the final chunk
     */
    appendContent(chunk, isComplete) {
        // Send a message to the webview to append content
        this._panel.webview.postMessage({
            command: 'append',
            text: chunk,
            isComplete
        });
    }
    _update(content) {
        const webview = this._panel.webview;
        // Get paths to resources
        const cssUri = webview.asWebviewUri(vscode.Uri.joinPath(this._extensionUri, 'media', 'styles.css'));
        const highlightJsUri = webview.asWebviewUri(vscode.Uri.joinPath(this._extensionUri, 'media', 'highlight.js'));
        // Create HTML content
        this._panel.webview.html = `
      <!DOCTYPE html>
      <html lang="en">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" href="${cssUri}">
        <title>Qwen Coder Response</title>
      </head>
      <body>
        <div id="response-container" class="response-container">
          ${this._formatMarkdown(content)}
        </div>
        <script src="${highlightJsUri}"></script>
        <script>
          const vscode = acquireVsCodeApi();
          let currentMarkdown = '';
          let isProcessingStream = false;
          const responseContainer = document.getElementById('response-container');

          // Listen for messages from the extension
          window.addEventListener('message', event => {
            const message = event.data;

            switch (message.command) {
              case 'append':
                // Handle streaming content
                currentMarkdown += message.text;
                responseContainer.innerHTML = formatMarkdown(currentMarkdown);

                // Apply syntax highlighting and add buttons to code blocks
                applyCodeFormatting();

                // If this is the final chunk, do any final processing
                if (message.isComplete) {
                  isProcessingStream = false;
                  // Final formatting pass
                  responseContainer.innerHTML = formatMarkdown(currentMarkdown);
                  applyCodeFormatting();
                }

                // Scroll to bottom to show new content
                window.scrollTo(0, document.body.scrollHeight);
                break;
            }
          });

          // Function to format markdown text to HTML
          function formatMarkdown(text) {
            if (!text) {
              return '<p>No response yet...</p>';
            }

            // Replace code blocks
            let html = text.replace(/\`\`\`(\w+)?\n([\s\S]*?)\`\`\`/g, (_, lang, code) => {
              return \`<pre><code class="language-\${lang || 'text'}">\${escapeHtml(code)}</code></pre>\`;
            });

            // Replace inline code
            html = html.replace(/\`([^\`]+)\`/g, '<code>$1</code>');

            // Replace headers
            html = html.replace(/^### (.*$)/gm, '<h3>$1</h3>');
            html = html.replace(/^## (.*$)/gm, '<h2>$1</h2>');
            html = html.replace(/^# (.*$)/gm, '<h1>$1</h1>');

            // Replace lists
            html = html.replace(/^\* (.*$)/gm, '<ul><li>$1</li></ul>');
            html = html.replace(/^- (.*$)/gm, '<ul><li>$1</li></ul>');
            html = html.replace(/^(\d+)\. (.*$)/gm, '<ol><li>$2</li></ol>');

            // Replace paragraphs
            html = html.replace(/^(?!<[hou]).+$/gm, '<p>$&</p>');

            // Fix nested lists
            html = html.replace(/<\/ul>\s*<ul>/g, '');
            html = html.replace(/<\/ol>\s*<ol>/g, '');

            return html;
          }

          // Function to escape HTML special characters
          function escapeHtml(text) {
            return text
              .replace(/&/g, '&amp;')
              .replace(/</g, '&lt;')
              .replace(/>/g, '&gt;')
              .replace(/"/g, '&quot;')
              .replace(/'/g, '&#039;');
          }

          // Function to apply syntax highlighting and add buttons to code blocks
          function applyCodeFormatting() {
            // Apply syntax highlighting to code blocks
            document.querySelectorAll('pre code').forEach((codeBlock) => {
              const language = codeBlock.className.replace('language-', '');
              if (language && language !== 'text') {
                const originalCode = codeBlock.textContent;
                try {
                  codeBlock.innerHTML = window.HighlightJS.highlight(originalCode, language);
                } catch (e) {
                  console.error('Error highlighting code:', e);
                }
              }
            });

            // Add copy and insert buttons to code blocks that don't already have them
            document.querySelectorAll('pre:not(.processed)').forEach((pre) => {
              pre.classList.add('processed');

              const container = document.createElement('div');
              container.className = 'code-block-container';
              pre.parentNode.insertBefore(container, pre);
              container.appendChild(pre);

              const copyButton = document.createElement('button');
              copyButton.className = 'copy-button';
              copyButton.textContent = 'Copy';
              copyButton.addEventListener('click', () => {
                const code = pre.textContent;
                vscode.postMessage({
                  command: 'copy',
                  text: code
                });
                copyButton.textContent = 'Copied!';
                setTimeout(() => {
                  copyButton.textContent = 'Copy';
                }, 2000);
              });

              const insertButton = document.createElement('button');
              insertButton.className = 'insert-button';
              insertButton.textContent = 'Insert';
              insertButton.addEventListener('click', () => {
                const code = pre.textContent;
                vscode.postMessage({
                  command: 'insert',
                  text: code
                });
              });

              container.appendChild(copyButton);
              container.appendChild(insertButton);
            });
          }

          // Initial formatting for any content that's already there
          applyCodeFormatting();
        </script>
      </body>
      </html>
    `;
    }
    _formatMarkdown(text) {
        if (!text) {
            return '<p>No response yet...</p>';
        }
        // Replace code blocks
        let html = text.replace(/```(\w+)?\n([\s\S]*?)```/g, (_, lang, code) => {
            return `<pre><code class="language-${lang || 'text'}">${this._escapeHtml(code)}</code></pre>`;
        });
        // Replace inline code
        html = html.replace(/`([^`]+)`/g, '<code>$1</code>');
        // Replace headers
        html = html.replace(/^### (.*$)/gm, '<h3>$1</h3>');
        html = html.replace(/^## (.*$)/gm, '<h2>$1</h2>');
        html = html.replace(/^# (.*$)/gm, '<h1>$1</h1>');
        // Replace lists
        html = html.replace(/^\* (.*$)/gm, '<ul><li>$1</li></ul>');
        html = html.replace(/^- (.*$)/gm, '<ul><li>$1</li></ul>');
        html = html.replace(/^(\d+)\. (.*$)/gm, '<ol><li>$2</li></ol>');
        // Replace paragraphs
        html = html.replace(/^(?!<[hou]).+$/gm, '<p>$&</p>');
        // Fix nested lists
        html = html.replace(/<\/ul>\s*<ul>/g, '');
        html = html.replace(/<\/ol>\s*<ol>/g, '');
        return html;
    }
    _escapeHtml(text) {
        return text
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#039;');
    }
}
exports.QwenResponsePanel = QwenResponsePanel;
//# sourceMappingURL=panel.js.map
```


---

### File: `archive/vscode-extension/src/webview/panel.ts`

```typescript
import * as vscode from 'vscode';
import { insertCodeIntoEditor } from '../responseFormatter';

export class QwenResponsePanel {
  public static currentPanel: QwenResponsePanel | undefined;
  private readonly _panel: vscode.WebviewPanel;
  private readonly _extensionUri: vscode.Uri;
  private _disposables: vscode.Disposable[] = [];

  public static createOrShow(extensionUri: vscode.Uri, title: string = 'Qwen Coder Response'): QwenResponsePanel {
    const column = vscode.window.activeTextEditor
      ? vscode.window.activeTextEditor.viewColumn
      : undefined;

    // If we already have a panel, show it
    if (QwenResponsePanel.currentPanel) {
      QwenResponsePanel.currentPanel._panel.reveal(column);
      QwenResponsePanel.currentPanel._panel.title = title;
      return QwenResponsePanel.currentPanel;
    }

    // Otherwise, create a new panel
    const panel = vscode.window.createWebviewPanel(
      'qwenResponse',
      title,
      column || vscode.ViewColumn.Beside,
      {
        enableScripts: true,
        localResourceRoots: [
          vscode.Uri.joinPath(extensionUri, 'media')
        ],
        retainContextWhenHidden: true
      }
    );

    QwenResponsePanel.currentPanel = new QwenResponsePanel(panel, extensionUri);
    return QwenResponsePanel.currentPanel;
  }

  private constructor(panel: vscode.WebviewPanel, extensionUri: vscode.Uri) {
    this._panel = panel;
    this._extensionUri = extensionUri;

    // Set the webview's initial html content
    this._update('');

    // Listen for when the panel is disposed
    // This happens when the user closes the panel or when the panel is closed programmatically
    this._panel.onDidDispose(() => this.dispose(), null, this._disposables);

    // Handle messages from the webview
    this._panel.webview.onDidReceiveMessage(
      message => {
        switch (message.command) {
          case 'copy':
            vscode.env.clipboard.writeText(message.text);
            vscode.window.showInformationMessage('Code copied to clipboard');
            break;
          case 'insert':
            insertCodeIntoEditor(message.text);
            vscode.window.showInformationMessage('Code inserted into editor');
            break;
        }
      },
      null,
      this._disposables
    );
  }

  public dispose(): void {
    QwenResponsePanel.currentPanel = undefined;

    // Clean up our resources
    this._panel.dispose();

    while (this._disposables.length) {
      const x = this._disposables.pop();
      if (x) {
        x.dispose();
      }
    }
  }

  public setContent(content: string): void {
    this._update(content);
  }

  /**
   * Append content to the existing content (for streaming)
   * @param chunk The content chunk to append
   * @param isComplete Whether this is the final chunk
   */
  public appendContent(chunk: string, isComplete: boolean): void {
    // Send a message to the webview to append content
    this._panel.webview.postMessage({
      command: 'append',
      text: chunk,
      isComplete
    });
  }

  private _update(content: string): void {
    const webview = this._panel.webview;

    // Get paths to resources
    const cssUri = webview.asWebviewUri(
      vscode.Uri.joinPath(this._extensionUri, 'media', 'styles.css')
    );
    const highlightJsUri = webview.asWebviewUri(
      vscode.Uri.joinPath(this._extensionUri, 'media', 'highlight.js')
    );

    // Create HTML content
    this._panel.webview.html = `
      <!DOCTYPE html>
      <html lang="en">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" href="${cssUri}">
        <title>Qwen Coder Response</title>
      </head>
      <body>
        <div id="response-container" class="response-container">
          ${this._formatMarkdown(content)}
        </div>
        <script src="${highlightJsUri}"></script>
        <script>
          const vscode = acquireVsCodeApi();
          let currentMarkdown = '';
          let isProcessingStream = false;
          const responseContainer = document.getElementById('response-container');

          // Listen for messages from the extension
          window.addEventListener('message', event => {
            const message = event.data;

            switch (message.command) {
              case 'append':
                // Handle streaming content
                currentMarkdown += message.text;
                responseContainer.innerHTML = formatMarkdown(currentMarkdown);

                // Apply syntax highlighting and add buttons to code blocks
                applyCodeFormatting();

                // If this is the final chunk, do any final processing
                if (message.isComplete) {
                  isProcessingStream = false;
                  // Final formatting pass
                  responseContainer.innerHTML = formatMarkdown(currentMarkdown);
                  applyCodeFormatting();
                }

                // Scroll to bottom to show new content
                window.scrollTo(0, document.body.scrollHeight);
                break;
            }
          });

          // Function to format markdown text to HTML
          function formatMarkdown(text) {
            if (!text) {
              return '<p>No response yet...</p>';
            }

            // Replace code blocks
            let html = text.replace(/\`\`\`(\w+)?\n([\s\S]*?)\`\`\`/g, (_, lang, code) => {
              return \`<pre><code class="language-\${lang || 'text'}">\${escapeHtml(code)}</code></pre>\`;
            });

            // Replace inline code
            html = html.replace(/\`([^\`]+)\`/g, '<code>$1</code>');

            // Replace headers
            html = html.replace(/^### (.*$)/gm, '<h3>$1</h3>');
            html = html.replace(/^## (.*$)/gm, '<h2>$1</h2>');
            html = html.replace(/^# (.*$)/gm, '<h1>$1</h1>');

            // Replace lists
            html = html.replace(/^\* (.*$)/gm, '<ul><li>$1</li></ul>');
            html = html.replace(/^- (.*$)/gm, '<ul><li>$1</li></ul>');
            html = html.replace(/^(\d+)\. (.*$)/gm, '<ol><li>$2</li></ol>');

            // Replace paragraphs
            html = html.replace(/^(?!<[hou]).+$/gm, '<p>$&</p>');

            // Fix nested lists
            html = html.replace(/<\/ul>\s*<ul>/g, '');
            html = html.replace(/<\/ol>\s*<ol>/g, '');

            return html;
          }

          // Function to escape HTML special characters
          function escapeHtml(text) {
            return text
              .replace(/&/g, '&amp;')
              .replace(/</g, '&lt;')
              .replace(/>/g, '&gt;')
              .replace(/"/g, '&quot;')
              .replace(/'/g, '&#039;');
          }

          // Function to apply syntax highlighting and add buttons to code blocks
          function applyCodeFormatting() {
            // Apply syntax highlighting to code blocks
            document.querySelectorAll('pre code').forEach((codeBlock) => {
              const language = codeBlock.className.replace('language-', '');
              if (language && language !== 'text') {
                const originalCode = codeBlock.textContent;
                try {
                  codeBlock.innerHTML = window.HighlightJS.highlight(originalCode, language);
                } catch (e) {
                  console.error('Error highlighting code:', e);
                }
              }
            });

            // Add copy and insert buttons to code blocks that don't already have them
            document.querySelectorAll('pre:not(.processed)').forEach((pre) => {
              pre.classList.add('processed');

              const container = document.createElement('div');
              container.className = 'code-block-container';
              pre.parentNode.insertBefore(container, pre);
              container.appendChild(pre);

              const copyButton = document.createElement('button');
              copyButton.className = 'copy-button';
              copyButton.textContent = 'Copy';
              copyButton.addEventListener('click', () => {
                const code = pre.textContent;
                vscode.postMessage({
                  command: 'copy',
                  text: code
                });
                copyButton.textContent = 'Copied!';
                setTimeout(() => {
                  copyButton.textContent = 'Copy';
                }, 2000);
              });

              const insertButton = document.createElement('button');
              insertButton.className = 'insert-button';
              insertButton.textContent = 'Insert';
              insertButton.addEventListener('click', () => {
                const code = pre.textContent;
                vscode.postMessage({
                  command: 'insert',
                  text: code
                });
              });

              container.appendChild(copyButton);
              container.appendChild(insertButton);
            });
          }

          // Initial formatting for any content that's already there
          applyCodeFormatting();
        </script>
      </body>
      </html>
    `;
  }

  private _formatMarkdown(text: string): string {
    if (!text) {
      return '<p>No response yet...</p>';
    }

    // Replace code blocks
    let html = text.replace(/```(\w+)?\n([\s\S]*?)```/g, (_, lang, code) => {
      return `<pre><code class="language-${lang || 'text'}">${this._escapeHtml(code)}</code></pre>`;
    });

    // Replace inline code
    html = html.replace(/`([^`]+)`/g, '<code>$1</code>');

    // Replace headers
    html = html.replace(/^### (.*$)/gm, '<h3>$1</h3>');
    html = html.replace(/^## (.*$)/gm, '<h2>$1</h2>');
    html = html.replace(/^# (.*$)/gm, '<h1>$1</h1>');

    // Replace lists
    html = html.replace(/^\* (.*$)/gm, '<ul><li>$1</li></ul>');
    html = html.replace(/^- (.*$)/gm, '<ul><li>$1</li></ul>');
    html = html.replace(/^(\d+)\. (.*$)/gm, '<ol><li>$2</li></ol>');

    // Replace paragraphs
    html = html.replace(/^(?!<[hou]).+$/gm, '<p>$&</p>');

    // Fix nested lists
    html = html.replace(/<\/ul>\s*<ul>/g, '');
    html = html.replace(/<\/ol>\s*<ol>/g, '');

    return html;
  }

  private _escapeHtml(text: string): string {
    return text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#039;');
  }
}

```


---

### File: `archive/vscode-extension/src/containers/containerManager.js`

```javascript
"use strict";
/**
 * Container Manager
 *
 * Handles the lifecycle of containerized MCP tools.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContainerManager = void 0;
const vscode = __importStar(require("vscode"));
const configuration_1 = require("../configuration");
/**
 * Container Manager class
 */
class ContainerManager {
    /**
     * Constructor
     */
    constructor() {
        this.outputChannel = vscode.window.createOutputChannel('Container Manager');
        this.statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left);
        this.statusBarItem.text = '$(docker) MCP Tools';
        this.statusBarItem.tooltip = 'MCP Tools Status';
        this.statusBarItem.command = 'qwenCoder.showContainerStatus';
        this.containerRegistry = {
            'github': {
                image: 'qwen-mcp-github:latest',
                command: 'uvx',
                args: ['mcp-server-github'],
                ports: [{ internal: 8080, external: 0 }]
            },
            'docker': {
                image: 'qwen-mcp-docker:latest',
                command: 'uvx',
                args: ['mcp-server-docker'],
                ports: [{ internal: 8080, external: 0 }]
            },
            'testing': {
                image: 'qwen-mcp-testing:latest',
                command: 'uvx',
                args: ['mcp-server-testing'],
                ports: [{ internal: 8080, external: 0 }]
            },
            'ci_cd': {
                image: 'qwen-mcp-cicd:latest',
                command: 'uvx',
                args: ['mcp-server-cicd'],
                ports: [{ internal: 8080, external: 0 }]
            }
        };
        this.activeContainers = {};
        this.healthCheckInterval = null;
        this.outputChannel.appendLine('Container Manager initialized');
    }
    /**
     * Initialize the container manager
     */
    async initialize() {
        try {
            this.statusBarItem.show();
            // Check if Docker is available
            const dockerAvailable = await this._checkDockerAvailability();
            if (!dockerAvailable) {
                this.outputChannel.appendLine('Docker is not available. Container features will be disabled.');
                this.statusBarItem.text = '$(alert) Docker Not Available';
                this.statusBarItem.tooltip = 'Docker is not available. Container features are disabled.';
                return;
            }
            // Start health check interval
            this._startHealthCheck();
            // Auto-start containers if configured
            const config = (0, configuration_1.getConfiguration)();
            const autoStartContainers = config.get('autoStartContainers', false);
            if (autoStartContainers) {
                this.outputChannel.appendLine('Auto-starting containers...');
                const containersToStart = config.get('autoStartContainerList', ['github', 'docker']);
                for (const containerName of containersToStart) {
                    try {
                        await this.startContainer(containerName);
                    }
                    catch (error) {
                        this.outputChannel.appendLine(`Error auto-starting container ${containerName}: ${error.message}`);
                    }
                }
            }
        }
        catch (error) {
            this.outputChannel.appendLine(`Error initializing Container Manager: ${error.message}`);
            this.statusBarItem.text = '$(error) MCP Tools Error';
            this.statusBarItem.tooltip = `Error: ${error.message}`;
        }
    }
    /**
     * Start a containerized MCP tool
     * @param containerName The name of the container to start
     * @returns The URL for accessing the container
     */
    async startContainer(containerName) {
        try {
            this.outputChannel.appendLine(`Starting container: ${containerName}`);
            // Check if container is already running
            if (this.activeContainers[containerName] && this.activeContainers[containerName].status === 'running') {
                this.outputChannel.appendLine(`Container ${containerName} is already running`);
                return this.activeContainers[containerName].url;
            }
            // Get container configuration
            const containerConfig = this.containerRegistry[containerName];
            if (!containerConfig) {
                throw new Error(`Unknown container: ${containerName}`);
            }
            // Check if Docker is available
            const dockerAvailable = await this._checkDockerAvailability();
            if (!dockerAvailable) {
                throw new Error('Docker is not available');
            }
            // Pull the image if needed
            await this._ensureImageAvailable(containerConfig.image);
            // Start the container
            const containerId = await this._startContainer(containerName, containerConfig);
            // Get container URL
            const url = await this._getContainerUrl(containerId, containerConfig);
            // Update active containers
            this.activeContainers[containerName] = {
                id: containerId,
                name: containerName,
                image: containerConfig.image,
                url,
                status: 'running',
                startTime: Date.now()
            };
            // Update status bar
            this._updateStatusBar();
            this.outputChannel.appendLine(`Container ${containerName} started successfully with URL: ${url}`);
            return url;
        }
        catch (error) {
            this.outputChannel.appendLine(`Error starting container ${containerName}: ${error.message}`);
            // Update active containers with error status
            this.activeContainers[containerName] = {
                id: '',
                name: containerName,
                image: this.containerRegistry[containerName]?.image || '',
                url: '',
                status: 'error',
                startTime: Date.now(),
                error: error.message
            };
            // Update status bar
            this._updateStatusBar();
            throw error;
        }
    }
    /**
     * Stop a containerized MCP tool
     * @param containerName The name of the container to stop
     */
    async stopContainer(containerName) {
        try {
            this.outputChannel.appendLine(`Stopping container: ${containerName}`);
            // Check if container is running
            if (!this.activeContainers[containerName] || this.activeContainers[containerName].status !== 'running') {
                this.outputChannel.appendLine(`Container ${containerName} is not running`);
                return;
            }
            const containerId = this.activeContainers[containerName].id;
            // Stop and remove the container
            await this._stopContainer(containerId);
            // Update active containers
            this.activeContainers[containerName] = {
                ...this.activeContainers[containerName],
                status: 'stopped'
            };
            // Update status bar
            this._updateStatusBar();
            this.outputChannel.appendLine(`Container ${containerName} stopped successfully`);
        }
        catch (error) {
            this.outputChannel.appendLine(`Error stopping container ${containerName}: ${error.message}`);
            throw error;
        }
    }
    /**
     * Get the URL for a running container
     * @param containerName The name of the container
     * @returns The URL for accessing the container
     */
    getContainerUrl(containerName) {
        if (!this.activeContainers[containerName] || this.activeContainers[containerName].status !== 'running') {
            throw new Error(`Container ${containerName} is not running`);
        }
        return this.activeContainers[containerName].url;
    }
    /**
     * Get the status of all containers
     * @returns The status of all containers
     */
    getContainerStatus() {
        return { ...this.activeContainers };
    }
    /**
     * Check if Docker is available
     * @returns Whether Docker is available
     */
    async _checkDockerAvailability() {
        try {
            // This is a placeholder for Docker availability check
            // In a real implementation, we would use the Docker SDK to check if Docker is running
            // For now, we'll assume Docker is available
            return true;
        }
        catch (error) {
            this.outputChannel.appendLine(`Error checking Docker availability: ${error.message}`);
            return false;
        }
    }
    /**
     * Ensure the Docker image is available
     * @param imageName The name of the image
     */
    async _ensureImageAvailable(imageName) {
        try {
            this.outputChannel.appendLine(`Ensuring image is available: ${imageName}`);
            // This is a placeholder for image availability check
            // In a real implementation, we would use the Docker SDK to check if the image exists locally
            // and pull it if it doesn't
            // For now, we'll assume the image is available
        }
        catch (error) {
            this.outputChannel.appendLine(`Error ensuring image availability: ${error.message}`);
            throw error;
        }
    }
    /**
     * Start a container
     * @param containerName The name of the container
     * @param config The container configuration
     * @returns The container ID
     */
    async _startContainer(containerName, config) {
        try {
            this.outputChannel.appendLine(`Starting container with image: ${config.image}`);
            // This is a placeholder for container start
            // In a real implementation, we would use the Docker SDK to start the container
            // For now, we'll return a fake container ID
            return `fake-container-id-${containerName}-${Date.now()}`;
        }
        catch (error) {
            this.outputChannel.appendLine(`Error starting container: ${error.message}`);
            throw error;
        }
    }
    /**
     * Stop a container
     * @param containerId The ID of the container
     */
    async _stopContainer(containerId) {
        try {
            this.outputChannel.appendLine(`Stopping container: ${containerId}`);
            // This is a placeholder for container stop
            // In a real implementation, we would use the Docker SDK to stop and remove the container
        }
        catch (error) {
            this.outputChannel.appendLine(`Error stopping container: ${error.message}`);
            throw error;
        }
    }
    /**
     * Get the URL for a container
     * @param containerId The ID of the container
     * @param config The container configuration
     * @returns The URL for accessing the container
     */
    async _getContainerUrl(containerId, config) {
        try {
            // This is a placeholder for getting the container URL
            // In a real implementation, we would use the Docker SDK to get the port mapping
            // For now, we'll return a fake URL
            return `http://localhost:${8080 + Math.floor(Math.random() * 1000)}`;
        }
        catch (error) {
            this.outputChannel.appendLine(`Error getting container URL: ${error.message}`);
            throw error;
        }
    }
    /**
     * Start health check interval
     */
    _startHealthCheck() {
        if (this.healthCheckInterval) {
            clearInterval(this.healthCheckInterval);
        }
        this.healthCheckInterval = setInterval(async () => {
            try {
                for (const containerName in this.activeContainers) {
                    const container = this.activeContainers[containerName];
                    if (container.status === 'running') {
                        // Check container health
                        const isHealthy = await this._checkContainerHealth(container);
                        if (!isHealthy) {
                            this.outputChannel.appendLine(`Container ${containerName} is not healthy, attempting to restart`);
                            // Attempt to restart the container
                            try {
                                await this.stopContainer(containerName);
                                await this.startContainer(containerName);
                                this.outputChannel.appendLine(`Container ${containerName} restarted successfully`);
                            }
                            catch (error) {
                                this.outputChannel.appendLine(`Error restarting container ${containerName}: ${error.message}`);
                            }
                        }
                    }
                }
                // Update status bar
                this._updateStatusBar();
            }
            catch (error) {
                this.outputChannel.appendLine(`Error in health check: ${error.message}`);
            }
        }, 60000); // Check every minute
    }
    /**
     * Check container health
     * @param container The container to check
     * @returns Whether the container is healthy
     */
    async _checkContainerHealth(container) {
        try {
            // This is a placeholder for container health check
            // In a real implementation, we would use the Docker SDK to check the container health
            // For now, we'll assume the container is healthy
            return true;
        }
        catch (error) {
            this.outputChannel.appendLine(`Error checking container health: ${error.message}`);
            return false;
        }
    }
    /**
     * Update status bar
     */
    _updateStatusBar() {
        const runningContainers = Object.values(this.activeContainers).filter(c => c.status === 'running').length;
        const totalContainers = Object.keys(this.activeContainers).length;
        if (runningContainers === 0) {
            this.statusBarItem.text = '$(docker) MCP Tools: None Running';
        }
        else {
            this.statusBarItem.text = `$(docker) MCP Tools: ${runningContainers}/${totalContainers} Running`;
        }
        // Update tooltip with container details
        let tooltip = 'MCP Tools Status:\n\n';
        for (const containerName in this.activeContainers) {
            const container = this.activeContainers[containerName];
            tooltip += `${containerName}: ${container.status}`;
            if (container.status === 'running') {
                tooltip += ` (${container.url})`;
            }
            else if (container.status === 'error') {
                tooltip += ` (${container.error})`;
            }
            tooltip += '\n';
        }
        this.statusBarItem.tooltip = tooltip;
    }
    /**
     * Stop all containers
     */
    async stopAllContainers() {
        try {
            this.outputChannel.appendLine('Stopping all containers');
            for (const containerName in this.activeContainers) {
                if (this.activeContainers[containerName].status === 'running') {
                    try {
                        await this.stopContainer(containerName);
                    }
                    catch (error) {
                        this.outputChannel.appendLine(`Error stopping container ${containerName}: ${error.message}`);
                    }
                }
            }
            this.outputChannel.appendLine('All containers stopped');
        }
        catch (error) {
            this.outputChannel.appendLine(`Error stopping all containers: ${error.message}`);
            throw error;
        }
    }
    /**
     * Dispose of resources
     */
    dispose() {
        if (this.healthCheckInterval) {
            clearInterval(this.healthCheckInterval);
            this.healthCheckInterval = null;
        }
        this.stopAllContainers().catch(error => {
            this.outputChannel.appendLine(`Error stopping containers during disposal: ${error.message}`);
        });
        this.statusBarItem.dispose();
        this.outputChannel.dispose();
    }
}
exports.ContainerManager = ContainerManager;
//# sourceMappingURL=containerManager.js.map
```


---

### File: `archive/vscode-extension/src/containers/containerManager.ts`

```typescript
/**
 * Container Manager
 * 
 * Handles the lifecycle of containerized MCP tools.
 */

import * as vscode from 'vscode';
import * as path from 'path';
import { getConfiguration } from '../configuration';

/**
 * Container information
 */
interface ContainerInfo {
  id: string;
  name: string;
  image: string;
  url: string;
  status: 'running' | 'stopped' | 'error';
  startTime: number;
  error?: string;
}

/**
 * Container configuration
 */
interface ContainerConfig {
  image: string;
  command: string;
  args: string[];
  env?: Record<string, string>;
  ports?: { internal: number, external: number }[];
}

/**
 * Container Manager class
 */
export class ContainerManager {
  private outputChannel: vscode.OutputChannel;
  private containerRegistry: Record<string, ContainerConfig>;
  private activeContainers: Record<string, ContainerInfo>;
  private statusBarItem: vscode.StatusBarItem;
  private healthCheckInterval: NodeJS.Timeout | null;

  /**
   * Constructor
   */
  constructor() {
    this.outputChannel = vscode.window.createOutputChannel('Container Manager');
    this.statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left);
    this.statusBarItem.text = '$(docker) MCP Tools';
    this.statusBarItem.tooltip = 'MCP Tools Status';
    this.statusBarItem.command = 'qwenCoder.showContainerStatus';
    
    this.containerRegistry = {
      'github': {
        image: 'qwen-mcp-github:latest',
        command: 'uvx',
        args: ['mcp-server-github'],
        ports: [{ internal: 8080, external: 0 }]
      },
      'docker': {
        image: 'qwen-mcp-docker:latest',
        command: 'uvx',
        args: ['mcp-server-docker'],
        ports: [{ internal: 8080, external: 0 }]
      },
      'testing': {
        image: 'qwen-mcp-testing:latest',
        command: 'uvx',
        args: ['mcp-server-testing'],
        ports: [{ internal: 8080, external: 0 }]
      },
      'ci_cd': {
        image: 'qwen-mcp-cicd:latest',
        command: 'uvx',
        args: ['mcp-server-cicd'],
        ports: [{ internal: 8080, external: 0 }]
      }
    };
    
    this.activeContainers = {};
    this.healthCheckInterval = null;
    
    this.outputChannel.appendLine('Container Manager initialized');
  }

  /**
   * Initialize the container manager
   */
  public async initialize(): Promise<void> {
    try {
      this.statusBarItem.show();
      
      // Check if Docker is available
      const dockerAvailable = await this._checkDockerAvailability();
      
      if (!dockerAvailable) {
        this.outputChannel.appendLine('Docker is not available. Container features will be disabled.');
        this.statusBarItem.text = '$(alert) Docker Not Available';
        this.statusBarItem.tooltip = 'Docker is not available. Container features are disabled.';
        return;
      }
      
      // Start health check interval
      this._startHealthCheck();
      
      // Auto-start containers if configured
      const config = getConfiguration();
      const autoStartContainers = config.get<boolean>('autoStartContainers', false);
      
      if (autoStartContainers) {
        this.outputChannel.appendLine('Auto-starting containers...');
        
        const containersToStart = config.get<string[]>('autoStartContainerList', ['github', 'docker']);
        
        for (const containerName of containersToStart) {
          try {
            await this.startContainer(containerName);
          } catch (error) {
            this.outputChannel.appendLine(`Error auto-starting container ${containerName}: ${error.message}`);
          }
        }
      }
    } catch (error) {
      this.outputChannel.appendLine(`Error initializing Container Manager: ${error.message}`);
      this.statusBarItem.text = '$(error) MCP Tools Error';
      this.statusBarItem.tooltip = `Error: ${error.message}`;
    }
  }

  /**
   * Start a containerized MCP tool
   * @param containerName The name of the container to start
   * @returns The URL for accessing the container
   */
  public async startContainer(containerName: string): Promise<string> {
    try {
      this.outputChannel.appendLine(`Starting container: ${containerName}`);
      
      // Check if container is already running
      if (this.activeContainers[containerName] && this.activeContainers[containerName].status === 'running') {
        this.outputChannel.appendLine(`Container ${containerName} is already running`);
        return this.activeContainers[containerName].url;
      }
      
      // Get container configuration
      const containerConfig = this.containerRegistry[containerName];
      if (!containerConfig) {
        throw new Error(`Unknown container: ${containerName}`);
      }
      
      // Check if Docker is available
      const dockerAvailable = await this._checkDockerAvailability();
      if (!dockerAvailable) {
        throw new Error('Docker is not available');
      }
      
      // Pull the image if needed
      await this._ensureImageAvailable(containerConfig.image);
      
      // Start the container
      const containerId = await this._startContainer(containerName, containerConfig);
      
      // Get container URL
      const url = await this._getContainerUrl(containerId, containerConfig);
      
      // Update active containers
      this.activeContainers[containerName] = {
        id: containerId,
        name: containerName,
        image: containerConfig.image,
        url,
        status: 'running',
        startTime: Date.now()
      };
      
      // Update status bar
      this._updateStatusBar();
      
      this.outputChannel.appendLine(`Container ${containerName} started successfully with URL: ${url}`);
      
      return url;
    } catch (error) {
      this.outputChannel.appendLine(`Error starting container ${containerName}: ${error.message}`);
      
      // Update active containers with error status
      this.activeContainers[containerName] = {
        id: '',
        name: containerName,
        image: this.containerRegistry[containerName]?.image || '',
        url: '',
        status: 'error',
        startTime: Date.now(),
        error: error.message
      };
      
      // Update status bar
      this._updateStatusBar();
      
      throw error;
    }
  }

  /**
   * Stop a containerized MCP tool
   * @param containerName The name of the container to stop
   */
  public async stopContainer(containerName: string): Promise<void> {
    try {
      this.outputChannel.appendLine(`Stopping container: ${containerName}`);
      
      // Check if container is running
      if (!this.activeContainers[containerName] || this.activeContainers[containerName].status !== 'running') {
        this.outputChannel.appendLine(`Container ${containerName} is not running`);
        return;
      }
      
      const containerId = this.activeContainers[containerName].id;
      
      // Stop and remove the container
      await this._stopContainer(containerId);
      
      // Update active containers
      this.activeContainers[containerName] = {
        ...this.activeContainers[containerName],
        status: 'stopped'
      };
      
      // Update status bar
      this._updateStatusBar();
      
      this.outputChannel.appendLine(`Container ${containerName} stopped successfully`);
    } catch (error) {
      this.outputChannel.appendLine(`Error stopping container ${containerName}: ${error.message}`);
      throw error;
    }
  }

  /**
   * Get the URL for a running container
   * @param containerName The name of the container
   * @returns The URL for accessing the container
   */
  public getContainerUrl(containerName: string): string {
    if (!this.activeContainers[containerName] || this.activeContainers[containerName].status !== 'running') {
      throw new Error(`Container ${containerName} is not running`);
    }
    
    return this.activeContainers[containerName].url;
  }

  /**
   * Get the status of all containers
   * @returns The status of all containers
   */
  public getContainerStatus(): Record<string, ContainerInfo> {
    return { ...this.activeContainers };
  }

  /**
   * Check if Docker is available
   * @returns Whether Docker is available
   */
  private async _checkDockerAvailability(): Promise<boolean> {
    try {
      // This is a placeholder for Docker availability check
      // In a real implementation, we would use the Docker SDK to check if Docker is running
      
      // For now, we'll assume Docker is available
      return true;
    } catch (error) {
      this.outputChannel.appendLine(`Error checking Docker availability: ${error.message}`);
      return false;
    }
  }

  /**
   * Ensure the Docker image is available
   * @param imageName The name of the image
   */
  private async _ensureImageAvailable(imageName: string): Promise<void> {
    try {
      this.outputChannel.appendLine(`Ensuring image is available: ${imageName}`);
      
      // This is a placeholder for image availability check
      // In a real implementation, we would use the Docker SDK to check if the image exists locally
      // and pull it if it doesn't
      
      // For now, we'll assume the image is available
    } catch (error) {
      this.outputChannel.appendLine(`Error ensuring image availability: ${error.message}`);
      throw error;
    }
  }

  /**
   * Start a container
   * @param containerName The name of the container
   * @param config The container configuration
   * @returns The container ID
   */
  private async _startContainer(containerName: string, config: ContainerConfig): Promise<string> {
    try {
      this.outputChannel.appendLine(`Starting container with image: ${config.image}`);
      
      // This is a placeholder for container start
      // In a real implementation, we would use the Docker SDK to start the container
      
      // For now, we'll return a fake container ID
      return `fake-container-id-${containerName}-${Date.now()}`;
    } catch (error) {
      this.outputChannel.appendLine(`Error starting container: ${error.message}`);
      throw error;
    }
  }

  /**
   * Stop a container
   * @param containerId The ID of the container
   */
  private async _stopContainer(containerId: string): Promise<void> {
    try {
      this.outputChannel.appendLine(`Stopping container: ${containerId}`);
      
      // This is a placeholder for container stop
      // In a real implementation, we would use the Docker SDK to stop and remove the container
    } catch (error) {
      this.outputChannel.appendLine(`Error stopping container: ${error.message}`);
      throw error;
    }
  }

  /**
   * Get the URL for a container
   * @param containerId The ID of the container
   * @param config The container configuration
   * @returns The URL for accessing the container
   */
  private async _getContainerUrl(containerId: string, config: ContainerConfig): Promise<string> {
    try {
      // This is a placeholder for getting the container URL
      // In a real implementation, we would use the Docker SDK to get the port mapping
      
      // For now, we'll return a fake URL
      return `http://localhost:${8080 + Math.floor(Math.random() * 1000)}`;
    } catch (error) {
      this.outputChannel.appendLine(`Error getting container URL: ${error.message}`);
      throw error;
    }
  }

  /**
   * Start health check interval
   */
  private _startHealthCheck(): void {
    if (this.healthCheckInterval) {
      clearInterval(this.healthCheckInterval);
    }
    
    this.healthCheckInterval = setInterval(async () => {
      try {
        for (const containerName in this.activeContainers) {
          const container = this.activeContainers[containerName];
          
          if (container.status === 'running') {
            // Check container health
            const isHealthy = await this._checkContainerHealth(container);
            
            if (!isHealthy) {
              this.outputChannel.appendLine(`Container ${containerName} is not healthy, attempting to restart`);
              
              // Attempt to restart the container
              try {
                await this.stopContainer(containerName);
                await this.startContainer(containerName);
                
                this.outputChannel.appendLine(`Container ${containerName} restarted successfully`);
              } catch (error) {
                this.outputChannel.appendLine(`Error restarting container ${containerName}: ${error.message}`);
              }
            }
          }
        }
        
        // Update status bar
        this._updateStatusBar();
      } catch (error) {
        this.outputChannel.appendLine(`Error in health check: ${error.message}`);
      }
    }, 60000); // Check every minute
  }

  /**
   * Check container health
   * @param container The container to check
   * @returns Whether the container is healthy
   */
  private async _checkContainerHealth(container: ContainerInfo): Promise<boolean> {
    try {
      // This is a placeholder for container health check
      // In a real implementation, we would use the Docker SDK to check the container health
      
      // For now, we'll assume the container is healthy
      return true;
    } catch (error) {
      this.outputChannel.appendLine(`Error checking container health: ${error.message}`);
      return false;
    }
  }

  /**
   * Update status bar
   */
  private _updateStatusBar(): void {
    const runningContainers = Object.values(this.activeContainers).filter(c => c.status === 'running').length;
    const totalContainers = Object.keys(this.activeContainers).length;
    
    if (runningContainers === 0) {
      this.statusBarItem.text = '$(docker) MCP Tools: None Running';
    } else {
      this.statusBarItem.text = `$(docker) MCP Tools: ${runningContainers}/${totalContainers} Running`;
    }
    
    // Update tooltip with container details
    let tooltip = 'MCP Tools Status:\n\n';
    
    for (const containerName in this.activeContainers) {
      const container = this.activeContainers[containerName];
      tooltip += `${containerName}: ${container.status}`;
      
      if (container.status === 'running') {
        tooltip += ` (${container.url})`;
      } else if (container.status === 'error') {
        tooltip += ` (${container.error})`;
      }
      
      tooltip += '\n';
    }
    
    this.statusBarItem.tooltip = tooltip;
  }

  /**
   * Stop all containers
   */
  public async stopAllContainers(): Promise<void> {
    try {
      this.outputChannel.appendLine('Stopping all containers');
      
      for (const containerName in this.activeContainers) {
        if (this.activeContainers[containerName].status === 'running') {
          try {
            await this.stopContainer(containerName);
          } catch (error) {
            this.outputChannel.appendLine(`Error stopping container ${containerName}: ${error.message}`);
          }
        }
      }
      
      this.outputChannel.appendLine('All containers stopped');
    } catch (error) {
      this.outputChannel.appendLine(`Error stopping all containers: ${error.message}`);
      throw error;
    }
  }

  /**
   * Dispose of resources
   */
  public dispose(): void {
    if (this.healthCheckInterval) {
      clearInterval(this.healthCheckInterval);
      this.healthCheckInterval = null;
    }
    
    this.stopAllContainers().catch(error => {
      this.outputChannel.appendLine(`Error stopping containers during disposal: ${error.message}`);
    });
    
    this.statusBarItem.dispose();
    this.outputChannel.dispose();
  }
}

```


---

### File: `archive/vscode-extension/src/agents/developmentAgent.ts`

```typescript
/**
 * Development Agent
 * 
 * Specialized agent for code generation, refactoring, and documentation.
 */

import * as vscode from 'vscode';
import { AgentType, ModelSize, ThinkingMode, Subtask, AgentResult } from './types';
import { QwenApiClient } from '../qwenApi';
import { getContextForCurrentFile } from '../contextProvider';

/**
 * Development Agent class
 */
export class DevelopmentAgent {
  private id: string;
  private qwenApi: QwenApiClient;
  private modelSize: ModelSize;
  private thinkingMode: ThinkingMode;
  private outputChannel: vscode.OutputChannel;

  /**
   * Constructor
   * @param id The agent ID
   * @param qwenApi The Qwen API client
   * @param modelSize The model size to use
   * @param thinkingMode The thinking mode to use
   */
  constructor(
    id: string,
    qwenApi: QwenApiClient,
    modelSize: ModelSize,
    thinkingMode: ThinkingMode
  ) {
    this.id = id;
    this.qwenApi = qwenApi;
    this.modelSize = modelSize;
    this.thinkingMode = thinkingMode;
    this.outputChannel = vscode.window.createOutputChannel(`Development Agent ${id}`);
    
    this.outputChannel.appendLine(`Development Agent initialized with model ${modelSize} and thinking mode ${thinkingMode}`);
  }

  /**
   * Execute a subtask
   * @param subtask The subtask to execute
   * @returns The result of the execution
   */
  public async execute(subtask: Subtask): Promise<AgentResult> {
    try {
      this.outputChannel.appendLine(`Executing subtask: ${subtask.description}`);
      
      // Get context from the current file
      const context = await getContextForCurrentFile();
      
      // Prepare the system message
      const systemMessage = `
        You are a Development Agent specializing in writing high-quality code, refactoring, and documentation.
        Your task is to help with development-related activities in a DevOps workflow.
        
        You excel at:
        1. Writing clean, efficient, and well-documented code
        2. Refactoring existing code to improve quality and maintainability
        3. Implementing best practices and design patterns
        4. Creating comprehensive documentation
        5. Solving complex programming problems
        
        When writing code:
        - Follow language-specific conventions and best practices
        - Include appropriate error handling
        - Add clear comments explaining complex logic
        - Consider edge cases and potential issues
        - Optimize for readability and maintainability
        
        When providing explanations:
        - Be clear and concise
        - Use examples to illustrate concepts
        - Explain your reasoning and decision-making process
        - Highlight trade-offs and alternatives considered
      `;
      
      // Prepare the user message
      const userMessage = `
        I need help with the following development task: ${subtask.description}
        
        ${context ? `Here is the current context:\n\n${context}` : ''}
      `;
      
      // Prepare the messages for the API call
      const messages = [
        { role: 'system', content: systemMessage },
        { role: 'user', content: userMessage }
      ];
      
      // Call the Qwen API with the appropriate thinking mode
      const enableThinking = this.thinkingMode === ThinkingMode.Enabled;
      const response = await this.qwenApi.chat(messages, {
        enableThinking,
        temperature: 0.3,
        maxTokens: 4096,
        modelName: this.modelSize
      });
      
      this.outputChannel.appendLine('Subtask executed successfully');
      
      return {
        subtaskId: subtask.id,
        thinking: enableThinking ? this._extractThinking(response) : undefined,
        content: this._extractContent(response, enableThinking),
        status: 'success'
      };
    } catch (error) {
      this.outputChannel.appendLine(`Error executing subtask: ${error.message}`);
      
      return {
        subtaskId: subtask.id,
        content: '',
        status: 'error',
        error: error.message
      };
    }
  }

  /**
   * Extract thinking from response
   * @param response The API response
   * @returns The extracted thinking
   */
  private _extractThinking(response: string): string {
    const thinkingMatch = response.match(/<think>([\s\S]*?)<\/think>/);
    return thinkingMatch ? thinkingMatch[1].trim() : '';
  }

  /**
   * Extract content from response
   * @param response The API response
   * @param enableThinking Whether thinking mode was enabled
   * @returns The extracted content
   */
  private _extractContent(response: string, enableThinking: boolean): string {
    if (enableThinking) {
      // Remove thinking tags and content
      return response.replace(/<think>[\s\S]*?<\/think>/, '').trim();
    }
    
    return response.trim();
  }

  /**
   * Dispose of resources
   */
  public dispose(): void {
    this.outputChannel.dispose();
  }
}

```


---

### File: `archive/vscode-extension/src/agents/types.js`

```javascript
"use strict";
/**
 * Type definitions for the hierarchical agent system
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ThinkingMode = exports.TaskComplexity = exports.ModelSize = exports.AgentType = void 0;
/**
 * Agent types supported by the system
 */
var AgentType;
(function (AgentType) {
    AgentType["Coordinator"] = "coordinator";
    AgentType["Development"] = "development";
    AgentType["Testing"] = "testing";
    AgentType["CICD"] = "ci_cd";
    AgentType["GitHub"] = "github";
    AgentType["Documentation"] = "documentation";
    AgentType["Architecture"] = "architecture";
    AgentType["Security"] = "security";
    AgentType["Performance"] = "performance";
})(AgentType || (exports.AgentType = AgentType = {}));
/**
 * Model sizes available for agents
 */
var ModelSize;
(function (ModelSize) {
    ModelSize["Tiny"] = "Qwen3-0.6B";
    ModelSize["Small"] = "Qwen3-1.7B";
    ModelSize["Medium"] = "Qwen3-4B";
    ModelSize["Large"] = "Qwen3-8B";
    ModelSize["XLarge"] = "Qwen3-14B";
    ModelSize["XXLarge"] = "Qwen3-32B";
    ModelSize["MoESmall"] = "Qwen3-30B-A3B";
    ModelSize["MoELarge"] = "Qwen3-235B-A22B";
})(ModelSize || (exports.ModelSize = ModelSize = {}));
/**
 * Task complexity levels
 */
var TaskComplexity;
(function (TaskComplexity) {
    TaskComplexity["Low"] = "low";
    TaskComplexity["Medium"] = "medium";
    TaskComplexity["High"] = "high";
})(TaskComplexity || (exports.TaskComplexity = TaskComplexity = {}));
/**
 * Thinking mode options
 */
var ThinkingMode;
(function (ThinkingMode) {
    ThinkingMode["Enabled"] = "enabled";
    ThinkingMode["Disabled"] = "disabled";
    ThinkingMode["Auto"] = "auto";
})(ThinkingMode || (exports.ThinkingMode = ThinkingMode = {}));
//# sourceMappingURL=types.js.map
```


---

### File: `archive/vscode-extension/src/agents/agentSelector.ts`

```typescript
/**
 * Agent Selector
 * 
 * Chooses the most appropriate agent for each subtask based on expertise, complexity, and available resources.
 */

import * as vscode from 'vscode';
import { 
  AgentType, 
  ModelSize, 
  ThinkingMode, 
  TaskComplexity, 
  Subtask, 
  ResourceUsage 
} from './types';
import { getConfiguration } from '../configuration';

/**
 * Agent Selector class
 */
export class AgentSelector {
  private outputChannel: vscode.OutputChannel;
  private agentConfigs: Record<AgentType, Record<TaskComplexity, { modelSize: ModelSize, thinkingMode: ThinkingMode }>>;

  /**
   * Constructor
   */
  constructor() {
    this.outputChannel = vscode.window.createOutputChannel('Agent Selector');
    
    // Initialize agent configurations
    this.agentConfigs = {
      [AgentType.Coordinator]: {
        [TaskComplexity.High]: { modelSize: ModelSize.MoESmall, thinkingMode: ThinkingMode.Enabled },
        [TaskComplexity.Medium]: { modelSize: ModelSize.MoESmall, thinkingMode: ThinkingMode.Enabled },
        [TaskComplexity.Low]: { modelSize: ModelSize.XXLarge, thinkingMode: ThinkingMode.Enabled }
      },
      [AgentType.Development]: {
        [TaskComplexity.High]: { modelSize: ModelSize.MoESmall, thinkingMode: ThinkingMode.Enabled },
        [TaskComplexity.Medium]: { modelSize: ModelSize.XXLarge, thinkingMode: ThinkingMode.Enabled },
        [TaskComplexity.Low]: { modelSize: ModelSize.XLarge, thinkingMode: ThinkingMode.Disabled }
      },
      [AgentType.Testing]: {
        [TaskComplexity.High]: { modelSize: ModelSize.XLarge, thinkingMode: ThinkingMode.Enabled },
        [TaskComplexity.Medium]: { modelSize: ModelSize.Large, thinkingMode: ThinkingMode.Enabled },
        [TaskComplexity.Low]: { modelSize: ModelSize.Medium, thinkingMode: ThinkingMode.Disabled }
      },
      [AgentType.CICD]: {
        [TaskComplexity.High]: { modelSize: ModelSize.Large, thinkingMode: ThinkingMode.Enabled },
        [TaskComplexity.Medium]: { modelSize: ModelSize.Medium, thinkingMode: ThinkingMode.Disabled },
        [TaskComplexity.Low]: { modelSize: ModelSize.Small, thinkingMode: ThinkingMode.Disabled }
      },
      [AgentType.GitHub]: {
        [TaskComplexity.High]: { modelSize: ModelSize.Large, thinkingMode: ThinkingMode.Enabled },
        [TaskComplexity.Medium]: { modelSize: ModelSize.Medium, thinkingMode: ThinkingMode.Disabled },
        [TaskComplexity.Low]: { modelSize: ModelSize.Small, thinkingMode: ThinkingMode.Disabled }
      },
      [AgentType.Documentation]: {
        [TaskComplexity.High]: { modelSize: ModelSize.Large, thinkingMode: ThinkingMode.Enabled },
        [TaskComplexity.Medium]: { modelSize: ModelSize.Medium, thinkingMode: ThinkingMode.Enabled },
        [TaskComplexity.Low]: { modelSize: ModelSize.Small, thinkingMode: ThinkingMode.Disabled }
      },
      [AgentType.Architecture]: {
        [TaskComplexity.High]: { modelSize: ModelSize.MoESmall, thinkingMode: ThinkingMode.Enabled },
        [TaskComplexity.Medium]: { modelSize: ModelSize.XXLarge, thinkingMode: ThinkingMode.Enabled },
        [TaskComplexity.Low]: { modelSize: ModelSize.XLarge, thinkingMode: ThinkingMode.Enabled }
      },
      [AgentType.Security]: {
        [TaskComplexity.High]: { modelSize: ModelSize.XLarge, thinkingMode: ThinkingMode.Enabled },
        [TaskComplexity.Medium]: { modelSize: ModelSize.Large, thinkingMode: ThinkingMode.Enabled },
        [TaskComplexity.Low]: { modelSize: ModelSize.Medium, thinkingMode: ThinkingMode.Disabled }
      },
      [AgentType.Performance]: {
        [TaskComplexity.High]: { modelSize: ModelSize.XLarge, thinkingMode: ThinkingMode.Enabled },
        [TaskComplexity.Medium]: { modelSize: ModelSize.Large, thinkingMode: ThinkingMode.Enabled },
        [TaskComplexity.Low]: { modelSize: ModelSize.Medium, thinkingMode: ThinkingMode.Disabled }
      }
    };
    
    this.outputChannel.appendLine('Agent Selector initialized');
  }

  /**
   * Select appropriate agents for each subtask
   * @param subtasks The subtasks to assign agents to
   * @param availableResources Available system resources
   * @returns Agent assignments for each subtask
   */
  public async selectAgents(
    subtasks: Record<string, Subtask>, 
    availableResources: ResourceUsage
  ): Promise<Record<string, { type: AgentType, modelSize: ModelSize, thinkingMode: ThinkingMode }>> {
    try {
      this.outputChannel.appendLine(`Selecting agents for ${Object.keys(subtasks).length} subtasks`);
      
      // Get user configuration
      const config = getConfiguration();
      const preferredModel = config.get<string>('preferredModel', 'auto');
      const preferThinking = config.get<boolean>('preferThinkingMode', true);
      
      // Initialize agent assignments
      const agentAssignments: Record<string, { type: AgentType, modelSize: ModelSize, thinkingMode: ThinkingMode }> = {};
      
      // Sort subtasks by dependencies (fewer dependencies first)
      const sortedSubtasks = Object.values(subtasks).sort((a, b) => 
        a.dependencies.length - b.dependencies.length
      );
      
      // Assign agents to each subtask
      for (const subtask of sortedSubtasks) {
        const expertise = subtask.expertise;
        const complexity = subtask.complexity;
        
        // Get the appropriate agent configuration
        let agentConfig = this.agentConfigs[expertise][complexity];
        
        // Apply user preferences
        if (preferredModel !== 'auto') {
          // Override model size based on user preference
          const userModelSize = this._getUserModelSize(preferredModel);
          if (userModelSize) {
            agentConfig = { ...agentConfig, modelSize: userModelSize };
          }
        }
        
        if (preferThinking) {
          // Prefer thinking mode if user has enabled it
          agentConfig = { ...agentConfig, thinkingMode: ThinkingMode.Enabled };
        }
        
        // Check if we have enough resources for this agent
        if (this._checkResources(agentConfig, availableResources)) {
          agentAssignments[subtask.id] = {
            type: expertise,
            modelSize: agentConfig.modelSize,
            thinkingMode: agentConfig.thinkingMode
          };
        } else {
          // Fallback to a smaller model if resources are constrained
          const fallbackAgent = this._getFallbackAgent(expertise, availableResources);
          agentAssignments[subtask.id] = fallbackAgent;
        }
        
        this.outputChannel.appendLine(`Assigned ${agentAssignments[subtask.id].type} agent with ${agentAssignments[subtask.id].modelSize} model to subtask ${subtask.id}`);
      }
      
      return agentAssignments;
    } catch (error) {
      this.outputChannel.appendLine(`Error selecting agents: ${error.message}`);
      throw error;
    }
  }

  /**
   * Check if we have enough resources for this agent
   * @param agentConfig The agent configuration
   * @param availableResources Available system resources
   * @returns Whether we have enough resources
   */
  private _checkResources(
    agentConfig: { modelSize: ModelSize, thinkingMode: ThinkingMode }, 
    availableResources: ResourceUsage
  ): boolean {
    // Calculate resource requirements based on model size and thinking mode
    let memoryRequirement = 0;
    let cpuRequirement = 0;
    
    // Memory requirements
    switch (agentConfig.modelSize) {
      case ModelSize.MoELarge:
        memoryRequirement = 0.8;
        break;
      case ModelSize.MoESmall:
        memoryRequirement = 0.5;
        break;
      case ModelSize.XXLarge:
        memoryRequirement = 0.4;
        break;
      case ModelSize.XLarge:
        memoryRequirement = 0.3;
        break;
      case ModelSize.Large:
        memoryRequirement = 0.2;
        break;
      case ModelSize.Medium:
        memoryRequirement = 0.1;
        break;
      case ModelSize.Small:
        memoryRequirement = 0.05;
        break;
      case ModelSize.Tiny:
        memoryRequirement = 0.02;
        break;
    }
    
    // CPU requirements
    switch (agentConfig.modelSize) {
      case ModelSize.MoELarge:
        cpuRequirement = 0.8;
        break;
      case ModelSize.MoESmall:
        cpuRequirement = 0.5;
        break;
      case ModelSize.XXLarge:
        cpuRequirement = 0.4;
        break;
      case ModelSize.XLarge:
        cpuRequirement = 0.3;
        break;
      case ModelSize.Large:
        cpuRequirement = 0.2;
        break;
      case ModelSize.Medium:
        cpuRequirement = 0.1;
        break;
      case ModelSize.Small:
        cpuRequirement = 0.05;
        break;
      case ModelSize.Tiny:
        cpuRequirement = 0.02;
        break;
    }
    
    // Adjust for thinking mode
    if (agentConfig.thinkingMode === ThinkingMode.Enabled) {
      memoryRequirement *= 1.5;
      cpuRequirement *= 1.5;
    }
    
    // Check if we have enough resources
    return (
      availableResources.memory >= memoryRequirement &&
      availableResources.cpu >= cpuRequirement
    );
  }

  /**
   * Get a fallback agent with lower resource requirements
   * @param expertise The required expertise
   * @param availableResources Available system resources
   * @returns A fallback agent configuration
   */
  private _getFallbackAgent(
    expertise: AgentType, 
    availableResources: ResourceUsage
  ): { type: AgentType, modelSize: ModelSize, thinkingMode: ThinkingMode } {
    this.outputChannel.appendLine(`Finding fallback agent for ${expertise} due to resource constraints`);
    
    // Try progressively smaller models
    const modelSizes = [
      ModelSize.Medium,
      ModelSize.Small,
      ModelSize.Tiny
    ];
    
    // Try without thinking mode first
    for (const modelSize of modelSizes) {
      const config = { modelSize, thinkingMode: ThinkingMode.Disabled };
      if (this._checkResources(config, availableResources)) {
        return { type: expertise, ...config };
      }
    }
    
    // If all else fails, use the smallest possible configuration
    return {
      type: expertise,
      modelSize: ModelSize.Tiny,
      thinkingMode: ThinkingMode.Disabled
    };
  }

  /**
   * Convert user model preference to ModelSize
   * @param preferredModel The user's preferred model
   * @returns The corresponding ModelSize or undefined
   */
  private _getUserModelSize(preferredModel: string): ModelSize | undefined {
    switch (preferredModel.toLowerCase()) {
      case 'tiny':
        return ModelSize.Tiny;
      case 'small':
        return ModelSize.Small;
      case 'medium':
        return ModelSize.Medium;
      case 'large':
        return ModelSize.Large;
      case 'xlarge':
        return ModelSize.XLarge;
      case 'xxlarge':
        return ModelSize.XXLarge;
      case 'moesmall':
      case 'moe-small':
        return ModelSize.MoESmall;
      case 'moelarge':
      case 'moe-large':
        return ModelSize.MoELarge;
      default:
        return undefined;
    }
  }

  /**
   * Dispose of resources
   */
  public dispose(): void {
    this.outputChannel.dispose();
  }
}

```


---

### File: `archive/vscode-extension/src/agents/resultAggregator.js`

```javascript
"use strict";
/**
 * Result Aggregator
 *
 * Combines outputs from multiple agents into a coherent response.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResultAggregator = void 0;
const vscode = __importStar(require("vscode"));
/**
 * Result Aggregator class
 */
class ResultAggregator {
    /**
     * Constructor
     * @param qwenApi The Qwen API client
     */
    constructor(qwenApi) {
        this.qwenApi = qwenApi;
        this.outputChannel = vscode.window.createOutputChannel('Result Aggregator');
    }
    /**
     * Aggregate results from multiple agents
     * @param results The results from each agent
     * @param subtasks The original subtasks
     * @returns The aggregated response
     */
    async aggregate(results, subtasks) {
        try {
            this.outputChannel.appendLine(`Aggregating results from ${Object.keys(results).length} agents`);
            // Check if we have any results
            if (Object.keys(results).length === 0) {
                return 'No results were generated. Please try again with a more specific request.';
            }
            // Check if we have only one result
            if (Object.keys(results).length === 1) {
                const result = Object.values(results)[0];
                return result.content;
            }
            // Prepare the system message
            const systemMessage = `
        You are a Result Aggregator. Your job is to combine outputs from multiple specialized agents into a coherent, unified response.
        Ensure that the final response is well-structured, consistent, and addresses all aspects of the original request.
        
        Follow these guidelines:
        1. Organize information logically, grouping related content together
        2. Eliminate redundancies while preserving important details
        3. Ensure a consistent tone and style throughout
        4. Highlight key insights and recommendations
        5. Format code snippets, commands, and technical information appropriately
        6. Provide a clear summary at the beginning if the response is lengthy
      `;
            // Prepare the context with all results
            let context = "Here are the results from different specialized agents:\n\n";
            // Sort subtasks by dependencies to maintain logical order
            const sortedSubtaskIds = this._sortSubtasksByDependencies(subtasks);
            // Add results in dependency order
            for (const subtaskId of sortedSubtaskIds) {
                if (results[subtaskId]) {
                    const subtask = subtasks[subtaskId];
                    const result = results[subtaskId];
                    context += `## Subtask: ${subtask.description}\n`;
                    context += `Expertise: ${subtask.expertise}\n`;
                    context += `Status: ${result.status}\n`;
                    if (result.status === 'error') {
                        context += `Error: ${result.error}\n\n`;
                    }
                    else {
                        context += `Result:\n${result.content}\n\n`;
                    }
                }
            }
            // Prepare the user message
            const userMessage = `Please combine these results into a coherent response:\n\n${context}`;
            // Prepare the messages for the API call
            const messages = [
                { role: 'system', content: systemMessage },
                { role: 'user', content: userMessage }
            ];
            // Call the Qwen API with thinking mode enabled
            const response = await this.qwenApi.chat(messages, {
                enableThinking: true,
                temperature: 0.3,
                maxTokens: 4096
            });
            this.outputChannel.appendLine('Results aggregated successfully');
            return response;
        }
        catch (error) {
            this.outputChannel.appendLine(`Error aggregating results: ${error.message}`);
            // Fallback: concatenate results
            let fallbackResponse = '# Combined Agent Results\n\n';
            for (const subtaskId in results) {
                const result = results[subtaskId];
                const subtask = subtasks[subtaskId];
                fallbackResponse += `## ${subtask.description}\n\n`;
                if (result.status === 'error') {
                    fallbackResponse += `**Error:** ${result.error}\n\n`;
                }
                else {
                    fallbackResponse += `${result.content}\n\n`;
                }
            }
            return fallbackResponse;
        }
    }
    /**
     * Sort subtasks by dependencies
     * @param subtasks The subtasks to sort
     * @returns Sorted subtask IDs
     */
    _sortSubtasksByDependencies(subtasks) {
        const visited = new Set();
        const result = [];
        const visit = (id) => {
            if (visited.has(id)) {
                return;
            }
            visited.add(id);
            // Visit dependencies first
            for (const depId of subtasks[id].dependencies) {
                if (subtasks[depId]) {
                    visit(depId);
                }
            }
            result.push(id);
        };
        // Visit all subtasks
        for (const id in subtasks) {
            visit(id);
        }
        return result;
    }
    /**
     * Dispose of resources
     */
    dispose() {
        this.outputChannel.dispose();
    }
}
exports.ResultAggregator = ResultAggregator;
//# sourceMappingURL=resultAggregator.js.map
```


---

### File: `archive/vscode-extension/src/agents/developmentAgent.js`

```javascript
"use strict";
/**
 * Development Agent
 *
 * Specialized agent for code generation, refactoring, and documentation.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.DevelopmentAgent = void 0;
const vscode = __importStar(require("vscode"));
const types_1 = require("./types");
const contextProvider_1 = require("../contextProvider");
/**
 * Development Agent class
 */
class DevelopmentAgent {
    /**
     * Constructor
     * @param id The agent ID
     * @param qwenApi The Qwen API client
     * @param modelSize The model size to use
     * @param thinkingMode The thinking mode to use
     */
    constructor(id, qwenApi, modelSize, thinkingMode) {
        this.id = id;
        this.qwenApi = qwenApi;
        this.modelSize = modelSize;
        this.thinkingMode = thinkingMode;
        this.outputChannel = vscode.window.createOutputChannel(`Development Agent ${id}`);
        this.outputChannel.appendLine(`Development Agent initialized with model ${modelSize} and thinking mode ${thinkingMode}`);
    }
    /**
     * Execute a subtask
     * @param subtask The subtask to execute
     * @returns The result of the execution
     */
    async execute(subtask) {
        try {
            this.outputChannel.appendLine(`Executing subtask: ${subtask.description}`);
            // Get context from the current file
            const context = await (0, contextProvider_1.getContextForCurrentFile)();
            // Prepare the system message
            const systemMessage = `
        You are a Development Agent specializing in writing high-quality code, refactoring, and documentation.
        Your task is to help with development-related activities in a DevOps workflow.
        
        You excel at:
        1. Writing clean, efficient, and well-documented code
        2. Refactoring existing code to improve quality and maintainability
        3. Implementing best practices and design patterns
        4. Creating comprehensive documentation
        5. Solving complex programming problems
        
        When writing code:
        - Follow language-specific conventions and best practices
        - Include appropriate error handling
        - Add clear comments explaining complex logic
        - Consider edge cases and potential issues
        - Optimize for readability and maintainability
        
        When providing explanations:
        - Be clear and concise
        - Use examples to illustrate concepts
        - Explain your reasoning and decision-making process
        - Highlight trade-offs and alternatives considered
      `;
            // Prepare the user message
            const userMessage = `
        I need help with the following development task: ${subtask.description}
        
        ${context ? `Here is the current context:\n\n${context}` : ''}
      `;
            // Prepare the messages for the API call
            const messages = [
                { role: 'system', content: systemMessage },
                { role: 'user', content: userMessage }
            ];
            // Call the Qwen API with the appropriate thinking mode
            const enableThinking = this.thinkingMode === types_1.ThinkingMode.Enabled;
            const response = await this.qwenApi.chat(messages, {
                enableThinking,
                temperature: 0.3,
                maxTokens: 4096,
                modelName: this.modelSize
            });
            this.outputChannel.appendLine('Subtask executed successfully');
            return {
                subtaskId: subtask.id,
                thinking: enableThinking ? this._extractThinking(response) : undefined,
                content: this._extractContent(response, enableThinking),
                status: 'success'
            };
        }
        catch (error) {
            this.outputChannel.appendLine(`Error executing subtask: ${error.message}`);
            return {
                subtaskId: subtask.id,
                content: '',
                status: 'error',
                error: error.message
            };
        }
    }
    /**
     * Extract thinking from response
     * @param response The API response
     * @returns The extracted thinking
     */
    _extractThinking(response) {
        const thinkingMatch = response.match(/<think>([\s\S]*?)<\/think>/);
        return thinkingMatch ? thinkingMatch[1].trim() : '';
    }
    /**
     * Extract content from response
     * @param response The API response
     * @param enableThinking Whether thinking mode was enabled
     * @returns The extracted content
     */
    _extractContent(response, enableThinking) {
        if (enableThinking) {
            // Remove thinking tags and content
            return response.replace(/<think>[\s\S]*?<\/think>/, '').trim();
        }
        return response.trim();
    }
    /**
     * Dispose of resources
     */
    dispose() {
        this.outputChannel.dispose();
    }
}
exports.DevelopmentAgent = DevelopmentAgent;
//# sourceMappingURL=developmentAgent.js.map
```


---

### File: `archive/vscode-extension/src/agents/taskDecomposer.js`

```javascript
"use strict";
/**
 * Task Decomposer
 *
 * Breaks down complex user requests into smaller, manageable subtasks.
 * Uses Qwen's thinking mode to perform detailed analysis.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.TaskDecomposer = void 0;
const vscode = __importStar(require("vscode"));
const uuid_1 = require("uuid");
const types_1 = require("./types");
/**
 * Task Decomposer class
 */
class TaskDecomposer {
    /**
     * Constructor
     * @param qwenApi The Qwen API client
     */
    constructor(qwenApi) {
        this.qwenApi = qwenApi;
        this.outputChannel = vscode.window.createOutputChannel('Task Decomposer');
    }
    /**
     * Decompose a user request into subtasks
     * @param userRequest The user's request
     * @param availableResources Available system resources
     * @returns A record of subtasks
     */
    async decompose(userRequest, availableResources) {
        try {
            this.outputChannel.appendLine(`Decomposing request: ${userRequest}`);
            // Prepare the system message for task decomposition
            const systemMessage = `
        You are a task decomposition expert. Your job is to break down complex DevOps tasks into smaller, manageable subtasks.
        For each subtask, provide:
        1. A unique ID
        2. A clear description
        3. Required expertise (development, testing, ci_cd, github, documentation, architecture, security, performance)
        4. Estimated complexity (low, medium, high)
        5. Dependencies on other subtasks (if any)
        
        Format your response as a JSON object with the following structure:
        {
          "subtasks": [
            {
              "id": "unique_id",
              "description": "Clear description of the subtask",
              "expertise": "One of: development, testing, ci_cd, github, documentation, architecture, security, performance",
              "complexity": "One of: low, medium, high",
              "dependencies": ["id_of_dependency_1", "id_of_dependency_2"]
            },
            ...
          ]
        }
        
        Consider the available system resources when decomposing the task:
        - Memory: ${availableResources.memory * 100}%
        - CPU: ${availableResources.cpu * 100}%
        - Active Agents: ${availableResources.activeAgents}
        
        If resources are limited, prioritize essential subtasks and reduce complexity.
      `;
            // Prepare the messages for the API call
            const messages = [
                { role: 'system', content: systemMessage },
                { role: 'user', content: `Please decompose the following DevOps task into subtasks: ${userRequest}` }
            ];
            // Call the Qwen API with thinking mode enabled
            const response = await this.qwenApi.chat(messages, {
                enableThinking: true,
                temperature: 0.2,
                maxTokens: 2048
            });
            // Parse the response to extract subtasks
            const subtasks = this._parseSubtasks(response);
            // Validate subtasks and ensure they're within resource constraints
            const validatedSubtasks = this._validateSubtasks(subtasks, availableResources);
            this.outputChannel.appendLine(`Decomposed into ${Object.keys(validatedSubtasks).length} subtasks`);
            return validatedSubtasks;
        }
        catch (error) {
            this.outputChannel.appendLine(`Error decomposing task: ${error.message}`);
            throw error;
        }
    }
    /**
     * Parse the LLM response to extract subtasks
     * @param response The LLM response
     * @returns A record of subtasks
     */
    _parseSubtasks(response) {
        try {
            // Extract JSON from the response
            const jsonMatch = response.match(/```json\n([\s\S]*?)\n```/) ||
                response.match(/{[\s\S]*?}/);
            if (!jsonMatch) {
                throw new Error('No valid JSON found in the response');
            }
            const jsonStr = jsonMatch[0].startsWith('```') ? jsonMatch[1] : jsonMatch[0];
            const parsed = JSON.parse(jsonStr);
            if (!parsed.subtasks || !Array.isArray(parsed.subtasks)) {
                throw new Error('Invalid subtasks format in the response');
            }
            // Convert array to record
            const subtasks = {};
            for (const subtask of parsed.subtasks) {
                // Ensure the subtask has a valid ID
                const id = subtask.id || (0, uuid_1.v4)();
                // Ensure the subtask has valid dependencies
                const dependencies = Array.isArray(subtask.dependencies) ? subtask.dependencies : [];
                // Create the subtask object
                subtasks[id] = {
                    id,
                    description: subtask.description || '',
                    expertise: this._validateExpertise(subtask.expertise),
                    complexity: this._validateComplexity(subtask.complexity),
                    dependencies
                };
            }
            return subtasks;
        }
        catch (error) {
            this.outputChannel.appendLine(`Error parsing subtasks: ${error.message}`);
            // Fallback: create a single subtask
            const id = (0, uuid_1.v4)();
            return {
                [id]: {
                    id,
                    description: 'Execute the requested task',
                    expertise: types_1.AgentType.Development,
                    complexity: types_1.TaskComplexity.Medium,
                    dependencies: []
                }
            };
        }
    }
    /**
     * Validate the expertise field
     * @param expertise The expertise string
     * @returns A valid AgentType
     */
    _validateExpertise(expertise) {
        if (!expertise || typeof expertise !== 'string') {
            return types_1.AgentType.Development;
        }
        const normalized = expertise.toLowerCase();
        switch (normalized) {
            case 'development':
                return types_1.AgentType.Development;
            case 'testing':
                return types_1.AgentType.Testing;
            case 'ci_cd':
            case 'cicd':
                return types_1.AgentType.CICD;
            case 'github':
                return types_1.AgentType.GitHub;
            case 'documentation':
                return types_1.AgentType.Documentation;
            case 'architecture':
                return types_1.AgentType.Architecture;
            case 'security':
                return types_1.AgentType.Security;
            case 'performance':
                return types_1.AgentType.Performance;
            default:
                return types_1.AgentType.Development;
        }
    }
    /**
     * Validate the complexity field
     * @param complexity The complexity string
     * @returns A valid TaskComplexity
     */
    _validateComplexity(complexity) {
        if (!complexity || typeof complexity !== 'string') {
            return types_1.TaskComplexity.Medium;
        }
        const normalized = complexity.toLowerCase();
        switch (normalized) {
            case 'low':
                return types_1.TaskComplexity.Low;
            case 'medium':
                return types_1.TaskComplexity.Medium;
            case 'high':
                return types_1.TaskComplexity.High;
            default:
                return types_1.TaskComplexity.Medium;
        }
    }
    /**
     * Validate subtasks and ensure they're within resource constraints
     * @param subtasks The subtasks to validate
     * @param availableResources Available system resources
     * @returns Validated subtasks
     */
    _validateSubtasks(subtasks, availableResources) {
        // Check if we have enough resources for all subtasks
        const totalSubtasks = Object.keys(subtasks).length;
        if (totalSubtasks > 10 && availableResources.memory < 0.5) {
            // If resources are limited, reduce the number of subtasks
            this.outputChannel.appendLine('Limited resources detected, reducing number of subtasks');
            // Sort subtasks by dependencies (fewer dependencies first)
            const sortedSubtasks = Object.values(subtasks).sort((a, b) => a.dependencies.length - b.dependencies.length);
            // Keep only the first 5-10 subtasks
            const maxSubtasks = Math.max(5, Math.min(10, Math.floor(availableResources.memory * 20)));
            const reducedSubtasks = {};
            for (let i = 0; i < Math.min(maxSubtasks, sortedSubtasks.length); i++) {
                const subtask = sortedSubtasks[i];
                reducedSubtasks[subtask.id] = subtask;
            }
            return reducedSubtasks;
        }
        // Check for circular dependencies
        const visited = new Set();
        const visiting = new Set();
        const hasCycle = (id) => {
            if (visiting.has(id)) {
                return true;
            }
            if (visited.has(id)) {
                return false;
            }
            visiting.add(id);
            for (const depId of subtasks[id].dependencies) {
                if (!subtasks[depId]) {
                    // Remove invalid dependency
                    subtasks[id].dependencies = subtasks[id].dependencies.filter(d => d !== depId);
                    continue;
                }
                if (hasCycle(depId)) {
                    return true;
                }
            }
            visiting.delete(id);
            visited.add(id);
            return false;
        };
        // Check each subtask for cycles
        for (const id in subtasks) {
            if (hasCycle(id)) {
                // Remove circular dependencies
                this.outputChannel.appendLine(`Circular dependency detected in subtask ${id}, removing dependencies`);
                subtasks[id].dependencies = [];
            }
        }
        return subtasks;
    }
    /**
     * Dispose of resources
     */
    dispose() {
        this.outputChannel.dispose();
    }
}
exports.TaskDecomposer = TaskDecomposer;
//# sourceMappingURL=taskDecomposer.js.map
```


---

### File: `archive/vscode-extension/src/agents/agentCoordinator.js`

```javascript
"use strict";
/**
 * Agent Coordinator
 *
 * The central component that orchestrates the hierarchical agent system.
 * Responsible for task decomposition, agent selection, and result aggregation.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.AgentCoordinator = void 0;
const vscode = __importStar(require("vscode"));
const types_1 = require("./types");
const taskDecomposer_1 = require("./taskDecomposer");
const agentSelector_1 = require("./agentSelector");
const resourceManager_1 = require("./resourceManager");
const resultAggregator_1 = require("./resultAggregator");
const qwenApi_1 = require("../qwenApi");
/**
 * Agent Coordinator class
 */
class AgentCoordinator {
    /**
     * Constructor
     */
    constructor() {
        this.outputChannel = vscode.window.createOutputChannel('Agent Coordinator');
        this.qwenApi = new qwenApi_1.QwenApiClient();
        this.taskDecomposer = new taskDecomposer_1.TaskDecomposer(this.qwenApi);
        this.agentSelector = new agentSelector_1.AgentSelector();
        this.resourceManager = new resourceManager_1.ResourceManager();
        this.resultAggregator = new resultAggregator_1.ResultAggregator(this.qwenApi);
        this.outputChannel.appendLine('Agent Coordinator initialized');
    }
    /**
     * Process a user request
     * @param userRequest The user's request
     * @returns The final response
     */
    async processRequest(userRequest) {
        try {
            this.outputChannel.appendLine(`Processing request: ${userRequest}`);
            // Get available resources
            const availableResources = await this.resourceManager.getAvailableResources();
            this.outputChannel.appendLine(`Available resources: ${JSON.stringify(availableResources)}`);
            // Decompose the task
            const subtasks = await this.taskDecomposer.decompose(userRequest, availableResources);
            this.outputChannel.appendLine(`Task decomposed into ${Object.keys(subtasks).length} subtasks`);
            // Select appropriate agents for each subtask
            const agentAssignments = await this.agentSelector.selectAgents(subtasks, availableResources);
            this.outputChannel.appendLine(`Agent assignments: ${JSON.stringify(agentAssignments)}`);
            // Execute subtasks with assigned agents
            const results = {};
            for (const subtaskId in agentAssignments) {
                const agentInfo = agentAssignments[subtaskId];
                const subtask = subtasks[subtaskId];
                this.outputChannel.appendLine(`Executing subtask ${subtaskId} with agent ${agentInfo.type}`);
                // Check if all dependencies are completed
                const dependenciesMet = subtask.dependencies.every(depId => results[depId] && results[depId].status === 'success');
                if (!dependenciesMet) {
                    this.outputChannel.appendLine(`Skipping subtask ${subtaskId} due to unmet dependencies`);
                    continue;
                }
                // Execute the subtask
                try {
                    const agent = await this.instantiateAgent(agentInfo);
                    results[subtaskId] = await agent.execute(subtask);
                    this.outputChannel.appendLine(`Subtask ${subtaskId} completed successfully`);
                }
                catch (error) {
                    this.outputChannel.appendLine(`Error executing subtask ${subtaskId}: ${error.message}`);
                    results[subtaskId] = {
                        subtaskId,
                        content: '',
                        status: 'error',
                        error: error.message
                    };
                }
            }
            // Aggregate results
            const finalResponse = await this.resultAggregator.aggregate(results, subtasks);
            this.outputChannel.appendLine('Request processing completed');
            return finalResponse;
        }
        catch (error) {
            this.outputChannel.appendLine(`Error processing request: ${error.message}`);
            throw error;
        }
    }
    /**
     * Instantiate an agent based on agent info
     * @param agentInfo The agent information
     * @returns The instantiated agent
     */
    async instantiateAgent(agentInfo) {
        // This is a placeholder for agent instantiation
        // In a real implementation, we would dynamically import and instantiate the appropriate agent
        const agentType = agentInfo.type;
        const modelSize = agentInfo.modelSize;
        const thinkingMode = agentInfo.thinkingMode;
        this.outputChannel.appendLine(`Instantiating agent: ${agentType} with model ${modelSize} and thinking mode ${thinkingMode}`);
        // Register the agent with the resource manager
        const agentId = await this.resourceManager.registerAgent(agentType, {
            modelSize,
            thinkingMode
        });
        // Import the appropriate agent class
        try {
            switch (agentType) {
                case types_1.AgentType.Development:
                    const { DevelopmentAgent } = await Promise.resolve().then(() => __importStar(require('./developmentAgent')));
                    return new DevelopmentAgent(agentId, this.qwenApi, modelSize, thinkingMode);
                case types_1.AgentType.Testing:
                    const { TestingAgent } = await Promise.resolve().then(() => __importStar(require('./testingAgent')));
                    return new TestingAgent(agentId, this.qwenApi, modelSize, thinkingMode);
                case types_1.AgentType.CICD:
                    const { CICDAgent } = await Promise.resolve().then(() => __importStar(require('./cicdAgent')));
                    return new CICDAgent(agentId, this.qwenApi, modelSize, thinkingMode);
                case types_1.AgentType.GitHub:
                    const { GitHubAgent } = await Promise.resolve().then(() => __importStar(require('./githubAgent')));
                    return new GitHubAgent(agentId, this.qwenApi, modelSize, thinkingMode);
                default:
                    throw new Error(`Unsupported agent type: ${agentType}`);
            }
        }
        catch (error) {
            this.outputChannel.appendLine(`Error instantiating agent: ${error.message}`);
            await this.resourceManager.unregisterAgent(agentId);
            throw error;
        }
    }
    /**
     * Dispose of resources
     */
    dispose() {
        this.outputChannel.dispose();
    }
}
exports.AgentCoordinator = AgentCoordinator;
//# sourceMappingURL=agentCoordinator.js.map
```


---

### File: `archive/vscode-extension/src/agents/agentSelector.js`

```javascript
"use strict";
/**
 * Agent Selector
 *
 * Chooses the most appropriate agent for each subtask based on expertise, complexity, and available resources.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.AgentSelector = void 0;
const vscode = __importStar(require("vscode"));
const types_1 = require("./types");
const configuration_1 = require("../configuration");
/**
 * Agent Selector class
 */
class AgentSelector {
    /**
     * Constructor
     */
    constructor() {
        this.outputChannel = vscode.window.createOutputChannel('Agent Selector');
        // Initialize agent configurations
        this.agentConfigs = {
            [types_1.AgentType.Coordinator]: {
                [types_1.TaskComplexity.High]: { modelSize: types_1.ModelSize.MoESmall, thinkingMode: types_1.ThinkingMode.Enabled },
                [types_1.TaskComplexity.Medium]: { modelSize: types_1.ModelSize.MoESmall, thinkingMode: types_1.ThinkingMode.Enabled },
                [types_1.TaskComplexity.Low]: { modelSize: types_1.ModelSize.XXLarge, thinkingMode: types_1.ThinkingMode.Enabled }
            },
            [types_1.AgentType.Development]: {
                [types_1.TaskComplexity.High]: { modelSize: types_1.ModelSize.MoESmall, thinkingMode: types_1.ThinkingMode.Enabled },
                [types_1.TaskComplexity.Medium]: { modelSize: types_1.ModelSize.XXLarge, thinkingMode: types_1.ThinkingMode.Enabled },
                [types_1.TaskComplexity.Low]: { modelSize: types_1.ModelSize.XLarge, thinkingMode: types_1.ThinkingMode.Disabled }
            },
            [types_1.AgentType.Testing]: {
                [types_1.TaskComplexity.High]: { modelSize: types_1.ModelSize.XLarge, thinkingMode: types_1.ThinkingMode.Enabled },
                [types_1.TaskComplexity.Medium]: { modelSize: types_1.ModelSize.Large, thinkingMode: types_1.ThinkingMode.Enabled },
                [types_1.TaskComplexity.Low]: { modelSize: types_1.ModelSize.Medium, thinkingMode: types_1.ThinkingMode.Disabled }
            },
            [types_1.AgentType.CICD]: {
                [types_1.TaskComplexity.High]: { modelSize: types_1.ModelSize.Large, thinkingMode: types_1.ThinkingMode.Enabled },
                [types_1.TaskComplexity.Medium]: { modelSize: types_1.ModelSize.Medium, thinkingMode: types_1.ThinkingMode.Disabled },
                [types_1.TaskComplexity.Low]: { modelSize: types_1.ModelSize.Small, thinkingMode: types_1.ThinkingMode.Disabled }
            },
            [types_1.AgentType.GitHub]: {
                [types_1.TaskComplexity.High]: { modelSize: types_1.ModelSize.Large, thinkingMode: types_1.ThinkingMode.Enabled },
                [types_1.TaskComplexity.Medium]: { modelSize: types_1.ModelSize.Medium, thinkingMode: types_1.ThinkingMode.Disabled },
                [types_1.TaskComplexity.Low]: { modelSize: types_1.ModelSize.Small, thinkingMode: types_1.ThinkingMode.Disabled }
            },
            [types_1.AgentType.Documentation]: {
                [types_1.TaskComplexity.High]: { modelSize: types_1.ModelSize.Large, thinkingMode: types_1.ThinkingMode.Enabled },
                [types_1.TaskComplexity.Medium]: { modelSize: types_1.ModelSize.Medium, thinkingMode: types_1.ThinkingMode.Enabled },
                [types_1.TaskComplexity.Low]: { modelSize: types_1.ModelSize.Small, thinkingMode: types_1.ThinkingMode.Disabled }
            },
            [types_1.AgentType.Architecture]: {
                [types_1.TaskComplexity.High]: { modelSize: types_1.ModelSize.MoESmall, thinkingMode: types_1.ThinkingMode.Enabled },
                [types_1.TaskComplexity.Medium]: { modelSize: types_1.ModelSize.XXLarge, thinkingMode: types_1.ThinkingMode.Enabled },
                [types_1.TaskComplexity.Low]: { modelSize: types_1.ModelSize.XLarge, thinkingMode: types_1.ThinkingMode.Enabled }
            },
            [types_1.AgentType.Security]: {
                [types_1.TaskComplexity.High]: { modelSize: types_1.ModelSize.XLarge, thinkingMode: types_1.ThinkingMode.Enabled },
                [types_1.TaskComplexity.Medium]: { modelSize: types_1.ModelSize.Large, thinkingMode: types_1.ThinkingMode.Enabled },
                [types_1.TaskComplexity.Low]: { modelSize: types_1.ModelSize.Medium, thinkingMode: types_1.ThinkingMode.Disabled }
            },
            [types_1.AgentType.Performance]: {
                [types_1.TaskComplexity.High]: { modelSize: types_1.ModelSize.XLarge, thinkingMode: types_1.ThinkingMode.Enabled },
                [types_1.TaskComplexity.Medium]: { modelSize: types_1.ModelSize.Large, thinkingMode: types_1.ThinkingMode.Enabled },
                [types_1.TaskComplexity.Low]: { modelSize: types_1.ModelSize.Medium, thinkingMode: types_1.ThinkingMode.Disabled }
            }
        };
        this.outputChannel.appendLine('Agent Selector initialized');
    }
    /**
     * Select appropriate agents for each subtask
     * @param subtasks The subtasks to assign agents to
     * @param availableResources Available system resources
     * @returns Agent assignments for each subtask
     */
    async selectAgents(subtasks, availableResources) {
        try {
            this.outputChannel.appendLine(`Selecting agents for ${Object.keys(subtasks).length} subtasks`);
            // Get user configuration
            const config = (0, configuration_1.getConfiguration)();
            const preferredModel = config.get('preferredModel', 'auto');
            const preferThinking = config.get('preferThinkingMode', true);
            // Initialize agent assignments
            const agentAssignments = {};
            // Sort subtasks by dependencies (fewer dependencies first)
            const sortedSubtasks = Object.values(subtasks).sort((a, b) => a.dependencies.length - b.dependencies.length);
            // Assign agents to each subtask
            for (const subtask of sortedSubtasks) {
                const expertise = subtask.expertise;
                const complexity = subtask.complexity;
                // Get the appropriate agent configuration
                let agentConfig = this.agentConfigs[expertise][complexity];
                // Apply user preferences
                if (preferredModel !== 'auto') {
                    // Override model size based on user preference
                    const userModelSize = this._getUserModelSize(preferredModel);
                    if (userModelSize) {
                        agentConfig = { ...agentConfig, modelSize: userModelSize };
                    }
                }
                if (preferThinking) {
                    // Prefer thinking mode if user has enabled it
                    agentConfig = { ...agentConfig, thinkingMode: types_1.ThinkingMode.Enabled };
                }
                // Check if we have enough resources for this agent
                if (this._checkResources(agentConfig, availableResources)) {
                    agentAssignments[subtask.id] = {
                        type: expertise,
                        modelSize: agentConfig.modelSize,
                        thinkingMode: agentConfig.thinkingMode
                    };
                }
                else {
                    // Fallback to a smaller model if resources are constrained
                    const fallbackAgent = this._getFallbackAgent(expertise, availableResources);
                    agentAssignments[subtask.id] = fallbackAgent;
                }
                this.outputChannel.appendLine(`Assigned ${agentAssignments[subtask.id].type} agent with ${agentAssignments[subtask.id].modelSize} model to subtask ${subtask.id}`);
            }
            return agentAssignments;
        }
        catch (error) {
            this.outputChannel.appendLine(`Error selecting agents: ${error.message}`);
            throw error;
        }
    }
    /**
     * Check if we have enough resources for this agent
     * @param agentConfig The agent configuration
     * @param availableResources Available system resources
     * @returns Whether we have enough resources
     */
    _checkResources(agentConfig, availableResources) {
        // Calculate resource requirements based on model size and thinking mode
        let memoryRequirement = 0;
        let cpuRequirement = 0;
        // Memory requirements
        switch (agentConfig.modelSize) {
            case types_1.ModelSize.MoELarge:
                memoryRequirement = 0.8;
                break;
            case types_1.ModelSize.MoESmall:
                memoryRequirement = 0.5;
                break;
            case types_1.ModelSize.XXLarge:
                memoryRequirement = 0.4;
                break;
            case types_1.ModelSize.XLarge:
                memoryRequirement = 0.3;
                break;
            case types_1.ModelSize.Large:
                memoryRequirement = 0.2;
                break;
            case types_1.ModelSize.Medium:
                memoryRequirement = 0.1;
                break;
            case types_1.ModelSize.Small:
                memoryRequirement = 0.05;
                break;
            case types_1.ModelSize.Tiny:
                memoryRequirement = 0.02;
                break;
        }
        // CPU requirements
        switch (agentConfig.modelSize) {
            case types_1.ModelSize.MoELarge:
                cpuRequirement = 0.8;
                break;
            case types_1.ModelSize.MoESmall:
                cpuRequirement = 0.5;
                break;
            case types_1.ModelSize.XXLarge:
                cpuRequirement = 0.4;
                break;
            case types_1.ModelSize.XLarge:
                cpuRequirement = 0.3;
                break;
            case types_1.ModelSize.Large:
                cpuRequirement = 0.2;
                break;
            case types_1.ModelSize.Medium:
                cpuRequirement = 0.1;
                break;
            case types_1.ModelSize.Small:
                cpuRequirement = 0.05;
                break;
            case types_1.ModelSize.Tiny:
                cpuRequirement = 0.02;
                break;
        }
        // Adjust for thinking mode
        if (agentConfig.thinkingMode === types_1.ThinkingMode.Enabled) {
            memoryRequirement *= 1.5;
            cpuRequirement *= 1.5;
        }
        // Check if we have enough resources
        return (availableResources.memory >= memoryRequirement &&
            availableResources.cpu >= cpuRequirement);
    }
    /**
     * Get a fallback agent with lower resource requirements
     * @param expertise The required expertise
     * @param availableResources Available system resources
     * @returns A fallback agent configuration
     */
    _getFallbackAgent(expertise, availableResources) {
        this.outputChannel.appendLine(`Finding fallback agent for ${expertise} due to resource constraints`);
        // Try progressively smaller models
        const modelSizes = [
            types_1.ModelSize.Medium,
            types_1.ModelSize.Small,
            types_1.ModelSize.Tiny
        ];
        // Try without thinking mode first
        for (const modelSize of modelSizes) {
            const config = { modelSize, thinkingMode: types_1.ThinkingMode.Disabled };
            if (this._checkResources(config, availableResources)) {
                return { type: expertise, ...config };
            }
        }
        // If all else fails, use the smallest possible configuration
        return {
            type: expertise,
            modelSize: types_1.ModelSize.Tiny,
            thinkingMode: types_1.ThinkingMode.Disabled
        };
    }
    /**
     * Convert user model preference to ModelSize
     * @param preferredModel The user's preferred model
     * @returns The corresponding ModelSize or undefined
     */
    _getUserModelSize(preferredModel) {
        switch (preferredModel.toLowerCase()) {
            case 'tiny':
                return types_1.ModelSize.Tiny;
            case 'small':
                return types_1.ModelSize.Small;
            case 'medium':
                return types_1.ModelSize.Medium;
            case 'large':
                return types_1.ModelSize.Large;
            case 'xlarge':
                return types_1.ModelSize.XLarge;
            case 'xxlarge':
                return types_1.ModelSize.XXLarge;
            case 'moesmall':
            case 'moe-small':
                return types_1.ModelSize.MoESmall;
            case 'moelarge':
            case 'moe-large':
                return types_1.ModelSize.MoELarge;
            default:
                return undefined;
        }
    }
    /**
     * Dispose of resources
     */
    dispose() {
        this.outputChannel.dispose();
    }
}
exports.AgentSelector = AgentSelector;
//# sourceMappingURL=agentSelector.js.map
```


---

### File: `archive/vscode-extension/src/agents/agentCoordinator.ts`

```typescript
/**
 * Agent Coordinator
 * 
 * The central component that orchestrates the hierarchical agent system.
 * Responsible for task decomposition, agent selection, and result aggregation.
 */

import * as vscode from 'vscode';
import { 
  AgentType, 
  ModelSize, 
  ThinkingMode, 
  TaskComplexity, 
  Subtask, 
  AgentResult, 
  ResourceUsage 
} from './types';
import { TaskDecomposer } from './taskDecomposer';
import { AgentSelector } from './agentSelector';
import { ResourceManager } from './resourceManager';
import { ResultAggregator } from './resultAggregator';
import { QwenApiClient } from '../qwenApi';
import { getConfiguration } from '../configuration';

/**
 * Agent Coordinator class
 */
export class AgentCoordinator {
  private taskDecomposer: TaskDecomposer;
  private agentSelector: AgentSelector;
  private resourceManager: ResourceManager;
  private resultAggregator: ResultAggregator;
  private qwenApi: QwenApiClient;
  private outputChannel: vscode.OutputChannel;

  /**
   * Constructor
   */
  constructor() {
    this.outputChannel = vscode.window.createOutputChannel('Agent Coordinator');
    this.qwenApi = new QwenApiClient();
    this.taskDecomposer = new TaskDecomposer(this.qwenApi);
    this.agentSelector = new AgentSelector();
    this.resourceManager = new ResourceManager();
    this.resultAggregator = new ResultAggregator(this.qwenApi);
    
    this.outputChannel.appendLine('Agent Coordinator initialized');
  }

  /**
   * Process a user request
   * @param userRequest The user's request
   * @returns The final response
   */
  public async processRequest(userRequest: string): Promise<string> {
    try {
      this.outputChannel.appendLine(`Processing request: ${userRequest}`);
      
      // Get available resources
      const availableResources = await this.resourceManager.getAvailableResources();
      this.outputChannel.appendLine(`Available resources: ${JSON.stringify(availableResources)}`);
      
      // Decompose the task
      const subtasks = await this.taskDecomposer.decompose(userRequest, availableResources);
      this.outputChannel.appendLine(`Task decomposed into ${Object.keys(subtasks).length} subtasks`);
      
      // Select appropriate agents for each subtask
      const agentAssignments = await this.agentSelector.selectAgents(subtasks, availableResources);
      this.outputChannel.appendLine(`Agent assignments: ${JSON.stringify(agentAssignments)}`);
      
      // Execute subtasks with assigned agents
      const results: Record<string, AgentResult> = {};
      for (const subtaskId in agentAssignments) {
        const agentInfo = agentAssignments[subtaskId];
        const subtask = subtasks[subtaskId];
        
        this.outputChannel.appendLine(`Executing subtask ${subtaskId} with agent ${agentInfo.type}`);
        
        // Check if all dependencies are completed
        const dependenciesMet = subtask.dependencies.every(depId => results[depId] && results[depId].status === 'success');
        if (!dependenciesMet) {
          this.outputChannel.appendLine(`Skipping subtask ${subtaskId} due to unmet dependencies`);
          continue;
        }
        
        // Execute the subtask
        try {
          const agent = await this.instantiateAgent(agentInfo);
          results[subtaskId] = await agent.execute(subtask);
          this.outputChannel.appendLine(`Subtask ${subtaskId} completed successfully`);
        } catch (error) {
          this.outputChannel.appendLine(`Error executing subtask ${subtaskId}: ${error.message}`);
          results[subtaskId] = {
            subtaskId,
            content: '',
            status: 'error',
            error: error.message
          };
        }
      }
      
      // Aggregate results
      const finalResponse = await this.resultAggregator.aggregate(results, subtasks);
      this.outputChannel.appendLine('Request processing completed');
      
      return finalResponse;
    } catch (error) {
      this.outputChannel.appendLine(`Error processing request: ${error.message}`);
      throw error;
    }
  }

  /**
   * Instantiate an agent based on agent info
   * @param agentInfo The agent information
   * @returns The instantiated agent
   */
  private async instantiateAgent(agentInfo: any): Promise<any> {
    // This is a placeholder for agent instantiation
    // In a real implementation, we would dynamically import and instantiate the appropriate agent
    
    const agentType = agentInfo.type;
    const modelSize = agentInfo.modelSize;
    const thinkingMode = agentInfo.thinkingMode;
    
    this.outputChannel.appendLine(`Instantiating agent: ${agentType} with model ${modelSize} and thinking mode ${thinkingMode}`);
    
    // Register the agent with the resource manager
    const agentId = await this.resourceManager.registerAgent(agentType, {
      modelSize,
      thinkingMode
    });
    
    // Import the appropriate agent class
    try {
      switch (agentType) {
        case AgentType.Development:
          const { DevelopmentAgent } = await import('./developmentAgent');
          return new DevelopmentAgent(agentId, this.qwenApi, modelSize, thinkingMode);
        
        case AgentType.Testing:
          const { TestingAgent } = await import('./testingAgent');
          return new TestingAgent(agentId, this.qwenApi, modelSize, thinkingMode);
        
        case AgentType.CICD:
          const { CICDAgent } = await import('./cicdAgent');
          return new CICDAgent(agentId, this.qwenApi, modelSize, thinkingMode);
        
        case AgentType.GitHub:
          const { GitHubAgent } = await import('./githubAgent');
          return new GitHubAgent(agentId, this.qwenApi, modelSize, thinkingMode);
        
        default:
          throw new Error(`Unsupported agent type: ${agentType}`);
      }
    } catch (error) {
      this.outputChannel.appendLine(`Error instantiating agent: ${error.message}`);
      await this.resourceManager.unregisterAgent(agentId);
      throw error;
    }
  }

  /**
   * Dispose of resources
   */
  public dispose(): void {
    this.outputChannel.dispose();
  }
}

```


---

### File: `archive/vscode-extension/src/agents/resourceManager.js`

```javascript
"use strict";
/**
 * Resource Manager
 *
 * Monitors system resources and controls agent instantiation.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResourceManager = void 0;
const vscode = __importStar(require("vscode"));
const os = __importStar(require("os"));
const uuid_1 = require("uuid");
/**
 * Resource Manager class
 */
class ResourceManager {
    /**
     * Constructor
     * @param maxMemoryUsage Maximum memory usage (0-1)
     * @param maxCpuUsage Maximum CPU usage (0-1)
     */
    constructor(maxMemoryUsage = 0.8, maxCpuUsage = 0.8) {
        this.outputChannel = vscode.window.createOutputChannel('Resource Manager');
        this.activeAgents = {};
        this.maxMemoryUsage = maxMemoryUsage;
        this.maxCpuUsage = maxCpuUsage;
        this.resourceCheckInterval = null;
        // Start resource monitoring
        this._startResourceMonitoring();
        this.outputChannel.appendLine('Resource Manager initialized');
    }
    /**
     * Get available system resources
     * @returns Available resources
     */
    async getAvailableResources() {
        try {
            // Get current system resource usage
            const currentMemoryUsage = this._getMemoryUsage();
            const currentCpuUsage = await this._getCpuUsage();
            // Calculate available resources
            const availableMemory = Math.max(0, this.maxMemoryUsage - currentMemoryUsage);
            const availableCpu = Math.max(0, this.maxCpuUsage - currentCpuUsage);
            const resources = {
                memory: availableMemory,
                cpu: availableCpu,
                activeAgents: Object.keys(this.activeAgents).length
            };
            this.outputChannel.appendLine(`Available resources: memory=${availableMemory.toFixed(2)}, cpu=${availableCpu.toFixed(2)}, activeAgents=${resources.activeAgents}`);
            return resources;
        }
        catch (error) {
            this.outputChannel.appendLine(`Error getting available resources: ${error.message}`);
            // Return conservative estimates in case of error
            return {
                memory: 0.2,
                cpu: 0.2,
                activeAgents: Object.keys(this.activeAgents).length
            };
        }
    }
    /**
     * Register a new agent with its resource requirements
     * @param type Agent type
     * @param requirements Resource requirements
     * @returns Agent ID
     */
    async registerAgent(type, requirements) {
        const agentId = (0, uuid_1.v4)();
        this.activeAgents[agentId] = {
            type,
            modelSize: requirements.modelSize,
            thinkingMode: requirements.thinkingMode,
            startTime: Date.now()
        };
        this.outputChannel.appendLine(`Registered agent ${agentId} of type ${type} with model ${requirements.modelSize}`);
        return agentId;
    }
    /**
     * Unregister an agent when it's no longer needed
     * @param agentId Agent ID
     */
    async unregisterAgent(agentId) {
        if (agentId in this.activeAgents) {
            const agent = this.activeAgents[agentId];
            const duration = (Date.now() - agent.startTime) / 1000;
            this.outputChannel.appendLine(`Unregistered agent ${agentId} of type ${agent.type} after ${duration.toFixed(2)}s`);
            delete this.activeAgents[agentId];
        }
    }
    /**
     * Get current memory usage
     * @returns Memory usage (0-1)
     */
    _getMemoryUsage() {
        const totalMem = os.totalmem();
        const freeMem = os.freemem();
        const usedMem = totalMem - freeMem;
        return usedMem / totalMem;
    }
    /**
     * Get current CPU usage
     * @returns CPU usage (0-1)
     */
    async _getCpuUsage() {
        return new Promise((resolve) => {
            const startMeasure = os.cpus().map(cpu => cpu.times);
            // Measure CPU usage over a short interval
            setTimeout(() => {
                const endMeasure = os.cpus().map(cpu => cpu.times);
                const cpuUsage = endMeasure.map((end, i) => {
                    const start = startMeasure[i];
                    const idle = end.idle - start.idle;
                    const total = (end.user - start.user) +
                        (end.nice - start.nice) +
                        (end.sys - start.sys) +
                        (end.irq - start.irq) +
                        idle;
                    return 1 - (idle / total);
                });
                // Average CPU usage across all cores
                const avgCpuUsage = cpuUsage.reduce((sum, usage) => sum + usage, 0) / cpuUsage.length;
                resolve(avgCpuUsage);
            }, 100);
        });
    }
    /**
     * Start resource monitoring
     */
    _startResourceMonitoring() {
        if (this.resourceCheckInterval) {
            clearInterval(this.resourceCheckInterval);
        }
        this.resourceCheckInterval = setInterval(async () => {
            try {
                const resources = await this.getAvailableResources();
                // Log resource usage periodically
                if (Object.keys(this.activeAgents).length > 0) {
                    this.outputChannel.appendLine(`Resource check: memory=${(1 - resources.memory).toFixed(2)}, cpu=${(1 - resources.cpu).toFixed(2)}, activeAgents=${resources.activeAgents}`);
                }
                // Check for resource constraints
                if (resources.memory < 0.1 || resources.cpu < 0.1) {
                    this.outputChannel.appendLine('WARNING: System resources are critically low');
                    // Notify the user
                    vscode.window.showWarningMessage('System resources are running low. Some agent operations may be delayed.');
                }
            }
            catch (error) {
                this.outputChannel.appendLine(`Error monitoring resources: ${error.message}`);
            }
        }, 30000); // Check every 30 seconds
    }
    /**
     * Dispose of resources
     */
    dispose() {
        if (this.resourceCheckInterval) {
            clearInterval(this.resourceCheckInterval);
            this.resourceCheckInterval = null;
        }
        this.outputChannel.dispose();
    }
}
exports.ResourceManager = ResourceManager;
//# sourceMappingURL=resourceManager.js.map
```


---

### File: `archive/vscode-extension/src/agents/types.ts`

```typescript
/**
 * Type definitions for the hierarchical agent system
 */

/**
 * Agent types supported by the system
 */
export enum AgentType {
  Coordinator = 'coordinator',
  Development = 'development',
  Testing = 'testing',
  CICD = 'ci_cd',
  GitHub = 'github',
  Documentation = 'documentation',
  Architecture = 'architecture',
  Security = 'security',
  Performance = 'performance'
}

/**
 * Model sizes available for agents
 */
export enum ModelSize {
  Tiny = 'Qwen3-0.6B',
  Small = 'Qwen3-1.7B',
  Medium = 'Qwen3-4B',
  Large = 'Qwen3-8B',
  XLarge = 'Qwen3-14B',
  XXLarge = 'Qwen3-32B',
  MoESmall = 'Qwen3-30B-A3B',
  MoELarge = 'Qwen3-235B-A22B'
}

/**
 * Task complexity levels
 */
export enum TaskComplexity {
  Low = 'low',
  Medium = 'medium',
  High = 'high'
}

/**
 * Thinking mode options
 */
export enum ThinkingMode {
  Enabled = 'enabled',
  Disabled = 'disabled',
  Auto = 'auto'
}

/**
 * Agent configuration
 */
export interface AgentConfig {
  type: AgentType;
  modelSize: ModelSize;
  thinkingMode: ThinkingMode;
  systemMessage: string;
  maxTokens: number;
}

/**
 * Subtask definition
 */
export interface Subtask {
  id: string;
  description: string;
  expertise: AgentType;
  complexity: TaskComplexity;
  dependencies: string[];
}

/**
 * Agent result
 */
export interface AgentResult {
  subtaskId: string;
  thinking?: string;
  content: string;
  status: 'success' | 'error';
  error?: string;
}

/**
 * Resource usage information
 */
export interface ResourceUsage {
  memory: number;
  cpu: number;
  activeAgents: number;
}

/**
 * Agent status
 */
export interface AgentStatus {
  id: string;
  type: AgentType;
  modelSize: ModelSize;
  thinkingMode: ThinkingMode;
  status: 'idle' | 'running' | 'completed' | 'failed';
  startTime: number;
  endTime?: number;
  error?: string;
}

```


---

### File: `archive/vscode-extension/src/agents/resourceManager.ts`

```typescript
/**
 * Resource Manager
 * 
 * Monitors system resources and controls agent instantiation.
 */

import * as vscode from 'vscode';
import * as os from 'os';
import { v4 as uuidv4 } from 'uuid';
import { AgentType, ModelSize, ThinkingMode, ResourceUsage } from './types';

/**
 * Resource Manager class
 */
export class ResourceManager {
  private outputChannel: vscode.OutputChannel;
  private activeAgents: Record<string, {
    type: AgentType;
    modelSize: ModelSize;
    thinkingMode: ThinkingMode;
    startTime: number;
  }>;
  private maxMemoryUsage: number;
  private maxCpuUsage: number;
  private resourceCheckInterval: NodeJS.Timeout | null;

  /**
   * Constructor
   * @param maxMemoryUsage Maximum memory usage (0-1)
   * @param maxCpuUsage Maximum CPU usage (0-1)
   */
  constructor(maxMemoryUsage = 0.8, maxCpuUsage = 0.8) {
    this.outputChannel = vscode.window.createOutputChannel('Resource Manager');
    this.activeAgents = {};
    this.maxMemoryUsage = maxMemoryUsage;
    this.maxCpuUsage = maxCpuUsage;
    this.resourceCheckInterval = null;
    
    // Start resource monitoring
    this._startResourceMonitoring();
    
    this.outputChannel.appendLine('Resource Manager initialized');
  }

  /**
   * Get available system resources
   * @returns Available resources
   */
  public async getAvailableResources(): Promise<ResourceUsage> {
    try {
      // Get current system resource usage
      const currentMemoryUsage = this._getMemoryUsage();
      const currentCpuUsage = await this._getCpuUsage();
      
      // Calculate available resources
      const availableMemory = Math.max(0, this.maxMemoryUsage - currentMemoryUsage);
      const availableCpu = Math.max(0, this.maxCpuUsage - currentCpuUsage);
      
      const resources = {
        memory: availableMemory,
        cpu: availableCpu,
        activeAgents: Object.keys(this.activeAgents).length
      };
      
      this.outputChannel.appendLine(`Available resources: memory=${availableMemory.toFixed(2)}, cpu=${availableCpu.toFixed(2)}, activeAgents=${resources.activeAgents}`);
      
      return resources;
    } catch (error) {
      this.outputChannel.appendLine(`Error getting available resources: ${error.message}`);
      
      // Return conservative estimates in case of error
      return {
        memory: 0.2,
        cpu: 0.2,
        activeAgents: Object.keys(this.activeAgents).length
      };
    }
  }

  /**
   * Register a new agent with its resource requirements
   * @param type Agent type
   * @param requirements Resource requirements
   * @returns Agent ID
   */
  public async registerAgent(
    type: AgentType, 
    requirements: { modelSize: ModelSize, thinkingMode: ThinkingMode }
  ): Promise<string> {
    const agentId = uuidv4();
    
    this.activeAgents[agentId] = {
      type,
      modelSize: requirements.modelSize,
      thinkingMode: requirements.thinkingMode,
      startTime: Date.now()
    };
    
    this.outputChannel.appendLine(`Registered agent ${agentId} of type ${type} with model ${requirements.modelSize}`);
    
    return agentId;
  }

  /**
   * Unregister an agent when it's no longer needed
   * @param agentId Agent ID
   */
  public async unregisterAgent(agentId: string): Promise<void> {
    if (agentId in this.activeAgents) {
      const agent = this.activeAgents[agentId];
      const duration = (Date.now() - agent.startTime) / 1000;
      
      this.outputChannel.appendLine(`Unregistered agent ${agentId} of type ${agent.type} after ${duration.toFixed(2)}s`);
      
      delete this.activeAgents[agentId];
    }
  }

  /**
   * Get current memory usage
   * @returns Memory usage (0-1)
   */
  private _getMemoryUsage(): number {
    const totalMem = os.totalmem();
    const freeMem = os.freemem();
    const usedMem = totalMem - freeMem;
    
    return usedMem / totalMem;
  }

  /**
   * Get current CPU usage
   * @returns CPU usage (0-1)
   */
  private async _getCpuUsage(): Promise<number> {
    return new Promise<number>((resolve) => {
      const startMeasure = os.cpus().map(cpu => cpu.times);
      
      // Measure CPU usage over a short interval
      setTimeout(() => {
        const endMeasure = os.cpus().map(cpu => cpu.times);
        const cpuUsage = endMeasure.map((end, i) => {
          const start = startMeasure[i];
          const idle = end.idle - start.idle;
          const total = (end.user - start.user) + 
                        (end.nice - start.nice) + 
                        (end.sys - start.sys) + 
                        (end.irq - start.irq) + 
                        idle;
          
          return 1 - (idle / total);
        });
        
        // Average CPU usage across all cores
        const avgCpuUsage = cpuUsage.reduce((sum, usage) => sum + usage, 0) / cpuUsage.length;
        
        resolve(avgCpuUsage);
      }, 100);
    });
  }

  /**
   * Start resource monitoring
   */
  private _startResourceMonitoring(): void {
    if (this.resourceCheckInterval) {
      clearInterval(this.resourceCheckInterval);
    }
    
    this.resourceCheckInterval = setInterval(async () => {
      try {
        const resources = await this.getAvailableResources();
        
        // Log resource usage periodically
        if (Object.keys(this.activeAgents).length > 0) {
          this.outputChannel.appendLine(`Resource check: memory=${(1 - resources.memory).toFixed(2)}, cpu=${(1 - resources.cpu).toFixed(2)}, activeAgents=${resources.activeAgents}`);
        }
        
        // Check for resource constraints
        if (resources.memory < 0.1 || resources.cpu < 0.1) {
          this.outputChannel.appendLine('WARNING: System resources are critically low');
          
          // Notify the user
          vscode.window.showWarningMessage('System resources are running low. Some agent operations may be delayed.');
        }
      } catch (error) {
        this.outputChannel.appendLine(`Error monitoring resources: ${error.message}`);
      }
    }, 30000); // Check every 30 seconds
  }

  /**
   * Dispose of resources
   */
  public dispose(): void {
    if (this.resourceCheckInterval) {
      clearInterval(this.resourceCheckInterval);
      this.resourceCheckInterval = null;
    }
    
    this.outputChannel.dispose();
  }
}

```


---

### File: `archive/vscode-extension/src/agents/resultAggregator.ts`

```typescript
/**
 * Result Aggregator
 * 
 * Combines outputs from multiple agents into a coherent response.
 */

import * as vscode from 'vscode';
import { Subtask, AgentResult } from './types';
import { QwenApiClient } from '../qwenApi';

/**
 * Result Aggregator class
 */
export class ResultAggregator {
  private qwenApi: QwenApiClient;
  private outputChannel: vscode.OutputChannel;

  /**
   * Constructor
   * @param qwenApi The Qwen API client
   */
  constructor(qwenApi: QwenApiClient) {
    this.qwenApi = qwenApi;
    this.outputChannel = vscode.window.createOutputChannel('Result Aggregator');
  }

  /**
   * Aggregate results from multiple agents
   * @param results The results from each agent
   * @param subtasks The original subtasks
   * @returns The aggregated response
   */
  public async aggregate(
    results: Record<string, AgentResult>, 
    subtasks: Record<string, Subtask>
  ): Promise<string> {
    try {
      this.outputChannel.appendLine(`Aggregating results from ${Object.keys(results).length} agents`);
      
      // Check if we have any results
      if (Object.keys(results).length === 0) {
        return 'No results were generated. Please try again with a more specific request.';
      }
      
      // Check if we have only one result
      if (Object.keys(results).length === 1) {
        const result = Object.values(results)[0];
        return result.content;
      }
      
      // Prepare the system message
      const systemMessage = `
        You are a Result Aggregator. Your job is to combine outputs from multiple specialized agents into a coherent, unified response.
        Ensure that the final response is well-structured, consistent, and addresses all aspects of the original request.
        
        Follow these guidelines:
        1. Organize information logically, grouping related content together
        2. Eliminate redundancies while preserving important details
        3. Ensure a consistent tone and style throughout
        4. Highlight key insights and recommendations
        5. Format code snippets, commands, and technical information appropriately
        6. Provide a clear summary at the beginning if the response is lengthy
      `;
      
      // Prepare the context with all results
      let context = "Here are the results from different specialized agents:\n\n";
      
      // Sort subtasks by dependencies to maintain logical order
      const sortedSubtaskIds = this._sortSubtasksByDependencies(subtasks);
      
      // Add results in dependency order
      for (const subtaskId of sortedSubtaskIds) {
        if (results[subtaskId]) {
          const subtask = subtasks[subtaskId];
          const result = results[subtaskId];
          
          context += `## Subtask: ${subtask.description}\n`;
          context += `Expertise: ${subtask.expertise}\n`;
          context += `Status: ${result.status}\n`;
          
          if (result.status === 'error') {
            context += `Error: ${result.error}\n\n`;
          } else {
            context += `Result:\n${result.content}\n\n`;
          }
        }
      }
      
      // Prepare the user message
      const userMessage = `Please combine these results into a coherent response:\n\n${context}`;
      
      // Prepare the messages for the API call
      const messages = [
        { role: 'system', content: systemMessage },
        { role: 'user', content: userMessage }
      ];
      
      // Call the Qwen API with thinking mode enabled
      const response = await this.qwenApi.chat(messages, {
        enableThinking: true,
        temperature: 0.3,
        maxTokens: 4096
      });
      
      this.outputChannel.appendLine('Results aggregated successfully');
      
      return response;
    } catch (error) {
      this.outputChannel.appendLine(`Error aggregating results: ${error.message}`);
      
      // Fallback: concatenate results
      let fallbackResponse = '# Combined Agent Results\n\n';
      
      for (const subtaskId in results) {
        const result = results[subtaskId];
        const subtask = subtasks[subtaskId];
        
        fallbackResponse += `## ${subtask.description}\n\n`;
        
        if (result.status === 'error') {
          fallbackResponse += `**Error:** ${result.error}\n\n`;
        } else {
          fallbackResponse += `${result.content}\n\n`;
        }
      }
      
      return fallbackResponse;
    }
  }

  /**
   * Sort subtasks by dependencies
   * @param subtasks The subtasks to sort
   * @returns Sorted subtask IDs
   */
  private _sortSubtasksByDependencies(subtasks: Record<string, Subtask>): string[] {
    const visited = new Set<string>();
    const result: string[] = [];
    
    const visit = (id: string) => {
      if (visited.has(id)) {
        return;
      }
      
      visited.add(id);
      
      // Visit dependencies first
      for (const depId of subtasks[id].dependencies) {
        if (subtasks[depId]) {
          visit(depId);
        }
      }
      
      result.push(id);
    };
    
    // Visit all subtasks
    for (const id in subtasks) {
      visit(id);
    }
    
    return result;
  }

  /**
   * Dispose of resources
   */
  public dispose(): void {
    this.outputChannel.dispose();
  }
}

```


---

### File: `archive/vscode-extension/src/agents/taskDecomposer.ts`

```typescript
/**
 * Task Decomposer
 * 
 * Breaks down complex user requests into smaller, manageable subtasks.
 * Uses Qwen's thinking mode to perform detailed analysis.
 */

import * as vscode from 'vscode';
import { v4 as uuidv4 } from 'uuid';
import { AgentType, TaskComplexity, Subtask, ResourceUsage } from './types';
import { QwenApiClient } from '../qwenApi';

/**
 * Task Decomposer class
 */
export class TaskDecomposer {
  private qwenApi: QwenApiClient;
  private outputChannel: vscode.OutputChannel;

  /**
   * Constructor
   * @param qwenApi The Qwen API client
   */
  constructor(qwenApi: QwenApiClient) {
    this.qwenApi = qwenApi;
    this.outputChannel = vscode.window.createOutputChannel('Task Decomposer');
  }

  /**
   * Decompose a user request into subtasks
   * @param userRequest The user's request
   * @param availableResources Available system resources
   * @returns A record of subtasks
   */
  public async decompose(userRequest: string, availableResources: ResourceUsage): Promise<Record<string, Subtask>> {
    try {
      this.outputChannel.appendLine(`Decomposing request: ${userRequest}`);
      
      // Prepare the system message for task decomposition
      const systemMessage = `
        You are a task decomposition expert. Your job is to break down complex DevOps tasks into smaller, manageable subtasks.
        For each subtask, provide:
        1. A unique ID
        2. A clear description
        3. Required expertise (development, testing, ci_cd, github, documentation, architecture, security, performance)
        4. Estimated complexity (low, medium, high)
        5. Dependencies on other subtasks (if any)
        
        Format your response as a JSON object with the following structure:
        {
          "subtasks": [
            {
              "id": "unique_id",
              "description": "Clear description of the subtask",
              "expertise": "One of: development, testing, ci_cd, github, documentation, architecture, security, performance",
              "complexity": "One of: low, medium, high",
              "dependencies": ["id_of_dependency_1", "id_of_dependency_2"]
            },
            ...
          ]
        }
        
        Consider the available system resources when decomposing the task:
        - Memory: ${availableResources.memory * 100}%
        - CPU: ${availableResources.cpu * 100}%
        - Active Agents: ${availableResources.activeAgents}
        
        If resources are limited, prioritize essential subtasks and reduce complexity.
      `;
      
      // Prepare the messages for the API call
      const messages = [
        { role: 'system', content: systemMessage },
        { role: 'user', content: `Please decompose the following DevOps task into subtasks: ${userRequest}` }
      ];
      
      // Call the Qwen API with thinking mode enabled
      const response = await this.qwenApi.chat(messages, {
        enableThinking: true,
        temperature: 0.2,
        maxTokens: 2048
      });
      
      // Parse the response to extract subtasks
      const subtasks = this._parseSubtasks(response);
      
      // Validate subtasks and ensure they're within resource constraints
      const validatedSubtasks = this._validateSubtasks(subtasks, availableResources);
      
      this.outputChannel.appendLine(`Decomposed into ${Object.keys(validatedSubtasks).length} subtasks`);
      return validatedSubtasks;
    } catch (error) {
      this.outputChannel.appendLine(`Error decomposing task: ${error.message}`);
      throw error;
    }
  }

  /**
   * Parse the LLM response to extract subtasks
   * @param response The LLM response
   * @returns A record of subtasks
   */
  private _parseSubtasks(response: string): Record<string, Subtask> {
    try {
      // Extract JSON from the response
      const jsonMatch = response.match(/```json\n([\s\S]*?)\n```/) || 
                        response.match(/{[\s\S]*?}/);
      
      if (!jsonMatch) {
        throw new Error('No valid JSON found in the response');
      }
      
      const jsonStr = jsonMatch[0].startsWith('```') ? jsonMatch[1] : jsonMatch[0];
      const parsed = JSON.parse(jsonStr);
      
      if (!parsed.subtasks || !Array.isArray(parsed.subtasks)) {
        throw new Error('Invalid subtasks format in the response');
      }
      
      // Convert array to record
      const subtasks: Record<string, Subtask> = {};
      for (const subtask of parsed.subtasks) {
        // Ensure the subtask has a valid ID
        const id = subtask.id || uuidv4();
        
        // Ensure the subtask has valid dependencies
        const dependencies = Array.isArray(subtask.dependencies) ? subtask.dependencies : [];
        
        // Create the subtask object
        subtasks[id] = {
          id,
          description: subtask.description || '',
          expertise: this._validateExpertise(subtask.expertise),
          complexity: this._validateComplexity(subtask.complexity),
          dependencies
        };
      }
      
      return subtasks;
    } catch (error) {
      this.outputChannel.appendLine(`Error parsing subtasks: ${error.message}`);
      
      // Fallback: create a single subtask
      const id = uuidv4();
      return {
        [id]: {
          id,
          description: 'Execute the requested task',
          expertise: AgentType.Development,
          complexity: TaskComplexity.Medium,
          dependencies: []
        }
      };
    }
  }

  /**
   * Validate the expertise field
   * @param expertise The expertise string
   * @returns A valid AgentType
   */
  private _validateExpertise(expertise: string): AgentType {
    if (!expertise || typeof expertise !== 'string') {
      return AgentType.Development;
    }
    
    const normalized = expertise.toLowerCase();
    
    switch (normalized) {
      case 'development':
        return AgentType.Development;
      case 'testing':
        return AgentType.Testing;
      case 'ci_cd':
      case 'cicd':
        return AgentType.CICD;
      case 'github':
        return AgentType.GitHub;
      case 'documentation':
        return AgentType.Documentation;
      case 'architecture':
        return AgentType.Architecture;
      case 'security':
        return AgentType.Security;
      case 'performance':
        return AgentType.Performance;
      default:
        return AgentType.Development;
    }
  }

  /**
   * Validate the complexity field
   * @param complexity The complexity string
   * @returns A valid TaskComplexity
   */
  private _validateComplexity(complexity: string): TaskComplexity {
    if (!complexity || typeof complexity !== 'string') {
      return TaskComplexity.Medium;
    }
    
    const normalized = complexity.toLowerCase();
    
    switch (normalized) {
      case 'low':
        return TaskComplexity.Low;
      case 'medium':
        return TaskComplexity.Medium;
      case 'high':
        return TaskComplexity.High;
      default:
        return TaskComplexity.Medium;
    }
  }

  /**
   * Validate subtasks and ensure they're within resource constraints
   * @param subtasks The subtasks to validate
   * @param availableResources Available system resources
   * @returns Validated subtasks
   */
  private _validateSubtasks(subtasks: Record<string, Subtask>, availableResources: ResourceUsage): Record<string, Subtask> {
    // Check if we have enough resources for all subtasks
    const totalSubtasks = Object.keys(subtasks).length;
    
    if (totalSubtasks > 10 && availableResources.memory < 0.5) {
      // If resources are limited, reduce the number of subtasks
      this.outputChannel.appendLine('Limited resources detected, reducing number of subtasks');
      
      // Sort subtasks by dependencies (fewer dependencies first)
      const sortedSubtasks = Object.values(subtasks).sort((a, b) => 
        a.dependencies.length - b.dependencies.length
      );
      
      // Keep only the first 5-10 subtasks
      const maxSubtasks = Math.max(5, Math.min(10, Math.floor(availableResources.memory * 20)));
      const reducedSubtasks: Record<string, Subtask> = {};
      
      for (let i = 0; i < Math.min(maxSubtasks, sortedSubtasks.length); i++) {
        const subtask = sortedSubtasks[i];
        reducedSubtasks[subtask.id] = subtask;
      }
      
      return reducedSubtasks;
    }
    
    // Check for circular dependencies
    const visited = new Set<string>();
    const visiting = new Set<string>();
    
    const hasCycle = (id: string): boolean => {
      if (visiting.has(id)) {
        return true;
      }
      
      if (visited.has(id)) {
        return false;
      }
      
      visiting.add(id);
      
      for (const depId of subtasks[id].dependencies) {
        if (!subtasks[depId]) {
          // Remove invalid dependency
          subtasks[id].dependencies = subtasks[id].dependencies.filter(d => d !== depId);
          continue;
        }
        
        if (hasCycle(depId)) {
          return true;
        }
      }
      
      visiting.delete(id);
      visited.add(id);
      
      return false;
    };
    
    // Check each subtask for cycles
    for (const id in subtasks) {
      if (hasCycle(id)) {
        // Remove circular dependencies
        this.outputChannel.appendLine(`Circular dependency detected in subtask ${id}, removing dependencies`);
        subtasks[id].dependencies = [];
      }
    }
    
    return subtasks;
  }

  /**
   * Dispose of resources
   */
  public dispose(): void {
    this.outputChannel.dispose();
  }
}

```


---

### File: `archive/vscode-extension/src/test/runTest.js`

```javascript
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const path = __importStar(require("path"));
const test_electron_1 = require("@vscode/test-electron");
async function main() {
    try {
        // The folder containing the Extension Manifest package.json
        // Passed to `--extensionDevelopmentPath`
        const extensionDevelopmentPath = path.resolve(__dirname, '../../');
        // The path to the extension test script
        // Passed to --extensionTestsPath
        const extensionTestsPath = path.resolve(__dirname, './suite/index');
        // Download VS Code, unzip it and run the integration test
        await (0, test_electron_1.runTests)({ extensionDevelopmentPath, extensionTestsPath });
    }
    catch (err) {
        console.error('Failed to run tests', err);
        process.exit(1);
    }
}
main();
//# sourceMappingURL=runTest.js.map
```


---

### File: `archive/vscode-extension/src/test/runTest.ts`

```typescript
import * as path from 'path';
import { runTests } from '@vscode/test-electron';

async function main() {
  try {
    // The folder containing the Extension Manifest package.json
    // Passed to `--extensionDevelopmentPath`
    const extensionDevelopmentPath = path.resolve(__dirname, '../../');

    // The path to the extension test script
    // Passed to --extensionTestsPath
    const extensionTestsPath = path.resolve(__dirname, './suite/index');

    // Download VS Code, unzip it and run the integration test
    await runTests({ extensionDevelopmentPath, extensionTestsPath });
  } catch (err) {
    console.error('Failed to run tests', err);
    process.exit(1);
  }
}

main();

```


---

### File: `archive/vscode-extension/src/test/suite/extension.test.js`

```javascript
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const assert = __importStar(require("assert"));
const vscode = __importStar(require("vscode"));
suite('Extension Test Suite', () => {
    vscode.window.showInformationMessage('Start all tests.');
    test('Extension should be present', () => {
        assert.ok(vscode.extensions.getExtension('qwen-coder-assistant'));
    });
    test('Extension should activate', async () => {
        const extension = vscode.extensions.getExtension('qwen-coder-assistant');
        if (!extension) {
            assert.fail('Extension not found');
            return;
        }
        await extension.activate();
        assert.ok(extension.isActive);
    });
    test('Commands should be registered', async () => {
        const commands = await vscode.commands.getCommands();
        assert.ok(commands.includes('qwen-coder-assistant.askQwen'));
        assert.ok(commands.includes('qwen-coder-assistant.explainCode'));
        assert.ok(commands.includes('qwen-coder-assistant.generateCode'));
    });
});
//# sourceMappingURL=extension.test.js.map
```


---

### File: `archive/vscode-extension/src/test/suite/index.ts`

```typescript
import glob from 'glob';
import Mocha from 'mocha';
import * as path from 'path';

export function run(): Promise<void> {
  // Create the mocha test
  const mocha = new Mocha({
    ui: 'tdd',
    color: true
  });

  const testsRoot = path.resolve(__dirname, '..');

  return new Promise<void>((c, e) => {
    glob('**/**.test.js', { cwd: testsRoot }, (err: any, files: string[]) => {
      if (err) {
        return e(err);
      }

      // Add files to the test suite
      files.forEach((f: string) => mocha.addFile(path.resolve(testsRoot, f)));

      try {
        // Run the mocha test
        mocha.run((failures: number) => {
          if (failures > 0) {
            e(new Error(`${failures} tests failed.`));
          } else {
            c();
          }
        });
      } catch (err) {
        console.error(err);
        e(err);
      }
    });
  });
}

```


---

### File: `archive/vscode-extension/src/test/suite/symbolExtractor.test.ts`

```typescript
import * as assert from 'assert';
import { SymbolExtractor } from '../../context/symbolExtractor';

suite('Symbol Extractor Test Suite', () => {
  let symbolExtractor: SymbolExtractor;

  setup(() => {
    symbolExtractor = new SymbolExtractor();
  });

  test('JavaScript Symbol Extraction', async () => {
    const jsCode = `
      import { useState } from 'react';
      import axios from 'axios';
      
      function calculateTotal(items) {
        return items.reduce((total, item) => total + item.price, 0);
      }
      
      class ShoppingCart {
        constructor(items = []) {
          this.items = items;
        }
        
        addItem(item) {
          this.items.push(item);
        }
        
        getTotal() {
          return calculateTotal(this.items);
        }
      }
      
      const cart = new ShoppingCart();
      const fetchItems = async () => {
        const response = await axios.get('/api/items');
        return response.data;
      };
    `;
    
    const result = await symbolExtractor.extractSymbols(jsCode, 'javascript');
    
    // Check symbols
    assert.ok(result.symbols.includes('calculateTotal'), 'Should extract function declaration');
    assert.ok(result.symbols.includes('ShoppingCart'), 'Should extract class declaration');
    assert.ok(result.symbols.includes('cart'), 'Should extract variable declaration');
    assert.ok(result.symbols.includes('fetchItems'), 'Should extract arrow function');
    assert.ok(result.symbols.includes('addItem'), 'Should extract method declaration');
    assert.ok(result.symbols.includes('getTotal'), 'Should extract method declaration');
    
    // Check imports
    assert.ok(result.imports.includes('react'), 'Should extract ES module import');
    assert.ok(result.imports.includes('axios'), 'Should extract default import');
  });

  test('Python Symbol Extraction', async () => {
    const pyCode = `
      import os
      import sys
      from datetime import datetime
      
      CONSTANT_VALUE = 42
      
      def calculate_age(birth_date):
          today = datetime.now()
          age = today.year - birth_date.year
          return age
      
      class Person:
          def __init__(self, name, birth_date):
              self.name = name
              self.birth_date = birth_date
          
          def get_age(self):
              return calculate_age(self.birth_date)
      
      @staticmethod
      def format_date(date):
          return date.strftime("%Y-%m-%d")
    `;
    
    const result = await symbolExtractor.extractSymbols(pyCode, 'python');
    
    // Check symbols
    assert.ok(result.symbols.includes('CONSTANT_VALUE'), 'Should extract constant');
    assert.ok(result.symbols.includes('calculate_age'), 'Should extract function declaration');
    assert.ok(result.symbols.includes('Person'), 'Should extract class declaration');
    assert.ok(result.symbols.includes('get_age'), 'Should extract method declaration');
    assert.ok(result.symbols.includes('format_date'), 'Should extract decorated function');
    
    // Check imports
    assert.ok(result.imports.includes('os'), 'Should extract simple import');
    assert.ok(result.imports.includes('sys'), 'Should extract simple import');
    assert.ok(result.imports.includes('datetime'), 'Should extract from import');
  });

  test('Java Symbol Extraction', async () => {
    const javaCode = `
      package com.example.app;
      
      import java.util.List;
      import java.util.ArrayList;
      
      public class UserManager {
          private List<User> users;
          
          public UserManager() {
              this.users = new ArrayList<>();
          }
          
          public void addUser(User user) {
              users.add(user);
          }
          
          public User findUserById(int id) {
              return users.stream()
                  .filter(user -> user.getId() == id)
                  .findFirst()
                  .orElse(null);
          }
      }
    `;
    
    const result = await symbolExtractor.extractSymbols(javaCode, 'java');
    
    // Check symbols
    assert.ok(result.symbols.includes('UserManager'), 'Should extract class declaration');
    assert.ok(result.symbols.includes('users'), 'Should extract field declaration');
    assert.ok(result.symbols.includes('addUser'), 'Should extract method declaration');
    assert.ok(result.symbols.includes('findUserById'), 'Should extract method declaration');
    
    // Check imports
    assert.ok(result.imports.includes('java.util.List'), 'Should extract import');
    assert.ok(result.imports.includes('java.util.ArrayList'), 'Should extract import');
  });

  test('Language Detection from Path', () => {
    assert.strictEqual(SymbolExtractor.detectLanguageFromPath('/path/to/file.js'), 'javascript');
    assert.strictEqual(SymbolExtractor.detectLanguageFromPath('/path/to/file.ts'), 'typescript');
    assert.strictEqual(SymbolExtractor.detectLanguageFromPath('/path/to/file.py'), 'python');
    assert.strictEqual(SymbolExtractor.detectLanguageFromPath('/path/to/file.java'), 'java');
    assert.strictEqual(SymbolExtractor.detectLanguageFromPath('/path/to/file.cpp'), 'cpp');
    assert.strictEqual(SymbolExtractor.detectLanguageFromPath('/path/to/file.cs'), 'csharp');
    assert.strictEqual(SymbolExtractor.detectLanguageFromPath('/path/to/file.go'), 'go');
    assert.strictEqual(SymbolExtractor.detectLanguageFromPath('/path/to/file.rb'), 'ruby');
    assert.strictEqual(SymbolExtractor.detectLanguageFromPath('/path/to/file.php'), 'php');
    assert.strictEqual(SymbolExtractor.detectLanguageFromPath('/path/to/file.rs'), 'rust');
    assert.strictEqual(SymbolExtractor.detectLanguageFromPath('/path/to/file.swift'), 'swift');
    assert.strictEqual(SymbolExtractor.detectLanguageFromPath('/path/to/file.kt'), 'kotlin');
    assert.strictEqual(SymbolExtractor.detectLanguageFromPath('/path/to/file.html'), 'html');
    assert.strictEqual(SymbolExtractor.detectLanguageFromPath('/path/to/file.css'), 'css');
    assert.strictEqual(SymbolExtractor.detectLanguageFromPath('/path/to/file.json'), 'json');
    assert.strictEqual(SymbolExtractor.detectLanguageFromPath('/path/to/file.xml'), 'xml');
    assert.strictEqual(SymbolExtractor.detectLanguageFromPath('/path/to/file.yaml'), 'yaml');
    assert.strictEqual(SymbolExtractor.detectLanguageFromPath('/path/to/file.md'), 'markdown');
  });
});

```


---

### File: `archive/vscode-extension/src/test/suite/symbolExtractor.test.js`

```javascript
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const assert = __importStar(require("assert"));
const symbolExtractor_1 = require("../../context/symbolExtractor");
suite('Symbol Extractor Test Suite', () => {
    let symbolExtractor;
    setup(() => {
        symbolExtractor = new symbolExtractor_1.SymbolExtractor();
    });
    test('JavaScript Symbol Extraction', async () => {
        const jsCode = `
      import { useState } from 'react';
      import axios from 'axios';
      
      function calculateTotal(items) {
        return items.reduce((total, item) => total + item.price, 0);
      }
      
      class ShoppingCart {
        constructor(items = []) {
          this.items = items;
        }
        
        addItem(item) {
          this.items.push(item);
        }
        
        getTotal() {
          return calculateTotal(this.items);
        }
      }
      
      const cart = new ShoppingCart();
      const fetchItems = async () => {
        const response = await axios.get('/api/items');
        return response.data;
      };
    `;
        const result = await symbolExtractor.extractSymbols(jsCode, 'javascript');
        // Check symbols
        assert.ok(result.symbols.includes('calculateTotal'), 'Should extract function declaration');
        assert.ok(result.symbols.includes('ShoppingCart'), 'Should extract class declaration');
        assert.ok(result.symbols.includes('cart'), 'Should extract variable declaration');
        assert.ok(result.symbols.includes('fetchItems'), 'Should extract arrow function');
        assert.ok(result.symbols.includes('addItem'), 'Should extract method declaration');
        assert.ok(result.symbols.includes('getTotal'), 'Should extract method declaration');
        // Check imports
        assert.ok(result.imports.includes('react'), 'Should extract ES module import');
        assert.ok(result.imports.includes('axios'), 'Should extract default import');
    });
    test('Python Symbol Extraction', async () => {
        const pyCode = `
      import os
      import sys
      from datetime import datetime
      
      CONSTANT_VALUE = 42
      
      def calculate_age(birth_date):
          today = datetime.now()
          age = today.year - birth_date.year
          return age
      
      class Person:
          def __init__(self, name, birth_date):
              self.name = name
              self.birth_date = birth_date
          
          def get_age(self):
              return calculate_age(self.birth_date)
      
      @staticmethod
      def format_date(date):
          return date.strftime("%Y-%m-%d")
    `;
        const result = await symbolExtractor.extractSymbols(pyCode, 'python');
        // Check symbols
        assert.ok(result.symbols.includes('CONSTANT_VALUE'), 'Should extract constant');
        assert.ok(result.symbols.includes('calculate_age'), 'Should extract function declaration');
        assert.ok(result.symbols.includes('Person'), 'Should extract class declaration');
        assert.ok(result.symbols.includes('get_age'), 'Should extract method declaration');
        assert.ok(result.symbols.includes('format_date'), 'Should extract decorated function');
        // Check imports
        assert.ok(result.imports.includes('os'), 'Should extract simple import');
        assert.ok(result.imports.includes('sys'), 'Should extract simple import');
        assert.ok(result.imports.includes('datetime'), 'Should extract from import');
    });
    test('Java Symbol Extraction', async () => {
        const javaCode = `
      package com.example.app;
      
      import java.util.List;
      import java.util.ArrayList;
      
      public class UserManager {
          private List<User> users;
          
          public UserManager() {
              this.users = new ArrayList<>();
          }
          
          public void addUser(User user) {
              users.add(user);
          }
          
          public User findUserById(int id) {
              return users.stream()
                  .filter(user -> user.getId() == id)
                  .findFirst()
                  .orElse(null);
          }
      }
    `;
        const result = await symbolExtractor.extractSymbols(javaCode, 'java');
        // Check symbols
        assert.ok(result.symbols.includes('UserManager'), 'Should extract class declaration');
        assert.ok(result.symbols.includes('users'), 'Should extract field declaration');
        assert.ok(result.symbols.includes('addUser'), 'Should extract method declaration');
        assert.ok(result.symbols.includes('findUserById'), 'Should extract method declaration');
        // Check imports
        assert.ok(result.imports.includes('java.util.List'), 'Should extract import');
        assert.ok(result.imports.includes('java.util.ArrayList'), 'Should extract import');
    });
    test('Language Detection from Path', () => {
        assert.strictEqual(symbolExtractor_1.SymbolExtractor.detectLanguageFromPath('/path/to/file.js'), 'javascript');
        assert.strictEqual(symbolExtractor_1.SymbolExtractor.detectLanguageFromPath('/path/to/file.ts'), 'typescript');
        assert.strictEqual(symbolExtractor_1.SymbolExtractor.detectLanguageFromPath('/path/to/file.py'), 'python');
        assert.strictEqual(symbolExtractor_1.SymbolExtractor.detectLanguageFromPath('/path/to/file.java'), 'java');
        assert.strictEqual(symbolExtractor_1.SymbolExtractor.detectLanguageFromPath('/path/to/file.cpp'), 'cpp');
        assert.strictEqual(symbolExtractor_1.SymbolExtractor.detectLanguageFromPath('/path/to/file.cs'), 'csharp');
        assert.strictEqual(symbolExtractor_1.SymbolExtractor.detectLanguageFromPath('/path/to/file.go'), 'go');
        assert.strictEqual(symbolExtractor_1.SymbolExtractor.detectLanguageFromPath('/path/to/file.rb'), 'ruby');
        assert.strictEqual(symbolExtractor_1.SymbolExtractor.detectLanguageFromPath('/path/to/file.php'), 'php');
        assert.strictEqual(symbolExtractor_1.SymbolExtractor.detectLanguageFromPath('/path/to/file.rs'), 'rust');
        assert.strictEqual(symbolExtractor_1.SymbolExtractor.detectLanguageFromPath('/path/to/file.swift'), 'swift');
        assert.strictEqual(symbolExtractor_1.SymbolExtractor.detectLanguageFromPath('/path/to/file.kt'), 'kotlin');
        assert.strictEqual(symbolExtractor_1.SymbolExtractor.detectLanguageFromPath('/path/to/file.html'), 'html');
        assert.strictEqual(symbolExtractor_1.SymbolExtractor.detectLanguageFromPath('/path/to/file.css'), 'css');
        assert.strictEqual(symbolExtractor_1.SymbolExtractor.detectLanguageFromPath('/path/to/file.json'), 'json');
        assert.strictEqual(symbolExtractor_1.SymbolExtractor.detectLanguageFromPath('/path/to/file.xml'), 'xml');
        assert.strictEqual(symbolExtractor_1.SymbolExtractor.detectLanguageFromPath('/path/to/file.yaml'), 'yaml');
        assert.strictEqual(symbolExtractor_1.SymbolExtractor.detectLanguageFromPath('/path/to/file.md'), 'markdown');
    });
});
//# sourceMappingURL=symbolExtractor.test.js.map
```


---

### File: `archive/vscode-extension/src/test/suite/index.js`

```javascript
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.run = run;
const glob_1 = __importDefault(require("glob"));
const mocha_1 = __importDefault(require("mocha"));
const path = __importStar(require("path"));
function run() {
    // Create the mocha test
    const mocha = new mocha_1.default({
        ui: 'tdd',
        color: true
    });
    const testsRoot = path.resolve(__dirname, '..');
    return new Promise((c, e) => {
        (0, glob_1.default)('**/**.test.js', { cwd: testsRoot }, (err, files) => {
            if (err) {
                return e(err);
            }
            // Add files to the test suite
            files.forEach((f) => mocha.addFile(path.resolve(testsRoot, f)));
            try {
                // Run the mocha test
                mocha.run((failures) => {
                    if (failures > 0) {
                        e(new Error(`${failures} tests failed.`));
                    }
                    else {
                        c();
                    }
                });
            }
            catch (err) {
                console.error(err);
                e(err);
            }
        });
    });
}
//# sourceMappingURL=index.js.map
```


---

### File: `archive/vscode-extension/src/test/suite/extension.test.ts`

```typescript
import * as assert from 'assert';
import * as vscode from 'vscode';

suite('Extension Test Suite', () => {
  vscode.window.showInformationMessage('Start all tests.');

  test('Extension should be present', () => {
    assert.ok(vscode.extensions.getExtension('qwen-coder-assistant'));
  });

  test('Extension should activate', async () => {
    const extension = vscode.extensions.getExtension('qwen-coder-assistant');
    if (!extension) {
      assert.fail('Extension not found');
      return;
    }
    
    await extension.activate();
    assert.ok(extension.isActive);
  });

  test('Commands should be registered', async () => {
    const commands = await vscode.commands.getCommands();
    assert.ok(commands.includes('qwen-coder-assistant.askQwen'));
    assert.ok(commands.includes('qwen-coder-assistant.explainCode'));
    assert.ok(commands.includes('qwen-coder-assistant.generateCode'));
  });
});

```


---

### File: `archive/vscode-extension/src/mcp/mcpClient.js`

```javascript
"use strict";
/**
 * MCP Client
 *
 * Client for interacting with Model-Control-Protocol (MCP) tools.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MCPClient = void 0;
const vscode = __importStar(require("vscode"));
const axios_1 = __importDefault(require("axios"));
/**
 * MCP Client class
 */
class MCPClient {
    /**
     * Constructor
     * @param containerManager The container manager
     */
    constructor(containerManager) {
        this.containerManager = containerManager;
        this.outputChannel = vscode.window.createOutputChannel('MCP Client');
        this.toolSchemas = {};
        this.outputChannel.appendLine('MCP Client initialized');
    }
    /**
     * Initialize the MCP client
     */
    async initialize() {
        try {
            this.outputChannel.appendLine('Initializing MCP client');
            // Get active containers
            const containerStatus = this.containerManager.getContainerStatus();
            // Fetch schemas for running containers
            for (const containerName in containerStatus) {
                const container = containerStatus[containerName];
                if (container.status === 'running') {
                    try {
                        await this.fetchToolSchema(containerName);
                    }
                    catch (error) {
                        this.outputChannel.appendLine(`Error fetching schema for ${containerName}: ${error.message}`);
                    }
                }
            }
            this.outputChannel.appendLine('MCP client initialized');
        }
        catch (error) {
            this.outputChannel.appendLine(`Error initializing MCP client: ${error.message}`);
            throw error;
        }
    }
    /**
     * Fetch the schema for a tool
     * @param toolName The name of the tool
     * @returns The tool schema
     */
    async fetchToolSchema(toolName) {
        try {
            this.outputChannel.appendLine(`Fetching schema for tool: ${toolName}`);
            // Get container URL
            const url = this.containerManager.getContainerUrl(toolName);
            // Fetch schema
            const response = await axios_1.default.get(`${url}/schema`);
            const schema = response.data;
            // Validate schema
            if (!schema.name || !schema.functions || !Array.isArray(schema.functions)) {
                throw new Error(`Invalid schema for tool ${toolName}`);
            }
            // Store schema
            this.toolSchemas[toolName] = schema;
            this.outputChannel.appendLine(`Schema fetched for tool ${toolName}: ${schema.functions.length} functions available`);
            return schema;
        }
        catch (error) {
            this.outputChannel.appendLine(`Error fetching schema for tool ${toolName}: ${error.message}`);
            throw error;
        }
    }
    /**
     * Get the schema for a tool
     * @param toolName The name of the tool
     * @returns The tool schema
     */
    getToolSchema(toolName) {
        return this.toolSchemas[toolName];
    }
    /**
     * Get all available tools
     * @returns The available tools
     */
    getAvailableTools() {
        return Object.keys(this.toolSchemas);
    }
    /**
     * Call a function on a tool
     * @param toolName The name of the tool
     * @param functionName The name of the function
     * @param parameters The function parameters
     * @returns The function call result
     */
    async callFunction(toolName, functionName, parameters) {
        try {
            this.outputChannel.appendLine(`Calling function ${functionName} on tool ${toolName}`);
            // Check if tool is available
            if (!this.toolSchemas[toolName]) {
                // Try to fetch schema
                try {
                    await this.fetchToolSchema(toolName);
                }
                catch (error) {
                    throw new Error(`Tool ${toolName} is not available: ${error.message}`);
                }
            }
            // Check if function exists
            const functionSchema = this.toolSchemas[toolName].functions.find(f => f.name === functionName);
            if (!functionSchema) {
                throw new Error(`Function ${functionName} not found in tool ${toolName}`);
            }
            // Validate parameters
            this._validateParameters(parameters, functionSchema);
            // Get container URL
            const url = this.containerManager.getContainerUrl(toolName);
            // Call function
            const response = await axios_1.default.post(`${url}/invoke`, {
                function: functionName,
                parameters
            });
            const result = response.data;
            this.outputChannel.appendLine(`Function ${functionName} called successfully on tool ${toolName}`);
            return result;
        }
        catch (error) {
            this.outputChannel.appendLine(`Error calling function ${functionName} on tool ${toolName}: ${error.message}`);
            return {
                status: 'error',
                error: error.message
            };
        }
    }
    /**
     * Validate function parameters
     * @param parameters The parameters to validate
     * @param functionSchema The function schema
     */
    _validateParameters(parameters, functionSchema) {
        // Check required parameters
        for (const requiredParam of functionSchema.parameters.required) {
            if (parameters[requiredParam] === undefined) {
                throw new Error(`Missing required parameter: ${requiredParam}`);
            }
        }
        // Check parameter types
        for (const paramName in parameters) {
            const paramSchema = functionSchema.parameters.properties[paramName];
            if (!paramSchema) {
                throw new Error(`Unknown parameter: ${paramName}`);
            }
            // Basic type checking
            const paramValue = parameters[paramName];
            const paramType = paramSchema.type;
            if (paramType === 'string' && typeof paramValue !== 'string') {
                throw new Error(`Parameter ${paramName} should be a string`);
            }
            else if (paramType === 'number' && typeof paramValue !== 'number') {
                throw new Error(`Parameter ${paramName} should be a number`);
            }
            else if (paramType === 'boolean' && typeof paramValue !== 'boolean') {
                throw new Error(`Parameter ${paramName} should be a boolean`);
            }
            else if (paramType === 'array' && !Array.isArray(paramValue)) {
                throw new Error(`Parameter ${paramName} should be an array`);
            }
            else if (paramType === 'object' && (typeof paramValue !== 'object' || paramValue === null || Array.isArray(paramValue))) {
                throw new Error(`Parameter ${paramName} should be an object`);
            }
            // Check enum values
            if (paramSchema.enum && !paramSchema.enum.includes(paramValue)) {
                throw new Error(`Parameter ${paramName} should be one of: ${paramSchema.enum.join(', ')}`);
            }
        }
    }
    /**
     * Dispose of resources
     */
    dispose() {
        this.outputChannel.dispose();
    }
}
exports.MCPClient = MCPClient;
//# sourceMappingURL=mcpClient.js.map
```


---

### File: `archive/vscode-extension/src/mcp/mcpClient.ts`

```typescript
/**
 * MCP Client
 * 
 * Client for interacting with Model-Control-Protocol (MCP) tools.
 */

import * as vscode from 'vscode';
import axios from 'axios';
import { ContainerManager } from '../containers/containerManager';

/**
 * MCP function schema
 */
interface MCPFunctionSchema {
  name: string;
  description: string;
  parameters: {
    type: string;
    properties: Record<string, {
      type: string;
      description: string;
      enum?: string[];
    }>;
    required: string[];
  };
}

/**
 * MCP tool schema
 */
interface MCPToolSchema {
  name: string;
  description: string;
  functions: MCPFunctionSchema[];
}

/**
 * MCP function call result
 */
interface MCPFunctionCallResult {
  status: 'success' | 'error';
  result?: any;
  error?: string;
}

/**
 * MCP Client class
 */
export class MCPClient {
  private containerManager: ContainerManager;
  private outputChannel: vscode.OutputChannel;
  private toolSchemas: Record<string, MCPToolSchema>;

  /**
   * Constructor
   * @param containerManager The container manager
   */
  constructor(containerManager: ContainerManager) {
    this.containerManager = containerManager;
    this.outputChannel = vscode.window.createOutputChannel('MCP Client');
    this.toolSchemas = {};
    
    this.outputChannel.appendLine('MCP Client initialized');
  }

  /**
   * Initialize the MCP client
   */
  public async initialize(): Promise<void> {
    try {
      this.outputChannel.appendLine('Initializing MCP client');
      
      // Get active containers
      const containerStatus = this.containerManager.getContainerStatus();
      
      // Fetch schemas for running containers
      for (const containerName in containerStatus) {
        const container = containerStatus[containerName];
        
        if (container.status === 'running') {
          try {
            await this.fetchToolSchema(containerName);
          } catch (error) {
            this.outputChannel.appendLine(`Error fetching schema for ${containerName}: ${error.message}`);
          }
        }
      }
      
      this.outputChannel.appendLine('MCP client initialized');
    } catch (error) {
      this.outputChannel.appendLine(`Error initializing MCP client: ${error.message}`);
      throw error;
    }
  }

  /**
   * Fetch the schema for a tool
   * @param toolName The name of the tool
   * @returns The tool schema
   */
  public async fetchToolSchema(toolName: string): Promise<MCPToolSchema> {
    try {
      this.outputChannel.appendLine(`Fetching schema for tool: ${toolName}`);
      
      // Get container URL
      const url = this.containerManager.getContainerUrl(toolName);
      
      // Fetch schema
      const response = await axios.get(`${url}/schema`);
      const schema = response.data;
      
      // Validate schema
      if (!schema.name || !schema.functions || !Array.isArray(schema.functions)) {
        throw new Error(`Invalid schema for tool ${toolName}`);
      }
      
      // Store schema
      this.toolSchemas[toolName] = schema;
      
      this.outputChannel.appendLine(`Schema fetched for tool ${toolName}: ${schema.functions.length} functions available`);
      
      return schema;
    } catch (error) {
      this.outputChannel.appendLine(`Error fetching schema for tool ${toolName}: ${error.message}`);
      throw error;
    }
  }

  /**
   * Get the schema for a tool
   * @param toolName The name of the tool
   * @returns The tool schema
   */
  public getToolSchema(toolName: string): MCPToolSchema | undefined {
    return this.toolSchemas[toolName];
  }

  /**
   * Get all available tools
   * @returns The available tools
   */
  public getAvailableTools(): string[] {
    return Object.keys(this.toolSchemas);
  }

  /**
   * Call a function on a tool
   * @param toolName The name of the tool
   * @param functionName The name of the function
   * @param parameters The function parameters
   * @returns The function call result
   */
  public async callFunction(
    toolName: string,
    functionName: string,
    parameters: Record<string, any>
  ): Promise<MCPFunctionCallResult> {
    try {
      this.outputChannel.appendLine(`Calling function ${functionName} on tool ${toolName}`);
      
      // Check if tool is available
      if (!this.toolSchemas[toolName]) {
        // Try to fetch schema
        try {
          await this.fetchToolSchema(toolName);
        } catch (error) {
          throw new Error(`Tool ${toolName} is not available: ${error.message}`);
        }
      }
      
      // Check if function exists
      const functionSchema = this.toolSchemas[toolName].functions.find(f => f.name === functionName);
      if (!functionSchema) {
        throw new Error(`Function ${functionName} not found in tool ${toolName}`);
      }
      
      // Validate parameters
      this._validateParameters(parameters, functionSchema);
      
      // Get container URL
      const url = this.containerManager.getContainerUrl(toolName);
      
      // Call function
      const response = await axios.post(`${url}/invoke`, {
        function: functionName,
        parameters
      });
      
      const result = response.data;
      
      this.outputChannel.appendLine(`Function ${functionName} called successfully on tool ${toolName}`);
      
      return result;
    } catch (error) {
      this.outputChannel.appendLine(`Error calling function ${functionName} on tool ${toolName}: ${error.message}`);
      
      return {
        status: 'error',
        error: error.message
      };
    }
  }

  /**
   * Validate function parameters
   * @param parameters The parameters to validate
   * @param functionSchema The function schema
   */
  private _validateParameters(parameters: Record<string, any>, functionSchema: MCPFunctionSchema): void {
    // Check required parameters
    for (const requiredParam of functionSchema.parameters.required) {
      if (parameters[requiredParam] === undefined) {
        throw new Error(`Missing required parameter: ${requiredParam}`);
      }
    }
    
    // Check parameter types
    for (const paramName in parameters) {
      const paramSchema = functionSchema.parameters.properties[paramName];
      
      if (!paramSchema) {
        throw new Error(`Unknown parameter: ${paramName}`);
      }
      
      // Basic type checking
      const paramValue = parameters[paramName];
      const paramType = paramSchema.type;
      
      if (paramType === 'string' && typeof paramValue !== 'string') {
        throw new Error(`Parameter ${paramName} should be a string`);
      } else if (paramType === 'number' && typeof paramValue !== 'number') {
        throw new Error(`Parameter ${paramName} should be a number`);
      } else if (paramType === 'boolean' && typeof paramValue !== 'boolean') {
        throw new Error(`Parameter ${paramName} should be a boolean`);
      } else if (paramType === 'array' && !Array.isArray(paramValue)) {
        throw new Error(`Parameter ${paramName} should be an array`);
      } else if (paramType === 'object' && (typeof paramValue !== 'object' || paramValue === null || Array.isArray(paramValue))) {
        throw new Error(`Parameter ${paramName} should be an object`);
      }
      
      // Check enum values
      if (paramSchema.enum && !paramSchema.enum.includes(paramValue)) {
        throw new Error(`Parameter ${paramName} should be one of: ${paramSchema.enum.join(', ')}`);
      }
    }
  }

  /**
   * Dispose of resources
   */
  public dispose(): void {
    this.outputChannel.dispose();
  }
}

```


---

### File: `archive/vscode-extension/src/context/fileIndexer.js`

```javascript
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileIndexer = void 0;
const vscode = __importStar(require("vscode"));
const symbolExtractor_1 = require("./symbolExtractor");
class FileIndexer {
    constructor(symbolExtractor, embeddingService, vectorStore) {
        this.symbolExtractor = symbolExtractor;
        this.embeddingService = embeddingService;
        this.vectorStore = vectorStore;
        // Create status bar item
        this.indexingStatus = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 100);
        // Set up file watcher
        this.fileWatcher = vscode.workspace.createFileSystemWatcher('**/*.*');
        this.fileWatcher.onDidChange(this.handleFileChange.bind(this));
        this.fileWatcher.onDidCreate(this.handleFileCreate.bind(this));
        this.fileWatcher.onDidDelete(this.handleFileDelete.bind(this));
    }
    /**
     * Index the entire workspace
     */
    async indexWorkspace() {
        this.indexingStatus.text = '$(sync~spin) Indexing workspace...';
        this.indexingStatus.show();
        try {
            // Expanded file pattern to include more languages
            const files = await vscode.workspace.findFiles('**/*.{js,ts,jsx,tsx,py,java,c,cpp,h,hpp,cs,go,rb,php,rs,swift,kt,html,css,scss,sass,json,yaml,yml,xml,md}', '{**/node_modules/**,**/dist/**,**/build/**,**/.git/**,**/venv/**,**/__pycache__/**}');
            let processedFiles = 0;
            const totalFiles = files.length;
            // Process files in batches to avoid blocking the UI
            const batchSize = 20;
            for (let i = 0; i < totalFiles; i += batchSize) {
                const batch = files.slice(i, i + batchSize);
                // Process batch in parallel
                await Promise.all(batch.map(file => this.indexFile(file)));
                processedFiles += batch.length;
                this.indexingStatus.text = `$(sync~spin) Indexing workspace... ${processedFiles}/${totalFiles}`;
                // Yield to the event loop to keep the UI responsive
                await new Promise(resolve => setTimeout(resolve, 0));
            }
            this.indexingStatus.text = `$(check) Workspace indexed (${totalFiles} files)`;
            setTimeout(() => {
                this.indexingStatus.hide();
            }, 3000);
        }
        catch (error) {
            this.indexingStatus.text = '$(error) Indexing failed';
            console.error('Error indexing workspace:', error);
        }
    }
    /**
     * Index a single file
     * @param uri File URI
     */
    async indexFile(uri) {
        try {
            // Get file path
            const filePath = uri.fsPath;
            // Try to detect language from file extension
            let language = symbolExtractor_1.SymbolExtractor.detectLanguageFromPath(filePath);
            // If we can't detect the language from the path, try to open the document
            if (!language) {
                try {
                    const document = await vscode.workspace.openTextDocument(uri);
                    language = document.languageId;
                }
                catch (e) {
                    // If we can't open the document, use a generic language
                    language = 'text';
                }
            }
            // Read file content
            let content;
            try {
                const document = await vscode.workspace.openTextDocument(uri);
                content = document.getText();
            }
            catch (e) {
                // If we can't open the document, skip this file
                console.warn(`Skipping file ${filePath}: Unable to read content`);
                return;
            }
            // Skip empty files or files that are too large
            if (content.length === 0) {
                console.log(`Skipping empty file: ${filePath}`);
                return;
            }
            if (content.length > 1000000) {
                console.log(`Skipping large file (${content.length} bytes): ${filePath}`);
                return;
            }
            // Skip binary files
            if (this.isBinaryContent(content)) {
                console.log(`Skipping binary file: ${filePath}`);
                return;
            }
            // Split file into chunks
            const chunks = this.chunkFile(content, filePath, language);
            // Process each chunk
            for (const chunk of chunks) {
                try {
                    // Extract symbols
                    const { symbols, imports, dependencies } = await this.symbolExtractor.extractSymbols(chunk.content, language);
                    chunk.symbols = symbols;
                    chunk.imports = imports;
                    // Generate embedding
                    chunk.embedding = await this.embeddingService.generateEmbedding(chunk.content);
                    // Add to vector store
                    await this.vectorStore.addChunk(chunk);
                }
                catch (chunkError) {
                    console.error(`Error processing chunk ${chunk.id}:`, chunkError);
                }
            }
        }
        catch (error) {
            console.error(`Error indexing file ${uri.fsPath}:`, error);
        }
    }
    /**
     * Check if content appears to be binary
     * @param content File content
     * @returns True if the content appears to be binary
     */
    isBinaryContent(content) {
        // Check for null bytes or a high percentage of non-printable characters
        if (content.includes('\0')) {
            return true;
        }
        // Check the first 1000 characters
        const sampleSize = Math.min(1000, content.length);
        const sample = content.substring(0, sampleSize);
        // Count non-printable characters
        let nonPrintableCount = 0;
        for (let i = 0; i < sample.length; i++) {
            const charCode = sample.charCodeAt(i);
            if ((charCode < 32 && charCode !== 9 && charCode !== 10 && charCode !== 13) || charCode > 126) {
                nonPrintableCount++;
            }
        }
        // If more than 10% of characters are non-printable, consider it binary
        return nonPrintableCount > sampleSize * 0.1;
    }
    /**
     * Split a file into chunks based on its content and language
     * @param content File content
     * @param filePath File path
     * @param language Language ID
     * @returns Array of code chunks
     */
    chunkFile(content, filePath, language) {
        const chunks = [];
        const lines = content.split('\n');
        // For very small files, use a single chunk
        if (lines.length <= 50) {
            chunks.push({
                id: `${filePath}:0-${lines.length}`,
                filePath,
                content,
                startLine: 0,
                endLine: lines.length,
                symbols: [],
                imports: [],
                language
            });
            return chunks;
        }
        // For medium-sized files, use a single chunk if it's not code
        if (lines.length <= 200 && this.isDataOrDocFile(language)) {
            chunks.push({
                id: `${filePath}:0-${lines.length}`,
                filePath,
                content,
                startLine: 0,
                endLine: lines.length,
                symbols: [],
                imports: [],
                language
            });
            return chunks;
        }
        // For larger files, use language-specific chunking
        switch (language) {
            case 'javascript':
            case 'typescript':
            case 'javascriptreact':
            case 'typescriptreact':
                return this.chunkJavaScriptFile(content, filePath, language, lines);
            case 'python':
                return this.chunkPythonFile(content, filePath, language, lines);
            case 'java':
            case 'csharp':
            case 'cpp':
            case 'c':
                return this.chunkCStyleFile(content, filePath, language, lines);
            default:
                return this.chunkGenericFile(content, filePath, language, lines);
        }
    }
    /**
     * Check if the file is a data or documentation file
     * @param language Language ID
     * @returns True if the file is a data or documentation file
     */
    isDataOrDocFile(language) {
        return ['json', 'yaml', 'xml', 'markdown', 'html', 'css', 'scss', 'sass'].includes(language);
    }
    /**
     * Chunk a JavaScript/TypeScript file
     */
    chunkJavaScriptFile(content, filePath, language, lines) {
        const chunks = [];
        let chunkStart = 0;
        let braceBalance = 0;
        let inFunction = false;
        let inClass = false;
        // Always include imports in the first chunk
        let importsEndLine = 0;
        for (let i = 0; i < Math.min(50, lines.length); i++) {
            if (lines[i].includes('import ') || lines[i].includes('require(')) {
                importsEndLine = i + 1;
            }
        }
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();
            // Track brace balance
            braceBalance += (line.match(/{/g) || []).length;
            braceBalance -= (line.match(/}/g) || []).length;
            // Detect function or class start
            if (!inFunction && !inClass) {
                if (line.includes('function ') || line.includes('=>') || line.includes('class ')) {
                    inFunction = line.includes('function ') || line.includes('=>');
                    inClass = line.includes('class ');
                }
            }
            // Check if we should end the current chunk
            const isBlockEnd = (braceBalance === 0 && (inFunction || inClass)) ||
                i === lines.length - 1;
            if (isBlockEnd || (i - chunkStart > 200)) {
                // Create a chunk
                const chunkEndLine = i + 1;
                const chunkContent = lines.slice(chunkStart, chunkEndLine).join('\n');
                // For the first chunk, include imports
                if (chunkStart === 0 && importsEndLine > 0 && chunkStart !== importsEndLine) {
                    const importsContent = lines.slice(0, importsEndLine).join('\n');
                    chunks.push({
                        id: `${filePath}:0-${importsEndLine}`,
                        filePath,
                        content: importsContent,
                        startLine: 0,
                        endLine: importsEndLine,
                        symbols: [],
                        imports: [],
                        language
                    });
                    // If the first chunk is just imports, continue to the next chunk
                    if (chunkEndLine <= importsEndLine) {
                        chunkStart = chunkEndLine;
                        inFunction = false;
                        inClass = false;
                        continue;
                    }
                }
                chunks.push({
                    id: `${filePath}:${chunkStart}-${chunkEndLine}`,
                    filePath,
                    content: chunkContent,
                    startLine: chunkStart,
                    endLine: chunkEndLine,
                    symbols: [],
                    imports: [],
                    language
                });
                chunkStart = chunkEndLine;
                inFunction = false;
                inClass = false;
            }
        }
        return chunks;
    }
    /**
     * Chunk a Python file
     */
    chunkPythonFile(content, filePath, language, lines) {
        const chunks = [];
        let chunkStart = 0;
        let indentLevel = 0;
        let inFunction = false;
        let inClass = false;
        // Always include imports in the first chunk
        let importsEndLine = 0;
        for (let i = 0; i < Math.min(50, lines.length); i++) {
            if (lines[i].includes('import ') || lines[i].includes('from ')) {
                importsEndLine = i + 1;
            }
        }
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            const trimmedLine = line.trim();
            // Skip empty lines and comments
            if (trimmedLine === '' || trimmedLine.startsWith('#')) {
                continue;
            }
            // Calculate indent level
            const currentIndent = line.length - line.trimStart().length;
            // Detect function or class start
            if (currentIndent === 0 && !inFunction && !inClass) {
                if (trimmedLine.startsWith('def ') || trimmedLine.startsWith('class ')) {
                    inFunction = trimmedLine.startsWith('def ');
                    inClass = trimmedLine.startsWith('class ');
                    indentLevel = currentIndent;
                }
            }
            // Check if we should end the current chunk
            const isBlockEnd = (currentIndent <= indentLevel && (inFunction || inClass) && i > chunkStart) ||
                i === lines.length - 1;
            if (isBlockEnd || (i - chunkStart > 200)) {
                // Create a chunk
                const chunkEndLine = i;
                const chunkContent = lines.slice(chunkStart, chunkEndLine).join('\n');
                // For the first chunk, include imports
                if (chunkStart === 0 && importsEndLine > 0 && chunkStart !== importsEndLine) {
                    const importsContent = lines.slice(0, importsEndLine).join('\n');
                    chunks.push({
                        id: `${filePath}:0-${importsEndLine}`,
                        filePath,
                        content: importsContent,
                        startLine: 0,
                        endLine: importsEndLine,
                        symbols: [],
                        imports: [],
                        language
                    });
                    // If the first chunk is just imports, continue to the next chunk
                    if (chunkEndLine <= importsEndLine) {
                        chunkStart = chunkEndLine;
                        inFunction = false;
                        inClass = false;
                        indentLevel = 0;
                        continue;
                    }
                }
                chunks.push({
                    id: `${filePath}:${chunkStart}-${chunkEndLine}`,
                    filePath,
                    content: chunkContent,
                    startLine: chunkStart,
                    endLine: chunkEndLine,
                    symbols: [],
                    imports: [],
                    language
                });
                chunkStart = chunkEndLine;
                inFunction = false;
                inClass = false;
                indentLevel = 0;
            }
        }
        // Handle the case where the file ends without a block end
        if (chunkStart < lines.length) {
            const chunkContent = lines.slice(chunkStart).join('\n');
            chunks.push({
                id: `${filePath}:${chunkStart}-${lines.length}`,
                filePath,
                content: chunkContent,
                startLine: chunkStart,
                endLine: lines.length,
                symbols: [],
                imports: [],
                language
            });
        }
        return chunks;
    }
    /**
     * Chunk a C-style file (Java, C#, C, C++)
     */
    chunkCStyleFile(content, filePath, language, lines) {
        const chunks = [];
        let chunkStart = 0;
        let braceBalance = 0;
        let inFunction = false;
        let inClass = false;
        // Always include imports/includes in the first chunk
        let importsEndLine = 0;
        for (let i = 0; i < Math.min(50, lines.length); i++) {
            if (lines[i].includes('import ') || lines[i].includes('#include ') ||
                lines[i].includes('using ') || lines[i].includes('package ')) {
                importsEndLine = i + 1;
            }
        }
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();
            // Track brace balance
            braceBalance += (line.match(/{/g) || []).length;
            braceBalance -= (line.match(/}/g) || []).length;
            // Detect function or class start
            if (!inFunction && !inClass && braceBalance === 0) {
                if ((line.includes('(') && line.includes(')') && !line.includes(';')) ||
                    line.includes('class ') || line.includes('interface ') ||
                    line.includes('struct ') || line.includes('enum ')) {
                    inFunction = line.includes('(') && line.includes(')') && !line.includes(';');
                    inClass = line.includes('class ') || line.includes('interface ') ||
                        line.includes('struct ') || line.includes('enum ');
                }
            }
            // Check if we should end the current chunk
            const isBlockEnd = (braceBalance === 0 && (inFunction || inClass) && i > chunkStart) ||
                i === lines.length - 1;
            if (isBlockEnd || (i - chunkStart > 200)) {
                // Create a chunk
                const chunkEndLine = i + 1;
                const chunkContent = lines.slice(chunkStart, chunkEndLine).join('\n');
                // For the first chunk, include imports
                if (chunkStart === 0 && importsEndLine > 0 && chunkStart !== importsEndLine) {
                    const importsContent = lines.slice(0, importsEndLine).join('\n');
                    chunks.push({
                        id: `${filePath}:0-${importsEndLine}`,
                        filePath,
                        content: importsContent,
                        startLine: 0,
                        endLine: importsEndLine,
                        symbols: [],
                        imports: [],
                        language
                    });
                    // If the first chunk is just imports, continue to the next chunk
                    if (chunkEndLine <= importsEndLine) {
                        chunkStart = chunkEndLine;
                        inFunction = false;
                        inClass = false;
                        braceBalance = 0;
                        continue;
                    }
                }
                chunks.push({
                    id: `${filePath}:${chunkStart}-${chunkEndLine}`,
                    filePath,
                    content: chunkContent,
                    startLine: chunkStart,
                    endLine: chunkEndLine,
                    symbols: [],
                    imports: [],
                    language
                });
                chunkStart = chunkEndLine;
                inFunction = false;
                inClass = false;
                braceBalance = 0;
            }
        }
        return chunks;
    }
    /**
     * Chunk a generic file (fallback for unsupported languages)
     */
    chunkGenericFile(content, filePath, language, lines) {
        const chunks = [];
        const maxChunkSize = 100; // lines
        // For data files, use larger chunks
        const chunkSize = this.isDataOrDocFile(language) ? 200 : maxChunkSize;
        for (let i = 0; i < lines.length; i += chunkSize) {
            const chunkEndLine = Math.min(i + chunkSize, lines.length);
            const chunkContent = lines.slice(i, chunkEndLine).join('\n');
            chunks.push({
                id: `${filePath}:${i}-${chunkEndLine}`,
                filePath,
                content: chunkContent,
                startLine: i,
                endLine: chunkEndLine,
                symbols: [],
                imports: [],
                language
            });
        }
        return chunks;
    }
    async handleFileChange(uri) {
        // Delete existing chunks for this file
        await this.deleteFileChunks(uri.fsPath);
        // Re-index the file
        await this.indexFile(uri);
    }
    async handleFileCreate(uri) {
        await this.indexFile(uri);
    }
    async handleFileDelete(uri) {
        await this.deleteFileChunks(uri.fsPath);
    }
    /**
     * Delete all chunks for a file
     * @param filePath File path
     */
    async deleteFileChunks(filePath) {
        try {
            // Get all chunks from the vector store
            const allChunks = await this.vectorStore.findSimilarChunks('', 10000);
            // Filter chunks for this file
            const fileChunks = allChunks.filter(chunk => chunk.filePath === filePath);
            // Delete each chunk
            for (const chunk of fileChunks) {
                await this.vectorStore.deleteChunk(chunk.id);
            }
            console.log(`Deleted ${fileChunks.length} chunks for file: ${filePath}`);
        }
        catch (error) {
            console.error(`Error deleting chunks for file ${filePath}:`, error);
        }
    }
    dispose() {
        this.fileWatcher.dispose();
        this.indexingStatus.dispose();
    }
}
exports.FileIndexer = FileIndexer;
//# sourceMappingURL=fileIndexer.js.map
```


---

### File: `archive/vscode-extension/src/context/embeddingService.ts`

```typescript
import axios from 'axios';
import { getConfiguration } from '../configuration';

export class EmbeddingService {
  private apiEndpoint: string;
  private apiKey: string;
  
  constructor() {
    const config = getConfiguration();
    this.apiEndpoint = config.apiEndpoint;
    this.apiKey = config.apiKey;
  }
  
  public async generateEmbedding(text: string): Promise<number[]> {
    try {
      const response = await axios.post(
        `${this.apiEndpoint}/embeddings`,
        {
          input: text,
          model: 'qwen3-embedding'
        },
        {
          headers: {
            'Authorization': `Bearer ${this.apiKey}`,
            'Content-Type': 'application/json'
          }
        }
      );
      
      return response.data.data[0].embedding;
    } catch (error) {
      console.error('Error generating embedding:', error);
      throw new Error('Failed to generate embedding');
    }
  }
  
  public async generateBatchEmbeddings(texts: string[]): Promise<number[][]> {
    try {
      const response = await axios.post(
        `${this.apiEndpoint}/embeddings`,
        {
          input: texts,
          model: 'qwen3-embedding'
        },
        {
          headers: {
            'Authorization': `Bearer ${this.apiKey}`,
            'Content-Type': 'application/json'
          }
        }
      );
      
      return response.data.data.map((item: any) => item.embedding);
    } catch (error) {
      console.error('Error generating batch embeddings:', error);
      throw new Error('Failed to generate batch embeddings');
    }
  }
}

```


---

### File: `archive/vscode-extension/src/context/types.js`

```javascript
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=types.js.map
```


---

### File: `archive/vscode-extension/src/context/contextEngine.ts`

```typescript
import * as vscode from 'vscode';
import { ContextComposer } from './contextComposer';
import { DependencyGraph } from './dependencyGraph';
import { EmbeddingService } from './embeddingService';
import { FileIndexer } from './fileIndexer';
import { SemanticSearch } from './semanticSearch';
import { SymbolExtractor } from './symbolExtractor';
import { CodeChunk } from './types';
import { VectorStore } from './vectorStore';

export class ContextEngine {
  private fileIndexer: FileIndexer;
  private embeddingService: EmbeddingService;
  private vectorStore: VectorStore;
  private symbolExtractor: SymbolExtractor;
  private contextComposer: ContextComposer;
  private dependencyGraph: DependencyGraph;
  private semanticSearch: SemanticSearch;
  private isInitialized: boolean = false;

  constructor() {
    this.embeddingService = new EmbeddingService();
    this.symbolExtractor = new SymbolExtractor();

    // Get configuration for context engine
    const config = getConfiguration().contextEngine;

    // Use persistent vector store if enabled in configuration
    if (config.persistEmbeddings) {
      console.log('Using persistent vector store for embeddings');
      this.vectorStore = new PersistentVectorStore(
        this.embeddingService,
        config.databasePath || undefined,
        config.autoSaveIntervalMs
      );
    } else {
      console.log('Using in-memory vector store for embeddings');
      this.vectorStore = new VectorStore(this.embeddingService);
    }

    this.contextComposer = new ContextComposer();
    this.dependencyGraph = new DependencyGraph();
    this.semanticSearch = new SemanticSearch(this.vectorStore, this.embeddingService);
    this.fileIndexer = new FileIndexer(
      this.symbolExtractor,
      this.embeddingService,
      this.vectorStore
    );
  }

  public async initialize(): Promise<void> {
    if (this.isInitialized) {
      return;
    }

    // Initialize the persistent vector store if needed
    if (this.vectorStore instanceof PersistentVectorStore) {
      console.log('Initializing persistent vector store');
      await (this.vectorStore as PersistentVectorStore).initialize();
    }

    // Only index the workspace if the vector store is empty
    const existingChunks = await this.vectorStore.findSimilarChunks('', 10);
    if (existingChunks.length === 0) {
      console.log('Vector store is empty, indexing workspace');
      await this.fileIndexer.indexWorkspace();
    } else {
      console.log(`Found ${existingChunks.length} existing chunks in vector store, skipping indexing`);
    }

    // Build dependency graph
    const allChunks = await this.vectorStore.findSimilarChunks('', 10000);
    for (const chunk of allChunks) {
      this.dependencyGraph.addChunk(chunk);
    }
    this.dependencyGraph.buildGraph();

    this.isInitialized = true;
  }

  public async getContext(query: string, tokenLimit: number = 4000): Promise<string> {
    if (!this.isInitialized) {
      await this.initialize();
    }

    // Find relevant chunks using semantic search
    const relevantChunks = await this.semanticSearch.search(query, 10);

    // Extract symbols from the query
    const symbols = this.extractSymbolsFromQuery(query);

    // If we found symbols, add chunks related to those symbols
    if (symbols.length > 0) {
      for (const symbol of symbols) {
        const symbolChunks = await this.semanticSearch.searchBySymbol(symbol, 5);

        // Add symbol chunks to relevant chunks, avoiding duplicates
        const existingIds = new Set(relevantChunks.map(chunk => chunk.id));
        for (const chunk of symbolChunks) {
          if (!existingIds.has(chunk.id)) {
            relevantChunks.push(chunk);
            existingIds.add(chunk.id);
          }
        }
      }
    }

    // Get the active editor file path
    const activeEditor = vscode.window.activeTextEditor;
    if (activeEditor) {
      const filePath = activeEditor.document.uri.fsPath;

      // Get related files from dependency graph
      const relatedFiles = this.dependencyGraph.getRelatedFiles(filePath, 1);

      // Add chunks from related files
      for (const relatedFile of relatedFiles) {
        const fileChunks = await this.getChunksForFile(relatedFile);

        // Add file chunks to relevant chunks, avoiding duplicates
        const existingIds = new Set(relevantChunks.map(chunk => chunk.id));
        for (const chunk of fileChunks) {
          if (!existingIds.has(chunk.id)) {
            relevantChunks.push(chunk);
            existingIds.add(chunk.id);
          }
        }
      }
    }

    // Compose context
    return this.contextComposer.composeContext(query, relevantChunks, tokenLimit);
  }

  public async getContextForFile(filePath: string, tokenLimit: number = 4000): Promise<string> {
    if (!this.isInitialized) {
      await this.initialize();
    }

    // Get chunks for this file
    const fileChunks = await this.getChunksForFile(filePath);

    // Get related files from dependency graph
    const relatedFiles = this.dependencyGraph.getRelatedFiles(filePath, 1);

    // Add chunks from related files
    const allChunks = [...fileChunks];
    const existingIds = new Set(allChunks.map(chunk => chunk.id));

    for (const relatedFile of relatedFiles) {
      const relatedChunks = await this.getChunksForFile(relatedFile);

      for (const chunk of relatedChunks) {
        if (!existingIds.has(chunk.id)) {
          allChunks.push(chunk);
          existingIds.add(chunk.id);
        }
      }
    }

    // Compose context
    return this.contextComposer.composeContext(`File: ${filePath}`, allChunks, tokenLimit);
  }

  public async getContextForSymbol(symbol: string, tokenLimit: number = 4000): Promise<string> {
    if (!this.isInitialized) {
      await this.initialize();
    }

    // Find chunks related to this symbol
    const symbolChunks = await this.semanticSearch.searchBySymbol(symbol, 10);

    // Compose context
    return this.contextComposer.composeContext(`Symbol: ${symbol}`, symbolChunks, tokenLimit);
  }

  private async getChunksForFile(filePath: string): Promise<CodeChunk[]> {
    // Find chunks for this file
    const allChunks = await this.vectorStore.findSimilarChunks('', 10000);
    return allChunks.filter(chunk => chunk.filePath === filePath);
  }

  private extractSymbolsFromQuery(query: string): string[] {
    // Extract potential symbols from the query
    // This is a simplified implementation
    const words = query.split(/\s+/);
    const symbols: string[] = [];

    for (const word of words) {
      // Clean up the word
      const cleanWord = word.replace(/[^\w]/g, '');

      // Check if it looks like a symbol (camelCase, PascalCase, snake_case)
      if (cleanWord.length > 0 &&
          (cleanWord.match(/[a-z][A-Z]/) || // camelCase
           cleanWord.match(/^[A-Z][a-z]/) || // PascalCase
           cleanWord.includes('_'))) { // snake_case
        symbols.push(cleanWord);
      }
    }

    return symbols;
  }

  public async dispose(): Promise<void> {
    // Dispose the file indexer
    this.fileIndexer.dispose();

    // Dispose the persistent vector store if needed
    if (this.vectorStore instanceof PersistentVectorStore) {
      console.log('Disposing persistent vector store');
      await (this.vectorStore as PersistentVectorStore).dispose();
    }
  }
}

```


---

### File: `archive/vscode-extension/src/context/contextComposer.js`

```javascript
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContextComposer = void 0;
const path = __importStar(require("path"));
class ContextComposer {
    constructor() {
        this.MAX_TOKENS_PER_CHUNK = 1000;
    }
    async composeContext(query, relevantChunks, tokenLimit = 4000) {
        // Sort chunks by relevance (assuming they're already sorted)
        // Group chunks by file
        const chunksByFile = {};
        for (const chunk of relevantChunks) {
            if (!chunksByFile[chunk.filePath]) {
                chunksByFile[chunk.filePath] = [];
            }
            chunksByFile[chunk.filePath].push(chunk);
        }
        // Sort chunks within each file by line number
        for (const filePath in chunksByFile) {
            chunksByFile[filePath].sort((a, b) => a.startLine - b.startLine);
        }
        // Compose context
        let context = `Query: ${query}\n\n`;
        let tokenCount = this.estimateTokens(context);
        // Add file contexts until we reach the token limit
        for (const filePath in chunksByFile) {
            const fileName = path.basename(filePath);
            const fileContext = `File: ${fileName} (${filePath})\n`;
            tokenCount += this.estimateTokens(fileContext);
            if (tokenCount > tokenLimit) {
                break;
            }
            context += fileContext;
            // Add chunks from this file
            for (const chunk of chunksByFile[filePath]) {
                const chunkHeader = `Lines ${chunk.startLine}-${chunk.endLine}:\n`;
                const chunkContent = chunk.content;
                const chunkTokens = this.estimateTokens(chunkHeader + chunkContent);
                if (tokenCount + chunkTokens > tokenLimit) {
                    // If adding this chunk would exceed the token limit, skip it
                    continue;
                }
                context += chunkHeader + chunkContent + '\n\n';
                tokenCount += chunkTokens;
            }
            context += '\n';
        }
        // Add a summary of symbols found in the context
        const allSymbols = new Set();
        const allImports = new Set();
        for (const chunk of relevantChunks) {
            chunk.symbols.forEach(symbol => allSymbols.add(symbol));
            chunk.imports.forEach(imp => allImports.add(imp));
        }
        const symbolSummary = `Symbols: ${Array.from(allSymbols).join(', ')}\n`;
        const importSummary = `Imports: ${Array.from(allImports).join(', ')}\n`;
        if (tokenCount + this.estimateTokens(symbolSummary + importSummary) <= tokenLimit) {
            context += '\nSummary:\n' + symbolSummary + importSummary;
        }
        return context;
    }
    estimateTokens(text) {
        // A very rough estimate: 1 token  4 characters
        return Math.ceil(text.length / 4);
    }
}
exports.ContextComposer = ContextComposer;
//# sourceMappingURL=contextComposer.js.map
```


---

### File: `archive/vscode-extension/src/context/vectorStore.js`

```javascript
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VectorStore = void 0;
class VectorStore {
    constructor(embeddingService) {
        this.chunks = [];
        this.embeddingService = embeddingService;
    }
    async addChunk(chunk) {
        // If the chunk doesn't have an embedding, generate one
        if (!chunk.embedding) {
            chunk.embedding = await this.embeddingService.generateEmbedding(chunk.content);
        }
        // Check if chunk already exists (by ID)
        const existingIndex = this.chunks.findIndex(c => c.id === chunk.id);
        if (existingIndex >= 0) {
            // Replace existing chunk
            this.chunks[existingIndex] = chunk;
        }
        else {
            // Add new chunk
            this.chunks.push(chunk);
        }
    }
    async findSimilarChunks(query, limit = 5) {
        // Generate embedding for the query
        const queryEmbedding = await this.embeddingService.generateEmbedding(query);
        // Find similar chunks
        return this.findSimilarChunksByEmbedding(queryEmbedding, limit);
    }
    async findSimilarChunksByEmbedding(embedding, limit = 5) {
        // Calculate cosine similarity for each chunk
        const chunksWithSimilarity = this.chunks.map(chunk => {
            const similarity = this.cosineSimilarity(embedding, chunk.embedding);
            return { chunk, similarity };
        });
        // Sort by similarity (descending)
        chunksWithSimilarity.sort((a, b) => b.similarity - a.similarity);
        // Return top N chunks
        return chunksWithSimilarity.slice(0, limit).map(item => item.chunk);
    }
    async deleteChunk(id) {
        this.chunks = this.chunks.filter(chunk => chunk.id !== id);
    }
    async clear() {
        this.chunks = [];
    }
    cosineSimilarity(a, b) {
        if (a.length !== b.length) {
            throw new Error('Vectors must have the same length');
        }
        let dotProduct = 0;
        let normA = 0;
        let normB = 0;
        for (let i = 0; i < a.length; i++) {
            dotProduct += a[i] * b[i];
            normA += a[i] * a[i];
            normB += b[i] * b[i];
        }
        return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
    }
}
exports.VectorStore = VectorStore;
//# sourceMappingURL=vectorStore.js.map
```


---

### File: `archive/vscode-extension/src/context/symbolExtractor.ts`

```typescript

/**
 * Language-specific symbol extractor for code files.
 * Extracts symbols, imports, and dependencies from code content.
 */
export class SymbolExtractor {
  // Map of file extensions to language IDs
  private static readonly extensionToLanguage: Record<string, string> = {
    // JavaScript/TypeScript
    '.js': 'javascript',
    '.jsx': 'javascriptreact',
    '.ts': 'typescript',
    '.tsx': 'typescriptreact',
    // Python
    '.py': 'python',
    '.pyw': 'python',
    '.ipynb': 'python',
    // Java
    '.java': 'java',
    // C/C++
    '.c': 'c',
    '.cpp': 'cpp',
    '.cc': 'cpp',
    '.h': 'c',
    '.hpp': 'cpp',
    // C#
    '.cs': 'csharp',
    // Go
    '.go': 'go',
    // Ruby
    '.rb': 'ruby',
    // PHP
    '.php': 'php',
    // Rust
    '.rs': 'rust',
    // Swift
    '.swift': 'swift',
    // Kotlin
    '.kt': 'kotlin',
    // HTML/CSS
    '.html': 'html',
    '.css': 'css',
    '.scss': 'scss',
    '.sass': 'sass',
    // Other
    '.json': 'json',
    '.xml': 'xml',
    '.yaml': 'yaml',
    '.yml': 'yaml',
    '.md': 'markdown'
  };

  /**
   * Detect language from file extension
   * @param filePath Path to the file
   * @returns Language ID or undefined if not detected
   */
  public static detectLanguageFromPath(filePath: string): string | undefined {
    const extension = filePath.substring(filePath.lastIndexOf('.')).toLowerCase();
    return SymbolExtractor.extensionToLanguage[extension];
  }

  /**
   * Extract symbols, imports, and dependencies from code content
   * @param content Code content
   * @param language Language ID
   * @returns Object containing symbols, imports, and dependencies
   */
  public async extractSymbols(content: string, language: string): Promise<{
    symbols: string[];
    imports: string[];
    dependencies: string[];
  }> {
    const symbols: string[] = [];
    const imports: string[] = [];
    const dependencies: string[] = [];

    // Extract based on language
    switch (language) {
      // JavaScript family
      case 'javascript':
      case 'typescript':
      case 'javascriptreact':
      case 'typescriptreact':
        this.extractJavaScriptSymbols(content, symbols, imports, dependencies);
        break;

      // Python
      case 'python':
        this.extractPythonSymbols(content, symbols, imports, dependencies);
        break;

      // Java
      case 'java':
        this.extractJavaSymbols(content, symbols, imports, dependencies);
        break;

      // C/C++
      case 'c':
      case 'cpp':
        this.extractCppSymbols(content, symbols, imports, dependencies);
        break;

      // C#
      case 'csharp':
        this.extractCSharpSymbols(content, symbols, imports, dependencies);
        break;

      // Go
      case 'go':
        this.extractGoSymbols(content, symbols, imports, dependencies);
        break;

      // Ruby
      case 'ruby':
        this.extractRubySymbols(content, symbols, imports, dependencies);
        break;

      // PHP
      case 'php':
        this.extractPhpSymbols(content, symbols, imports, dependencies);
        break;

      // Rust
      case 'rust':
        this.extractRustSymbols(content, symbols, imports, dependencies);
        break;

      // Swift
      case 'swift':
        this.extractSwiftSymbols(content, symbols, imports, dependencies);
        break;

      // Kotlin
      case 'kotlin':
        this.extractKotlinSymbols(content, symbols, imports, dependencies);
        break;

      // HTML/CSS
      case 'html':
      case 'css':
      case 'scss':
      case 'sass':
        this.extractWebSymbols(content, symbols, imports, dependencies, language);
        break;

      // Data formats
      case 'json':
      case 'yaml':
      case 'xml':
        this.extractDataFormatSymbols(content, symbols, imports, dependencies, language);
        break;

      // Default fallback
      default:
        // Use regex-based fallback for unknown languages
        this.extractGenericSymbols(content, symbols, imports, dependencies);
    }

    // Remove duplicates
    return {
      symbols: [...new Set(symbols)],
      imports: [...new Set(imports)],
      dependencies: [...new Set(dependencies)]
    };
  }

  /**
   * Extract symbols from JavaScript/TypeScript code
   */
  private extractJavaScriptSymbols(
    content: string,
    symbols: string[],
    imports: string[],
    dependencies: string[]
  ): void {
    // Extract function declarations (both regular and arrow functions)
    const functionRegex = /(?:function\s+([a-zA-Z_$][a-zA-Z0-9_$]*)|(?:const|let|var)\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\s*=\s*(?:async\s*)?\([^)]*\)\s*=>)/g;
    let match;
    while ((match = functionRegex.exec(content)) !== null) {
      if (match[1]) {
        symbols.push(match[1]);
      } else if (match[2]) {
        symbols.push(match[2]);
      }
    }

    // Extract class declarations
    const classRegex = /class\s+([a-zA-Z_$][a-zA-Z0-9_$]*)/g;
    while ((match = classRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract method declarations
    const methodRegex = /(?:async\s+)?([a-zA-Z_$][a-zA-Z0-9_$]*)\s*\([^)]*\)\s*{/g;
    while ((match = methodRegex.exec(content)) !== null) {
      // Filter out common keywords that might be matched
      const keywords = ['if', 'for', 'while', 'switch', 'catch'];
      if (!keywords.includes(match[1])) {
        symbols.push(match[1]);
      }
    }

    // Extract variable declarations
    const varRegex = /(?:const|let|var)\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\s*(?:[=;]|$)/g;
    while ((match = varRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract interface and type declarations (TypeScript)
    const typeRegex = /(?:interface|type)\s+([a-zA-Z_$][a-zA-Z0-9_$]*)/g;
    while ((match = typeRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract imports (ES modules)
    const importRegex = /import\s+(?:{([^}]*)}\s+from\s+['"]([^'"]+)['"]|.*?from\s+['"]([^'"]+)['"])/g;
    while ((match = importRegex.exec(content)) !== null) {
      // Extract the module path
      const modulePath = match[2] || match[3];
      if (modulePath) {
        imports.push(modulePath);
        dependencies.push(modulePath);
      }

      // Extract named imports if available
      if (match[1]) {
        const namedImports = match[1].split(',').map(s => s.trim());
        for (const namedImport of namedImports) {
          // Handle "as" aliases
          const importName = namedImport.split(' as ')[0].trim();
          if (importName) {
            symbols.push(importName);
          }
        }
      }
    }

    // Extract CommonJS requires
    const requireRegex = /(?:const|let|var)\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\s*=\s*require\s*\(\s*['"]([^'"]+)['"]\s*\)/g;
    while ((match = requireRegex.exec(content)) !== null) {
      symbols.push(match[1]); // The variable name
      imports.push(match[2]); // The module path
      dependencies.push(match[2]);
    }
  }

  /**
   * Extract symbols from Python code
   */
  private extractPythonSymbols(
    content: string,
    symbols: string[],
    imports: string[],
    dependencies: string[]
  ): void {
    // Extract function declarations
    const functionRegex = /def\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/g;
    let match;
    while ((match = functionRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract class declarations
    const classRegex = /class\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*(?:\(|:)/g;
    while ((match = classRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract variable assignments (global level)
    const varRegex = /^([A-Z_][A-Z0-9_]*)\s*=/gm;
    while ((match = varRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract imports - from X import Y
    const fromImportRegex = /from\s+([a-zA-Z0-9_.]+)\s+import\s+([^#\n]+)/g;
    while ((match = fromImportRegex.exec(content)) !== null) {
      const module = match[1];
      imports.push(module);
      dependencies.push(module);

      // Extract imported symbols
      const importedSymbols = match[2].split(',').map(s => s.trim());
      for (const importedSymbol of importedSymbols) {
        // Handle "as" aliases
        const symbolName = importedSymbol.split(' as ')[0].trim();
        if (symbolName && symbolName !== '*') {
          symbols.push(symbolName);
        }
      }
    }

    // Extract imports - import X
    const importRegex = /import\s+([^#\n]+)/g;
    while ((match = importRegex.exec(content)) !== null) {
      const importedModules = match[1].split(',').map(s => s.trim());
      for (const importedModule of importedModules) {
        // Handle "as" aliases
        const moduleName = importedModule.split(' as ')[0].trim();
        if (moduleName) {
          imports.push(moduleName);
          dependencies.push(moduleName);

          // Also add the module name as a symbol (since it can be used directly)
          const alias = importedModule.includes(' as ')
            ? importedModule.split(' as ')[1].trim()
            : moduleName.split('.').pop() || '';
          if (alias) {
            symbols.push(alias);
          }
        }
      }
    }

    // Extract decorated functions and classes
    const decoratorRegex = /@[^\n]+\s+(?:def|class)\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
    while ((match = decoratorRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }
  }

  /**
   * Extract symbols from Java code
   */
  private extractJavaSymbols(
    content: string,
    symbols: string[],
    imports: string[],
    dependencies: string[]
  ): void {
    // Extract class and interface declarations
    const classRegex = /(?:public|private|protected)?\s*(?:abstract|final)?\s*(?:class|interface|enum)\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
    let match;
    while ((match = classRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract method declarations
    const methodRegex = /(?:public|private|protected)?\s*(?:static|final|abstract)?\s*(?:<[^>]+>\s*)?(?:[a-zA-Z_][a-zA-Z0-9_.<>]*)\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/g;
    while ((match = methodRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract field declarations
    const fieldRegex = /(?:public|private|protected)?\s*(?:static|final)?\s*(?:[a-zA-Z_][a-zA-Z0-9_.<>]*)\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*(?:=|;)/g;
    while ((match = fieldRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract imports
    const importRegex = /import\s+([a-zA-Z0-9_.]+(?:\.[a-zA-Z0-9_*]+)*);/g;
    while ((match = importRegex.exec(content)) !== null) {
      imports.push(match[1]);
      dependencies.push(match[1]);
    }

    // Extract package declaration
    const packageRegex = /package\s+([a-zA-Z0-9_.]+);/g;
    while ((match = packageRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }
  }

  /**
   * Extract symbols from C/C++ code
   */
  private extractCppSymbols(
    content: string,
    symbols: string[],
    imports: string[],
    dependencies: string[]
  ): void {
    // Extract function declarations
    const functionRegex = /(?:(?:static|inline|extern|const)\s+)*(?:[a-zA-Z_][a-zA-Z0-9_:]*\s+)+([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/g;
    let match;
    while ((match = functionRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract class/struct/enum declarations
    const classRegex = /(?:class|struct|enum|union)\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
    while ((match = classRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract namespace declarations
    const namespaceRegex = /namespace\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
    while ((match = namespaceRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract #include directives
    const includeRegex = /#include\s+[<"]([^>"]+)[>"]/g;
    while ((match = includeRegex.exec(content)) !== null) {
      imports.push(match[1]);
      dependencies.push(match[1]);
    }

    // Extract typedefs
    const typedefRegex = /typedef\s+(?:[a-zA-Z_][a-zA-Z0-9_:]*\s+)+([a-zA-Z_][a-zA-Z0-9_]*)/g;
    while ((match = typedefRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract #define macros
    const defineRegex = /#define\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
    while ((match = defineRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }
  }

  /**
   * Extract symbols from C# code
   */
  private extractCSharpSymbols(
    content: string,
    symbols: string[],
    imports: string[],
    dependencies: string[]
  ): void {
    // Extract class, interface, struct, enum declarations
    const classRegex = /(?:public|private|protected|internal)?\s*(?:abstract|sealed|static)?\s*(?:class|interface|struct|enum|record)\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
    let match;
    while ((match = classRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract method declarations
    const methodRegex = /(?:public|private|protected|internal)?\s*(?:static|virtual|abstract|override|sealed)?\s*(?:[a-zA-Z_][a-zA-Z0-9_.<>]*)\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/g;
    while ((match = methodRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract property declarations
    const propertyRegex = /(?:public|private|protected|internal)?\s*(?:static|virtual|abstract|override|sealed)?\s*(?:[a-zA-Z_][a-zA-Z0-9_.<>]*)\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*\{/g;
    while ((match = propertyRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract using directives
    const usingRegex = /using\s+([a-zA-Z0-9_.]+);/g;
    while ((match = usingRegex.exec(content)) !== null) {
      imports.push(match[1]);
      dependencies.push(match[1]);
    }

    // Extract namespace declarations
    const namespaceRegex = /namespace\s+([a-zA-Z0-9_.]+)/g;
    while ((match = namespaceRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }
  }

  /**
   * Extract symbols from Go code
   */
  private extractGoSymbols(
    content: string,
    symbols: string[],
    imports: string[],
    dependencies: string[]
  ): void {
    // Extract function declarations
    const functionRegex = /func\s+(?:\([^)]*\)\s+)?([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/g;
    let match;
    while ((match = functionRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract type declarations
    const typeRegex = /type\s+([a-zA-Z_][a-zA-Z0-9_]*)\s+(?:struct|interface|[a-zA-Z_][a-zA-Z0-9_]*)/g;
    while ((match = typeRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract const declarations
    const constRegex = /const\s+([a-zA-Z_][a-zA-Z0-9_]*)\s+/g;
    while ((match = constRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract var declarations
    const varRegex = /var\s+([a-zA-Z_][a-zA-Z0-9_]*)\s+/g;
    while ((match = varRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract imports
    const importRegex = /import\s+(?:\(\s*((?:[^)]+))\s*\)|["']([^"']+)["'])/g;
    while ((match = importRegex.exec(content)) !== null) {
      if (match[1]) {
        // Multi-line import
        const importLines = match[1].split('\n');
        for (const line of importLines) {
          const importMatch = line.match(/["']([^"']+)["']/);
          if (importMatch) {
            imports.push(importMatch[1]);
            dependencies.push(importMatch[1]);
          }
        }
      } else if (match[2]) {
        // Single import
        imports.push(match[2]);
        dependencies.push(match[2]);
      }
    }

    // Extract package declaration
    const packageRegex = /package\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
    while ((match = packageRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }
  }

  /**
   * Extract symbols from Ruby code
   */
  private extractRubySymbols(
    content: string,
    symbols: string[],
    imports: string[],
    dependencies: string[]
  ): void {
    // Extract class declarations
    const classRegex = /class\s+([A-Z][a-zA-Z0-9_]*)/g;
    let match;
    while ((match = classRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract module declarations
    const moduleRegex = /module\s+([A-Z][a-zA-Z0-9_]*)/g;
    while ((match = moduleRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract method declarations
    const methodRegex = /def\s+(?:self\.)?([a-zA-Z_][a-zA-Z0-9_?!]*)/g;
    while ((match = methodRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract constant declarations
    const constRegex = /([A-Z][A-Z0-9_]*)\s*=/g;
    while ((match = constRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract requires
    const requireRegex = /require\s+['"]([^'"]+)['"]/g;
    while ((match = requireRegex.exec(content)) !== null) {
      imports.push(match[1]);
      dependencies.push(match[1]);
    }

    // Extract includes
    const includeRegex = /include\s+([A-Z][a-zA-Z0-9_]*)/g;
    while ((match = includeRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }
  }

  /**
   * Extract symbols from PHP code
   */
  private extractPhpSymbols(
    content: string,
    symbols: string[],
    imports: string[],
    dependencies: string[]
  ): void {
    // Extract class declarations
    const classRegex = /class\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
    let match;
    while ((match = classRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract interface declarations
    const interfaceRegex = /interface\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
    while ((match = interfaceRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract function declarations
    const functionRegex = /function\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/g;
    while ((match = functionRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract method declarations
    const methodRegex = /(?:public|private|protected)?\s*(?:static)?\s*function\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/g;
    while ((match = methodRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract namespace declarations
    const namespaceRegex = /namespace\s+([a-zA-Z_][a-zA-Z0-9_\\]*)/g;
    while ((match = namespaceRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract use statements (imports)
    const useRegex = /use\s+([a-zA-Z_][a-zA-Z0-9_\\]*)/g;
    while ((match = useRegex.exec(content)) !== null) {
      imports.push(match[1]);
      dependencies.push(match[1]);
    }

    // Extract require/include statements
    const requireRegex = /(?:require|include)(?:_once)?\s*\(\s*['"]([^'"]+)['"]\s*\)/g;
    while ((match = requireRegex.exec(content)) !== null) {
      imports.push(match[1]);
      dependencies.push(match[1]);
    }
  }

  /**
   * Extract symbols from Rust code
   */
  private extractRustSymbols(
    content: string,
    symbols: string[],
    imports: string[],
    dependencies: string[]
  ): void {
    // Extract function declarations
    const functionRegex = /fn\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*(?:<[^>]*>)?\s*\(/g;
    let match;
    while ((match = functionRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract struct declarations
    const structRegex = /struct\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
    while ((match = structRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract enum declarations
    const enumRegex = /enum\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
    while ((match = enumRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract trait declarations
    const traitRegex = /trait\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
    while ((match = traitRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract impl blocks
    const implRegex = /impl(?:<[^>]*>)?\s+(?:[^{]*\s+)?([a-zA-Z_][a-zA-Z0-9_]*)/g;
    while ((match = implRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract const declarations
    const constRegex = /const\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*:/g;
    while ((match = constRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract static declarations
    const staticRegex = /static\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*:/g;
    while ((match = staticRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract use statements (imports)
    const useRegex = /use\s+([a-zA-Z0-9_:{}]+);/g;
    while ((match = useRegex.exec(content)) !== null) {
      imports.push(match[1]);
      dependencies.push(match[1]);
    }

    // Extract mod declarations
    const modRegex = /mod\s+([a-zA-Z_][a-zA-Z0-9_]*);/g;
    while ((match = modRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }
  }

  /**
   * Extract symbols from Swift code
   */
  private extractSwiftSymbols(
    content: string,
    symbols: string[],
    imports: string[],
    dependencies: string[]
  ): void {
    // Extract class declarations
    const classRegex = /class\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
    let match;
    while ((match = classRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract struct declarations
    const structRegex = /struct\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
    while ((match = structRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract enum declarations
    const enumRegex = /enum\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
    while ((match = enumRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract protocol declarations
    const protocolRegex = /protocol\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
    while ((match = protocolRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract function declarations
    const functionRegex = /func\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*(?:<[^>]*>)?\s*\(/g;
    while ((match = functionRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract variable declarations
    const varRegex = /(?:var|let)\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*:/g;
    while ((match = varRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract import statements
    const importRegex = /import\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
    while ((match = importRegex.exec(content)) !== null) {
      imports.push(match[1]);
      dependencies.push(match[1]);
    }

    // Extract extension declarations
    const extensionRegex = /extension\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
    while ((match = extensionRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }
  }

  /**
   * Extract symbols from Kotlin code
   */
  private extractKotlinSymbols(
    content: string,
    symbols: string[],
    imports: string[],
    dependencies: string[]
  ): void {
    // Extract class declarations
    const classRegex = /class\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
    let match;
    while ((match = classRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract interface declarations
    const interfaceRegex = /interface\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
    while ((match = interfaceRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract function declarations
    const functionRegex = /fun\s+(?:<[^>]*>\s+)?([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/g;
    while ((match = functionRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract property declarations
    const propertyRegex = /(?:val|var)\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*(?::|=)/g;
    while ((match = propertyRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract object declarations
    const objectRegex = /object\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
    while ((match = objectRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract import statements
    const importRegex = /import\s+([a-zA-Z0-9_.]*(?:\.[a-zA-Z0-9_*]+)*)/g;
    while ((match = importRegex.exec(content)) !== null) {
      imports.push(match[1]);
      dependencies.push(match[1]);
    }

    // Extract package declaration
    const packageRegex = /package\s+([a-zA-Z0-9_.]+)/g;
    while ((match = packageRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }
  }

  /**
   * Extract symbols from HTML/CSS/SCSS/SASS code
   */
  private extractWebSymbols(
    content: string,
    symbols: string[],
    imports: string[],
    dependencies: string[],
    language: string
  ): void {
    if (language === 'html') {
      // Extract IDs
      const idRegex = /id=["']([^"']+)["']/g;
      let match;
      while ((match = idRegex.exec(content)) !== null) {
        symbols.push(match[1]);
      }

      // Extract classes
      const classRegex = /class=["']([^"']+)["']/g;
      while ((match = classRegex.exec(content)) !== null) {
        const classes = match[1].split(/\s+/);
        for (const cls of classes) {
          if (cls) {
            symbols.push(cls);
          }
        }
      }

      // Extract custom elements
      const customElementRegex = /<([a-z]+-[a-z-]+)/g;
      while ((match = customElementRegex.exec(content)) !== null) {
        symbols.push(match[1]);
      }

      // Extract script src and link href
      const linkRegex = /(?:src|href)=["']([^"']+)["']/g;
      while ((match = linkRegex.exec(content)) !== null) {
        imports.push(match[1]);
        dependencies.push(match[1]);
      }
    } else {
      // CSS/SCSS/SASS

      // Extract selectors
      const selectorRegex = /([.#][a-zA-Z_-][a-zA-Z0-9_-]*)/g;
      let match;
      while ((match = selectorRegex.exec(content)) !== null) {
        symbols.push(match[1]);
      }

      // Extract custom properties
      const customPropRegex = /(--[a-zA-Z0-9_-]+)\s*:/g;
      while ((match = customPropRegex.exec(content)) !== null) {
        symbols.push(match[1]);
      }

      // Extract @import statements
      const importRegex = /@import\s+["']([^"']+)["']/g;
      while ((match = importRegex.exec(content)) !== null) {
        imports.push(match[1]);
        dependencies.push(match[1]);
      }

      // Extract SCSS/SASS variables
      if (language === 'scss' || language === 'sass') {
        const varRegex = /\$([a-zA-Z_-][a-zA-Z0-9_-]*)\s*:/g;
        while ((match = varRegex.exec(content)) !== null) {
          symbols.push('$' + match[1]);
        }

        // Extract mixins
        const mixinRegex = /@mixin\s+([a-zA-Z_-][a-zA-Z0-9_-]*)/g;
        while ((match = mixinRegex.exec(content)) !== null) {
          symbols.push(match[1]);
        }
      }
    }
  }

  /**
   * Extract symbols from data formats (JSON, YAML, XML)
   */
  private extractDataFormatSymbols(
    content: string,
    symbols: string[],
    imports: string[],
    dependencies: string[],
    language: string
  ): void {
    if (language === 'json') {
      // Extract property names from JSON
      const propRegex = /"([a-zA-Z_][a-zA-Z0-9_]*)"\s*:/g;
      let match;
      while ((match = propRegex.exec(content)) !== null) {
        symbols.push(match[1]);
      }
    } else if (language === 'yaml') {
      // Extract keys from YAML
      const keyRegex = /^([a-zA-Z_][a-zA-Z0-9_]*)\s*:/gm;
      let match;
      while ((match = keyRegex.exec(content)) !== null) {
        symbols.push(match[1]);
      }
    } else if (language === 'xml') {
      // Extract tag names from XML
      const tagRegex = /<([a-zA-Z_][a-zA-Z0-9_:-]*)(?:\s|>|\/)/g;
      let match;
      while ((match = tagRegex.exec(content)) !== null) {
        symbols.push(match[1]);
      }

      // Extract attribute names
      const attrRegex = /\s([a-zA-Z_][a-zA-Z0-9_:-]*)=/g;
      while ((match = attrRegex.exec(content)) !== null) {
        symbols.push(match[1]);
      }
    }
  }

  /**
   * Generic symbol extraction for unsupported languages
   */
  private extractGenericSymbols(
    content: string,
    symbols: string[],
    imports: string[],
    dependencies: string[]
  ): void {
    // Generic symbol extraction using regex
    // This is a fallback for languages we don't have specific parsers for

    // Extract words that look like symbols (camelCase, PascalCase, snake_case)
    const symbolRegex = /\b([a-zA-Z_][a-zA-Z0-9_]*)\b/g;
    let match;
    while ((match = symbolRegex.exec(content)) !== null) {
      // Filter out common keywords across languages
      const keywords = [
        // Common programming keywords
        'if', 'else', 'for', 'while', 'do', 'switch', 'case', 'break', 'continue',
        'return', 'function', 'class', 'struct', 'enum', 'interface', 'namespace',
        'public', 'private', 'protected', 'static', 'final', 'const', 'var', 'let',
        'void', 'int', 'float', 'double', 'string', 'bool', 'true', 'false', 'null',
        'this', 'super', 'new', 'delete', 'try', 'catch', 'finally', 'throw'
      ];

      if (!keywords.includes(match[1])) {
        // Prioritize symbols that look like identifiers
        // - PascalCase (class/type names)
        // - camelCase (method/variable names)
        // - snake_case (variable names in some languages)
        // - UPPER_CASE (constants)
        if (
          /^[A-Z][a-z0-9]+[A-Z]/.test(match[1]) || // PascalCase
          /^[a-z]+[A-Z]/.test(match[1]) || // camelCase
          match[1].includes('_') || // snake_case or UPPER_CASE
          /^[A-Z][A-Z0-9_]+$/.test(match[1]) // UPPER_CASE constants
        ) {
          symbols.push(match[1]);
        }
      }
    }

    // Try to extract imports based on common patterns across languages
    const importRegex = /(?:import|include|require|using|from|#include)\s+['"]?([a-zA-Z0-9_./\\<>]+)['"]?/g;
    while ((match = importRegex.exec(content)) !== null) {
      imports.push(match[1]);
      dependencies.push(match[1]);
    }
  }
}

```


---

### File: `archive/vscode-extension/src/context/vectorStore.ts`

```typescript
import { CodeChunk } from './types';
import { EmbeddingService } from './embeddingService';

export class VectorStore {
  private chunks: CodeChunk[] = [];
  private embeddingService: EmbeddingService;
  
  constructor(embeddingService: EmbeddingService) {
    this.embeddingService = embeddingService;
  }
  
  public async addChunk(chunk: CodeChunk): Promise<void> {
    // If the chunk doesn't have an embedding, generate one
    if (!chunk.embedding) {
      chunk.embedding = await this.embeddingService.generateEmbedding(chunk.content);
    }
    
    // Check if chunk already exists (by ID)
    const existingIndex = this.chunks.findIndex(c => c.id === chunk.id);
    if (existingIndex >= 0) {
      // Replace existing chunk
      this.chunks[existingIndex] = chunk;
    } else {
      // Add new chunk
      this.chunks.push(chunk);
    }
  }
  
  public async findSimilarChunks(query: string, limit: number = 5): Promise<CodeChunk[]> {
    // Generate embedding for the query
    const queryEmbedding = await this.embeddingService.generateEmbedding(query);
    
    // Find similar chunks
    return this.findSimilarChunksByEmbedding(queryEmbedding, limit);
  }
  
  public async findSimilarChunksByEmbedding(embedding: number[], limit: number = 5): Promise<CodeChunk[]> {
    // Calculate cosine similarity for each chunk
    const chunksWithSimilarity = this.chunks.map(chunk => {
      const similarity = this.cosineSimilarity(embedding, chunk.embedding!);
      return { chunk, similarity };
    });
    
    // Sort by similarity (descending)
    chunksWithSimilarity.sort((a, b) => b.similarity - a.similarity);
    
    // Return top N chunks
    return chunksWithSimilarity.slice(0, limit).map(item => item.chunk);
  }
  
  public async deleteChunk(id: string): Promise<void> {
    this.chunks = this.chunks.filter(chunk => chunk.id !== id);
  }
  
  public async clear(): Promise<void> {
    this.chunks = [];
  }
  
  private cosineSimilarity(a: number[], b: number[]): number {
    if (a.length !== b.length) {
      throw new Error('Vectors must have the same length');
    }
    
    let dotProduct = 0;
    let normA = 0;
    let normB = 0;
    
    for (let i = 0; i < a.length; i++) {
      dotProduct += a[i] * b[i];
      normA += a[i] * a[i];
      normB += b[i] * b[i];
    }
    
    return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
  }
}

```


---

### File: `archive/vscode-extension/src/context/semanticSearch.ts`

```typescript
import { VectorStore } from './vectorStore';
import { EmbeddingService } from './embeddingService';
import { CodeChunk } from './types';

export class SemanticSearch {
  private vectorStore: VectorStore;
  private embeddingService: EmbeddingService;
  
  constructor(vectorStore: VectorStore, embeddingService: EmbeddingService) {
    this.vectorStore = vectorStore;
    this.embeddingService = embeddingService;
  }
  
  public async search(query: string, limit: number = 10): Promise<CodeChunk[]> {
    // Generate embedding for the query
    const queryEmbedding = await this.embeddingService.generateEmbedding(query);
    
    // Find similar chunks
    return this.vectorStore.findSimilarChunksByEmbedding(queryEmbedding, limit);
  }
  
  public async searchBySymbol(symbol: string, limit: number = 10): Promise<CodeChunk[]> {
    // First, try to find exact symbol matches
    const allChunks = await this.vectorStore.findSimilarChunks('', 1000);
    const exactMatches = allChunks.filter(chunk => 
      chunk.symbols.includes(symbol) || 
      chunk.content.includes(`function ${symbol}`) ||
      chunk.content.includes(`class ${symbol}`) ||
      chunk.content.includes(`def ${symbol}`)
    );
    
    if (exactMatches.length >= limit) {
      return exactMatches.slice(0, limit);
    }
    
    // If we don't have enough exact matches, supplement with semantic search
    const semanticMatches = await this.search(symbol, limit - exactMatches.length);
    
    // Combine results, removing duplicates
    const combinedResults: CodeChunk[] = [...exactMatches];
    const existingIds = new Set(combinedResults.map(chunk => chunk.id));
    
    for (const match of semanticMatches) {
      if (!existingIds.has(match.id)) {
        combinedResults.push(match);
        existingIds.add(match.id);
      }
    }
    
    return combinedResults;
  }
}

```


---

### File: `archive/vscode-extension/src/context/persistentVectorStore.ts`

```typescript
import * as path from 'path';
import * as fs from 'fs';
import * as vscode from 'vscode';
import * as sqlite3 from 'sqlite3';
import { Database, open } from 'sqlite';
import { CodeChunk } from './types';
import { EmbeddingService } from './embeddingService';
import { VectorStore } from './vectorStore';

/**
 * A vector store that persists embeddings to disk using SQLite
 */
export class PersistentVectorStore extends VectorStore {
  private dbPath: string;
  private db: Database | null = null;
  private autoSaveInterval: NodeJS.Timeout | null = null;
  private isDirty: boolean = false;
  private isInitialized: boolean = false;
  
  /**
   * Create a new persistent vector store
   * @param embeddingService The embedding service to use
   * @param dbPath Path to the SQLite database file (optional, defaults to extension storage path)
   * @param autoSaveIntervalMs Interval in milliseconds to auto-save changes (optional, defaults to 60000)
   */
  constructor(
    embeddingService: EmbeddingService, 
    dbPath?: string,
    autoSaveIntervalMs: number = 60000
  ) {
    super(embeddingService);
    
    // If no dbPath is provided, use the extension's storage path
    if (!dbPath) {
      const storagePath = this.getStoragePath();
      if (!storagePath) {
        throw new Error('Could not determine storage path for persistent vector store');
      }
      
      // Ensure the directory exists
      if (!fs.existsSync(storagePath)) {
        fs.mkdirSync(storagePath, { recursive: true });
      }
      
      this.dbPath = path.join(storagePath, 'vector-store.db');
    } else {
      this.dbPath = dbPath;
    }
    
    // Set up auto-save if interval is positive
    if (autoSaveIntervalMs > 0) {
      this.autoSaveInterval = setInterval(() => {
        if (this.isDirty) {
          this.saveToDatabase().catch(error => {
            console.error('Error auto-saving vector store:', error);
          });
        }
      }, autoSaveIntervalMs);
    }
  }
  
  /**
   * Initialize the database
   */
  public async initialize(): Promise<void> {
    if (this.isInitialized) {
      return;
    }
    
    try {
      // Open the database
      this.db = await open({
        filename: this.dbPath,
        driver: sqlite3.Database
      });
      
      // Create tables if they don't exist
      await this.db.exec(`
        CREATE TABLE IF NOT EXISTS chunks (
          id TEXT PRIMARY KEY,
          filePath TEXT NOT NULL,
          content TEXT NOT NULL,
          startLine INTEGER NOT NULL,
          endLine INTEGER NOT NULL,
          language TEXT NOT NULL,
          symbols TEXT,
          imports TEXT
        );
        
        CREATE TABLE IF NOT EXISTS embeddings (
          chunk_id TEXT PRIMARY KEY,
          embedding BLOB NOT NULL,
          FOREIGN KEY (chunk_id) REFERENCES chunks (id) ON DELETE CASCADE
        );
        
        CREATE INDEX IF NOT EXISTS idx_chunks_filePath ON chunks (filePath);
      `);
      
      // Load existing chunks from the database
      await this.loadFromDatabase();
      
      this.isInitialized = true;
    } catch (error) {
      console.error('Error initializing persistent vector store:', error);
      throw error;
    }
  }
  
  /**
   * Add a chunk to the vector store
   * @param chunk The chunk to add
   */
  public async addChunk(chunk: CodeChunk): Promise<void> {
    // Call the parent method to add the chunk to memory
    await super.addChunk(chunk);
    
    // Mark as dirty to trigger auto-save
    this.isDirty = true;
  }
  
  /**
   * Delete a chunk from the vector store
   * @param id The ID of the chunk to delete
   */
  public async deleteChunk(id: string): Promise<void> {
    // Call the parent method to delete the chunk from memory
    await super.deleteChunk(id);
    
    // Delete from database if initialized
    if (this.db) {
      try {
        await this.db.run('DELETE FROM chunks WHERE id = ?', id);
        await this.db.run('DELETE FROM embeddings WHERE chunk_id = ?', id);
      } catch (error) {
        console.error(`Error deleting chunk ${id} from database:`, error);
      }
    }
    
    // Mark as dirty to trigger auto-save
    this.isDirty = true;
  }
  
  /**
   * Clear the vector store
   */
  public async clear(): Promise<void> {
    // Call the parent method to clear the in-memory store
    await super.clear();
    
    // Clear the database if initialized
    if (this.db) {
      try {
        await this.db.exec('DELETE FROM embeddings');
        await this.db.exec('DELETE FROM chunks');
      } catch (error) {
        console.error('Error clearing database:', error);
      }
    }
    
    // Mark as dirty to trigger auto-save
    this.isDirty = true;
  }
  
  /**
   * Save all chunks to the database
   */
  public async saveToDatabase(): Promise<void> {
    if (!this.db) {
      await this.initialize();
    }
    
    if (!this.db) {
      throw new Error('Database not initialized');
    }
    
    try {
      // Start a transaction
      await this.db.exec('BEGIN TRANSACTION');
      
      // Get all chunks
      const chunks = await this.getAllChunks();
      
      // Insert or update each chunk
      for (const chunk of chunks) {
        // Insert or replace the chunk
        await this.db.run(
          `INSERT OR REPLACE INTO chunks (id, filePath, content, startLine, endLine, language, symbols, imports)
           VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
          chunk.id,
          chunk.filePath,
          chunk.content,
          chunk.startLine,
          chunk.endLine,
          chunk.language,
          JSON.stringify(chunk.symbols),
          JSON.stringify(chunk.imports)
        );
        
        // Insert or replace the embedding if it exists
        if (chunk.embedding) {
          await this.db.run(
            `INSERT OR REPLACE INTO embeddings (chunk_id, embedding)
             VALUES (?, ?)`,
            chunk.id,
            Buffer.from(new Float32Array(chunk.embedding).buffer)
          );
        }
      }
      
      // Commit the transaction
      await this.db.exec('COMMIT');
      
      // Reset dirty flag
      this.isDirty = false;
      
      console.log(`Saved ${chunks.length} chunks to database`);
    } catch (error) {
      // Rollback the transaction on error
      if (this.db) {
        await this.db.exec('ROLLBACK');
      }
      
      console.error('Error saving to database:', error);
      throw error;
    }
  }
  
  /**
   * Load chunks from the database
   */
  private async loadFromDatabase(): Promise<void> {
    if (!this.db) {
      throw new Error('Database not initialized');
    }
    
    try {
      // Get all chunks from the database
      const rows = await this.db.all(`
        SELECT c.id, c.filePath, c.content, c.startLine, c.endLine, c.language, c.symbols, c.imports, e.embedding
        FROM chunks c
        LEFT JOIN embeddings e ON c.id = e.chunk_id
      `);
      
      // Clear existing chunks
      await super.clear();
      
      // Add each chunk to the in-memory store
      for (const row of rows) {
        const chunk: CodeChunk = {
          id: row.id,
          filePath: row.filePath,
          content: row.content,
          startLine: row.startLine,
          endLine: row.endLine,
          language: row.language,
          symbols: row.symbols ? JSON.parse(row.symbols) : [],
          imports: row.imports ? JSON.parse(row.imports) : []
        };
        
        // Add embedding if it exists
        if (row.embedding) {
          const buffer = Buffer.from(row.embedding);
          const float32Array = new Float32Array(buffer.buffer, buffer.byteOffset, buffer.byteLength / 4);
          chunk.embedding = Array.from(float32Array);
        }
        
        // Add to in-memory store without saving to database
        await super.addChunk(chunk);
      }
      
      console.log(`Loaded ${rows.length} chunks from database`);
    } catch (error) {
      console.error('Error loading from database:', error);
      throw error;
    }
  }
  
  /**
   * Get the storage path for the extension
   */
  private getStoragePath(): string | undefined {
    // Get the extension context
    const extension = vscode.extensions.getExtension('qwen-coder-assistant');
    if (extension) {
      return extension.extensionPath;
    }
    
    // Fallback to the workspace storage path
    if (vscode.workspace.workspaceFolders && vscode.workspace.workspaceFolders.length > 0) {
      return path.join(vscode.workspace.workspaceFolders[0].uri.fsPath, '.vscode');
    }
    
    return undefined;
  }
  
  /**
   * Dispose of resources
   */
  public async dispose(): Promise<void> {
    // Clear auto-save interval
    if (this.autoSaveInterval) {
      clearInterval(this.autoSaveInterval);
      this.autoSaveInterval = null;
    }
    
    // Save any pending changes
    if (this.isDirty && this.db) {
      try {
        await this.saveToDatabase();
      } catch (error) {
        console.error('Error saving vector store during disposal:', error);
      }
    }
    
    // Close the database
    if (this.db) {
      await this.db.close();
      this.db = null;
    }
  }
}

```


---

### File: `archive/vscode-extension/src/context/semanticSearch.js`

```javascript
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SemanticSearch = void 0;
class SemanticSearch {
    constructor(vectorStore, embeddingService) {
        this.vectorStore = vectorStore;
        this.embeddingService = embeddingService;
    }
    async search(query, limit = 10) {
        // Generate embedding for the query
        const queryEmbedding = await this.embeddingService.generateEmbedding(query);
        // Find similar chunks
        return this.vectorStore.findSimilarChunksByEmbedding(queryEmbedding, limit);
    }
    async searchBySymbol(symbol, limit = 10) {
        // First, try to find exact symbol matches
        const allChunks = await this.vectorStore.findSimilarChunks('', 1000);
        const exactMatches = allChunks.filter(chunk => chunk.symbols.includes(symbol) ||
            chunk.content.includes(`function ${symbol}`) ||
            chunk.content.includes(`class ${symbol}`) ||
            chunk.content.includes(`def ${symbol}`));
        if (exactMatches.length >= limit) {
            return exactMatches.slice(0, limit);
        }
        // If we don't have enough exact matches, supplement with semantic search
        const semanticMatches = await this.search(symbol, limit - exactMatches.length);
        // Combine results, removing duplicates
        const combinedResults = [...exactMatches];
        const existingIds = new Set(combinedResults.map(chunk => chunk.id));
        for (const match of semanticMatches) {
            if (!existingIds.has(match.id)) {
                combinedResults.push(match);
                existingIds.add(match.id);
            }
        }
        return combinedResults;
    }
}
exports.SemanticSearch = SemanticSearch;
//# sourceMappingURL=semanticSearch.js.map
```


---

### File: `archive/vscode-extension/src/context/symbolExtractor.js`

```javascript
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SymbolExtractor = void 0;
/**
 * Language-specific symbol extractor for code files.
 * Extracts symbols, imports, and dependencies from code content.
 */
class SymbolExtractor {
    /**
     * Detect language from file extension
     * @param filePath Path to the file
     * @returns Language ID or undefined if not detected
     */
    static detectLanguageFromPath(filePath) {
        const extension = filePath.substring(filePath.lastIndexOf('.')).toLowerCase();
        return SymbolExtractor.extensionToLanguage[extension];
    }
    /**
     * Extract symbols, imports, and dependencies from code content
     * @param content Code content
     * @param language Language ID
     * @returns Object containing symbols, imports, and dependencies
     */
    async extractSymbols(content, language) {
        const symbols = [];
        const imports = [];
        const dependencies = [];
        // Extract based on language
        switch (language) {
            // JavaScript family
            case 'javascript':
            case 'typescript':
            case 'javascriptreact':
            case 'typescriptreact':
                this.extractJavaScriptSymbols(content, symbols, imports, dependencies);
                break;
            // Python
            case 'python':
                this.extractPythonSymbols(content, symbols, imports, dependencies);
                break;
            // Java
            case 'java':
                this.extractJavaSymbols(content, symbols, imports, dependencies);
                break;
            // C/C++
            case 'c':
            case 'cpp':
                this.extractCppSymbols(content, symbols, imports, dependencies);
                break;
            // C#
            case 'csharp':
                this.extractCSharpSymbols(content, symbols, imports, dependencies);
                break;
            // Go
            case 'go':
                this.extractGoSymbols(content, symbols, imports, dependencies);
                break;
            // Ruby
            case 'ruby':
                this.extractRubySymbols(content, symbols, imports, dependencies);
                break;
            // PHP
            case 'php':
                this.extractPhpSymbols(content, symbols, imports, dependencies);
                break;
            // Rust
            case 'rust':
                this.extractRustSymbols(content, symbols, imports, dependencies);
                break;
            // Swift
            case 'swift':
                this.extractSwiftSymbols(content, symbols, imports, dependencies);
                break;
            // Kotlin
            case 'kotlin':
                this.extractKotlinSymbols(content, symbols, imports, dependencies);
                break;
            // HTML/CSS
            case 'html':
            case 'css':
            case 'scss':
            case 'sass':
                this.extractWebSymbols(content, symbols, imports, dependencies, language);
                break;
            // Data formats
            case 'json':
            case 'yaml':
            case 'xml':
                this.extractDataFormatSymbols(content, symbols, imports, dependencies, language);
                break;
            // Default fallback
            default:
                // Use regex-based fallback for unknown languages
                this.extractGenericSymbols(content, symbols, imports, dependencies);
        }
        // Remove duplicates
        return {
            symbols: [...new Set(symbols)],
            imports: [...new Set(imports)],
            dependencies: [...new Set(dependencies)]
        };
    }
    /**
     * Extract symbols from JavaScript/TypeScript code
     */
    extractJavaScriptSymbols(content, symbols, imports, dependencies) {
        // Extract function declarations (both regular and arrow functions)
        const functionRegex = /(?:function\s+([a-zA-Z_$][a-zA-Z0-9_$]*)|(?:const|let|var)\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\s*=\s*(?:async\s*)?\([^)]*\)\s*=>)/g;
        let match;
        while ((match = functionRegex.exec(content)) !== null) {
            if (match[1]) {
                symbols.push(match[1]);
            }
            else if (match[2]) {
                symbols.push(match[2]);
            }
        }
        // Extract class declarations
        const classRegex = /class\s+([a-zA-Z_$][a-zA-Z0-9_$]*)/g;
        while ((match = classRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract method declarations
        const methodRegex = /(?:async\s+)?([a-zA-Z_$][a-zA-Z0-9_$]*)\s*\([^)]*\)\s*{/g;
        while ((match = methodRegex.exec(content)) !== null) {
            // Filter out common keywords that might be matched
            const keywords = ['if', 'for', 'while', 'switch', 'catch'];
            if (!keywords.includes(match[1])) {
                symbols.push(match[1]);
            }
        }
        // Extract variable declarations
        const varRegex = /(?:const|let|var)\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\s*(?:[=;]|$)/g;
        while ((match = varRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract interface and type declarations (TypeScript)
        const typeRegex = /(?:interface|type)\s+([a-zA-Z_$][a-zA-Z0-9_$]*)/g;
        while ((match = typeRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract imports (ES modules)
        const importRegex = /import\s+(?:{([^}]*)}\s+from\s+['"]([^'"]+)['"]|.*?from\s+['"]([^'"]+)['"])/g;
        while ((match = importRegex.exec(content)) !== null) {
            // Extract the module path
            const modulePath = match[2] || match[3];
            if (modulePath) {
                imports.push(modulePath);
                dependencies.push(modulePath);
            }
            // Extract named imports if available
            if (match[1]) {
                const namedImports = match[1].split(',').map(s => s.trim());
                for (const namedImport of namedImports) {
                    // Handle "as" aliases
                    const importName = namedImport.split(' as ')[0].trim();
                    if (importName) {
                        symbols.push(importName);
                    }
                }
            }
        }
        // Extract CommonJS requires
        const requireRegex = /(?:const|let|var)\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\s*=\s*require\s*\(\s*['"]([^'"]+)['"]\s*\)/g;
        while ((match = requireRegex.exec(content)) !== null) {
            symbols.push(match[1]); // The variable name
            imports.push(match[2]); // The module path
            dependencies.push(match[2]);
        }
    }
    /**
     * Extract symbols from Python code
     */
    extractPythonSymbols(content, symbols, imports, dependencies) {
        // Extract function declarations
        const functionRegex = /def\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/g;
        let match;
        while ((match = functionRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract class declarations
        const classRegex = /class\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*(?:\(|:)/g;
        while ((match = classRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract variable assignments (global level)
        const varRegex = /^([A-Z_][A-Z0-9_]*)\s*=/gm;
        while ((match = varRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract imports - from X import Y
        const fromImportRegex = /from\s+([a-zA-Z0-9_.]+)\s+import\s+([^#\n]+)/g;
        while ((match = fromImportRegex.exec(content)) !== null) {
            const module = match[1];
            imports.push(module);
            dependencies.push(module);
            // Extract imported symbols
            const importedSymbols = match[2].split(',').map(s => s.trim());
            for (const importedSymbol of importedSymbols) {
                // Handle "as" aliases
                const symbolName = importedSymbol.split(' as ')[0].trim();
                if (symbolName && symbolName !== '*') {
                    symbols.push(symbolName);
                }
            }
        }
        // Extract imports - import X
        const importRegex = /import\s+([^#\n]+)/g;
        while ((match = importRegex.exec(content)) !== null) {
            const importedModules = match[1].split(',').map(s => s.trim());
            for (const importedModule of importedModules) {
                // Handle "as" aliases
                const moduleName = importedModule.split(' as ')[0].trim();
                if (moduleName) {
                    imports.push(moduleName);
                    dependencies.push(moduleName);
                    // Also add the module name as a symbol (since it can be used directly)
                    const alias = importedModule.includes(' as ')
                        ? importedModule.split(' as ')[1].trim()
                        : moduleName.split('.').pop() || '';
                    if (alias) {
                        symbols.push(alias);
                    }
                }
            }
        }
        // Extract decorated functions and classes
        const decoratorRegex = /@[^\n]+\s+(?:def|class)\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
        while ((match = decoratorRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
    }
    /**
     * Extract symbols from Java code
     */
    extractJavaSymbols(content, symbols, imports, dependencies) {
        // Extract class and interface declarations
        const classRegex = /(?:public|private|protected)?\s*(?:abstract|final)?\s*(?:class|interface|enum)\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
        let match;
        while ((match = classRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract method declarations
        const methodRegex = /(?:public|private|protected)?\s*(?:static|final|abstract)?\s*(?:<[^>]+>\s*)?(?:[a-zA-Z_][a-zA-Z0-9_.<>]*)\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/g;
        while ((match = methodRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract field declarations
        const fieldRegex = /(?:public|private|protected)?\s*(?:static|final)?\s*(?:[a-zA-Z_][a-zA-Z0-9_.<>]*)\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*(?:=|;)/g;
        while ((match = fieldRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract imports
        const importRegex = /import\s+([a-zA-Z0-9_.]+(?:\.[a-zA-Z0-9_*]+)*);/g;
        while ((match = importRegex.exec(content)) !== null) {
            imports.push(match[1]);
            dependencies.push(match[1]);
        }
        // Extract package declaration
        const packageRegex = /package\s+([a-zA-Z0-9_.]+);/g;
        while ((match = packageRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
    }
    /**
     * Extract symbols from C/C++ code
     */
    extractCppSymbols(content, symbols, imports, dependencies) {
        // Extract function declarations
        const functionRegex = /(?:(?:static|inline|extern|const)\s+)*(?:[a-zA-Z_][a-zA-Z0-9_:]*\s+)+([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/g;
        let match;
        while ((match = functionRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract class/struct/enum declarations
        const classRegex = /(?:class|struct|enum|union)\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
        while ((match = classRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract namespace declarations
        const namespaceRegex = /namespace\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
        while ((match = namespaceRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract #include directives
        const includeRegex = /#include\s+[<"]([^>"]+)[>"]/g;
        while ((match = includeRegex.exec(content)) !== null) {
            imports.push(match[1]);
            dependencies.push(match[1]);
        }
        // Extract typedefs
        const typedefRegex = /typedef\s+(?:[a-zA-Z_][a-zA-Z0-9_:]*\s+)+([a-zA-Z_][a-zA-Z0-9_]*)/g;
        while ((match = typedefRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract #define macros
        const defineRegex = /#define\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
        while ((match = defineRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
    }
    /**
     * Extract symbols from C# code
     */
    extractCSharpSymbols(content, symbols, imports, dependencies) {
        // Extract class, interface, struct, enum declarations
        const classRegex = /(?:public|private|protected|internal)?\s*(?:abstract|sealed|static)?\s*(?:class|interface|struct|enum|record)\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
        let match;
        while ((match = classRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract method declarations
        const methodRegex = /(?:public|private|protected|internal)?\s*(?:static|virtual|abstract|override|sealed)?\s*(?:[a-zA-Z_][a-zA-Z0-9_.<>]*)\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/g;
        while ((match = methodRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract property declarations
        const propertyRegex = /(?:public|private|protected|internal)?\s*(?:static|virtual|abstract|override|sealed)?\s*(?:[a-zA-Z_][a-zA-Z0-9_.<>]*)\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*\{/g;
        while ((match = propertyRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract using directives
        const usingRegex = /using\s+([a-zA-Z0-9_.]+);/g;
        while ((match = usingRegex.exec(content)) !== null) {
            imports.push(match[1]);
            dependencies.push(match[1]);
        }
        // Extract namespace declarations
        const namespaceRegex = /namespace\s+([a-zA-Z0-9_.]+)/g;
        while ((match = namespaceRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
    }
    /**
     * Extract symbols from Go code
     */
    extractGoSymbols(content, symbols, imports, dependencies) {
        // Extract function declarations
        const functionRegex = /func\s+(?:\([^)]*\)\s+)?([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/g;
        let match;
        while ((match = functionRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract type declarations
        const typeRegex = /type\s+([a-zA-Z_][a-zA-Z0-9_]*)\s+(?:struct|interface|[a-zA-Z_][a-zA-Z0-9_]*)/g;
        while ((match = typeRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract const declarations
        const constRegex = /const\s+([a-zA-Z_][a-zA-Z0-9_]*)\s+/g;
        while ((match = constRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract var declarations
        const varRegex = /var\s+([a-zA-Z_][a-zA-Z0-9_]*)\s+/g;
        while ((match = varRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract imports
        const importRegex = /import\s+(?:\(\s*((?:[^)]+))\s*\)|["']([^"']+)["'])/g;
        while ((match = importRegex.exec(content)) !== null) {
            if (match[1]) {
                // Multi-line import
                const importLines = match[1].split('\n');
                for (const line of importLines) {
                    const importMatch = line.match(/["']([^"']+)["']/);
                    if (importMatch) {
                        imports.push(importMatch[1]);
                        dependencies.push(importMatch[1]);
                    }
                }
            }
            else if (match[2]) {
                // Single import
                imports.push(match[2]);
                dependencies.push(match[2]);
            }
        }
        // Extract package declaration
        const packageRegex = /package\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
        while ((match = packageRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
    }
    /**
     * Extract symbols from Ruby code
     */
    extractRubySymbols(content, symbols, imports, dependencies) {
        // Extract class declarations
        const classRegex = /class\s+([A-Z][a-zA-Z0-9_]*)/g;
        let match;
        while ((match = classRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract module declarations
        const moduleRegex = /module\s+([A-Z][a-zA-Z0-9_]*)/g;
        while ((match = moduleRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract method declarations
        const methodRegex = /def\s+(?:self\.)?([a-zA-Z_][a-zA-Z0-9_?!]*)/g;
        while ((match = methodRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract constant declarations
        const constRegex = /([A-Z][A-Z0-9_]*)\s*=/g;
        while ((match = constRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract requires
        const requireRegex = /require\s+['"]([^'"]+)['"]/g;
        while ((match = requireRegex.exec(content)) !== null) {
            imports.push(match[1]);
            dependencies.push(match[1]);
        }
        // Extract includes
        const includeRegex = /include\s+([A-Z][a-zA-Z0-9_]*)/g;
        while ((match = includeRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
    }
    /**
     * Extract symbols from PHP code
     */
    extractPhpSymbols(content, symbols, imports, dependencies) {
        // Extract class declarations
        const classRegex = /class\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
        let match;
        while ((match = classRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract interface declarations
        const interfaceRegex = /interface\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
        while ((match = interfaceRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract function declarations
        const functionRegex = /function\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/g;
        while ((match = functionRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract method declarations
        const methodRegex = /(?:public|private|protected)?\s*(?:static)?\s*function\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/g;
        while ((match = methodRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract namespace declarations
        const namespaceRegex = /namespace\s+([a-zA-Z_][a-zA-Z0-9_\\]*)/g;
        while ((match = namespaceRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract use statements (imports)
        const useRegex = /use\s+([a-zA-Z_][a-zA-Z0-9_\\]*)/g;
        while ((match = useRegex.exec(content)) !== null) {
            imports.push(match[1]);
            dependencies.push(match[1]);
        }
        // Extract require/include statements
        const requireRegex = /(?:require|include)(?:_once)?\s*\(\s*['"]([^'"]+)['"]\s*\)/g;
        while ((match = requireRegex.exec(content)) !== null) {
            imports.push(match[1]);
            dependencies.push(match[1]);
        }
    }
    /**
     * Extract symbols from Rust code
     */
    extractRustSymbols(content, symbols, imports, dependencies) {
        // Extract function declarations
        const functionRegex = /fn\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*(?:<[^>]*>)?\s*\(/g;
        let match;
        while ((match = functionRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract struct declarations
        const structRegex = /struct\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
        while ((match = structRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract enum declarations
        const enumRegex = /enum\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
        while ((match = enumRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract trait declarations
        const traitRegex = /trait\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
        while ((match = traitRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract impl blocks
        const implRegex = /impl(?:<[^>]*>)?\s+(?:[^{]*\s+)?([a-zA-Z_][a-zA-Z0-9_]*)/g;
        while ((match = implRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract const declarations
        const constRegex = /const\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*:/g;
        while ((match = constRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract static declarations
        const staticRegex = /static\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*:/g;
        while ((match = staticRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract use statements (imports)
        const useRegex = /use\s+([a-zA-Z0-9_:{}]+);/g;
        while ((match = useRegex.exec(content)) !== null) {
            imports.push(match[1]);
            dependencies.push(match[1]);
        }
        // Extract mod declarations
        const modRegex = /mod\s+([a-zA-Z_][a-zA-Z0-9_]*);/g;
        while ((match = modRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
    }
    /**
     * Extract symbols from Swift code
     */
    extractSwiftSymbols(content, symbols, imports, dependencies) {
        // Extract class declarations
        const classRegex = /class\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
        let match;
        while ((match = classRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract struct declarations
        const structRegex = /struct\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
        while ((match = structRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract enum declarations
        const enumRegex = /enum\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
        while ((match = enumRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract protocol declarations
        const protocolRegex = /protocol\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
        while ((match = protocolRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract function declarations
        const functionRegex = /func\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*(?:<[^>]*>)?\s*\(/g;
        while ((match = functionRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract variable declarations
        const varRegex = /(?:var|let)\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*:/g;
        while ((match = varRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract import statements
        const importRegex = /import\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
        while ((match = importRegex.exec(content)) !== null) {
            imports.push(match[1]);
            dependencies.push(match[1]);
        }
        // Extract extension declarations
        const extensionRegex = /extension\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
        while ((match = extensionRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
    }
    /**
     * Extract symbols from Kotlin code
     */
    extractKotlinSymbols(content, symbols, imports, dependencies) {
        // Extract class declarations
        const classRegex = /class\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
        let match;
        while ((match = classRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract interface declarations
        const interfaceRegex = /interface\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
        while ((match = interfaceRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract function declarations
        const functionRegex = /fun\s+(?:<[^>]*>\s+)?([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/g;
        while ((match = functionRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract property declarations
        const propertyRegex = /(?:val|var)\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*(?::|=)/g;
        while ((match = propertyRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract object declarations
        const objectRegex = /object\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
        while ((match = objectRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
        // Extract import statements
        const importRegex = /import\s+([a-zA-Z0-9_.]*(?:\.[a-zA-Z0-9_*]+)*)/g;
        while ((match = importRegex.exec(content)) !== null) {
            imports.push(match[1]);
            dependencies.push(match[1]);
        }
        // Extract package declaration
        const packageRegex = /package\s+([a-zA-Z0-9_.]+)/g;
        while ((match = packageRegex.exec(content)) !== null) {
            symbols.push(match[1]);
        }
    }
    /**
     * Extract symbols from HTML/CSS/SCSS/SASS code
     */
    extractWebSymbols(content, symbols, imports, dependencies, language) {
        if (language === 'html') {
            // Extract IDs
            const idRegex = /id=["']([^"']+)["']/g;
            let match;
            while ((match = idRegex.exec(content)) !== null) {
                symbols.push(match[1]);
            }
            // Extract classes
            const classRegex = /class=["']([^"']+)["']/g;
            while ((match = classRegex.exec(content)) !== null) {
                const classes = match[1].split(/\s+/);
                for (const cls of classes) {
                    if (cls) {
                        symbols.push(cls);
                    }
                }
            }
            // Extract custom elements
            const customElementRegex = /<([a-z]+-[a-z-]+)/g;
            while ((match = customElementRegex.exec(content)) !== null) {
                symbols.push(match[1]);
            }
            // Extract script src and link href
            const linkRegex = /(?:src|href)=["']([^"']+)["']/g;
            while ((match = linkRegex.exec(content)) !== null) {
                imports.push(match[1]);
                dependencies.push(match[1]);
            }
        }
        else {
            // CSS/SCSS/SASS
            // Extract selectors
            const selectorRegex = /([.#][a-zA-Z_-][a-zA-Z0-9_-]*)/g;
            let match;
            while ((match = selectorRegex.exec(content)) !== null) {
                symbols.push(match[1]);
            }
            // Extract custom properties
            const customPropRegex = /(--[a-zA-Z0-9_-]+)\s*:/g;
            while ((match = customPropRegex.exec(content)) !== null) {
                symbols.push(match[1]);
            }
            // Extract @import statements
            const importRegex = /@import\s+["']([^"']+)["']/g;
            while ((match = importRegex.exec(content)) !== null) {
                imports.push(match[1]);
                dependencies.push(match[1]);
            }
            // Extract SCSS/SASS variables
            if (language === 'scss' || language === 'sass') {
                const varRegex = /\$([a-zA-Z_-][a-zA-Z0-9_-]*)\s*:/g;
                while ((match = varRegex.exec(content)) !== null) {
                    symbols.push('$' + match[1]);
                }
                // Extract mixins
                const mixinRegex = /@mixin\s+([a-zA-Z_-][a-zA-Z0-9_-]*)/g;
                while ((match = mixinRegex.exec(content)) !== null) {
                    symbols.push(match[1]);
                }
            }
        }
    }
    /**
     * Extract symbols from data formats (JSON, YAML, XML)
     */
    extractDataFormatSymbols(content, symbols, imports, dependencies, language) {
        if (language === 'json') {
            // Extract property names from JSON
            const propRegex = /"([a-zA-Z_][a-zA-Z0-9_]*)"\s*:/g;
            let match;
            while ((match = propRegex.exec(content)) !== null) {
                symbols.push(match[1]);
            }
        }
        else if (language === 'yaml') {
            // Extract keys from YAML
            const keyRegex = /^([a-zA-Z_][a-zA-Z0-9_]*)\s*:/gm;
            let match;
            while ((match = keyRegex.exec(content)) !== null) {
                symbols.push(match[1]);
            }
        }
        else if (language === 'xml') {
            // Extract tag names from XML
            const tagRegex = /<([a-zA-Z_][a-zA-Z0-9_:-]*)(?:\s|>|\/)/g;
            let match;
            while ((match = tagRegex.exec(content)) !== null) {
                symbols.push(match[1]);
            }
            // Extract attribute names
            const attrRegex = /\s([a-zA-Z_][a-zA-Z0-9_:-]*)=/g;
            while ((match = attrRegex.exec(content)) !== null) {
                symbols.push(match[1]);
            }
        }
    }
    /**
     * Generic symbol extraction for unsupported languages
     */
    extractGenericSymbols(content, symbols, imports, dependencies) {
        // Generic symbol extraction using regex
        // This is a fallback for languages we don't have specific parsers for
        // Extract words that look like symbols (camelCase, PascalCase, snake_case)
        const symbolRegex = /\b([a-zA-Z_][a-zA-Z0-9_]*)\b/g;
        let match;
        while ((match = symbolRegex.exec(content)) !== null) {
            // Filter out common keywords across languages
            const keywords = [
                // Common programming keywords
                'if', 'else', 'for', 'while', 'do', 'switch', 'case', 'break', 'continue',
                'return', 'function', 'class', 'struct', 'enum', 'interface', 'namespace',
                'public', 'private', 'protected', 'static', 'final', 'const', 'var', 'let',
                'void', 'int', 'float', 'double', 'string', 'bool', 'true', 'false', 'null',
                'this', 'super', 'new', 'delete', 'try', 'catch', 'finally', 'throw'
            ];
            if (!keywords.includes(match[1])) {
                // Prioritize symbols that look like identifiers
                // - PascalCase (class/type names)
                // - camelCase (method/variable names)
                // - snake_case (variable names in some languages)
                // - UPPER_CASE (constants)
                if (/^[A-Z][a-z0-9]+[A-Z]/.test(match[1]) || // PascalCase
                    /^[a-z]+[A-Z]/.test(match[1]) || // camelCase
                    match[1].includes('_') || // snake_case or UPPER_CASE
                    /^[A-Z][A-Z0-9_]+$/.test(match[1]) // UPPER_CASE constants
                ) {
                    symbols.push(match[1]);
                }
            }
        }
        // Try to extract imports based on common patterns across languages
        const importRegex = /(?:import|include|require|using|from|#include)\s+['"]?([a-zA-Z0-9_./\\<>]+)['"]?/g;
        while ((match = importRegex.exec(content)) !== null) {
            imports.push(match[1]);
            dependencies.push(match[1]);
        }
    }
}
exports.SymbolExtractor = SymbolExtractor;
// Map of file extensions to language IDs
SymbolExtractor.extensionToLanguage = {
    // JavaScript/TypeScript
    '.js': 'javascript',
    '.jsx': 'javascriptreact',
    '.ts': 'typescript',
    '.tsx': 'typescriptreact',
    // Python
    '.py': 'python',
    '.pyw': 'python',
    '.ipynb': 'python',
    // Java
    '.java': 'java',
    // C/C++
    '.c': 'c',
    '.cpp': 'cpp',
    '.cc': 'cpp',
    '.h': 'c',
    '.hpp': 'cpp',
    // C#
    '.cs': 'csharp',
    // Go
    '.go': 'go',
    // Ruby
    '.rb': 'ruby',
    // PHP
    '.php': 'php',
    // Rust
    '.rs': 'rust',
    // Swift
    '.swift': 'swift',
    // Kotlin
    '.kt': 'kotlin',
    // HTML/CSS
    '.html': 'html',
    '.css': 'css',
    '.scss': 'scss',
    '.sass': 'sass',
    // Other
    '.json': 'json',
    '.xml': 'xml',
    '.yaml': 'yaml',
    '.yml': 'yaml',
    '.md': 'markdown'
};
//# sourceMappingURL=symbolExtractor.js.map
```


---

### File: `archive/vscode-extension/src/context/contextComposer.ts`

```typescript
import { CodeChunk } from './types';
import * as path from 'path';

export class ContextComposer {
  private readonly MAX_TOKENS_PER_CHUNK = 1000;
  
  public async composeContext(query: string, relevantChunks: CodeChunk[], tokenLimit: number = 4000): Promise<string> {
    // Sort chunks by relevance (assuming they're already sorted)
    // Group chunks by file
    const chunksByFile: { [filePath: string]: CodeChunk[] } = {};
    for (const chunk of relevantChunks) {
      if (!chunksByFile[chunk.filePath]) {
        chunksByFile[chunk.filePath] = [];
      }
      chunksByFile[chunk.filePath].push(chunk);
    }
    
    // Sort chunks within each file by line number
    for (const filePath in chunksByFile) {
      chunksByFile[filePath].sort((a, b) => a.startLine - b.startLine);
    }
    
    // Compose context
    let context = `Query: ${query}\n\n`;
    let tokenCount = this.estimateTokens(context);
    
    // Add file contexts until we reach the token limit
    for (const filePath in chunksByFile) {
      const fileName = path.basename(filePath);
      const fileContext = `File: ${fileName} (${filePath})\n`;
      tokenCount += this.estimateTokens(fileContext);
      
      if (tokenCount > tokenLimit) {
        break;
      }
      
      context += fileContext;
      
      // Add chunks from this file
      for (const chunk of chunksByFile[filePath]) {
        const chunkHeader = `Lines ${chunk.startLine}-${chunk.endLine}:\n`;
        const chunkContent = chunk.content;
        const chunkTokens = this.estimateTokens(chunkHeader + chunkContent);
        
        if (tokenCount + chunkTokens > tokenLimit) {
          // If adding this chunk would exceed the token limit, skip it
          continue;
        }
        
        context += chunkHeader + chunkContent + '\n\n';
        tokenCount += chunkTokens;
      }
      
      context += '\n';
    }
    
    // Add a summary of symbols found in the context
    const allSymbols = new Set<string>();
    const allImports = new Set<string>();
    
    for (const chunk of relevantChunks) {
      chunk.symbols.forEach(symbol => allSymbols.add(symbol));
      chunk.imports.forEach(imp => allImports.add(imp));
    }
    
    const symbolSummary = `Symbols: ${Array.from(allSymbols).join(', ')}\n`;
    const importSummary = `Imports: ${Array.from(allImports).join(', ')}\n`;
    
    if (tokenCount + this.estimateTokens(symbolSummary + importSummary) <= tokenLimit) {
      context += '\nSummary:\n' + symbolSummary + importSummary;
    }
    
    return context;
  }
  
  private estimateTokens(text: string): number {
    // A very rough estimate: 1 token  4 characters
    return Math.ceil(text.length / 4);
  }
}

```


---

### File: `archive/vscode-extension/src/context/types.ts`

```typescript
export interface CodeChunk {
  id: string;
  filePath: string;
  content: string;
  startLine: number;
  endLine: number;
  symbols: string[];
  imports: string[];
  language: string;
  embedding?: number[];
}

```


---

### File: `archive/vscode-extension/src/context/dependencyGraph.js`

```javascript
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DependencyGraph = void 0;
class DependencyGraph {
    constructor() {
        this.nodes = new Map();
    }
    addChunk(chunk) {
        const nodeId = chunk.filePath;
        if (!this.nodes.has(nodeId)) {
            this.nodes.set(nodeId, {
                id: nodeId,
                filePath: chunk.filePath,
                symbols: [...chunk.symbols],
                imports: [...chunk.imports],
                dependencies: [],
                dependents: []
            });
        }
        else {
            // Update existing node
            const node = this.nodes.get(nodeId);
            chunk.symbols.forEach(symbol => {
                if (!node.symbols.includes(symbol)) {
                    node.symbols.push(symbol);
                }
            });
            chunk.imports.forEach(imp => {
                if (!node.imports.includes(imp)) {
                    node.imports.push(imp);
                }
            });
        }
    }
    buildGraph() {
        // Clear existing dependencies
        for (const node of this.nodes.values()) {
            node.dependencies = [];
            node.dependents = [];
        }
        // Build dependencies based on imports and symbols
        for (const [id, node] of this.nodes.entries()) {
            for (const [otherId, otherNode] of this.nodes.entries()) {
                if (id === otherId) {
                    continue;
                }
                // Check if this node imports symbols from the other node
                for (const imp of node.imports) {
                    if (otherNode.symbols.some(symbol => imp.includes(symbol))) {
                        if (!node.dependencies.includes(otherId)) {
                            node.dependencies.push(otherId);
                        }
                        if (!otherNode.dependents.includes(id)) {
                            otherNode.dependents.push(id);
                        }
                    }
                }
            }
        }
    }
    getRelatedFiles(filePath, depth = 1) {
        const node = this.nodes.get(filePath);
        if (!node) {
            return [];
        }
        const visited = new Set();
        const result = [];
        // Add direct dependencies
        this.traverseGraph(node, visited, result, depth, true);
        // Add direct dependents
        this.traverseGraph(node, visited, result, depth, false);
        return result;
    }
    traverseGraph(node, visited, result, depth, isDependency) {
        if (depth <= 0 || visited.has(node.id)) {
            return;
        }
        visited.add(node.id);
        if (node.id !== result[0]) { // Don't add the starting node
            result.push(node.id);
        }
        const nextNodes = isDependency ? node.dependencies : node.dependents;
        for (const nextId of nextNodes) {
            const nextNode = this.nodes.get(nextId);
            if (nextNode) {
                this.traverseGraph(nextNode, visited, result, depth - 1, isDependency);
            }
        }
    }
}
exports.DependencyGraph = DependencyGraph;
//# sourceMappingURL=dependencyGraph.js.map
```


---

### File: `archive/vscode-extension/src/context/persistentVectorStore.js`

```javascript
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.PersistentVectorStore = void 0;
const path = __importStar(require("path"));
const fs = __importStar(require("fs"));
const vscode = __importStar(require("vscode"));
const sqlite3 = __importStar(require("sqlite3"));
const sqlite_1 = require("sqlite");
const vectorStore_1 = require("./vectorStore");
/**
 * A vector store that persists embeddings to disk using SQLite
 */
class PersistentVectorStore extends vectorStore_1.VectorStore {
    /**
     * Create a new persistent vector store
     * @param embeddingService The embedding service to use
     * @param dbPath Path to the SQLite database file (optional, defaults to extension storage path)
     * @param autoSaveIntervalMs Interval in milliseconds to auto-save changes (optional, defaults to 60000)
     */
    constructor(embeddingService, dbPath, autoSaveIntervalMs = 60000) {
        super(embeddingService);
        this.db = null;
        this.autoSaveInterval = null;
        this.isDirty = false;
        this.isInitialized = false;
        // If no dbPath is provided, use the extension's storage path
        if (!dbPath) {
            const storagePath = this.getStoragePath();
            if (!storagePath) {
                throw new Error('Could not determine storage path for persistent vector store');
            }
            // Ensure the directory exists
            if (!fs.existsSync(storagePath)) {
                fs.mkdirSync(storagePath, { recursive: true });
            }
            this.dbPath = path.join(storagePath, 'vector-store.db');
        }
        else {
            this.dbPath = dbPath;
        }
        // Set up auto-save if interval is positive
        if (autoSaveIntervalMs > 0) {
            this.autoSaveInterval = setInterval(() => {
                if (this.isDirty) {
                    this.saveToDatabase().catch(error => {
                        console.error('Error auto-saving vector store:', error);
                    });
                }
            }, autoSaveIntervalMs);
        }
    }
    /**
     * Initialize the database
     */
    async initialize() {
        if (this.isInitialized) {
            return;
        }
        try {
            // Open the database
            this.db = await (0, sqlite_1.open)({
                filename: this.dbPath,
                driver: sqlite3.Database
            });
            // Create tables if they don't exist
            await this.db.exec(`
        CREATE TABLE IF NOT EXISTS chunks (
          id TEXT PRIMARY KEY,
          filePath TEXT NOT NULL,
          content TEXT NOT NULL,
          startLine INTEGER NOT NULL,
          endLine INTEGER NOT NULL,
          language TEXT NOT NULL,
          symbols TEXT,
          imports TEXT
        );
        
        CREATE TABLE IF NOT EXISTS embeddings (
          chunk_id TEXT PRIMARY KEY,
          embedding BLOB NOT NULL,
          FOREIGN KEY (chunk_id) REFERENCES chunks (id) ON DELETE CASCADE
        );
        
        CREATE INDEX IF NOT EXISTS idx_chunks_filePath ON chunks (filePath);
      `);
            // Load existing chunks from the database
            await this.loadFromDatabase();
            this.isInitialized = true;
        }
        catch (error) {
            console.error('Error initializing persistent vector store:', error);
            throw error;
        }
    }
    /**
     * Add a chunk to the vector store
     * @param chunk The chunk to add
     */
    async addChunk(chunk) {
        // Call the parent method to add the chunk to memory
        await super.addChunk(chunk);
        // Mark as dirty to trigger auto-save
        this.isDirty = true;
    }
    /**
     * Delete a chunk from the vector store
     * @param id The ID of the chunk to delete
     */
    async deleteChunk(id) {
        // Call the parent method to delete the chunk from memory
        await super.deleteChunk(id);
        // Delete from database if initialized
        if (this.db) {
            try {
                await this.db.run('DELETE FROM chunks WHERE id = ?', id);
                await this.db.run('DELETE FROM embeddings WHERE chunk_id = ?', id);
            }
            catch (error) {
                console.error(`Error deleting chunk ${id} from database:`, error);
            }
        }
        // Mark as dirty to trigger auto-save
        this.isDirty = true;
    }
    /**
     * Clear the vector store
     */
    async clear() {
        // Call the parent method to clear the in-memory store
        await super.clear();
        // Clear the database if initialized
        if (this.db) {
            try {
                await this.db.exec('DELETE FROM embeddings');
                await this.db.exec('DELETE FROM chunks');
            }
            catch (error) {
                console.error('Error clearing database:', error);
            }
        }
        // Mark as dirty to trigger auto-save
        this.isDirty = true;
    }
    /**
     * Save all chunks to the database
     */
    async saveToDatabase() {
        if (!this.db) {
            await this.initialize();
        }
        if (!this.db) {
            throw new Error('Database not initialized');
        }
        try {
            // Start a transaction
            await this.db.exec('BEGIN TRANSACTION');
            // Get all chunks
            const chunks = await this.getAllChunks();
            // Insert or update each chunk
            for (const chunk of chunks) {
                // Insert or replace the chunk
                await this.db.run(`INSERT OR REPLACE INTO chunks (id, filePath, content, startLine, endLine, language, symbols, imports)
           VALUES (?, ?, ?, ?, ?, ?, ?, ?)`, chunk.id, chunk.filePath, chunk.content, chunk.startLine, chunk.endLine, chunk.language, JSON.stringify(chunk.symbols), JSON.stringify(chunk.imports));
                // Insert or replace the embedding if it exists
                if (chunk.embedding) {
                    await this.db.run(`INSERT OR REPLACE INTO embeddings (chunk_id, embedding)
             VALUES (?, ?)`, chunk.id, Buffer.from(new Float32Array(chunk.embedding).buffer));
                }
            }
            // Commit the transaction
            await this.db.exec('COMMIT');
            // Reset dirty flag
            this.isDirty = false;
            console.log(`Saved ${chunks.length} chunks to database`);
        }
        catch (error) {
            // Rollback the transaction on error
            if (this.db) {
                await this.db.exec('ROLLBACK');
            }
            console.error('Error saving to database:', error);
            throw error;
        }
    }
    /**
     * Load chunks from the database
     */
    async loadFromDatabase() {
        if (!this.db) {
            throw new Error('Database not initialized');
        }
        try {
            // Get all chunks from the database
            const rows = await this.db.all(`
        SELECT c.id, c.filePath, c.content, c.startLine, c.endLine, c.language, c.symbols, c.imports, e.embedding
        FROM chunks c
        LEFT JOIN embeddings e ON c.id = e.chunk_id
      `);
            // Clear existing chunks
            await super.clear();
            // Add each chunk to the in-memory store
            for (const row of rows) {
                const chunk = {
                    id: row.id,
                    filePath: row.filePath,
                    content: row.content,
                    startLine: row.startLine,
                    endLine: row.endLine,
                    language: row.language,
                    symbols: row.symbols ? JSON.parse(row.symbols) : [],
                    imports: row.imports ? JSON.parse(row.imports) : []
                };
                // Add embedding if it exists
                if (row.embedding) {
                    const buffer = Buffer.from(row.embedding);
                    const float32Array = new Float32Array(buffer.buffer, buffer.byteOffset, buffer.byteLength / 4);
                    chunk.embedding = Array.from(float32Array);
                }
                // Add to in-memory store without saving to database
                await super.addChunk(chunk);
            }
            console.log(`Loaded ${rows.length} chunks from database`);
        }
        catch (error) {
            console.error('Error loading from database:', error);
            throw error;
        }
    }
    /**
     * Get the storage path for the extension
     */
    getStoragePath() {
        // Get the extension context
        const extension = vscode.extensions.getExtension('qwen-coder-assistant');
        if (extension) {
            return extension.extensionPath;
        }
        // Fallback to the workspace storage path
        if (vscode.workspace.workspaceFolders && vscode.workspace.workspaceFolders.length > 0) {
            return path.join(vscode.workspace.workspaceFolders[0].uri.fsPath, '.vscode');
        }
        return undefined;
    }
    /**
     * Dispose of resources
     */
    async dispose() {
        // Clear auto-save interval
        if (this.autoSaveInterval) {
            clearInterval(this.autoSaveInterval);
            this.autoSaveInterval = null;
        }
        // Save any pending changes
        if (this.isDirty && this.db) {
            try {
                await this.saveToDatabase();
            }
            catch (error) {
                console.error('Error saving vector store during disposal:', error);
            }
        }
        // Close the database
        if (this.db) {
            await this.db.close();
            this.db = null;
        }
    }
}
exports.PersistentVectorStore = PersistentVectorStore;
//# sourceMappingURL=persistentVectorStore.js.map
```


---

### File: `archive/vscode-extension/src/context/embeddingService.js`

```javascript
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddingService = void 0;
const axios_1 = __importDefault(require("axios"));
const configuration_1 = require("../configuration");
class EmbeddingService {
    constructor() {
        const config = (0, configuration_1.getConfiguration)();
        this.apiEndpoint = config.apiEndpoint;
        this.apiKey = config.apiKey;
    }
    async generateEmbedding(text) {
        try {
            const response = await axios_1.default.post(`${this.apiEndpoint}/embeddings`, {
                input: text,
                model: 'qwen3-embedding'
            }, {
                headers: {
                    'Authorization': `Bearer ${this.apiKey}`,
                    'Content-Type': 'application/json'
                }
            });
            return response.data.data[0].embedding;
        }
        catch (error) {
            console.error('Error generating embedding:', error);
            throw new Error('Failed to generate embedding');
        }
    }
    async generateBatchEmbeddings(texts) {
        try {
            const response = await axios_1.default.post(`${this.apiEndpoint}/embeddings`, {
                input: texts,
                model: 'qwen3-embedding'
            }, {
                headers: {
                    'Authorization': `Bearer ${this.apiKey}`,
                    'Content-Type': 'application/json'
                }
            });
            return response.data.data.map((item) => item.embedding);
        }
        catch (error) {
            console.error('Error generating batch embeddings:', error);
            throw new Error('Failed to generate batch embeddings');
        }
    }
}
exports.EmbeddingService = EmbeddingService;
//# sourceMappingURL=embeddingService.js.map
```


---

### File: `archive/vscode-extension/src/context/contextEngine.js`

```javascript
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContextEngine = void 0;
const vscode = __importStar(require("vscode"));
const contextComposer_1 = require("./contextComposer");
const dependencyGraph_1 = require("./dependencyGraph");
const embeddingService_1 = require("./embeddingService");
const fileIndexer_1 = require("./fileIndexer");
const semanticSearch_1 = require("./semanticSearch");
const symbolExtractor_1 = require("./symbolExtractor");
const vectorStore_1 = require("./vectorStore");
class ContextEngine {
    constructor() {
        this.isInitialized = false;
        this.embeddingService = new embeddingService_1.EmbeddingService();
        this.symbolExtractor = new symbolExtractor_1.SymbolExtractor();
        // Get configuration for context engine
        const config = getConfiguration().contextEngine;
        // Use persistent vector store if enabled in configuration
        if (config.persistEmbeddings) {
            console.log('Using persistent vector store for embeddings');
            this.vectorStore = new PersistentVectorStore(this.embeddingService, config.databasePath || undefined, config.autoSaveIntervalMs);
        }
        else {
            console.log('Using in-memory vector store for embeddings');
            this.vectorStore = new vectorStore_1.VectorStore(this.embeddingService);
        }
        this.contextComposer = new contextComposer_1.ContextComposer();
        this.dependencyGraph = new dependencyGraph_1.DependencyGraph();
        this.semanticSearch = new semanticSearch_1.SemanticSearch(this.vectorStore, this.embeddingService);
        this.fileIndexer = new fileIndexer_1.FileIndexer(this.symbolExtractor, this.embeddingService, this.vectorStore);
    }
    async initialize() {
        if (this.isInitialized) {
            return;
        }
        // Initialize the persistent vector store if needed
        if (this.vectorStore instanceof PersistentVectorStore) {
            console.log('Initializing persistent vector store');
            await this.vectorStore.initialize();
        }
        // Only index the workspace if the vector store is empty
        const existingChunks = await this.vectorStore.findSimilarChunks('', 10);
        if (existingChunks.length === 0) {
            console.log('Vector store is empty, indexing workspace');
            await this.fileIndexer.indexWorkspace();
        }
        else {
            console.log(`Found ${existingChunks.length} existing chunks in vector store, skipping indexing`);
        }
        // Build dependency graph
        const allChunks = await this.vectorStore.findSimilarChunks('', 10000);
        for (const chunk of allChunks) {
            this.dependencyGraph.addChunk(chunk);
        }
        this.dependencyGraph.buildGraph();
        this.isInitialized = true;
    }
    async getContext(query, tokenLimit = 4000) {
        if (!this.isInitialized) {
            await this.initialize();
        }
        // Find relevant chunks using semantic search
        const relevantChunks = await this.semanticSearch.search(query, 10);
        // Extract symbols from the query
        const symbols = this.extractSymbolsFromQuery(query);
        // If we found symbols, add chunks related to those symbols
        if (symbols.length > 0) {
            for (const symbol of symbols) {
                const symbolChunks = await this.semanticSearch.searchBySymbol(symbol, 5);
                // Add symbol chunks to relevant chunks, avoiding duplicates
                const existingIds = new Set(relevantChunks.map(chunk => chunk.id));
                for (const chunk of symbolChunks) {
                    if (!existingIds.has(chunk.id)) {
                        relevantChunks.push(chunk);
                        existingIds.add(chunk.id);
                    }
                }
            }
        }
        // Get the active editor file path
        const activeEditor = vscode.window.activeTextEditor;
        if (activeEditor) {
            const filePath = activeEditor.document.uri.fsPath;
            // Get related files from dependency graph
            const relatedFiles = this.dependencyGraph.getRelatedFiles(filePath, 1);
            // Add chunks from related files
            for (const relatedFile of relatedFiles) {
                const fileChunks = await this.getChunksForFile(relatedFile);
                // Add file chunks to relevant chunks, avoiding duplicates
                const existingIds = new Set(relevantChunks.map(chunk => chunk.id));
                for (const chunk of fileChunks) {
                    if (!existingIds.has(chunk.id)) {
                        relevantChunks.push(chunk);
                        existingIds.add(chunk.id);
                    }
                }
            }
        }
        // Compose context
        return this.contextComposer.composeContext(query, relevantChunks, tokenLimit);
    }
    async getContextForFile(filePath, tokenLimit = 4000) {
        if (!this.isInitialized) {
            await this.initialize();
        }
        // Get chunks for this file
        const fileChunks = await this.getChunksForFile(filePath);
        // Get related files from dependency graph
        const relatedFiles = this.dependencyGraph.getRelatedFiles(filePath, 1);
        // Add chunks from related files
        const allChunks = [...fileChunks];
        const existingIds = new Set(allChunks.map(chunk => chunk.id));
        for (const relatedFile of relatedFiles) {
            const relatedChunks = await this.getChunksForFile(relatedFile);
            for (const chunk of relatedChunks) {
                if (!existingIds.has(chunk.id)) {
                    allChunks.push(chunk);
                    existingIds.add(chunk.id);
                }
            }
        }
        // Compose context
        return this.contextComposer.composeContext(`File: ${filePath}`, allChunks, tokenLimit);
    }
    async getContextForSymbol(symbol, tokenLimit = 4000) {
        if (!this.isInitialized) {
            await this.initialize();
        }
        // Find chunks related to this symbol
        const symbolChunks = await this.semanticSearch.searchBySymbol(symbol, 10);
        // Compose context
        return this.contextComposer.composeContext(`Symbol: ${symbol}`, symbolChunks, tokenLimit);
    }
    async getChunksForFile(filePath) {
        // Find chunks for this file
        const allChunks = await this.vectorStore.findSimilarChunks('', 10000);
        return allChunks.filter(chunk => chunk.filePath === filePath);
    }
    extractSymbolsFromQuery(query) {
        // Extract potential symbols from the query
        // This is a simplified implementation
        const words = query.split(/\s+/);
        const symbols = [];
        for (const word of words) {
            // Clean up the word
            const cleanWord = word.replace(/[^\w]/g, '');
            // Check if it looks like a symbol (camelCase, PascalCase, snake_case)
            if (cleanWord.length > 0 &&
                (cleanWord.match(/[a-z][A-Z]/) || // camelCase
                    cleanWord.match(/^[A-Z][a-z]/) || // PascalCase
                    cleanWord.includes('_'))) { // snake_case
                symbols.push(cleanWord);
            }
        }
        return symbols;
    }
    async dispose() {
        // Dispose the file indexer
        this.fileIndexer.dispose();
        // Dispose the persistent vector store if needed
        if (this.vectorStore instanceof PersistentVectorStore) {
            console.log('Disposing persistent vector store');
            await this.vectorStore.dispose();
        }
    }
}
exports.ContextEngine = ContextEngine;
//# sourceMappingURL=contextEngine.js.map
```


---

### File: `archive/vscode-extension/src/context/fileIndexer.ts`

```typescript
import * as vscode from 'vscode';
import { EmbeddingService } from './embeddingService';
import { SymbolExtractor } from './symbolExtractor';
import { CodeChunk } from './types';
import { VectorStore } from './vectorStore';

export class FileIndexer {
  private symbolExtractor: SymbolExtractor;
  private embeddingService: EmbeddingService;
  private vectorStore: VectorStore;
  private fileWatcher: vscode.FileSystemWatcher;
  private indexingStatus: vscode.StatusBarItem;

  constructor(
    symbolExtractor: SymbolExtractor,
    embeddingService: EmbeddingService,
    vectorStore: VectorStore
  ) {
    this.symbolExtractor = symbolExtractor;
    this.embeddingService = embeddingService;
    this.vectorStore = vectorStore;

    // Create status bar item
    this.indexingStatus = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 100);

    // Set up file watcher
    this.fileWatcher = vscode.workspace.createFileSystemWatcher('**/*.*');
    this.fileWatcher.onDidChange(this.handleFileChange.bind(this));
    this.fileWatcher.onDidCreate(this.handleFileCreate.bind(this));
    this.fileWatcher.onDidDelete(this.handleFileDelete.bind(this));
  }

  /**
   * Index the entire workspace
   */
  public async indexWorkspace(): Promise<void> {
    this.indexingStatus.text = '$(sync~spin) Indexing workspace...';
    this.indexingStatus.show();

    try {
      // Expanded file pattern to include more languages
      const files = await vscode.workspace.findFiles(
        '**/*.{js,ts,jsx,tsx,py,java,c,cpp,h,hpp,cs,go,rb,php,rs,swift,kt,html,css,scss,sass,json,yaml,yml,xml,md}',
        '{**/node_modules/**,**/dist/**,**/build/**,**/.git/**,**/venv/**,**/__pycache__/**}'
      );

      let processedFiles = 0;
      const totalFiles = files.length;

      // Process files in batches to avoid blocking the UI
      const batchSize = 20;
      for (let i = 0; i < totalFiles; i += batchSize) {
        const batch = files.slice(i, i + batchSize);

        // Process batch in parallel
        await Promise.all(batch.map(file => this.indexFile(file)));

        processedFiles += batch.length;
        this.indexingStatus.text = `$(sync~spin) Indexing workspace... ${processedFiles}/${totalFiles}`;

        // Yield to the event loop to keep the UI responsive
        await new Promise(resolve => setTimeout(resolve, 0));
      }

      this.indexingStatus.text = `$(check) Workspace indexed (${totalFiles} files)`;
      setTimeout(() => {
        this.indexingStatus.hide();
      }, 3000);
    } catch (error) {
      this.indexingStatus.text = '$(error) Indexing failed';
      console.error('Error indexing workspace:', error);
    }
  }

  /**
   * Index a single file
   * @param uri File URI
   */
  private async indexFile(uri: vscode.Uri): Promise<void> {
    try {
      // Get file path
      const filePath = uri.fsPath;

      // Try to detect language from file extension
      let language = SymbolExtractor.detectLanguageFromPath(filePath);

      // If we can't detect the language from the path, try to open the document
      if (!language) {
        try {
          const document = await vscode.workspace.openTextDocument(uri);
          language = document.languageId;
        } catch (e) {
          // If we can't open the document, use a generic language
          language = 'text';
        }
      }

      // Read file content
      let content: string;
      try {
        const document = await vscode.workspace.openTextDocument(uri);
        content = document.getText();
      } catch (e) {
        // If we can't open the document, skip this file
        console.warn(`Skipping file ${filePath}: Unable to read content`);
        return;
      }

      // Skip empty files or files that are too large
      if (content.length === 0) {
        console.log(`Skipping empty file: ${filePath}`);
        return;
      }

      if (content.length > 1000000) {
        console.log(`Skipping large file (${content.length} bytes): ${filePath}`);
        return;
      }

      // Skip binary files
      if (this.isBinaryContent(content)) {
        console.log(`Skipping binary file: ${filePath}`);
        return;
      }

      // Split file into chunks
      const chunks = this.chunkFile(content, filePath, language);

      // Process each chunk
      for (const chunk of chunks) {
        try {
          // Extract symbols
          const { symbols, imports, dependencies } = await this.symbolExtractor.extractSymbols(chunk.content, language);
          chunk.symbols = symbols;
          chunk.imports = imports;

          // Generate embedding
          chunk.embedding = await this.embeddingService.generateEmbedding(chunk.content);

          // Add to vector store
          await this.vectorStore.addChunk(chunk);
        } catch (chunkError) {
          console.error(`Error processing chunk ${chunk.id}:`, chunkError);
        }
      }
    } catch (error) {
      console.error(`Error indexing file ${uri.fsPath}:`, error);
    }
  }

  /**
   * Check if content appears to be binary
   * @param content File content
   * @returns True if the content appears to be binary
   */
  private isBinaryContent(content: string): boolean {
    // Check for null bytes or a high percentage of non-printable characters
    if (content.includes('\0')) {
      return true;
    }

    // Check the first 1000 characters
    const sampleSize = Math.min(1000, content.length);
    const sample = content.substring(0, sampleSize);

    // Count non-printable characters
    let nonPrintableCount = 0;
    for (let i = 0; i < sample.length; i++) {
      const charCode = sample.charCodeAt(i);
      if ((charCode < 32 && charCode !== 9 && charCode !== 10 && charCode !== 13) || charCode > 126) {
        nonPrintableCount++;
      }
    }

    // If more than 10% of characters are non-printable, consider it binary
    return nonPrintableCount > sampleSize * 0.1;
  }

  /**
   * Split a file into chunks based on its content and language
   * @param content File content
   * @param filePath File path
   * @param language Language ID
   * @returns Array of code chunks
   */
  private chunkFile(content: string, filePath: string, language: string): CodeChunk[] {
    const chunks: CodeChunk[] = [];
    const lines = content.split('\n');

    // For very small files, use a single chunk
    if (lines.length <= 50) {
      chunks.push({
        id: `${filePath}:0-${lines.length}`,
        filePath,
        content,
        startLine: 0,
        endLine: lines.length,
        symbols: [],
        imports: [],
        language
      });
      return chunks;
    }

    // For medium-sized files, use a single chunk if it's not code
    if (lines.length <= 200 && this.isDataOrDocFile(language)) {
      chunks.push({
        id: `${filePath}:0-${lines.length}`,
        filePath,
        content,
        startLine: 0,
        endLine: lines.length,
        symbols: [],
        imports: [],
        language
      });
      return chunks;
    }

    // For larger files, use language-specific chunking
    switch (language) {
      case 'javascript':
      case 'typescript':
      case 'javascriptreact':
      case 'typescriptreact':
        return this.chunkJavaScriptFile(content, filePath, language, lines);

      case 'python':
        return this.chunkPythonFile(content, filePath, language, lines);

      case 'java':
      case 'csharp':
      case 'cpp':
      case 'c':
        return this.chunkCStyleFile(content, filePath, language, lines);

      default:
        return this.chunkGenericFile(content, filePath, language, lines);
    }
  }

  /**
   * Check if the file is a data or documentation file
   * @param language Language ID
   * @returns True if the file is a data or documentation file
   */
  private isDataOrDocFile(language: string): boolean {
    return ['json', 'yaml', 'xml', 'markdown', 'html', 'css', 'scss', 'sass'].includes(language);
  }

  /**
   * Chunk a JavaScript/TypeScript file
   */
  private chunkJavaScriptFile(content: string, filePath: string, language: string, lines: string[]): CodeChunk[] {
    const chunks: CodeChunk[] = [];
    let chunkStart = 0;
    let braceBalance = 0;
    let inFunction = false;
    let inClass = false;

    // Always include imports in the first chunk
    let importsEndLine = 0;
    for (let i = 0; i < Math.min(50, lines.length); i++) {
      if (lines[i].includes('import ') || lines[i].includes('require(')) {
        importsEndLine = i + 1;
      }
    }

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();

      // Track brace balance
      braceBalance += (line.match(/{/g) || []).length;
      braceBalance -= (line.match(/}/g) || []).length;

      // Detect function or class start
      if (!inFunction && !inClass) {
        if (line.includes('function ') || line.includes('=>') || line.includes('class ')) {
          inFunction = line.includes('function ') || line.includes('=>');
          inClass = line.includes('class ');
        }
      }

      // Check if we should end the current chunk
      const isBlockEnd = (braceBalance === 0 && (inFunction || inClass)) ||
                         i === lines.length - 1;

      if (isBlockEnd || (i - chunkStart > 200)) {
        // Create a chunk
        const chunkEndLine = i + 1;
        const chunkContent = lines.slice(chunkStart, chunkEndLine).join('\n');

        // For the first chunk, include imports
        if (chunkStart === 0 && importsEndLine > 0 && chunkStart !== importsEndLine) {
          const importsContent = lines.slice(0, importsEndLine).join('\n');
          chunks.push({
            id: `${filePath}:0-${importsEndLine}`,
            filePath,
            content: importsContent,
            startLine: 0,
            endLine: importsEndLine,
            symbols: [],
            imports: [],
            language
          });

          // If the first chunk is just imports, continue to the next chunk
          if (chunkEndLine <= importsEndLine) {
            chunkStart = chunkEndLine;
            inFunction = false;
            inClass = false;
            continue;
          }
        }

        chunks.push({
          id: `${filePath}:${chunkStart}-${chunkEndLine}`,
          filePath,
          content: chunkContent,
          startLine: chunkStart,
          endLine: chunkEndLine,
          symbols: [],
          imports: [],
          language
        });

        chunkStart = chunkEndLine;
        inFunction = false;
        inClass = false;
      }
    }

    return chunks;
  }

  /**
   * Chunk a Python file
   */
  private chunkPythonFile(content: string, filePath: string, language: string, lines: string[]): CodeChunk[] {
    const chunks: CodeChunk[] = [];
    let chunkStart = 0;
    let indentLevel = 0;
    let inFunction = false;
    let inClass = false;

    // Always include imports in the first chunk
    let importsEndLine = 0;
    for (let i = 0; i < Math.min(50, lines.length); i++) {
      if (lines[i].includes('import ') || lines[i].includes('from ')) {
        importsEndLine = i + 1;
      }
    }

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const trimmedLine = line.trim();

      // Skip empty lines and comments
      if (trimmedLine === '' || trimmedLine.startsWith('#')) {
        continue;
      }

      // Calculate indent level
      const currentIndent = line.length - line.trimStart().length;

      // Detect function or class start
      if (currentIndent === 0 && !inFunction && !inClass) {
        if (trimmedLine.startsWith('def ') || trimmedLine.startsWith('class ')) {
          inFunction = trimmedLine.startsWith('def ');
          inClass = trimmedLine.startsWith('class ');
          indentLevel = currentIndent;
        }
      }

      // Check if we should end the current chunk
      const isBlockEnd = (currentIndent <= indentLevel && (inFunction || inClass) && i > chunkStart) ||
                         i === lines.length - 1;

      if (isBlockEnd || (i - chunkStart > 200)) {
        // Create a chunk
        const chunkEndLine = i;
        const chunkContent = lines.slice(chunkStart, chunkEndLine).join('\n');

        // For the first chunk, include imports
        if (chunkStart === 0 && importsEndLine > 0 && chunkStart !== importsEndLine) {
          const importsContent = lines.slice(0, importsEndLine).join('\n');
          chunks.push({
            id: `${filePath}:0-${importsEndLine}`,
            filePath,
            content: importsContent,
            startLine: 0,
            endLine: importsEndLine,
            symbols: [],
            imports: [],
            language
          });

          // If the first chunk is just imports, continue to the next chunk
          if (chunkEndLine <= importsEndLine) {
            chunkStart = chunkEndLine;
            inFunction = false;
            inClass = false;
            indentLevel = 0;
            continue;
          }
        }

        chunks.push({
          id: `${filePath}:${chunkStart}-${chunkEndLine}`,
          filePath,
          content: chunkContent,
          startLine: chunkStart,
          endLine: chunkEndLine,
          symbols: [],
          imports: [],
          language
        });

        chunkStart = chunkEndLine;
        inFunction = false;
        inClass = false;
        indentLevel = 0;
      }
    }

    // Handle the case where the file ends without a block end
    if (chunkStart < lines.length) {
      const chunkContent = lines.slice(chunkStart).join('\n');
      chunks.push({
        id: `${filePath}:${chunkStart}-${lines.length}`,
        filePath,
        content: chunkContent,
        startLine: chunkStart,
        endLine: lines.length,
        symbols: [],
        imports: [],
        language
      });
    }

    return chunks;
  }

  /**
   * Chunk a C-style file (Java, C#, C, C++)
   */
  private chunkCStyleFile(content: string, filePath: string, language: string, lines: string[]): CodeChunk[] {
    const chunks: CodeChunk[] = [];
    let chunkStart = 0;
    let braceBalance = 0;
    let inFunction = false;
    let inClass = false;

    // Always include imports/includes in the first chunk
    let importsEndLine = 0;
    for (let i = 0; i < Math.min(50, lines.length); i++) {
      if (lines[i].includes('import ') || lines[i].includes('#include ') ||
          lines[i].includes('using ') || lines[i].includes('package ')) {
        importsEndLine = i + 1;
      }
    }

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();

      // Track brace balance
      braceBalance += (line.match(/{/g) || []).length;
      braceBalance -= (line.match(/}/g) || []).length;

      // Detect function or class start
      if (!inFunction && !inClass && braceBalance === 0) {
        if ((line.includes('(') && line.includes(')') && !line.includes(';')) ||
            line.includes('class ') || line.includes('interface ') ||
            line.includes('struct ') || line.includes('enum ')) {
          inFunction = line.includes('(') && line.includes(')') && !line.includes(';');
          inClass = line.includes('class ') || line.includes('interface ') ||
                   line.includes('struct ') || line.includes('enum ');
        }
      }

      // Check if we should end the current chunk
      const isBlockEnd = (braceBalance === 0 && (inFunction || inClass) && i > chunkStart) ||
                         i === lines.length - 1;

      if (isBlockEnd || (i - chunkStart > 200)) {
        // Create a chunk
        const chunkEndLine = i + 1;
        const chunkContent = lines.slice(chunkStart, chunkEndLine).join('\n');

        // For the first chunk, include imports
        if (chunkStart === 0 && importsEndLine > 0 && chunkStart !== importsEndLine) {
          const importsContent = lines.slice(0, importsEndLine).join('\n');
          chunks.push({
            id: `${filePath}:0-${importsEndLine}`,
            filePath,
            content: importsContent,
            startLine: 0,
            endLine: importsEndLine,
            symbols: [],
            imports: [],
            language
          });

          // If the first chunk is just imports, continue to the next chunk
          if (chunkEndLine <= importsEndLine) {
            chunkStart = chunkEndLine;
            inFunction = false;
            inClass = false;
            braceBalance = 0;
            continue;
          }
        }

        chunks.push({
          id: `${filePath}:${chunkStart}-${chunkEndLine}`,
          filePath,
          content: chunkContent,
          startLine: chunkStart,
          endLine: chunkEndLine,
          symbols: [],
          imports: [],
          language
        });

        chunkStart = chunkEndLine;
        inFunction = false;
        inClass = false;
        braceBalance = 0;
      }
    }

    return chunks;
  }

  /**
   * Chunk a generic file (fallback for unsupported languages)
   */
  private chunkGenericFile(content: string, filePath: string, language: string, lines: string[]): CodeChunk[] {
    const chunks: CodeChunk[] = [];
    const maxChunkSize = 100; // lines

    // For data files, use larger chunks
    const chunkSize = this.isDataOrDocFile(language) ? 200 : maxChunkSize;

    for (let i = 0; i < lines.length; i += chunkSize) {
      const chunkEndLine = Math.min(i + chunkSize, lines.length);
      const chunkContent = lines.slice(i, chunkEndLine).join('\n');

      chunks.push({
        id: `${filePath}:${i}-${chunkEndLine}`,
        filePath,
        content: chunkContent,
        startLine: i,
        endLine: chunkEndLine,
        symbols: [],
        imports: [],
        language
      });
    }

    return chunks;
  }

  private async handleFileChange(uri: vscode.Uri): Promise<void> {
    // Delete existing chunks for this file
    await this.deleteFileChunks(uri.fsPath);

    // Re-index the file
    await this.indexFile(uri);
  }

  private async handleFileCreate(uri: vscode.Uri): Promise<void> {
    await this.indexFile(uri);
  }

  private async handleFileDelete(uri: vscode.Uri): Promise<void> {
    await this.deleteFileChunks(uri.fsPath);
  }

  /**
   * Delete all chunks for a file
   * @param filePath File path
   */
  private async deleteFileChunks(filePath: string): Promise<void> {
    try {
      // Get all chunks from the vector store
      const allChunks = await this.vectorStore.findSimilarChunks('', 10000);

      // Filter chunks for this file
      const fileChunks = allChunks.filter(chunk => chunk.filePath === filePath);

      // Delete each chunk
      for (const chunk of fileChunks) {
        await this.vectorStore.deleteChunk(chunk.id);
      }

      console.log(`Deleted ${fileChunks.length} chunks for file: ${filePath}`);
    } catch (error) {
      console.error(`Error deleting chunks for file ${filePath}:`, error);
    }
  }

  public dispose(): void {
    this.fileWatcher.dispose();
    this.indexingStatus.dispose();
  }
}

```


---

### File: `archive/vscode-extension/src/context/dependencyGraph.ts`

```typescript
import { CodeChunk } from './types';

interface DependencyNode {
  id: string;
  filePath: string;
  symbols: string[];
  imports: string[];
  dependencies: string[];
  dependents: string[];
}

export class DependencyGraph {
  private nodes: Map<string, DependencyNode> = new Map();
  
  public addChunk(chunk: CodeChunk): void {
    const nodeId = chunk.filePath;
    
    if (!this.nodes.has(nodeId)) {
      this.nodes.set(nodeId, {
        id: nodeId,
        filePath: chunk.filePath,
        symbols: [...chunk.symbols],
        imports: [...chunk.imports],
        dependencies: [],
        dependents: []
      });
    } else {
      // Update existing node
      const node = this.nodes.get(nodeId)!;
      chunk.symbols.forEach(symbol => {
        if (!node.symbols.includes(symbol)) {
          node.symbols.push(symbol);
        }
      });
      chunk.imports.forEach(imp => {
        if (!node.imports.includes(imp)) {
          node.imports.push(imp);
        }
      });
    }
  }
  
  public buildGraph(): void {
    // Clear existing dependencies
    for (const node of this.nodes.values()) {
      node.dependencies = [];
      node.dependents = [];
    }
    
    // Build dependencies based on imports and symbols
    for (const [id, node] of this.nodes.entries()) {
      for (const [otherId, otherNode] of this.nodes.entries()) {
        if (id === otherId) {
          continue;
        }
        
        // Check if this node imports symbols from the other node
        for (const imp of node.imports) {
          if (otherNode.symbols.some(symbol => imp.includes(symbol))) {
            if (!node.dependencies.includes(otherId)) {
              node.dependencies.push(otherId);
            }
            if (!otherNode.dependents.includes(id)) {
              otherNode.dependents.push(id);
            }
          }
        }
      }
    }
  }
  
  public getRelatedFiles(filePath: string, depth: number = 1): string[] {
    const node = this.nodes.get(filePath);
    if (!node) {
      return [];
    }
    
    const visited = new Set<string>();
    const result: string[] = [];
    
    // Add direct dependencies
    this.traverseGraph(node, visited, result, depth, true);
    
    // Add direct dependents
    this.traverseGraph(node, visited, result, depth, false);
    
    return result;
  }
  
  private traverseGraph(
    node: DependencyNode,
    visited: Set<string>,
    result: string[],
    depth: number,
    isDependency: boolean
  ): void {
    if (depth <= 0 || visited.has(node.id)) {
      return;
    }
    
    visited.add(node.id);
    if (node.id !== result[0]) { // Don't add the starting node
      result.push(node.id);
    }
    
    const nextNodes = isDependency ? node.dependencies : node.dependents;
    for (const nextId of nextNodes) {
      const nextNode = this.nodes.get(nextId);
      if (nextNode) {
        this.traverseGraph(nextNode, visited, result, depth - 1, isDependency);
      }
    }
  }
}

```


---

### File: `src/errorHandler.ts`

```typescript
import * as vscode from 'vscode';
import axios, { AxiosError } from 'axios';

export enum ErrorType {
  NetworkError = 'NetworkError',
  AuthenticationError = 'AuthenticationError',
  RateLimitError = 'RateLimitError',
  ServerError = 'ServerError',
  TimeoutError = 'TimeoutError',
  UnknownError = 'UnknownError'
}

export interface ErrorDetails {
  type: ErrorType;
  message: string;
  originalError?: Error;
  retryable: boolean;
  suggestedAction?: string;
}

/**
 * Handles API errors and provides user-friendly error messages
 */
export class ErrorHandler {
  /**
   * Process an error and return structured error details
   * @param error The error to process
   * @returns Structured error details
   */
  public static processError(error: unknown): ErrorDetails {
    // Default error details
    let errorDetails: ErrorDetails = {
      type: ErrorType.UnknownError,
      message: 'An unknown error occurred',
      originalError: error instanceof Error ? error : undefined,
      retryable: false
    };

    // Handle Axios errors
    if (axios.isAxiosError(error)) {
      errorDetails = this.processAxiosError(error);
    } 
    // Handle timeout errors
    else if (error instanceof Error && error.message.includes('timeout')) {
      errorDetails = {
        type: ErrorType.TimeoutError,
        message: 'The request timed out. The server might be overloaded.',
        originalError: error,
        retryable: true,
        suggestedAction: 'Try again later or check your internet connection.'
      };
    } 
    // Handle other errors
    else if (error instanceof Error) {
      errorDetails = {
        type: ErrorType.UnknownError,
        message: `Error: ${error.message}`,
        originalError: error,
        retryable: false
      };
    }

    return errorDetails;
  }

  /**
   * Process an Axios error and return structured error details
   * @param error The Axios error to process
   * @returns Structured error details
   */
  private static processAxiosError(error: AxiosError): ErrorDetails {
    // Network errors
    if (error.code === 'ECONNABORTED' || error.code === 'ECONNREFUSED' || error.code === 'ENOTFOUND') {
      return {
        type: ErrorType.NetworkError,
        message: 'Could not connect to the API. Please check your internet connection.',
        originalError: error,
        retryable: true,
        suggestedAction: 'Check your network connection and try again.'
      };
    }

    // Handle based on HTTP status code
    switch (error.response?.status) {
      case 401:
      case 403:
        return {
          type: ErrorType.AuthenticationError,
          message: 'Authentication failed. Please check your API key.',
          originalError: error,
          retryable: false,
          suggestedAction: 'Update your API key in the extension settings.'
        };
      case 429:
        return {
          type: ErrorType.RateLimitError,
          message: 'Rate limit exceeded. Too many requests in a short period.',
          originalError: error,
          retryable: true,
          suggestedAction: 'Wait a moment before trying again.'
        };
      case 500:
      case 502:
      case 503:
      case 504:
        return {
          type: ErrorType.ServerError,
          message: `Server error (${error.response.status}). The API service might be experiencing issues.`,
          originalError: error,
          retryable: true,
          suggestedAction: 'Try again later.'
        };
      default:
        // Try to extract error message from response if available
        let message = 'An error occurred while communicating with the API.';
        try {
          if (error.response?.data) {
            if (typeof error.response.data === 'string') {
              message = error.response.data;
            } else if (typeof error.response.data === 'object' && error.response.data.error) {
              message = error.response.data.error;
            }
          }
        } catch (e) {
          // Ignore parsing errors
        }

        return {
          type: ErrorType.UnknownError,
          message,
          originalError: error,
          retryable: false
        };
    }
  }

  /**
   * Display an error message to the user
   * @param error The error details to display
   */
  public static showErrorToUser(error: ErrorDetails): void {
    const message = `${error.message}${error.suggestedAction ? '\n\n' + error.suggestedAction : ''}`;
    
    // Show different types of notifications based on error type
    if (error.retryable) {
      vscode.window.showWarningMessage(message, 'Retry').then(selection => {
        if (selection === 'Retry') {
          // Emit an event that can be listened to for retrying the operation
          // This will be implemented when we add the retry functionality
        }
      });
    } else {
      vscode.window.showErrorMessage(message);
    }

    // Log the error for debugging
    console.error('API Error:', error.type, error.originalError);
  }

  /**
   * Handle an error by processing it and showing a message to the user
   * @param error The error to handle
   * @returns The processed error details
   */
  public static handleError(error: unknown): ErrorDetails {
    const errorDetails = this.processError(error);
    this.showErrorToUser(errorDetails);
    return errorDetails;
  }
}

```


---

### File: `src/extension.ts`

```typescript
import * as vscode from 'vscode';
import { AgentCoordinator } from './agents/agentCoordinator';
import { getConfiguration, QwenCoderConfig, registerConfigurationListener, verifyConfiguration } from './configuration';
import { AuthManager } from './mcp-client/authentication/authManager';
import { McpClient } from './mcp-client/mcpClient';
import { McpServerManager } from './mcp-client/mcpServerManager';
import { OfficialMcpServersManager } from './mcp-client/officialMcpServers';
import { ServerHealthMonitor } from './mcp-client/serverHealthMonitor';
import { QwenApiClient } from './qwenApi';
import { McpServerTreeDataProvider, McpServerTreeItem } from './ui/mcpServerTreeDataProvider';

// Global state
let mcpServerManager: McpServerManager | undefined;
let mcpClient: McpClient | undefined;
let mcpServerTreeDataProvider: McpServerTreeDataProvider | undefined;
let qwenApiClient: QwenApiClient | undefined;
let agentCoordinator: AgentCoordinator | undefined;
let serverHealthMonitor: ServerHealthMonitor | undefined;
let officialMcpServersManager: OfficialMcpServersManager | undefined;
let authManager: AuthManager | undefined;

/**
 * Activate the extension
 * @param context Extension context
 */
export async function activate(context: vscode.ExtensionContext) {
  console.log('Qwen Coder Assistant is now active!');

  // Get configuration
  const config = getConfiguration();

  // Initialize the MCP server manager
  mcpServerManager = new McpServerManager();

  // Initialize the authentication manager
  authManager = new AuthManager(context);
  context.subscriptions.push(authManager);

  // Initialize the MCP client
  mcpClient = new McpClient(mcpServerManager, authManager);

  // Initialize the server health monitor
  serverHealthMonitor = new ServerHealthMonitor(mcpServerManager);
  context.subscriptions.push(serverHealthMonitor);

  // Initialize the official MCP servers manager
  officialMcpServersManager = new OfficialMcpServersManager(mcpServerManager);

  // Initialize the MCP server tree data provider
  mcpServerTreeDataProvider = new McpServerTreeDataProvider(mcpServerManager, serverHealthMonitor);

  // Register the MCP server tree data provider
  vscode.window.registerTreeDataProvider('qwenMcpServers', mcpServerTreeDataProvider);

  // Initialize the Qwen API client
  qwenApiClient = new QwenApiClient(config);

  // Initialize the agent coordinator
  agentCoordinator = new AgentCoordinator(qwenApiClient, mcpClient, config);

  // Register commands
  registerCommands(context);

  // Listen for configuration changes
  context.subscriptions.push(
    registerConfigurationListener(handleConfigurationChange)
  );

  // Start the server health monitor
  serverHealthMonitor.start();

  // Start auto-start servers
  await mcpServerManager.startAutoStartServers();
}

/**
 * Register commands
 * @param context Extension context
 */
function registerCommands(context: vscode.ExtensionContext) {
  // Register the askQwen command
  context.subscriptions.push(
    vscode.commands.registerCommand('qwen-coder-assistant.askQwen', askQwen)
  );

  // Register the explainCode command
  context.subscriptions.push(
    vscode.commands.registerCommand('qwen-coder-assistant.explainCode', explainCode)
  );

  // Register the generateCode command
  context.subscriptions.push(
    vscode.commands.registerCommand('qwen-coder-assistant.generateCode', generateCode)
  );

  // Register the addMcpRepo command
  context.subscriptions.push(
    vscode.commands.registerCommand('qwen-coder-assistant.addMcpRepo', addMcpRepo)
  );

  // Register the manageMcpServers command
  context.subscriptions.push(
    vscode.commands.registerCommand('qwen-coder-assistant.manageMcpServers', manageMcpServers)
  );

  // Register the startMcpServer command
  context.subscriptions.push(
    vscode.commands.registerCommand('qwen-coder-assistant.startMcpServer', startMcpServer)
  );

  // Register the stopMcpServer command
  context.subscriptions.push(
    vscode.commands.registerCommand('qwen-coder-assistant.stopMcpServer', stopMcpServer)
  );

  // Register the restartMcpServer command
  context.subscriptions.push(
    vscode.commands.registerCommand('qwen-coder-assistant.restartMcpServer', restartMcpServer)
  );

  // Register the viewMcpServerLogs command
  context.subscriptions.push(
    vscode.commands.registerCommand('qwen-coder-assistant.viewMcpServerLogs', viewMcpServerLogs)
  );

  // Register the viewMcpServerSchema command
  context.subscriptions.push(
    vscode.commands.registerCommand('qwen-coder-assistant.viewMcpServerSchema', viewMcpServerSchema)
  );

  // Register the refreshMcpServers command
  context.subscriptions.push(
    vscode.commands.registerCommand('qwen-coder-assistant.refreshMcpServers', refreshMcpServers)
  );

  // Register the testApiConnection command
  context.subscriptions.push(
    vscode.commands.registerCommand('qwen-coder-assistant.testApiConnection', testApiConnection)
  );

  // Register the verifyConfiguration command
  context.subscriptions.push(
    vscode.commands.registerCommand('qwen-coder-assistant.verifyConfiguration', verifyExtensionConfiguration)
  );

  // Register the testMcpTool command
  context.subscriptions.push(
    vscode.commands.registerCommand('qwen-coder-assistant.testMcpTool', testMcpTool)
  );

  // Register the testMcpQwenBridge command
  context.subscriptions.push(
    vscode.commands.registerCommand('qwen-coder-assistant.testMcpQwenBridge', async () => {
      try {
        // Import the test module
        const { runMcpQwenBridgeTest } = await import('./test/mcpQwenBridgeTest');

        // Run the test
        await runMcpQwenBridgeTest();

        // Show success message
        vscode.window.showInformationMessage('MCP-Qwen bridge test completed. Check the console for results.');
      } catch (error) {
        vscode.window.showErrorMessage(`Error testing MCP-Qwen bridge: ${error}`);
      }
    })
  );

  // Register the testMcpQwenIntegration command
  context.subscriptions.push(
    vscode.commands.registerCommand('qwen-coder-assistant.testMcpQwenIntegration', async () => {
      try {
        // Import the test module
        const { runMcpQwenIntegrationTest } = await import('./test/mcpQwenIntegrationTest');

        // Run the test
        await runMcpQwenIntegrationTest();

        // Show success message
        vscode.window.showInformationMessage('MCP-Qwen integration test completed. Check the output channel for results.');
      } catch (error) {
        vscode.window.showErrorMessage(`Error testing MCP-Qwen integration: ${error}`);
      }
    })
  );

  // Register the configureMcpServer command
  context.subscriptions.push(
    vscode.commands.registerCommand('qwen-coder-assistant.configureMcpServer', (item?: McpServerTreeItem) => {
      try {
        if (!mcpServerManager || !officialMcpServersManager || !serverHealthMonitor) {
          throw new Error('MCP server manager, official servers manager, or health monitor not initialized');
        }

        // Get the server ID from the tree item
        const serverId = item?.server.id;

        // Create the configuration view
        McpServerConfigView.createOrShow(
          context.extensionUri,
          mcpServerManager,
          officialMcpServersManager,
          serverHealthMonitor,
          serverId
        );
      } catch (error) {
        vscode.window.showErrorMessage(`Error configuring MCP server: ${error}`);
      }
    })
  );

  // Register the addOfficialMcpServer command
  context.subscriptions.push(
    vscode.commands.registerCommand('qwen-coder-assistant.addOfficialMcpServer', async () => {
      try {
        if (!officialMcpServersManager) {
          throw new Error('Official MCP servers manager not initialized');
        }

        // Show a quick pick to select a server type
        const serverTypes = [
          { label: 'GitHub MCP Server', value: 'GITHUB' },
          { label: 'Docker MCP Server', value: 'DOCKER' },
          { label: 'Git MCP Server', value: 'GIT' },
          { label: 'Memory MCP Server', value: 'MEMORY' },
          { label: 'Filesystem MCP Server', value: 'FILESYSTEM' },
          { label: 'All Official MCP Servers', value: 'ALL' }
        ];

        const selectedType = await vscode.window.showQuickPick(serverTypes, {
          placeHolder: 'Select an official MCP server to add',
          title: 'Add Official MCP Server'
        });

        if (!selectedType) {
          return;
        }

        // Show a progress notification
        vscode.window.withProgress({
          location: vscode.ProgressLocation.Notification,
          title: `Adding ${selectedType.label}...`,
          cancellable: false
        }, async () => {
          try {
            if (selectedType.value === 'ALL') {
              const serverIds = await officialMcpServersManager.addAllOfficialServers();
              vscode.window.showInformationMessage(`Added ${serverIds.length} official MCP servers`);
            } else {
              let serverId: string;

              switch (selectedType.value) {
                case 'GITHUB':
                  serverId = await officialMcpServersManager.addGitHubServer();
                  break;
                case 'DOCKER':
                  serverId = await officialMcpServersManager.addDockerServer();
                  break;
                case 'GIT':
                  serverId = await officialMcpServersManager.addGitServer();
                  break;
                case 'MEMORY':
                  serverId = await officialMcpServersManager.addMemoryServer();
                  break;
                case 'FILESYSTEM':
                  serverId = await officialMcpServersManager.addFilesystemServer();
                  break;
                default:
                  throw new Error(`Unknown server type: ${selectedType.value}`);
              }

              vscode.window.showInformationMessage(`Added ${selectedType.label}`);
            }
          } catch (error) {
            vscode.window.showErrorMessage(`Error adding official MCP server: ${error}`);
          }
        });
      } catch (error) {
        vscode.window.showErrorMessage(`Error adding official MCP server: ${error}`);
      }
    })
  );

  // Register the checkMcpServerHealth command
  context.subscriptions.push(
    vscode.commands.registerCommand('qwen-coder-assistant.checkMcpServerHealth', async (item?: McpServerTreeItem) => {
      try {
        if (!serverHealthMonitor) {
          throw new Error('Server health monitor not initialized');
        }

        // If no item is provided, check all servers
        if (!item) {
          // Show a progress notification
          vscode.window.withProgress({
            location: vscode.ProgressLocation.Notification,
            title: 'Checking all MCP servers health...',
            cancellable: false
          }, async () => {
            try {
              await serverHealthMonitor.checkAllServersHealth();
              vscode.window.showInformationMessage('All MCP servers health checked');
            } catch (error) {
              vscode.window.showErrorMessage(`Error checking MCP servers health: ${error}`);
            }
          });
          return;
        }

        // Check the health of the selected server
        const serverId = item.server.id;

        // Show a progress notification
        vscode.window.withProgress({
          location: vscode.ProgressLocation.Notification,
          title: `Checking MCP server health: ${item.server.name}...`,
          cancellable: false
        }, async () => {
          try {
            await serverHealthMonitor.checkServerHealth(serverId);
            const server = mcpServerManager?.getServer(serverId);
            if (server) {
              vscode.window.showInformationMessage(`MCP server ${server.name} health: ${server.healthStatus || 'unknown'}`);
            }
          } catch (error) {
            vscode.window.showErrorMessage(`Error checking MCP server health: ${error}`);
          }
        });
      } catch (error) {
        vscode.window.showErrorMessage(`Error checking MCP server health: ${error}`);
      }
    })
  );
}

/**
 * Handle configuration changes
 * @param config New configuration
 */
function handleConfigurationChange(config: QwenCoderConfig) {
  console.log('Configuration changed:', config);

  // Update the Qwen API client
  if (qwenApiClient) {
    qwenApiClient.updateConfig(config);
  }

  // Update the agent coordinator
  if (agentCoordinator) {
    agentCoordinator.updateConfig(config);
  }
}

/**
 * Ask Qwen
 */
async function askQwen() {
  // Get the input from the user
  const input = await vscode.window.showInputBox({
    prompt: 'What would you like to ask Qwen?',
    placeHolder: 'Enter your question...'
  });

  if (!input) {
    return;
  }

  // Create a webview panel to display the response
  const panel = vscode.window.createWebviewPanel(
    'qwenResponse',
    'Qwen Response',
    vscode.ViewColumn.One,
    {
      enableScripts: true,
      retainContextWhenHidden: true
    }
  );

  // Set initial content
  panel.webview.html = getLoadingWebviewContent();

  // Show a progress notification
  vscode.window.withProgress({
    location: vscode.ProgressLocation.Notification,
    title: 'Asking Qwen...',
    cancellable: false
  }, async () => {
    try {
      if (!agentCoordinator) {
        throw new Error('Agent coordinator not initialized');
      }

      // Process the request using the agent coordinator
      const response = await agentCoordinator.processRequest(input);

      // Update the webview with the response
      panel.webview.html = getResponseWebviewContent(input, response);
    } catch (error) {
      // Handle the error
      const errorDetails = error instanceof Error ? error.message : String(error);
      panel.webview.html = getErrorWebviewContent(input, errorDetails);
      vscode.window.showErrorMessage(`Error asking Qwen: ${errorDetails}`);
    }
  });
}

/**
 * Get loading webview content
 * @returns HTML content for the loading state
 */
function getLoadingWebviewContent(): string {
  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Qwen Response</title>
  <style>
    body {
      font-family: var(--vscode-font-family);
      font-size: var(--vscode-font-size);
      color: var(--vscode-foreground);
      background-color: var(--vscode-editor-background);
      padding: 20px;
    }
    .loading {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
    }
    .spinner {
      width: 50px;
      height: 50px;
      border: 5px solid var(--vscode-button-background);
      border-top: 5px solid var(--vscode-editor-background);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 20px;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <div class="loading">
    <div class="spinner"></div>
    <p>Asking Qwen...</p>
  </div>
</body>
</html>`;
}

/**
 * Get response webview content
 * @param question The user's question
 * @param answer The answer from Qwen
 * @returns HTML content for the response
 */
function getResponseWebviewContent(question: string, answer: string): string {
  // Convert the answer to HTML (replace newlines with <br>, etc.)
  const formattedAnswer = answer
    .replace(/\n/g, '<br>')
    .replace(/```(\w*)\n([\s\S]*?)\n```/g, '<pre><code class="language-$1">$2</code></pre>');

  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Qwen Response</title>
  <style>
    body {
      font-family: var(--vscode-font-family);
      font-size: var(--vscode-font-size);
      color: var(--vscode-foreground);
      background-color: var(--vscode-editor-background);
      padding: 20px;
      line-height: 1.5;
    }
    .container {
      max-width: 800px;
      margin: 0 auto;
    }
    .question {
      background-color: var(--vscode-input-background);
      padding: 15px;
      border-radius: 5px;
      margin-bottom: 20px;
      border-left: 5px solid var(--vscode-button-background);
    }
    .answer {
      background-color: var(--vscode-editor-background);
      padding: 15px;
      border-radius: 5px;
    }
    pre {
      background-color: var(--vscode-textCodeBlock-background);
      padding: 10px;
      border-radius: 5px;
      overflow-x: auto;
    }
    code {
      font-family: var(--vscode-editor-font-family);
      font-size: var(--vscode-editor-font-size);
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>Your Question</h2>
    <div class="question">
      ${question}
    </div>
    <h2>Qwen's Response</h2>
    <div class="answer">
      ${formattedAnswer}
    </div>
  </div>
</body>
</html>`;
}

/**
 * Get error webview content
 * @param question The user's question
 * @param error The error message
 * @returns HTML content for the error state
 */
function getErrorWebviewContent(question: string, error: string): string {
  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Qwen Response</title>
  <style>
    body {
      font-family: var(--vscode-font-family);
      font-size: var(--vscode-font-size);
      color: var(--vscode-foreground);
      background-color: var(--vscode-editor-background);
      padding: 20px;
      line-height: 1.5;
    }
    .container {
      max-width: 800px;
      margin: 0 auto;
    }
    .question {
      background-color: var(--vscode-input-background);
      padding: 15px;
      border-radius: 5px;
      margin-bottom: 20px;
      border-left: 5px solid var(--vscode-button-background);
    }
    .error {
      background-color: var(--vscode-inputValidation-errorBackground);
      color: var(--vscode-inputValidation-errorForeground);
      padding: 15px;
      border-radius: 5px;
      border-left: 5px solid var(--vscode-errorForeground);
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>Your Question</h2>
    <div class="question">
      ${question}
    </div>
    <h2>Error</h2>
    <div class="error">
      <p>An error occurred while processing your request:</p>
      <p>${error}</p>
    </div>
  </div>
</body>
</html>`;
}

/**
 * Explain code
 */
async function explainCode() {
  // Get the active editor
  const editor = vscode.window.activeTextEditor;
  if (!editor) {
    vscode.window.showErrorMessage('No active editor');
    return;
  }

  // Get the selected text
  const selection = editor.selection;
  const text = editor.document.getText(selection);

  if (!text) {
    vscode.window.showErrorMessage('No text selected');
    return;
  }

  // Get the file path and language
  const filePath = editor.document.uri.fsPath;
  const fileName = filePath.split(/[\\/]/).pop() || '';
  const language = editor.document.languageId;

  // Create a webview panel to display the explanation
  const panel = vscode.window.createWebviewPanel(
    'qwenExplanation',
    `Explanation: ${fileName}`,
    vscode.ViewColumn.Beside,
    {
      enableScripts: true,
      retainContextWhenHidden: true
    }
  );

  // Set initial content
  panel.webview.html = getLoadingWebviewContent();

  // Show a progress notification
  vscode.window.withProgress({
    location: vscode.ProgressLocation.Notification,
    title: 'Explaining code...',
    cancellable: false
  }, async () => {
    try {
      if (!agentCoordinator) {
        throw new Error('Agent coordinator not initialized');
      }

      // Create a prompt that includes the code and asks for an explanation
      const prompt = `Please explain the following ${language} code:

\`\`\`${language}
${text}
\`\`\`

Please provide a detailed explanation of what this code does, how it works, and any important patterns or concepts it demonstrates.`;

      // Process the request using the agent coordinator
      const response = await agentCoordinator.processRequest(prompt);

      // Update the webview with the explanation
      panel.webview.html = getExplanationWebviewContent(text, language, response);
    } catch (error) {
      // Handle the error
      const errorDetails = error instanceof Error ? error.message : String(error);
      panel.webview.html = getErrorExplanationWebviewContent(text, language, errorDetails);
      vscode.window.showErrorMessage(`Error explaining code: ${errorDetails}`);
    }
  });
}

/**
 * Get explanation webview content
 * @param code The code to explain
 * @param language The code language
 * @param explanation The explanation from Qwen
 * @returns HTML content for the explanation
 */
function getExplanationWebviewContent(code: string, language: string, explanation: string): string {
  // Convert the explanation to HTML (replace newlines with <br>, etc.)
  const formattedExplanation = explanation
    .replace(/\n/g, '<br>')
    .replace(/```(\w*)\n([\s\S]*?)\n```/g, '<pre><code class="language-$1">$2</code></pre>');

  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Code Explanation</title>
  <style>
    body {
      font-family: var(--vscode-font-family);
      font-size: var(--vscode-font-size);
      color: var(--vscode-foreground);
      background-color: var(--vscode-editor-background);
      padding: 20px;
      line-height: 1.5;
    }
    .container {
      max-width: 800px;
      margin: 0 auto;
    }
    .code {
      background-color: var(--vscode-textCodeBlock-background);
      padding: 15px;
      border-radius: 5px;
      margin-bottom: 20px;
      overflow-x: auto;
      font-family: var(--vscode-editor-font-family);
      font-size: var(--vscode-editor-font-size);
      white-space: pre;
    }
    .explanation {
      background-color: var(--vscode-editor-background);
      padding: 15px;
      border-radius: 5px;
    }
    pre {
      background-color: var(--vscode-textCodeBlock-background);
      padding: 10px;
      border-radius: 5px;
      overflow-x: auto;
    }
    code {
      font-family: var(--vscode-editor-font-family);
      font-size: var(--vscode-editor-font-size);
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>Code</h2>
    <div class="code">
      <code>${code.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</code>
    </div>
    <h2>Explanation</h2>
    <div class="explanation">
      ${formattedExplanation}
    </div>
  </div>
</body>
</html>`;
}

/**
 * Get error explanation webview content
 * @param code The code to explain
 * @param language The code language
 * @param error The error message
 * @returns HTML content for the error state
 */
function getErrorExplanationWebviewContent(code: string, language: string, error: string): string {
  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Code Explanation</title>
  <style>
    body {
      font-family: var(--vscode-font-family);
      font-size: var(--vscode-font-size);
      color: var(--vscode-foreground);
      background-color: var(--vscode-editor-background);
      padding: 20px;
      line-height: 1.5;
    }
    .container {
      max-width: 800px;
      margin: 0 auto;
    }
    .code {
      background-color: var(--vscode-textCodeBlock-background);
      padding: 15px;
      border-radius: 5px;
      margin-bottom: 20px;
      overflow-x: auto;
      font-family: var(--vscode-editor-font-family);
      font-size: var(--vscode-editor-font-size);
      white-space: pre;
    }
    .error {
      background-color: var(--vscode-inputValidation-errorBackground);
      color: var(--vscode-inputValidation-errorForeground);
      padding: 15px;
      border-radius: 5px;
      border-left: 5px solid var(--vscode-errorForeground);
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>Code</h2>
    <div class="code">
      <code>${code.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</code>
    </div>
    <h2>Error</h2>
    <div class="error">
      <p>An error occurred while explaining the code:</p>
      <p>${error}</p>
    </div>
  </div>
</body>
</html>`;
}

/**
 * Generate code
 */
async function generateCode() {
  // Get the active editor
  const editor = vscode.window.activeTextEditor;
  if (!editor) {
    vscode.window.showErrorMessage('No active editor');
    return;
  }

  // Get the input from the user
  const input = await vscode.window.showInputBox({
    prompt: 'What code would you like to generate?',
    placeHolder: 'Enter your request...'
  });

  if (!input) {
    return;
  }

  // Get the language
  const language = editor.document.languageId;

  // Create a webview panel to display the generated code
  const panel = vscode.window.createWebviewPanel(
    'qwenCodeGeneration',
    'Generated Code',
    vscode.ViewColumn.Beside,
    {
      enableScripts: true,
      retainContextWhenHidden: true
    }
  );

  // Set initial content
  panel.webview.html = getLoadingWebviewContent();

  // Show a progress notification
  vscode.window.withProgress({
    location: vscode.ProgressLocation.Notification,
    title: 'Generating code...',
    cancellable: false
  }, async () => {
    try {
      if (!agentCoordinator) {
        throw new Error('Agent coordinator not initialized');
      }

      // Create a prompt that asks for code generation
      const prompt = `Please generate ${language} code for the following request:

${input}

Please provide well-structured, efficient, and well-commented code that follows best practices for ${language}.`;

      // Process the request using the agent coordinator
      const response = await agentCoordinator.processRequest(prompt);

      // Update the webview with the generated code
      panel.webview.html = getGeneratedCodeWebviewContent(input, language, response);

      // Add a button to insert the code
      panel.webview.onDidReceiveMessage(async message => {
        if (message.command === 'insertCode') {
          try {
            // Extract the code from the response
            const codeMatch = response.match(/```(?:\w+)?\s*([\s\S]*?)```/);
            const codeToInsert = codeMatch ? codeMatch[1].trim() : response;

            // Insert the code at the current cursor position
            editor.edit(editBuilder => {
              editBuilder.insert(editor.selection.active, codeToInsert);
            });

            vscode.window.showInformationMessage('Code inserted successfully');
          } catch (error) {
            vscode.window.showErrorMessage(`Error inserting code: ${error}`);
          }
        }
      });

      // Enable messaging from the webview
      panel.webview.options = { enableScripts: true };
    } catch (error) {
      // Handle the error
      const errorDetails = error instanceof Error ? error.message : String(error);
      panel.webview.html = getErrorGeneratedCodeWebviewContent(input, language, errorDetails);
      vscode.window.showErrorMessage(`Error generating code: ${errorDetails}`);
    }
  });
}

/**
 * Get generated code webview content
 * @param request The user's request
 * @param language The code language
 * @param response The response from Qwen
 * @returns HTML content for the generated code
 */
function getGeneratedCodeWebviewContent(request: string, language: string, response: string): string {
  // Extract code blocks from the response
  const codeBlocks: string[] = [];
  const codeBlockRegex = /```(?:\w+)?\s*([\s\S]*?)```/g;
  let match;
  while ((match = codeBlockRegex.exec(response)) !== null) {
    codeBlocks.push(match[1].trim());
  }

  // Format the response
  let formattedResponse = response
    .replace(/\n/g, '<br>')
    .replace(/```(\w*)\n([\s\S]*?)\n```/g, '<pre><code class="language-$1">$2</code></pre>');

  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Generated Code</title>
  <style>
    body {
      font-family: var(--vscode-font-family);
      font-size: var(--vscode-font-size);
      color: var(--vscode-foreground);
      background-color: var(--vscode-editor-background);
      padding: 20px;
      line-height: 1.5;
    }
    .container {
      max-width: 800px;
      margin: 0 auto;
    }
    .request {
      background-color: var(--vscode-input-background);
      padding: 15px;
      border-radius: 5px;
      margin-bottom: 20px;
      border-left: 5px solid var(--vscode-button-background);
    }
    .response {
      background-color: var(--vscode-editor-background);
      padding: 15px;
      border-radius: 5px;
    }
    pre {
      background-color: var(--vscode-textCodeBlock-background);
      padding: 10px;
      border-radius: 5px;
      overflow-x: auto;
    }
    code {
      font-family: var(--vscode-editor-font-family);
      font-size: var(--vscode-editor-font-size);
    }
    button {
      background-color: var(--vscode-button-background);
      color: var(--vscode-button-foreground);
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      margin-top: 20px;
      font-size: var(--vscode-font-size);
    }
    button:hover {
      background-color: var(--vscode-button-hoverBackground);
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>Your Request</h2>
    <div class="request">
      ${request}
    </div>
    <h2>Generated Code</h2>
    <div class="response">
      ${formattedResponse}
    </div>
    <button id="insertButton">Insert Code</button>
  </div>
  <script>
    const vscode = acquireVsCodeApi();
    document.getElementById('insertButton').addEventListener('click', () => {
      vscode.postMessage({
        command: 'insertCode'
      });
    });
  </script>
</body>
</html>`;
}

/**
 * Get error generated code webview content
 * @param request The user's request
 * @param language The code language
 * @param error The error message
 * @returns HTML content for the error state
 */
function getErrorGeneratedCodeWebviewContent(request: string, language: string, error: string): string {
  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Generated Code</title>
  <style>
    body {
      font-family: var(--vscode-font-family);
      font-size: var(--vscode-font-size);
      color: var(--vscode-foreground);
      background-color: var(--vscode-editor-background);
      padding: 20px;
      line-height: 1.5;
    }
    .container {
      max-width: 800px;
      margin: 0 auto;
    }
    .request {
      background-color: var(--vscode-input-background);
      padding: 15px;
      border-radius: 5px;
      margin-bottom: 20px;
      border-left: 5px solid var(--vscode-button-background);
    }
    .error {
      background-color: var(--vscode-inputValidation-errorBackground);
      color: var(--vscode-inputValidation-errorForeground);
      padding: 15px;
      border-radius: 5px;
      border-left: 5px solid var(--vscode-errorForeground);
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>Your Request</h2>
    <div class="request">
      ${request}
    </div>
    <h2>Error</h2>
    <div class="error">
      <p>An error occurred while generating code:</p>
      <p>${error}</p>
    </div>
  </div>
</body>
</html>`;
}

/**
 * Add an MCP server from a GitHub repository
 */
async function addMcpRepo() {
  // Get the repository URL from the user
  const repoUrl = await vscode.window.showInputBox({
    prompt: 'Enter the GitHub repository URL',
    placeHolder: 'https://github.com/username/repo',
    validateInput: (value) => {
      if (!value) {
        return 'Repository URL is required';
      }

      if (!value.startsWith('https://github.com/')) {
        return 'Repository URL must start with https://github.com/';
      }

      return null;
    }
  });

  if (!repoUrl) {
    return;
  }

  // Show a progress notification
  vscode.window.withProgress({
    location: vscode.ProgressLocation.Notification,
    title: 'Adding MCP server...',
    cancellable: false
  }, async () => {
    try {
      // Add the server
      const server = await mcpServerManager?.addServerFromGitHub(repoUrl);

      // Show a success message
      vscode.window.showInformationMessage(`Added MCP server: ${server?.name}`);
    } catch (error) {
      vscode.window.showErrorMessage(`Error adding MCP server: ${error}`);
    }
  });
}

/**
 * Manage MCP servers
 */
async function manageMcpServers() {
  // Focus the MCP servers view
  vscode.commands.executeCommand('qwenMcpServers.focus');
}

/**
 * Start an MCP server
 * @param item Server tree item
 */
async function startMcpServer(item?: McpServerTreeItem) {
  // If no item is provided, show a quick pick to select a server
  let serverId: string | undefined;

  if (item?.server?.id) {
    serverId = item.server.id;
  } else {
    const servers = mcpServerManager?.getServers() || [];
    const stoppedServers = servers.filter(s => s.status === 'stopped');

    if (stoppedServers.length === 0) {
      vscode.window.showInformationMessage('No stopped servers to start');
      return;
    }

    const items = stoppedServers.map(s => ({
      label: s.name,
      description: s.description,
      id: s.id
    }));

    const selected = await vscode.window.showQuickPick(items, {
      placeHolder: 'Select a server to start'
    });

    if (!selected) {
      return;
    }

    serverId = selected.id;
  }

  if (!serverId) {
    return;
  }

  // Show a progress notification
  vscode.window.withProgress({
    location: vscode.ProgressLocation.Notification,
    title: 'Starting MCP server...',
    cancellable: false
  }, async () => {
    try {
      // Start the server
      if (mcpServerManager && serverId) {
        await mcpServerManager.startServer(serverId);
      }

      // Show a success message
      vscode.window.showInformationMessage(`Started MCP server: ${serverId}`);
    } catch (error) {
      vscode.window.showErrorMessage(`Error starting MCP server: ${error}`);
    }
  });
}

/**
 * Stop an MCP server
 * @param item Server tree item
 */
async function stopMcpServer(item?: McpServerTreeItem) {
  // If no item is provided, show a quick pick to select a server
  let serverId: string | undefined;

  if (item?.server?.id) {
    serverId = item.server.id;
  } else {
    const servers = mcpServerManager?.getServers() || [];
    const runningServers = servers.filter(s => s.status === 'running');

    if (runningServers.length === 0) {
      vscode.window.showInformationMessage('No running servers to stop');
      return;
    }

    const items = runningServers.map(s => ({
      label: s.name,
      description: s.description,
      id: s.id
    }));

    const selected = await vscode.window.showQuickPick(items, {
      placeHolder: 'Select a server to stop'
    });

    if (!selected) {
      return;
    }

    serverId = selected.id;
  }

  if (!serverId) {
    return;
  }

  // Show a progress notification
  vscode.window.withProgress({
    location: vscode.ProgressLocation.Notification,
    title: 'Stopping MCP server...',
    cancellable: false
  }, async () => {
    try {
      // Stop the server
      if (mcpServerManager && serverId) {
        await mcpServerManager.stopServer(serverId);
      }

      // Show a success message
      vscode.window.showInformationMessage(`Stopped MCP server: ${serverId}`);
    } catch (error) {
      vscode.window.showErrorMessage(`Error stopping MCP server: ${error}`);
    }
  });
}

/**
 * Restart an MCP server
 * @param item Server tree item
 */
async function restartMcpServer(item?: McpServerTreeItem) {
  // If no item is provided, show a quick pick to select a server
  let serverId: string | undefined;

  if (item?.server?.id) {
    serverId = item.server.id;
  } else {
    const servers = mcpServerManager?.getServers() || [];
    const runningServers = servers.filter(s => s.status === 'running');

    if (runningServers.length === 0) {
      vscode.window.showInformationMessage('No running servers to restart');
      return;
    }

    const items = runningServers.map(s => ({
      label: s.name,
      description: s.description,
      id: s.id
    }));

    const selected = await vscode.window.showQuickPick(items, {
      placeHolder: 'Select a server to restart'
    });

    if (!selected) {
      return;
    }

    serverId = selected.id;
  }

  if (!serverId) {
    return;
  }

  // Show a progress notification
  vscode.window.withProgress({
    location: vscode.ProgressLocation.Notification,
    title: 'Restarting MCP server...',
    cancellable: false
  }, async () => {
    try {
      // Restart the server
      if (mcpServerManager && serverId) {
        await mcpServerManager.restartServer(serverId);
      }

      // Show a success message
      vscode.window.showInformationMessage(`Restarted MCP server: ${serverId}`);
    } catch (error) {
      vscode.window.showErrorMessage(`Error restarting MCP server: ${error}`);
    }
  });
}

/**
 * View the logs for an MCP server
 * @param item Server tree item
 */
async function viewMcpServerLogs(item?: McpServerTreeItem) {
  // If no item is provided, show a quick pick to select a server
  let serverId: string | undefined;

  if (item?.server?.id) {
    serverId = item.server.id;
  } else {
    const servers = mcpServerManager?.getServers() || [];

    if (servers.length === 0) {
      vscode.window.showInformationMessage('No servers available');
      return;
    }

    const items = servers.map(s => ({
      label: s.name,
      description: s.description,
      id: s.id
    }));

    const selected = await vscode.window.showQuickPick(items, {
      placeHolder: 'Select a server to view logs'
    });

    if (!selected) {
      return;
    }

    serverId = selected.id;
  }

  if (!serverId) {
    return;
  }

  try {
    // Get the server
    const server = mcpServerManager?.getServer(serverId);

    if (!server) {
      vscode.window.showErrorMessage(`Server ${serverId} not found`);
      return;
    }

    // Get the logs
    const logs = mcpServerManager?.getServerLogs(serverId);

    if (!logs || logs.length === 0) {
      vscode.window.showInformationMessage(`No logs available for server ${serverId}`);
      return;
    }

    // Create a new output channel
    const channel = vscode.window.createOutputChannel(`MCP Server: ${server.name}`);

    // Write the logs to the channel
    channel.appendLine(logs.join('\n'));

    // Show the channel
    channel.show();
  } catch (error) {
    vscode.window.showErrorMessage(`Error viewing logs: ${error}`);
  }
}

/**
 * View the schema for an MCP server
 * @param item Server tree item
 */
async function viewMcpServerSchema(item?: McpServerTreeItem) {
  // If no item is provided, show a quick pick to select a server
  let serverId: string | undefined;

  if (item?.server?.id) {
    serverId = item.server.id;
  } else {
    const servers = mcpServerManager?.getServers() || [];
    const runningServers = servers.filter(s => s.status === 'running');

    if (runningServers.length === 0) {
      vscode.window.showInformationMessage('No running servers to view schema');
      return;
    }

    const items = runningServers.map(s => ({
      label: s.name,
      description: s.description,
      id: s.id
    }));

    const selected = await vscode.window.showQuickPick(items, {
      placeHolder: 'Select a server to view schema'
    });

    if (!selected) {
      return;
    }

    serverId = selected.id;
  }

  if (!serverId) {
    return;
  }

  try {
    // Get the server
    const server = mcpServerManager?.getServer(serverId);

    if (!server) {
      vscode.window.showErrorMessage(`Server ${serverId} not found`);
      return;
    }

    // Get the schema
    const schema = server.schema;

    if (!schema) {
      vscode.window.showInformationMessage(`No schema available for server ${serverId}`);
      return;
    }

    // Create a new untitled document
    const document = await vscode.workspace.openTextDocument({
      content: JSON.stringify(schema, null, 2),
      language: 'json'
    });

    // Show the document
    await vscode.window.showTextDocument(document);
  } catch (error) {
    vscode.window.showErrorMessage(`Error viewing schema: ${error}`);
  }
}

/**
 * Refresh the MCP servers view
 */
async function refreshMcpServers() {
  mcpServerTreeDataProvider?.refresh();
}

/**
 * Test the API connection
 */
async function testApiConnection() {
  if (!qwenApiClient) {
    vscode.window.showErrorMessage('Qwen API client not initialized');
    return;
  }

  // Show a progress notification
  vscode.window.withProgress({
    location: vscode.ProgressLocation.Notification,
    title: 'Testing API connection...',
    cancellable: false
  }, async () => {
    try {
      // Create a simple test prompt
      const response = await qwenApiClient!.generateCompletion({
        prompt: 'Hello, can you respond with a simple "Hello, I am Qwen!" to test the connection?',
        maxTokens: 20,
        skipCache: true // Skip cache to ensure we're testing the actual API connection
      });

      // Show a success message
      vscode.window.showInformationMessage(`API connection successful! Response: ${response.text.substring(0, 50)}${response.text.length > 50 ? '...' : ''}`);
    } catch (error) {
      // Show an error message
      const errorMessage = error instanceof Error ? error.message : String(error);
      vscode.window.showErrorMessage(`API connection failed: ${errorMessage}`);
    }
  });
}

/**
 * Verify the extension configuration
 */
async function verifyExtensionConfiguration() {
  // Get the current configuration
  const config = getConfiguration();

  // Verify the configuration
  const verificationResult = verifyConfiguration(config);

  if (verificationResult.isValid) {
    // Show a success message
    vscode.window.showInformationMessage('Configuration is valid');
  } else {
    // Show an error message with the issues
    const issuesMessage = verificationResult.issues.join('\n');
    vscode.window.showErrorMessage(`Configuration issues found:\n${issuesMessage}`);

    // Offer to open settings
    const openSettings = 'Open Settings';
    vscode.window.showWarningMessage('Would you like to update your settings?', openSettings)
      .then(selection => {
        if (selection === openSettings) {
          vscode.commands.executeCommand('workbench.action.openSettings', 'qwen-coder-assistant');
        }
      });
  }
}

/**
 * Test an MCP tool
 */
async function testMcpTool() {
  try {
    if (!mcpClient || !mcpServerManager) {
      throw new Error('MCP client or server manager not initialized');
    }

    // Get all running servers
    const servers = mcpServerManager.getServers().filter(s => s.status === 'running');

    if (servers.length === 0) {
      throw new Error('No running MCP servers found. Please start a server first.');
    }

    // Let the user select a server
    const serverItems = servers.map(s => ({
      label: s.name,
      description: s.description,
      detail: `Status: ${s.status}, Endpoint: ${s.endpoint || 'N/A'}`,
      server: s
    }));

    const selectedServer = await vscode.window.showQuickPick(serverItems, {
      placeHolder: 'Select an MCP server',
      title: 'Test MCP Tool'
    });

    if (!selectedServer) {
      return;
    }

    // Get all tools for the selected server
    const tools = selectedServer.server.schema?.tools || [];

    if (tools.length === 0) {
      throw new Error(`No tools found for server ${selectedServer.server.name}`);
    }

    // Let the user select a tool
    const toolItems = tools.map(t => ({
      label: t.name,
      description: t.description,
      detail: `Parameters: ${t.parameters.length}`,
      tool: t
    }));

    const selectedTool = await vscode.window.showQuickPick(toolItems, {
      placeHolder: 'Select a tool to test',
      title: 'Test MCP Tool'
    });

    if (!selectedTool) {
      return;
    }

    // Collect parameters for the tool
    const parameters: Record<string, any> = {};

    for (const param of selectedTool.tool.parameters) {
      const paramValue = await vscode.window.showInputBox({
        prompt: `Enter value for parameter '${param.name}'${param.required ? ' (required)' : ''}`,
        placeHolder: param.description,
        ignoreFocusOut: true,
        validateInput: value => {
          if (param.required && !value) {
            return 'This parameter is required';
          }
          return null;
        }
      });

      if (param.required && !paramValue) {
        return; // User cancelled
      }

      if (paramValue) {
        // Convert the value to the appropriate type
        if (param.type === 'number') {
          parameters[param.name] = Number(paramValue);
        } else if (param.type === 'boolean') {
          parameters[param.name] = paramValue.toLowerCase() === 'true';
        } else if (param.type === 'array' || param.type === 'object') {
          try {
            parameters[param.name] = JSON.parse(paramValue);
          } catch (error) {
            throw new Error(`Invalid JSON for parameter ${param.name}: ${error}`);
          }
        } else {
          parameters[param.name] = paramValue;
        }
      }
    }

    // Show a progress notification
    vscode.window.withProgress({
      location: vscode.ProgressLocation.Notification,
      title: `Invoking tool ${selectedTool.tool.name}...`,
      cancellable: false
    }, async () => {
      try {
        // Invoke the tool
        const result = await mcpClient!.invokeTool(
          selectedServer.server.id,
          selectedTool.tool.name,
          parameters
        );

        // Create a new untitled document to display the result
        const document = await vscode.workspace.openTextDocument({
          content: JSON.stringify(result, null, 2),
          language: 'json'
        });

        // Show the document
        await vscode.window.showTextDocument(document);

        // Show a success message
        if (result.status === 'success') {
          vscode.window.showInformationMessage(`Tool ${selectedTool.tool.name} invoked successfully`);
        } else {
          vscode.window.showErrorMessage(`Error invoking tool: ${result.error}`);
        }
      } catch (error) {
        vscode.window.showErrorMessage(`Error invoking tool: ${error}`);
      }
    });
  } catch (error) {
    vscode.window.showErrorMessage(`Error testing MCP tool: ${error}`);
  }
}

/**
 * Deactivate the extension
 */
export async function deactivate() {
  // Clean up resources when the extension is deactivated
  console.log('Qwen Coder Assistant is now deactivated!');

  // Dispose the agent coordinator
  if (agentCoordinator) {
    agentCoordinator.dispose();
    agentCoordinator = undefined;
  }

  // Dispose the MCP server manager
  if (mcpServerManager) {
    mcpServerManager.dispose();
    mcpServerManager = undefined;
  }

  // Dispose the MCP client
  if (mcpClient) {
    mcpClient.dispose();
    mcpClient = undefined;
  }
}



```


---

### File: `src/configuration.ts`

```typescript
import * as vscode from 'vscode';

export interface DockerOptions {
  socketPath: string;
  memory: number;
  cpus: number;
}

export interface GitHubOptions {
  token: string;
  timeout: number;
}

export interface McpServersConfig {
  storagePath: string;
  autoStart: boolean;
  autoStartList: string[];
  dockerOptions: DockerOptions;
  githubOptions: GitHubOptions;
}

export interface QwenCoderConfig {
  apiEndpoint: string;
  apiKey: string;
  maxTokens: number;
  temperature: number;
  cacheEnabled?: boolean;
  cacheTTLMinutes?: number;
  cacheMaxEntries?: number;
  mcpServers: McpServersConfig;
}

/**
 * Get the extension configuration
 * @returns The extension configuration
 */
export function getConfiguration(): QwenCoderConfig {
  const config = vscode.workspace.getConfiguration('qwen-coder-assistant');

  return {
    apiEndpoint: config.get<string>('apiEndpoint') || 'http://localhost:8000/v1',
    apiKey: config.get<string>('apiKey') || '',
    maxTokens: config.get<number>('maxTokens') || 2048,
    temperature: config.get<number>('temperature') || 0.7,
    cacheEnabled: config.get<boolean>('cacheEnabled') !== false, // Default to true
    cacheTTLMinutes: config.get<number>('cacheTTLMinutes') || 30,
    cacheMaxEntries: config.get<number>('cacheMaxEntries') || 100,
    mcpServers: {
      storagePath: config.get<string>('mcpServers.storagePath') || '',
      autoStart: config.get<boolean>('mcpServers.autoStart') !== false, // Default to true
      autoStartList: config.get<string[]>('mcpServers.autoStartList') || [],
      dockerOptions: config.get<DockerOptions>('mcpServers.dockerOptions') || {
        socketPath: '/var/run/docker.sock',
        memory: 2048,
        cpus: 2
      },
      githubOptions: config.get<GitHubOptions>('mcpServers.githubOptions') || {
        token: '',
        timeout: 30000
      }
    }
  };
}

/**
 * Verify that the configuration is valid
 * @param config The configuration to verify
 * @returns An object with validation results
 */
export function verifyConfiguration(config: QwenCoderConfig): {
  isValid: boolean;
  issues: string[];
  apiConfigured: boolean;
  mcpConfigured: boolean;
} {
  const issues: string[] = [];

  // Check API configuration
  const apiConfigured = Boolean(config.apiEndpoint && config.apiEndpoint.trim() !== '');
  if (!apiConfigured) {
    issues.push('API endpoint is not configured');
  }

  // Check MCP server configuration
  const mcpConfigured = Boolean(config.mcpServers.storagePath && config.mcpServers.storagePath.trim() !== '');
  if (!mcpConfigured) {
    issues.push('MCP server storage path is not configured');
  }

  // Check Docker configuration
  if (!config.mcpServers.dockerOptions.socketPath) {
    issues.push('Docker socket path is not configured');
  }

  return {
    isValid: issues.length === 0,
    issues,
    apiConfigured,
    mcpConfigured
  };
}

// Listen for configuration changes
export function registerConfigurationListener(callback: (config: QwenCoderConfig) => void): vscode.Disposable {
  return vscode.workspace.onDidChangeConfiguration(event => {
    if (event.affectsConfiguration('qwen-coder-assistant')) {
      callback(getConfiguration());
    }
  });
}

```


---

### File: `src/conversationHistory.ts`

```typescript
import * as fs from 'fs';
import * as path from 'path';
import * as vscode from 'vscode';

/**
 * Represents a conversation entry in the history
 */
export interface ConversationEntry {
  id: string;
  title: string;
  timestamp: number;
  prompt: string;
  response: string;
  systemPrompt?: string;
}

/**
 * Manages conversation history for the extension
 */
export class ConversationHistoryManager {
  private static instance: ConversationHistoryManager;
  private conversations: ConversationEntry[] = [];
  private storageUri?: vscode.Uri;
  private readonly MAX_HISTORY_ITEMS = 50;

  private constructor(context: vscode.ExtensionContext) {
    this.storageUri = context.globalStorageUri;
    this.loadConversations();
  }

  /**
   * Get the singleton instance of the conversation history manager
   */
  public static getInstance(context: vscode.ExtensionContext): ConversationHistoryManager {
    if (!ConversationHistoryManager.instance) {
      ConversationHistoryManager.instance = new ConversationHistoryManager(context);
    }
    return ConversationHistoryManager.instance;
  }

  /**
   * Add a new conversation to the history
   */
  public addConversation(prompt: string, response: string, systemPrompt?: string): ConversationEntry {
    // Generate a title from the prompt (first line or first few words)
    const title = this.generateTitle(prompt);

    // Create a new conversation entry
    const entry: ConversationEntry = {
      id: Date.now().toString(),
      title,
      timestamp: Date.now(),
      prompt,
      response,
      systemPrompt
    };

    // Add to the beginning of the array
    this.conversations.unshift(entry);

    // Limit the number of conversations
    if (this.conversations.length > this.MAX_HISTORY_ITEMS) {
      this.conversations = this.conversations.slice(0, this.MAX_HISTORY_ITEMS);
    }

    // Save the updated conversations
    this.saveConversations();

    return entry;
  }

  /**
   * Get all conversations
   */
  public getConversations(): ConversationEntry[] {
    return [...this.conversations];
  }

  /**
   * Get a conversation by ID
   */
  public getConversation(id: string): ConversationEntry | undefined {
    return this.conversations.find(c => c.id === id);
  }

  /**
   * Delete a conversation by ID
   */
  public deleteConversation(id: string): boolean {
    const initialLength = this.conversations.length;
    this.conversations = this.conversations.filter(c => c.id !== id);

    if (this.conversations.length !== initialLength) {
      this.saveConversations();
      return true;
    }

    return false;
  }

  /**
   * Clear all conversations
   */
  public clearConversations(): void {
    this.conversations = [];
    this.saveConversations();
  }

  /**
   * Generate a title from the prompt
   */
  private generateTitle(prompt: string): string {
    // Use the first line if it's short enough
    const firstLine = prompt.split('\n')[0].trim();
    if (firstLine.length <= 50) {
      return firstLine;
    }

    // Otherwise use the first few words
    return firstLine.substring(0, 47) + '...';
  }

  /**
   * Load conversations from storage
   */
  private loadConversations(): void {
    try {
      if (!this.storageUri) {
        return;
      }

      // Create the storage directory if it doesn't exist
      const dirPath = this.storageUri.fsPath;
      if (!fs.existsSync(dirPath)) {
        fs.mkdirSync(dirPath, { recursive: true });
      }

      const filePath = path.join(dirPath, 'conversations.json');
      if (fs.existsSync(filePath)) {
        const data = fs.readFileSync(filePath, 'utf8');
        this.conversations = JSON.parse(data);
      }
    } catch (error) {
      console.error('Error loading conversations:', error);
      this.conversations = [];
    }
  }

  /**
   * Save conversations to storage
   */
  private saveConversations(): void {
    try {
      if (!this.storageUri) {
        return;
      }

      // Create the storage directory if it doesn't exist
      const dirPath = this.storageUri.fsPath;
      if (!fs.existsSync(dirPath)) {
        fs.mkdirSync(dirPath, { recursive: true });
      }

      const filePath = path.join(dirPath, 'conversations.json');
      fs.writeFileSync(filePath, JSON.stringify(this.conversations, null, 2), 'utf8');
    } catch (error) {
      console.error('Error saving conversations:', error);
    }
  }
}

/**
 * Tree data provider for conversation history
 */
export class ConversationHistoryProvider implements vscode.TreeDataProvider<ConversationTreeItem> {
  private _onDidChangeTreeData: vscode.EventEmitter<ConversationTreeItem | undefined | null | void> = new vscode.EventEmitter<ConversationTreeItem | undefined | null | void>();
  readonly onDidChangeTreeData: vscode.Event<ConversationTreeItem | undefined | null | void> = this._onDidChangeTreeData.event;

  constructor(private historyManager: ConversationHistoryManager) {}

  refresh(): void {
    this._onDidChangeTreeData.fire();
  }

  getTreeItem(element: ConversationTreeItem): vscode.TreeItem {
    return element;
  }

  getChildren(element?: ConversationTreeItem): Thenable<ConversationTreeItem[]> {
    if (element) {
      return Promise.resolve([]);
    } else {
      const conversations = this.historyManager.getConversations();
      return Promise.resolve(
        conversations.map(conversation => new ConversationTreeItem(conversation))
      );
    }
  }
}

/**
 * Tree item for a conversation
 */
export class ConversationTreeItem extends vscode.TreeItem {
  constructor(public readonly conversation: ConversationEntry) {
    super(conversation.title, vscode.TreeItemCollapsibleState.None);

    // Format the date
    const date = new Date(conversation.timestamp);
    const formattedDate = date.toLocaleDateString() + ' ' + date.toLocaleTimeString();

    this.tooltip = `${conversation.title}\n${formattedDate}`;
    this.description = formattedDate;
    this.contextValue = 'conversation';

    // Set the command to open the conversation
    this.command = {
      command: 'qwen-coder-assistant.openConversation',
      title: 'Open Conversation',
      arguments: [conversation]
    };
  }
}

/**
 * Register the conversation history view
 */
export function registerConversationHistoryView(context: vscode.ExtensionContext): void {
  // Create the history manager
  const historyManager = ConversationHistoryManager.getInstance(context);

  // Create the tree data provider
  const treeDataProvider = new ConversationHistoryProvider(historyManager);

  // Register the tree view
  const treeView = vscode.window.createTreeView('qwenConversationHistory', {
    treeDataProvider,
    showCollapseAll: false
  });

  // Register the refresh command
  const refreshCommand = vscode.commands.registerCommand(
    'qwen-coder-assistant.refreshConversationHistory',
    () => {
      treeDataProvider.refresh();
    }
  );

  // Register the open conversation command
  const openConversationCommand = vscode.commands.registerCommand(
    'qwen-coder-assistant.openConversation',
    (conversation: ConversationEntry) => {
      // Import the QwenResponsePanel class to use its functionality
      const { QwenResponsePanel } = require('./webview/panel');

      // Create or show the panel
      const panel = QwenResponsePanel.createOrShow(
        context.extensionUri,
        `Conversation: ${conversation.title}`
      );

      // Format the conversation for display
      const content = `# ${conversation.title}\n\n## Prompt\n\n${conversation.prompt}\n\n## Response\n\n${conversation.response}`;

      // Set the content
      panel.setContent(content);
    }
  );

  // Register the delete conversation command
  const deleteConversationCommand = vscode.commands.registerCommand(
    'qwen-coder-assistant.deleteConversation',
    async (item: ConversationTreeItem) => {
      const result = await vscode.window.showWarningMessage(
        `Are you sure you want to delete the conversation "${item.conversation.title}"?`,
        { modal: true },
        'Delete'
      );

      if (result === 'Delete') {
        historyManager.deleteConversation(item.conversation.id);
        treeDataProvider.refresh();
      }
    }
  );

  // Register the clear all conversations command
  const clearConversationsCommand = vscode.commands.registerCommand(
    'qwen-coder-assistant.clearConversations',
    async () => {
      const result = await vscode.window.showWarningMessage(
        'Are you sure you want to clear all conversations? This cannot be undone.',
        { modal: true },
        'Clear All'
      );

      if (result === 'Clear All') {
        historyManager.clearConversations();
        treeDataProvider.refresh();
      }
    }
  );

  // Add to subscriptions
  context.subscriptions.push(
    treeView,
    refreshCommand,
    openConversationCommand,
    deleteConversationCommand,
    clearConversationsCommand
  );
}

/**
 * Save a conversation to history
 */
export function saveToHistory(
  context: vscode.ExtensionContext,
  prompt: string,
  response: string,
  systemPrompt?: string
): void {
  const historyManager = ConversationHistoryManager.getInstance(context);
  historyManager.addConversation(prompt, response, systemPrompt);

  // Refresh the tree view
  vscode.commands.executeCommand('qwen-coder-assistant.refreshConversationHistory');
}

```


---

### File: `src/commands.ts`

```typescript
import * as vscode from 'vscode';
import { getConfiguration } from './configuration';
import { getEditorContext, getProjectContext } from './contextProvider';
import { ErrorHandler } from './errorHandler';
import { QwenApiClient, QwenRequestOptions } from './qwenApi';
import { showResponseInPanel, showStreamingResponseInPanel } from './responseFormatter';

export function registerCommands(
  context: vscode.ExtensionContext,
  apiClient: QwenApiClient,
  agentCoordinator?: AgentCoordinator,
  mcpClient?: MCPClient
): void {
  // Register the "Ask Qwen" command
  const askQwenCommand = vscode.commands.registerCommand('qwen-coder-assistant.askQwen', async () => {
    const userPrompt = await vscode.window.showInputBox({
      prompt: 'What would you like to ask Qwen?',
      placeHolder: 'E.g., How do I implement a binary search in JavaScript?'
    });

    if (!userPrompt) {
      return; // User cancelled
    }

    try {
      vscode.window.withProgress({
        location: vscode.ProgressLocation.Notification,
        title: 'Asking Qwen...',
        cancellable: false
      }, async (progress) => {
        progress.report({ increment: 0 });

        const editorContext = await getEditorContext();

        let prompt = userPrompt;
        if (editorContext) {
          prompt += `\n\nContext:\nFile: ${editorContext.fileName}\nLanguage: ${editorContext.language}\n`;

          if (editorContext.selectedCode) {
            prompt += `\nSelected code:\n\`\`\`${editorContext.language}\n${editorContext.selectedCode}\n\`\`\``;
          }
        }

        progress.report({ increment: 30, message: 'Retrieving code context...' });

        // Get relevant context from the context engine
        const codeContext = await getProjectContext(userPrompt);
        if (codeContext) {
          prompt += `\n\nRelevant code context:\n${codeContext}`;
        }

        progress.report({ increment: 50 });

        const options: QwenRequestOptions = {
          prompt,
          systemPrompt: 'You are Qwen Coder, an AI assistant specialized in helping with programming tasks. Provide clear, concise, and accurate responses to coding questions. Include code examples when appropriate.'
        };

        // Check if streaming is enabled in configuration
        const config = getConfiguration();
        if (config.streamingEnabled) {
          // Use streaming API
          progress.report({ message: 'Streaming response...' });

          // Variable to accumulate the full response for history
          let fullResponse = '';

          showStreamingResponseInPanel(context, (streamHandler) => {
            apiClient.generateStreamingCompletion(options, (chunk, done) => {
              // Accumulate the response
              fullResponse += chunk;

              // Pass to the original handler
              streamHandler(chunk, done);

              // When streaming is complete, save to history
              if (done) {
                saveToHistory(context, prompt, fullResponse, options.systemPrompt);
              }
            }).catch(error => {
              ErrorHandler.handleError(error);
            });
          });

          progress.report({ increment: 100 });
        } else {
          // Use non-streaming API
          const response = await apiClient.generateCompletion(options);
          progress.report({ increment: 100 });

          // Save to conversation history
          saveToHistory(context, prompt, response.text, options.systemPrompt);

          // Show response in panel
          showResponseInPanel(response.text, context);
        }
      });
    } catch (error) {
      ErrorHandler.handleError(error);
    }
  });

  // Register the "Explain Code" command
  const explainCodeCommand = vscode.commands.registerCommand('qwen-coder-assistant.explainCode', async () => {
    const editorContext = await getEditorContext();

    if (!editorContext || !editorContext.selectedCode) {
      vscode.window.showInformationMessage('Please select some code to explain.');
      return;
    }

    try {
      vscode.window.withProgress({
        location: vscode.ProgressLocation.Notification,
        title: 'Explaining code...',
        cancellable: false
      }, async (progress) => {
        progress.report({ increment: 0 });

        const prompt = `Please explain the following code in detail:\n\`\`\`${editorContext.language}\n${editorContext.selectedCode}\n\`\`\``;

        const options: QwenRequestOptions = {
          prompt,
          systemPrompt: 'You are Qwen Coder, an AI assistant specialized in explaining code. Provide clear, detailed explanations of how the code works, its purpose, and any important patterns or concepts it demonstrates.'
        };

        progress.report({ increment: 50 });

        // Check if streaming is enabled in configuration
        const config = getConfiguration();
        if (config.streamingEnabled) {
          // Use streaming API
          progress.report({ message: 'Streaming response...' });

          // Variable to accumulate the full response for history
          let fullResponse = '';

          showStreamingResponseInPanel(context, (streamHandler) => {
            apiClient.generateStreamingCompletion(options, (chunk, done) => {
              // Accumulate the response
              fullResponse += chunk;

              // Pass to the original handler
              streamHandler(chunk, done);

              // When streaming is complete, save to history
              if (done) {
                saveToHistory(context, prompt, fullResponse, options.systemPrompt);
              }
            }).catch(error => {
              ErrorHandler.handleError(error);
            });
          });

          progress.report({ increment: 100 });
        } else {
          // Use non-streaming API
          const response = await apiClient.generateCompletion(options);
          progress.report({ increment: 100 });

          // Save to conversation history
          saveToHistory(context, prompt, response.text, options.systemPrompt);

          // Show response in panel
          showResponseInPanel(response.text, context);
        }
      });
    } catch (error) {
      ErrorHandler.handleError(error);
    }
  });

  // Register the "Generate Code" command
  const generateCodeCommand = vscode.commands.registerCommand('qwen-coder-assistant.generateCode', async () => {
    const userPrompt = await vscode.window.showInputBox({
      prompt: 'What code would you like to generate?',
      placeHolder: 'E.g., Write a function to sort an array of objects by a property'
    });

    if (!userPrompt) {
      return; // User cancelled
    }

    try {
      vscode.window.withProgress({
        location: vscode.ProgressLocation.Notification,
        title: 'Generating code...',
        cancellable: false
      }, async (progress) => {
        progress.report({ increment: 0 });

        const editorContext = await getEditorContext();

        let prompt = `Generate code for: ${userPrompt}`;
        if (editorContext) {
          prompt += `\n\nContext:\nFile: ${editorContext.fileName}\nLanguage: ${editorContext.language}\n`;

          if (editorContext.visibleRangeText) {
            prompt += `\nSurrounding code:\n\`\`\`${editorContext.language}\n${editorContext.visibleRangeText}\n\`\`\``;
          }
        }

        progress.report({ increment: 30 });

        // Get project context for better code generation
        progress.report({ message: 'Retrieving code context...' });
        const projectContext = await getProjectContext(userPrompt);
        if (projectContext) {
          prompt += `\n\nProject context (relevant files):\n${projectContext}`;
        }

        progress.report({ increment: 50 });

        const options: QwenRequestOptions = {
          prompt,
          systemPrompt: 'You are Qwen Coder, an AI assistant specialized in generating high-quality code. Generate code that is efficient, well-documented, and follows best practices for the given language and context.'
        };

        // Check if streaming is enabled in configuration
        const config = getConfiguration();
        if (config.streamingEnabled) {
          // Use streaming API
          progress.report({ message: 'Streaming response...' });

          // Variable to accumulate the full response for history
          let fullResponse = '';

          showStreamingResponseInPanel(context, (streamHandler) => {
            apiClient.generateStreamingCompletion(options, (chunk, done) => {
              // Accumulate the response
              fullResponse += chunk;

              // Pass to the original handler
              streamHandler(chunk, done);

              // When streaming is complete, save to history
              if (done) {
                saveToHistory(context, prompt, fullResponse, options.systemPrompt);
              }
            }).catch(error => {
              ErrorHandler.handleError(error);
            });
          });

          progress.report({ increment: 100 });
        } else {
          // Use non-streaming API
          const response = await apiClient.generateCompletion(options);
          progress.report({ increment: 100 });

          // Save to conversation history
          saveToHistory(context, prompt, response.text, options.systemPrompt);

          // Show response in panel
          showResponseInPanel(response.text, context);
        }
      });
    } catch (error) {
      ErrorHandler.handleError(error);
    }
  });

  // Register the "Clear Cache" command
  const clearCacheCommand = vscode.commands.registerCommand('qwen-coder-assistant.clearCache', async () => {
    try {
      apiClient.clearCache();
      vscode.window.showInformationMessage('Qwen Coder cache cleared successfully.');
    } catch (error) {
      ErrorHandler.handleError(error);
    }
  });

  // Register the "Refactor Code" command
  const refactorCodeCommand = vscode.commands.registerCommand('qwen-coder-assistant.refactorCode', async () => {
    const editorContext = await getEditorContext();

    if (!editorContext || !editorContext.selectedCode) {
      vscode.window.showInformationMessage('Please select some code to refactor.');
      return;
    }

    try {
      vscode.window.withProgress({
        location: vscode.ProgressLocation.Notification,
        title: 'Refactoring code...',
        cancellable: false
      }, async (progress) => {
        progress.report({ increment: 0 });

        const prompt = `Please refactor the following code to improve its readability, efficiency, and maintainability. Provide the refactored code and explain the improvements made:\n\`\`\`${editorContext.language}\n${editorContext.selectedCode}\n\`\`\``;

        const options: QwenRequestOptions = {
          prompt,
          systemPrompt: 'You are Qwen Coder, an AI assistant specialized in refactoring code. Provide clean, efficient, and well-structured code that follows best practices and design patterns. Explain the improvements you made.'
        };

        progress.report({ increment: 50 });

        // Check if streaming is enabled in configuration
        const config = getConfiguration();
        if (config.streamingEnabled) {
          // Use streaming API
          progress.report({ message: 'Streaming response...' });

          // Variable to accumulate the full response for history
          let fullResponse = '';

          showStreamingResponseInPanel(context, (streamHandler) => {
            apiClient.generateStreamingCompletion(options, (chunk, done) => {
              // Accumulate the response
              fullResponse += chunk;

              // Pass to the original handler
              streamHandler(chunk, done);

              // When streaming is complete, save to history
              if (done) {
                saveToHistory(context, prompt, fullResponse, options.systemPrompt);
              }
            }).catch(error => {
              ErrorHandler.handleError(error);
            });
          });

          progress.report({ increment: 100 });
        } else {
          // Use non-streaming API
          const response = await apiClient.generateCompletion(options);
          progress.report({ increment: 100 });

          // Save to conversation history
          saveToHistory(context, prompt, response.text, options.systemPrompt);

          // Show response in panel
          showResponseInPanel(response.text, context);
        }
      });
    } catch (error) {
      ErrorHandler.handleError(error);
    }
  });

  // Register the "Document Code" command
  const documentCodeCommand = vscode.commands.registerCommand('qwen-coder-assistant.documentCode', async () => {
    const editorContext = await getEditorContext();

    if (!editorContext || !editorContext.selectedCode) {
      vscode.window.showInformationMessage('Please select some code to document.');
      return;
    }

    try {
      vscode.window.withProgress({
        location: vscode.ProgressLocation.Notification,
        title: 'Documenting code...',
        cancellable: false
      }, async (progress) => {
        progress.report({ increment: 0 });

        const prompt = `Please add comprehensive documentation to the following code. Include function/method descriptions, parameter explanations, return value details, and any other relevant documentation:\n\`\`\`${editorContext.language}\n${editorContext.selectedCode}\n\`\`\``;

        const options: QwenRequestOptions = {
          prompt,
          systemPrompt: 'You are Qwen Coder, an AI assistant specialized in documenting code. Provide clear, comprehensive documentation that follows the conventions of the given programming language. Include function/method descriptions, parameter explanations, return value details, and usage examples where appropriate.'
        };

        progress.report({ increment: 50 });

        // Check if streaming is enabled in configuration
        const config = getConfiguration();
        if (config.streamingEnabled) {
          // Use streaming API
          progress.report({ message: 'Streaming response...' });

          // Variable to accumulate the full response for history
          let fullResponse = '';

          showStreamingResponseInPanel(context, (streamHandler) => {
            apiClient.generateStreamingCompletion(options, (chunk, done) => {
              // Accumulate the response
              fullResponse += chunk;

              // Pass to the original handler
              streamHandler(chunk, done);

              // When streaming is complete, save to history
              if (done) {
                saveToHistory(context, prompt, fullResponse, options.systemPrompt);
              }
            }).catch(error => {
              ErrorHandler.handleError(error);
            });
          });

          progress.report({ increment: 100 });
        } else {
          // Use non-streaming API
          const response = await apiClient.generateCompletion(options);
          progress.report({ increment: 100 });

          // Save to conversation history
          saveToHistory(context, prompt, response.text, options.systemPrompt);

          // Show response in panel
          showResponseInPanel(response.text, context);
        }
      });
    } catch (error) {
      ErrorHandler.handleError(error);
    }
  });

  // Register the "Fix Issues" command
  const fixIssuesCommand = vscode.commands.registerCommand('qwen-coder-assistant.fixIssues', async () => {
    const editorContext = await getEditorContext();

    if (!editorContext || !editorContext.selectedCode) {
      vscode.window.showInformationMessage('Please select some code to fix.');
      return;
    }

    try {
      vscode.window.withProgress({
        location: vscode.ProgressLocation.Notification,
        title: 'Fixing code issues...',
        cancellable: false
      }, async (progress) => {
        progress.report({ increment: 0 });

        const prompt = `Please identify and fix any issues in the following code. This could include bugs, syntax errors, performance issues, or security vulnerabilities. Provide the fixed code and explain the issues that were addressed:\n\`\`\`${editorContext.language}\n${editorContext.selectedCode}\n\`\`\``;

        const options: QwenRequestOptions = {
          prompt,
          systemPrompt: 'You are Qwen Coder, an AI assistant specialized in identifying and fixing code issues. Look for bugs, syntax errors, performance issues, security vulnerabilities, and other problems. Provide the fixed code and explain the issues that were addressed.'
        };

        progress.report({ increment: 50 });

        // Check if streaming is enabled in configuration
        const config = getConfiguration();
        if (config.streamingEnabled) {
          // Use streaming API
          progress.report({ message: 'Streaming response...' });

          // Variable to accumulate the full response for history
          let fullResponse = '';

          showStreamingResponseInPanel(context, (streamHandler) => {
            apiClient.generateStreamingCompletion(options, (chunk, done) => {
              // Accumulate the response
              fullResponse += chunk;

              // Pass to the original handler
              streamHandler(chunk, done);

              // When streaming is complete, save to history
              if (done) {
                saveToHistory(context, prompt, fullResponse, options.systemPrompt);
              }
            }).catch(error => {
              ErrorHandler.handleError(error);
            });
          });

          progress.report({ increment: 100 });
        } else {
          // Use non-streaming API
          const response = await apiClient.generateCompletion(options);
          progress.report({ increment: 100 });

          // Save to conversation history
          saveToHistory(context, prompt, response.text, options.systemPrompt);

          // Show response in panel
          showResponseInPanel(response.text, context);
        }
      });
    } catch (error) {
      ErrorHandler.handleError(error);
    }
  });

  // Register the "Hierarchical Agent" command
  const hierarchicalAgentCommand = vscode.commands.registerCommand('qwen-coder-assistant.hierarchicalAgent', async () => {
    if (!agentCoordinator) {
      vscode.window.showErrorMessage('Hierarchical agent system is not available.');
      return;
    }

    const userPrompt = await vscode.window.showInputBox({
      prompt: 'What would you like the hierarchical agent system to do?',
      placeHolder: 'E.g., Implement a feature, refactor a module, create tests for a function'
    });

    if (!userPrompt) {
      return; // User cancelled
    }

    try {
      vscode.window.withProgress({
        location: vscode.ProgressLocation.Notification,
        title: 'Processing with hierarchical agent system...',
        cancellable: false
      }, async (progress) => {
        progress.report({ increment: 0 });

        // Create a webview panel to display the results
        const panel = vscode.window.createWebviewPanel(
          'qwenCoderHierarchicalAgent',
          'Hierarchical Agent',
          vscode.ViewColumn.One,
          {
            enableScripts: true,
            retainContextWhenHidden: true
          }
        );

        // Show loading indicator
        panel.webview.html = getLoadingWebviewContent();

        progress.report({ increment: 30, message: 'Decomposing task...' });

        try {
          // Process the request with the agent coordinator
          progress.report({ increment: 50, message: 'Executing subtasks...' });
          const response = await agentCoordinator.processRequest(userPrompt);

          progress.report({ increment: 100, message: 'Aggregating results...' });

          // Show the response in the panel
          panel.webview.html = getWebviewContent(userPrompt, response);

          // Save to conversation history
          saveToHistory(context, userPrompt, response, 'Hierarchical Agent System');
        } catch (error) {
          panel.webview.html = getErrorWebviewContent(userPrompt, error.message);
          ErrorHandler.handleError(error);
        }
      });
    } catch (error) {
      ErrorHandler.handleError(error);
    }
  });

  // Register the "MCP Tool" command
  const mcpToolCommand = vscode.commands.registerCommand('qwen-coder-assistant.mcpTool', async () => {
    if (!mcpClient) {
      vscode.window.showErrorMessage('MCP tools are not available.');
      return;
    }

    try {
      // Get available tools
      const availableTools = mcpClient.getAvailableTools();

      if (availableTools.length === 0) {
        vscode.window.showInformationMessage('No MCP tools are currently available. Please start some tools first.');
        return;
      }

      // Let the user select a tool
      const selectedTool = await vscode.window.showQuickPick(availableTools, {
        placeHolder: 'Select an MCP tool to use'
      });

      if (!selectedTool) {
        return; // User cancelled
      }

      // Get the tool schema
      const toolSchema = mcpClient.getToolSchema(selectedTool);

      if (!toolSchema) {
        vscode.window.showErrorMessage(`Schema for tool ${selectedTool} is not available.`);
        return;
      }

      // Let the user select a function
      const functionItems = toolSchema.functions.map(func => ({
        label: func.name,
        description: func.description,
        detail: `Parameters: ${Object.keys(func.parameters.properties).join(', ')}`,
        function: func
      }));

      const selectedFunction = await vscode.window.showQuickPick(functionItems, {
        placeHolder: 'Select a function to call'
      });

      if (!selectedFunction) {
        return; // User cancelled
      }

      // Collect parameters for the function
      const parameters: Record<string, any> = {};

      for (const paramName of selectedFunction.function.parameters.required) {
        const paramSchema = selectedFunction.function.parameters.properties[paramName];

        const paramValue = await vscode.window.showInputBox({
          prompt: `Enter value for ${paramName}`,
          placeHolder: paramSchema.description
        });

        if (paramValue === undefined) {
          return; // User cancelled
        }

        // Convert value to appropriate type
        if (paramSchema.type === 'number') {
          parameters[paramName] = Number(paramValue);
        } else if (paramSchema.type === 'boolean') {
          parameters[paramName] = paramValue.toLowerCase() === 'true';
        } else {
          parameters[paramName] = paramValue;
        }
      }

      // Call the function
      vscode.window.withProgress({
        location: vscode.ProgressLocation.Notification,
        title: `Calling ${selectedFunction.label} on ${selectedTool}...`,
        cancellable: false
      }, async (progress) => {
        progress.report({ increment: 0 });

        const result = await mcpClient.callFunction(selectedTool, selectedFunction.label, parameters);

        progress.report({ increment: 100 });

        // Show the result
        if (result.status === 'success') {
          // Create a webview panel to display the results
          const panel = vscode.window.createWebviewPanel(
            'qwenCoderMcpTool',
            `${selectedTool} - ${selectedFunction.label}`,
            vscode.ViewColumn.One,
            {
              enableScripts: true,
              retainContextWhenHidden: true
            }
          );

          // Show the result
          panel.webview.html = `<!DOCTYPE html>
          <html lang="en">
          <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>${selectedTool} - ${selectedFunction.label}</title>
            <style>
              body {
                font-family: var(--vscode-font-family);
                color: var(--vscode-editor-foreground);
                background-color: var(--vscode-editor-background);
                padding: 20px;
              }
              pre {
                background-color: var(--vscode-textCodeBlock-background);
                padding: 16px;
                border-radius: 4px;
                overflow: auto;
              }
            </style>
          </head>
          <body>
            <h1>${selectedTool} - ${selectedFunction.label}</h1>
            <h2>Parameters</h2>
            <pre>${JSON.stringify(parameters, null, 2)}</pre>
            <h2>Result</h2>
            <pre>${JSON.stringify(result.result, null, 2)}</pre>
          </body>
          </html>`;
        } else {
          vscode.window.showErrorMessage(`Error calling function: ${result.error}`);
        }
      });
    } catch (error) {
      ErrorHandler.handleError(error);
    }
  });

  // Add commands to subscriptions
  context.subscriptions.push(
    askQwenCommand,
    explainCodeCommand,
    generateCodeCommand,
    refactorCodeCommand,
    documentCodeCommand,
    fixIssuesCommand,
    clearCacheCommand,
    hierarchicalAgentCommand,
    mcpToolCommand
  );
}

// Helper function to get loading webview content
function getLoadingWebviewContent(): string {
  return `<!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Processing Request</title>
    <style>
      body {
        font-family: var(--vscode-font-family);
        color: var(--vscode-editor-foreground);
        background-color: var(--vscode-editor-background);
        padding: 20px;
      }
      .loading {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 300px;
      }
      .spinner {
        width: 50px;
        height: 50px;
        border: 5px solid var(--vscode-button-background);
        border-radius: 50%;
        border-top-color: transparent;
        animation: spin 1s linear infinite;
        margin-bottom: 20px;
      }
      @keyframes spin {
        to { transform: rotate(360deg); }
      }
    </style>
  </head>
  <body>
    <div class="loading">
      <div class="spinner"></div>
      <h2>Processing your request...</h2>
      <p>The hierarchical agent system is working on your task.</p>
    </div>
  </body>
  </html>`;
}

// Helper function to get webview content
function getWebviewContent(request: string, response: string): string {
  return `<!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Agent Response</title>
    <style>
      body {
        font-family: var(--vscode-font-family);
        color: var(--vscode-editor-foreground);
        background-color: var(--vscode-editor-background);
        padding: 20px;
        line-height: 1.5;
      }
      h1, h2, h3, h4, h5, h6 {
        color: var(--vscode-editor-foreground);
      }
      pre {
        background-color: var(--vscode-textCodeBlock-background);
        padding: 16px;
        border-radius: 4px;
        overflow: auto;
      }
      code {
        font-family: var(--vscode-editor-font-family);
        font-size: var(--vscode-editor-font-size);
      }
      .request {
        background-color: var(--vscode-input-background);
        padding: 10px;
        border-radius: 4px;
        margin-bottom: 20px;
        border-left: 4px solid var(--vscode-activityBarBadge-background);
      }
    </style>
  </head>
  <body>
    <div class="request">
      <strong>Your request:</strong> ${request}
    </div>
    <div class="response">
      ${markdownToHtml(response)}
    </div>
  </body>
  </html>`;
}

// Helper function to get error webview content
function getErrorWebviewContent(request: string, errorMessage: string): string {
  return `<!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Error</title>
    <style>
      body {
        font-family: var(--vscode-font-family);
        color: var(--vscode-editor-foreground);
        background-color: var(--vscode-editor-background);
        padding: 20px;
      }
      .request {
        background-color: var(--vscode-input-background);
        padding: 10px;
        border-radius: 4px;
        margin-bottom: 20px;
        border-left: 4px solid var(--vscode-activityBarBadge-background);
      }
      .error {
        background-color: var(--vscode-inputValidation-errorBackground);
        color: var(--vscode-inputValidation-errorForeground);
        padding: 10px;
        border-radius: 4px;
        margin-bottom: 20px;
        border-left: 4px solid var(--vscode-errorForeground);
      }
    </style>
  </head>
  <body>
    <div class="request">
      <strong>Your request:</strong> ${request}
    </div>
    <div class="error">
      <strong>Error:</strong> ${errorMessage}
    </div>
    <p>Please try again with a more specific request or check the extension logs for more details.</p>
  </body>
  </html>`;
}

// Helper function to convert markdown to HTML
function markdownToHtml(markdown: string): string {
  // This is a very simple markdown to HTML converter
  // In a real implementation, we would use a proper markdown parser

  // Replace headers
  let html = markdown
    .replace(/^### (.*$)/gim, '<h3>$1</h3>')
    .replace(/^## (.*$)/gim, '<h2>$1</h2>')
    .replace(/^# (.*$)/gim, '<h1>$1</h1>');

  // Replace code blocks
  html = html.replace(/```([a-z]*)\n([\s\S]*?)\n```/gim, '<pre><code class="language-$1">$2</code></pre>');

  // Replace inline code
  html = html.replace(/`([^`]+)`/gim, '<code>$1</code>');

  // Replace lists
  html = html.replace(/^\s*\*\s(.*$)/gim, '<ul><li>$1</li></ul>');
  html = html.replace(/^\s*\d+\.\s(.*$)/gim, '<ol><li>$1</li></ol>');

  // Replace paragraphs
  html = html.replace(/^\s*(\n)?([^\n]+)\n/gim, '<p>$2</p>');

  // Fix consecutive lists
  html = html.replace(/<\/ul>\s*<ul>/gim, '');
  html = html.replace(/<\/ol>\s*<ol>/gim, '');

  return html;
}

```


---

### File: `src/contextProvider.ts`

```typescript
import * as path from 'path';
import * as vscode from 'vscode';
import { ContextEngine } from './context/contextEngine';

// Create a singleton instance of the context engine
const contextEngine = new ContextEngine();

export interface CodeContext {
  selectedCode: string;
  fullDocumentText: string;
  fileName: string;
  fileExtension: string;
  language: string;
  selection: vscode.Selection | null;
  visibleRangeText: string;
  projectContext?: string;
}

export async function getEditorContext(): Promise<CodeContext | null> {
  const editor = vscode.window.activeTextEditor;
  if (!editor) {
    return null;
  }

  const document = editor.document;
  const selection = editor.selection;
  const selectedText = document.getText(selection);
  const fullText = document.getText();
  const fileName = path.basename(document.fileName);
  const fileExtension = path.extname(document.fileName).substring(1);
  const language = document.languageId;

  // Get visible range text
  const visibleRanges = editor.visibleRanges;
  let visibleText = '';
  for (const range of visibleRanges) {
    visibleText += document.getText(range) + '\n';
  }

  return {
    selectedCode: selectedText,
    fullDocumentText: fullText,
    fileName,
    fileExtension,
    language,
    selection: selection.isEmpty ? null : selection,
    visibleRangeText: visibleText
  };
}

export async function getProjectContext(query: string = '', maxTokens: number = 4000): Promise<string> {
  try {
    // Initialize the context engine if it hasn't been initialized yet
    if (!contextEngine) {
      return "Context engine not available";
    }

    // Get context from the context engine
    return await contextEngine.getContext(query, maxTokens);
  } catch (error) {
    console.error('Error getting project context:', error);
    return `Error getting project context: ${error instanceof Error ? error.message : String(error)}`;
  }
}

export async function getContextForFile(filePath: string, maxTokens: number = 4000): Promise<string> {
  try {
    // Initialize the context engine if it hasn't been initialized yet
    if (!contextEngine) {
      return "Context engine not available";
    }

    // Get context for the file
    return await contextEngine.getContextForFile(filePath, maxTokens);
  } catch (error) {
    console.error('Error getting file context:', error);
    return `Error getting file context: ${error instanceof Error ? error.message : String(error)}`;
  }
}

export async function getContextForSymbol(symbol: string, maxTokens: number = 4000): Promise<string> {
  try {
    // Initialize the context engine if it hasn't been initialized yet
    if (!contextEngine) {
      return "Context engine not available";
    }

    // Get context for the symbol
    return await contextEngine.getContextForSymbol(symbol, maxTokens);
  } catch (error) {
    console.error('Error getting symbol context:', error);
    return `Error getting symbol context: ${error instanceof Error ? error.message : String(error)}`;
  }
}

export async function initializeContextEngine(): Promise<void> {
  try {
    await contextEngine.initialize();
  } catch (error) {
    console.error('Error initializing context engine:', error);
  }
}

export async function disposeContextEngine(): Promise<void> {
  try {
    await contextEngine.dispose();
  } catch (error) {
    console.error('Error disposing context engine:', error);
  }
}

```


---

### File: `src/responseFormatter.ts`

```typescript
import * as vscode from 'vscode';

export interface FormattedResponse {
  markdown: string;
  codeBlocks: { language: string; code: string }[];
}

export function formatResponse(response: string): FormattedResponse {
  // Extract code blocks from the response
  const codeBlockRegex = /```(\w+)?\n([\s\S]*?)```/g;
  const codeBlocks: { language: string; code: string }[] = [];

  let match;
  while ((match = codeBlockRegex.exec(response)) !== null) {
    const language = match[1] || 'text';
    const code = match[2];
    codeBlocks.push({ language, code });
  }

  return {
    markdown: response,
    codeBlocks
  };
}

export function insertCodeIntoEditor(code: string, editor?: vscode.TextEditor): void {
  if (!editor) {
    editor = vscode.window.activeTextEditor;
    if (!editor) {
      vscode.window.showErrorMessage('No active editor found');
      return;
    }
  }

  const selection = editor.selection;
  editor.edit(editBuilder => {
    if (selection.isEmpty) {
      editBuilder.insert(selection.start, code);
    } else {
      editBuilder.replace(selection, code);
    }
  });
}

export function showResponseInPanel(response: string, context: vscode.ExtensionContext): void {
  // Import the QwenResponsePanel class to use its functionality
  const { QwenResponsePanel } = require('./webview/panel');

  // Create or show the panel
  const panel = QwenResponsePanel.createOrShow(context.extensionUri, 'Qwen Coder Response');

  // Set the content
  panel.setContent(response);
}

/**
 * Show a streaming response in a webview panel
 * @param context The extension context
 * @param onPanelReady Callback that receives the streaming handler function
 */
export function showStreamingResponseInPanel(
  context: vscode.ExtensionContext,
  onPanelReady: (streamHandler: (chunk: string, isComplete: boolean) => void) => void
): void {
  // Import the QwenResponsePanel class to use its functionality
  const { QwenResponsePanel } = require('./webview/panel');

  // Create or show the panel
  const panel = QwenResponsePanel.createOrShow(context.extensionUri, 'Qwen Coder Response (Streaming)');

  // Set initial empty content
  panel.setContent('');

  // Create a streaming handler function
  const streamHandler = (chunk: string, isComplete: boolean) => {
    panel.appendContent(chunk, isComplete);
  };

  // Call the callback with the streaming handler
  onPanelReady(streamHandler);
}



```


---

### File: `src/mockQwenApi.ts`

```typescript
import { generateCacheKey } from './cache';
import { QwenCoderConfig } from './configuration';
import { QwenApiClient, QwenRequestOptions, QwenResponse } from './qwenApi';

/**
 * A mock implementation of the QwenApiClient for testing and development
 * without requiring an actual API endpoint.
 */
export class MockQwenApiClient extends QwenApiClient {

  constructor(config: QwenCoderConfig) {
    super(config);
  }

  /**
   * Override the updateConfig method to update the cache configuration
   */
  public updateConfig(config: QwenCoderConfig): void {
    super.updateConfig(config);
  }

  /**
   * Override the generateCompletion method to return mock responses
   */
  public async generateCompletion(options: QwenRequestOptions): Promise<QwenResponse> {
    // Check cache first (unless skipCache is true or cacheEnabled is false)
    if (!options.skipCache && this.config.cacheEnabled) {
      const cacheKey = generateCacheKey(options.prompt, {
        systemPrompt: options.systemPrompt,
        maxTokens: options.maxTokens || this.config.maxTokens,
        temperature: options.temperature || this.config.temperature
      });

      const cachedResponse = this.cache.get<QwenResponse>(cacheKey);
      if (cachedResponse) {
        console.log('Using cached mock response for prompt:', options.prompt.substring(0, 50) + '...');
        return {
          ...cachedResponse,
          cached: true
        };
      }
    }

    // Simulate API delay
    await new Promise(resolve => setTimeout(resolve, 1000));

    // Generate a mock response based on the prompt
    const prompt = options.prompt.toLowerCase();
    let response = '';

    if (prompt.includes('explain')) {
      response = this.generateExplanationResponse(prompt);
    } else if (prompt.includes('generate') || prompt.includes('write')) {
      response = this.generateCodeResponse(prompt);
    } else {
      response = this.generateGeneralResponse(prompt);
    }

    const result: QwenResponse = {
      text: response,
      usage: {
        promptTokens: options.prompt.length,
        completionTokens: response.length,
        totalTokens: options.prompt.length + response.length
      }
    };

    // Cache the response (unless skipCache is true or cacheEnabled is false)
    if (!options.skipCache && this.config.cacheEnabled) {
      const cacheKey = generateCacheKey(options.prompt, {
        systemPrompt: options.systemPrompt,
        maxTokens: options.maxTokens || this.config.maxTokens,
        temperature: options.temperature || this.config.temperature
      });

      this.cache.set(cacheKey, result);
    }

    return result;
  }

  private generateExplanationResponse(prompt: string): string {
    return `# Code Explanation

This code appears to be ${prompt.includes('javascript') ? 'JavaScript' : prompt.includes('python') ? 'Python' : 'a programming language'} code that performs some operations.

## Key Components:

1. **Initialization**: The code sets up initial variables and configurations.
2. **Processing**: It processes data through several steps.
3. **Output**: Finally, it returns or displays the results.

## How It Works:

The code follows a typical pattern where it:
1. Takes input
2. Transforms the input through algorithms
3. Produces output based on the transformation

## Best Practices:

The code demonstrates several good practices:
- Clear variable naming
- Proper error handling
- Efficient algorithm implementation

Would you like me to explain any specific part in more detail?`;
  }

  private generateCodeResponse(prompt: string): string {
    const language = prompt.includes('javascript') || prompt.includes('js') ? 'javascript' :
                    prompt.includes('typescript') || prompt.includes('ts') ? 'typescript' :
                    prompt.includes('python') || prompt.includes('py') ? 'python' : 'javascript';

    if (language === 'javascript' || language === 'typescript') {
      return `# Generated Code

Here's a ${language} implementation for your request:

\`\`\`${language}
/**
 * A utility function that performs the requested operation
 * @param {Array} data - The input data to process
 * @param {Object} options - Configuration options
 * @returns {Array} - The processed results
 */
function processData(data, options = {}) {
  // Default options
  const config = {
    sortBy: 'name',
    filterEmpty: true,
    maxResults: 100,
    ...options
  };

  // Input validation
  if (!Array.isArray(data)) {
    throw new Error('Input must be an array');
  }

  // Filter out empty items if configured
  let results = config.filterEmpty
    ? data.filter(item => item && Object.keys(item).length > 0)
    : [...data];

  // Sort the results if needed
  if (config.sortBy) {
    results.sort((a, b) => {
      if (a[config.sortBy] < b[config.sortBy]) return -1;
      if (a[config.sortBy] > b[config.sortBy]) return 1;
      return 0;
    });
  }

  // Limit the number of results
  if (config.maxResults && results.length > config.maxResults) {
    results = results.slice(0, config.maxResults);
  }

  return results;
}

// Example usage
const sampleData = [
  { name: 'Item 3', value: 30 },
  { name: 'Item 1', value: 10 },
  { name: 'Item 2', value: 20 },
  {},  // Empty object
  { name: 'Item 4', value: 40 }
];

const result = processData(sampleData, {
  sortBy: 'value',
  maxResults: 3
});

console.log(result);
\`\`\`

This implementation includes:
- Flexible configuration options
- Input validation
- Sorting and filtering capabilities
- Example usage

You can customize the function parameters and behavior based on your specific requirements.`;
    } else if (language === 'python') {
      return `# Generated Code

Here's a Python implementation for your request:

\`\`\`python
from typing import List, Dict, Any, Optional
import copy

def process_data(data: List[Dict[str, Any]],
                 sort_by: Optional[str] = 'name',
                 filter_empty: bool = True,
                 max_results: Optional[int] = 100) -> List[Dict[str, Any]]:
    """
    Process a list of dictionaries based on the provided options.

    Args:
        data: List of dictionaries to process
        sort_by: Key to sort by (None for no sorting)
        filter_empty: Whether to filter out empty dictionaries
        max_results: Maximum number of results to return (None for all)

    Returns:
        Processed list of dictionaries
    """
    # Input validation
    if not isinstance(data, list):
        raise TypeError("Input must be a list")

    # Create a copy to avoid modifying the original
    results = copy.deepcopy(data)

    # Filter out empty items if configured
    if filter_empty:
        results = [item for item in results if item and len(item) > 0]

    # Sort the results if needed
    if sort_by is not None:
        results.sort(key=lambda x: x.get(sort_by, None))

    # Limit the number of results
    if max_results is not None and len(results) > max_results:
        results = results[:max_results]

    return results

# Example usage
if __name__ == "__main__":
    sample_data = [
        {"name": "Item 3", "value": 30},
        {"name": "Item 1", "value": 10},
        {"name": "Item 2", "value": 20},
        {},  # Empty dictionary
        {"name": "Item 4", "value": 40}
    ]

    result = process_data(
        data=sample_data,
        sort_by="value",
        max_results=3
    )

    print(result)
\`\`\`

This implementation includes:
- Type hints for better code quality
- Docstring with parameter descriptions
- Input validation
- Deep copying to prevent modifying the original data
- Sorting and filtering capabilities
- Example usage

You can adjust the function parameters and behavior based on your specific requirements.`;
    } else {
      return `# Generated Code

I'm not sure which programming language you prefer, so here's a pseudocode implementation:

\`\`\`
function ProcessData(data, options)
    // Set default options
    if options.sortBy is undefined then options.sortBy = "name"
    if options.filterEmpty is undefined then options.filterEmpty = true
    if options.maxResults is undefined then options.maxResults = 100

    // Validate input
    if data is not a list/array then
        throw Error("Input must be an array/list")
    end if

    // Create a copy of the data
    results = copy(data)

    // Filter empty items if needed
    if options.filterEmpty then
        results = filter(results, item => item is not empty)
    end if

    // Sort if needed
    if options.sortBy is not null then
        results = sort(results by options.sortBy)
    end if

    // Limit results
    if options.maxResults is not null and length(results) > options.maxResults then
        results = first options.maxResults items from results
    end if

    return results
end function
\`\`\`

Let me know which programming language you'd prefer, and I can provide a more specific implementation.`;
    }
  }

  private generateGeneralResponse(_prompt: string): string {
    return `# Response

Thank you for your question! Here's what I can tell you:

The concept you're asking about is fundamental in software development. Let me break it down:

## Key Points:

1. **Understanding the Basics**:
   It's important to grasp the fundamental concepts before diving into implementation details.

2. **Best Practices**:
   - Write clean, maintainable code
   - Document your work thoroughly
   - Test your code regularly
   - Follow established patterns and conventions

3. **Common Approaches**:
   There are several ways to tackle this problem, each with its own advantages:
   - Method A: Simple but may not scale well
   - Method B: More complex but highly efficient
   - Method C: Balanced approach for most use cases

## Example:

Here's a simplified example to illustrate:

\`\`\`javascript
function demonstrateConcept(input) {
  // Validate input
  if (!input) {
    return null;
  }

  // Process the input
  const result = input.map(item => {
    return {
      ...item,
      processed: true,
      timestamp: Date.now()
    };
  });

  return result;
}
\`\`\`

## Further Learning:

If you'd like to explore this topic further, I recommend:
- Reading the official documentation
- Practicing with small projects
- Joining community discussions

Is there a specific aspect you'd like me to elaborate on?`;
  }

  /**
   * Override the generateStreamingCompletion method to simulate streaming responses
   */
  public async generateStreamingCompletion(
    options: QwenRequestOptions,
    onChunk: StreamingResponseHandler
  ): Promise<void> {
    try {
      // Generate a complete response first
      const prompt = options.prompt.toLowerCase();
      let fullResponse = '';

      if (prompt.includes('explain')) {
        fullResponse = this.generateExplanationResponse(prompt);
      } else if (prompt.includes('generate') || prompt.includes('write')) {
        fullResponse = this.generateCodeResponse(prompt);
      } else {
        fullResponse = this.generateGeneralResponse(prompt);
      }

      // Simulate streaming by sending chunks with delays
      const chunks = this.chunkResponse(fullResponse);

      for (let i = 0; i < chunks.length; i++) {
        // Simulate network delay
        await new Promise(resolve => setTimeout(resolve, 100));

        // Send the chunk
        const isLast = i === chunks.length - 1;
        onChunk(chunks[i], isLast);

        // If we're simulating an error, break early
        if (prompt.includes('error') && i > chunks.length / 2) {
          onChunk('\n\nError: Simulated streaming error for testing purposes', true);
          break;
        }
      }
    } catch (error) {
      console.error('Error in mock streaming:', error);
      onChunk(`Error: ${error instanceof Error ? error.message : String(error)}`, true);
    }
  }

  /**
   * Split a response into chunks for simulated streaming
   */
  private chunkResponse(response: string): string[] {
    // Split by sentences or line breaks for more natural chunking
    const chunks: string[] = [];
    const sentences = response.split(/(?<=\.|\?|\!|\n)\s+/);

    // Group sentences into reasonable chunks
    let currentChunk = '';
    for (const sentence of sentences) {
      currentChunk += sentence + ' ';

      // When chunk gets big enough, add it to chunks array
      if (currentChunk.length > 30) {
        chunks.push(currentChunk.trim());
        currentChunk = '';
      }
    }

    // Add any remaining content
    if (currentChunk.trim()) {
      chunks.push(currentChunk.trim());
    }

    return chunks;
  }
}

```


---

### File: `src/qwenApi.ts`

```typescript
import axios, { AxiosInstance } from 'axios';
import { ResponseCache, generateCacheKey } from './cache';
import { QwenCoderConfig } from './configuration';
import { ErrorHandler } from './errorHandler';

export interface QwenRequestOptions {
  prompt: string;
  maxTokens?: number;
  temperature?: number;
  systemPrompt?: string;
  skipCache?: boolean;
  stream?: boolean;
}

export interface QwenChatOptions {
  enableThinking?: boolean;
  thinkingMode?: 'auto' | 'always' | 'never'; // Enhanced thinking mode control
  thinkingBudget?: number; // Token budget for thinking
  temperature?: number;
  maxTokens?: number;
  modelName?: string;
  skipCache?: boolean;
  stream?: boolean;
  tools?: QwenTool[]; // Tools for function calling
}

export interface QwenMessage {
  role: 'system' | 'user' | 'assistant';
  content: string;
  tool_calls?: QwenToolCall[]; // For assistant messages with tool calls
  tool_call_id?: string; // For tool response messages
  name?: string; // For tool response messages
}

export interface QwenResponse {
  text: string;
  tool_calls?: QwenToolCall[]; // Tool calls in the response
  usage?: {
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
  };
  cached?: boolean;
}

// Function calling interfaces
export interface QwenTool {
  type: 'function';
  function: {
    name: string;
    description: string;
    parameters: {
      type: 'object';
      properties: Record<string, {
        type: string;
        description: string;
        enum?: string[];
      }>;
      required: string[];
    };
  };
}

export interface QwenToolCall {
  id: string;
  type: 'function';
  function: {
    name: string;
    arguments: string; // JSON string of arguments
  };
}

export interface QwenToolResult {
  tool_call_id: string;
  role: 'tool';
  name: string;
  content: string; // Result of the tool call
}

export type StreamingResponseHandler = (chunk: string, done: boolean, toolCall?: QwenToolCall) => void;

export class QwenApiClient {
  private client: AxiosInstance;
  protected config: QwenCoderConfig;
  protected cache: ResponseCache;

  constructor(config: QwenCoderConfig) {
    this.config = config;
    this.client = axios.create({
      baseURL: config.apiEndpoint,
      headers: config.apiKey ? {
        'Authorization': `Bearer ${config.apiKey}`,
        'Content-Type': 'application/json'
      } : {
        'Content-Type': 'application/json'
      }
    });
    this.cache = ResponseCache.getInstance();
  }

  public updateConfig(config: QwenCoderConfig): void {
    this.config = config;
    this.client = axios.create({
      baseURL: config.apiEndpoint,
      headers: config.apiKey ? {
        'Authorization': `Bearer ${config.apiKey}`,
        'Content-Type': 'application/json'
      } : {
        'Content-Type': 'application/json'
      }
    });

    // Update cache configuration if provided
    if (config.cacheTTLMinutes && config.cacheMaxEntries) {
      this.cache.configure(config.cacheMaxEntries, config.cacheTTLMinutes);
    }
  }

  public async generateCompletion(options: QwenRequestOptions): Promise<QwenResponse> {
    // Check cache first (unless skipCache is true)
    if (!options.skipCache) {
      const cacheKey = generateCacheKey(options.prompt, {
        systemPrompt: options.systemPrompt,
        maxTokens: options.maxTokens || this.config.maxTokens,
        temperature: options.temperature || this.config.temperature
      });

      const cachedResponse = this.cache.get<QwenResponse>(cacheKey);
      if (cachedResponse) {
        console.log('Using cached response for prompt:', options.prompt.substring(0, 50) + '...');
        return {
          ...cachedResponse,
          cached: true
        };
      }
    }

    try {
      // Set timeout for the request
      const timeoutMs = 30000; // 30 seconds timeout
      const response = await this.client.post('/chat/completions', {
        model: 'qwen3-coder',
        messages: [
          ...(options.systemPrompt ? [{ role: 'system', content: options.systemPrompt }] : []),
          { role: 'user', content: options.prompt }
        ],
        max_tokens: options.maxTokens || this.config.maxTokens,
        temperature: options.temperature || this.config.temperature
      }, { timeout: timeoutMs });

      const result: QwenResponse = {
        text: response.data.choices[0].message.content,
        usage: response.data.usage
      };

      // Cache the response (unless skipCache is true)
      if (!options.skipCache) {
        const cacheKey = generateCacheKey(options.prompt, {
          systemPrompt: options.systemPrompt,
          maxTokens: options.maxTokens || this.config.maxTokens,
          temperature: options.temperature || this.config.temperature
        });

        this.cache.set(cacheKey, result);
      }

      return result;
    } catch (error) {
      // Use the error handler to process the error
      const errorDetails = ErrorHandler.processError(error);
      console.error(`Error calling Qwen API: ${errorDetails.type}`, error);

      // Throw a more informative error
      throw new Error(errorDetails.message);
    }
  }

  /**
   * Generate a streaming completion
   * @param options Request options
   * @param onChunk Callback function to handle streaming chunks
   */
  public async generateStreamingCompletion(
    options: QwenRequestOptions,
    onChunk: StreamingResponseHandler
  ): Promise<void> {
    // Streaming responses can't be cached, so we don't check the cache

    try {
      // Set timeout for the request
      const timeoutMs = 60000; // 60 seconds timeout for streaming

      const response = await this.client.post('/chat/completions', {
        model: 'qwen3-coder',
        messages: [
          ...(options.systemPrompt ? [{ role: 'system', content: options.systemPrompt }] : []),
          { role: 'user', content: options.prompt }
        ],
        max_tokens: options.maxTokens || this.config.maxTokens,
        temperature: options.temperature || this.config.temperature,
        stream: true
      }, {
        timeout: timeoutMs,
        responseType: 'stream'
      });

      // Process the streaming response
      const stream = response.data;

      stream.on('data', (chunk: Buffer) => {
        try {
          const lines = chunk.toString().split('\n').filter(line => line.trim() !== '');

          for (const line of lines) {
            // Skip empty lines and "data: [DONE]" messages
            if (!line || line === 'data: [DONE]') {continue;}

            // Remove the "data: " prefix
            const jsonStr = line.replace(/^data: /, '');

            try {
              const json = JSON.parse(jsonStr);
              if (json.choices && json.choices[0] && json.choices[0].delta && json.choices[0].delta.content) {
                const content = json.choices[0].delta.content;
                onChunk(content, false);
              }
            } catch (parseError) {
              console.error('Error parsing streaming response JSON:', parseError);
            }
          }
        } catch (error) {
          console.error('Error processing stream chunk:', error);
        }
      });

      stream.on('end', () => {
        onChunk('', true); // Signal that streaming is complete
      });

      stream.on('error', (error: Error) => {
        const errorDetails = ErrorHandler.processError(error);
        console.error(`Error in stream: ${errorDetails.type}`, error);
        throw new Error(errorDetails.message);
      });
    } catch (error) {
      // Use the error handler to process the error
      const errorDetails = ErrorHandler.processError(error);
      console.error(`Error setting up streaming: ${errorDetails.type}`, error);

      // Signal error to the handler
      onChunk(`Error: ${errorDetails.message}`, true);

      // Throw a more informative error
      throw new Error(errorDetails.message);
    }
  }

  /**
   * Chat with Qwen using messages
   * @param messages Array of messages
   * @param options Chat options
   * @returns Promise that resolves to the response text
   */
  public async chat(
    messages: QwenMessage[],
    options: QwenChatOptions = {}
  ): Promise<string> {
    // Check cache first (unless skipCache is true)
    if (!options.skipCache) {
      const cacheKey = generateCacheKey(JSON.stringify(messages), {
        enableThinking: options.enableThinking,
        temperature: options.temperature || this.config.temperature,
        maxTokens: options.maxTokens || this.config.maxTokens,
        modelName: options.modelName || 'qwen3-coder'
      });

      const cachedResponse = this.cache.get<QwenResponse>(cacheKey);
      if (cachedResponse) {
        console.log('Using cached response for chat');
        return cachedResponse.text;
      }
    }

    try {
      // Set timeout for the request
      const timeoutMs = 60000; // 60 seconds timeout for chat

      // Add thinking mode if enabled
      let systemMessage = messages.find(m => m.role === 'system');
      if (options.enableThinking && systemMessage) {
        systemMessage.content = `${systemMessage.content}\n\nWhen solving complex problems, use <think></think> tags to show your reasoning process.`;
      }

      const response = await this.client.post('/chat/completions', {
        model: options.modelName || 'qwen3-coder',
        messages,
        max_tokens: options.maxTokens || this.config.maxTokens,
        temperature: options.temperature || this.config.temperature
      }, { timeout: timeoutMs });

      const result: QwenResponse = {
        text: response.data.choices[0].message.content,
        usage: response.data.usage
      };

      // Cache the response (unless skipCache is true)
      if (!options.skipCache) {
        const cacheKey = generateCacheKey(JSON.stringify(messages), {
          enableThinking: options.enableThinking,
          temperature: options.temperature || this.config.temperature,
          maxTokens: options.maxTokens || this.config.maxTokens,
          modelName: options.modelName || 'qwen3-coder'
        });

        this.cache.set(cacheKey, result);
      }

      return result.text;
    } catch (error) {
      // Use the error handler to process the error
      const errorDetails = ErrorHandler.processError(error);
      console.error(`Error calling Qwen API chat: ${errorDetails.type}`, error);

      // Throw a more informative error
      throw new Error(errorDetails.message);
    }
  }

  /**
   * Chat with Qwen using messages with streaming response
   * @param messages Array of messages
   * @param options Chat options
   * @param onChunk Callback function to handle streaming chunks
   */
  public async chatStream(
    messages: QwenMessage[],
    options: QwenChatOptions = {},
    onChunk: StreamingResponseHandler
  ): Promise<void> {
    try {
      // Set timeout for the request
      const timeoutMs = 60000; // 60 seconds timeout for streaming

      // Add thinking mode if enabled
      let systemMessage = messages.find(m => m.role === 'system');
      if (options.enableThinking && systemMessage) {
        systemMessage.content = `${systemMessage.content}\n\nWhen solving complex problems, use <think></think> tags to show your reasoning process.`;
      }

      const response = await this.client.post('/chat/completions', {
        model: options.modelName || 'qwen3-coder',
        messages,
        max_tokens: options.maxTokens || this.config.maxTokens,
        temperature: options.temperature || this.config.temperature,
        stream: true
      }, {
        timeout: timeoutMs,
        responseType: 'stream'
      });

      // Process the streaming response
      const stream = response.data;

      stream.on('data', (chunk: Buffer) => {
        try {
          const lines = chunk.toString().split('\n').filter(line => line.trim() !== '');

          for (const line of lines) {
            // Skip empty lines and "data: [DONE]" messages
            if (!line || line === 'data: [DONE]') {continue;}

            // Remove the "data: " prefix
            const jsonStr = line.replace(/^data: /, '');

            try {
              const json = JSON.parse(jsonStr);
              if (json.choices && json.choices[0] && json.choices[0].delta && json.choices[0].delta.content) {
                const content = json.choices[0].delta.content;
                onChunk(content, false);
              }
            } catch (parseError) {
              console.error('Error parsing streaming response JSON:', parseError);
            }
          }
        } catch (error) {
          console.error('Error processing stream chunk:', error);
        }
      });

      stream.on('end', () => {
        onChunk('', true); // Signal that streaming is complete
      });

      stream.on('error', (error: Error) => {
        const errorDetails = ErrorHandler.processError(error);
        console.error(`Error in stream: ${errorDetails.type}`, error);
        throw new Error(errorDetails.message);
      });
    } catch (error) {
      // Use the error handler to process the error
      const errorDetails = ErrorHandler.processError(error);
      console.error(`Error setting up streaming chat: ${errorDetails.type}`, error);

      // Signal error to the handler
      onChunk(`Error: ${errorDetails.message}`, true);

      // Throw a more informative error
      throw new Error(errorDetails.message);
    }
  }

  /**
   * Chat with Qwen using messages and tools
   * @param messages Array of messages
   * @param options Chat options including tools
   * @returns Promise that resolves to the response with possible tool calls
   */
  public async chatWithTools(
    messages: QwenMessage[],
    options: QwenChatOptions = {}
  ): Promise<QwenResponse> {
    // Check cache first (unless skipCache is true)
    if (!options.skipCache) {
      const cacheKey = generateCacheKey(JSON.stringify(messages), {
        enableThinking: options.enableThinking,
        thinkingMode: options.thinkingMode,
        thinkingBudget: options.thinkingBudget,
        temperature: options.temperature || this.config.temperature,
        maxTokens: options.maxTokens || this.config.maxTokens,
        modelName: options.modelName || 'qwen3-coder',
        tools: options.tools ? JSON.stringify(options.tools) : undefined
      });

      const cachedResponse = this.cache.get<QwenResponse>(cacheKey);
      if (cachedResponse) {
        console.log('Using cached response for chat with tools');
        return cachedResponse;
      }
    }

    try {
      // Set timeout for the request
      const timeoutMs = 60000; // 60 seconds timeout for chat with tools

      // Apply thinking mode
      let systemMessage = messages.find(m => m.role === 'system');
      this._applyThinkingMode(systemMessage, options);

      // Prepare the request payload
      const payload: any = {
        model: options.modelName || 'qwen3-coder',
        messages,
        max_tokens: options.maxTokens || this.config.maxTokens,
        temperature: options.temperature || this.config.temperature
      };

      // Add tools if provided
      if (options.tools && options.tools.length > 0) {
        payload.tools = options.tools;
      }

      const response = await this.client.post('/chat/completions', payload, { timeout: timeoutMs });

      // Extract tool calls if present
      const toolCalls = response.data.choices[0].message.tool_calls || [];

      const result: QwenResponse = {
        text: response.data.choices[0].message.content,
        tool_calls: toolCalls.length > 0 ? toolCalls : undefined,
        usage: response.data.usage
      };

      // Cache the response (unless skipCache is true)
      if (!options.skipCache) {
        const cacheKey = generateCacheKey(JSON.stringify(messages), {
          enableThinking: options.enableThinking,
          thinkingMode: options.thinkingMode,
          thinkingBudget: options.thinkingBudget,
          temperature: options.temperature || this.config.temperature,
          maxTokens: options.maxTokens || this.config.maxTokens,
          modelName: options.modelName || 'qwen3-coder',
          tools: options.tools ? JSON.stringify(options.tools) : undefined
        });

        this.cache.set(cacheKey, result);
      }

      return result;
    } catch (error) {
      // Use the error handler to process the error
      const errorDetails = ErrorHandler.processError(error);
      console.error(`Error calling Qwen API chat with tools: ${errorDetails.type}`, error);

      // Throw a more informative error
      throw new Error(errorDetails.message);
    }
  }

  /**
   * Chat with Qwen using messages and tools with streaming response
   * @param messages Array of messages
   * @param options Chat options including tools
   * @param onChunk Callback function to handle streaming chunks
   */
  public async chatStreamWithTools(
    messages: QwenMessage[],
    options: QwenChatOptions = {},
    onChunk: StreamingResponseHandler
  ): Promise<void> {
    try {
      // Set timeout for the request
      const timeoutMs = 60000; // 60 seconds timeout for streaming

      // Apply thinking mode
      let systemMessage = messages.find(m => m.role === 'system');
      this._applyThinkingMode(systemMessage, options);

      // Prepare the request payload
      const payload: any = {
        model: options.modelName || 'qwen3-coder',
        messages,
        max_tokens: options.maxTokens || this.config.maxTokens,
        temperature: options.temperature || this.config.temperature,
        stream: true
      };

      // Add tools if provided
      if (options.tools && options.tools.length > 0) {
        payload.tools = options.tools;
      }

      const response = await this.client.post('/chat/completions', payload, {
        timeout: timeoutMs,
        responseType: 'stream'
      });

      // Process the streaming response
      const stream = response.data;
      let toolCalls: QwenToolCall[] = [];

      stream.on('data', (chunk: Buffer) => {
        try {
          const lines = chunk.toString().split('\n').filter(line => line.trim() !== '');

          for (const line of lines) {
            // Skip empty lines and "data: [DONE]" messages
            if (!line || line === 'data: [DONE]') {continue;}

            // Remove the "data: " prefix
            const jsonStr = line.replace(/^data: /, '');

            try {
              const json = JSON.parse(jsonStr);

              // Handle content
              if (json.choices && json.choices[0] && json.choices[0].delta && json.choices[0].delta.content) {
                const content = json.choices[0].delta.content;
                onChunk(content, false);
              }

              // Handle tool calls
              if (json.choices && json.choices[0] && json.choices[0].delta && json.choices[0].delta.tool_calls) {
                // Process tool calls
                for (const toolCallDelta of json.choices[0].delta.tool_calls) {
                  // Find existing tool call or create a new one
                  let toolCall = toolCalls.find(tc => tc.id === toolCallDelta.id);

                  if (!toolCall) {
                    // Create a new tool call
                    toolCall = {
                      id: toolCallDelta.id,
                      type: 'function',
                      function: {
                        name: toolCallDelta.function?.name || '',
                        arguments: toolCallDelta.function?.arguments || ''
                      }
                    };
                    toolCalls.push(toolCall);
                  } else {
                    // Update existing tool call
                    if (toolCallDelta.function?.name) {
                      toolCall.function.name = toolCallDelta.function.name;
                    }
                    if (toolCallDelta.function?.arguments) {
                      toolCall.function.arguments += toolCallDelta.function.arguments;
                    }
                  }

                  // Notify about the tool call
                  onChunk('', false, toolCall);
                }
              }
            } catch (parseError) {
              console.error('Error parsing streaming response JSON:', parseError);
            }
          }
        } catch (error) {
          console.error('Error processing stream chunk:', error);
        }
      });

      stream.on('end', () => {
        onChunk('', true); // Signal that streaming is complete
      });

      stream.on('error', (error: Error) => {
        const errorDetails = ErrorHandler.processError(error);
        console.error(`Error in stream: ${errorDetails.type}`, error);
        throw new Error(errorDetails.message);
      });
    } catch (error) {
      // Use the error handler to process the error
      const errorDetails = ErrorHandler.processError(error);
      console.error(`Error setting up streaming chat with tools: ${errorDetails.type}`, error);

      // Signal error to the handler
      onChunk(`Error: ${errorDetails.message}`, true);

      // Throw a more informative error
      throw new Error(errorDetails.message);
    }
  }

  /**
   * Apply thinking mode to the system message based on options
   * @param systemMessage The system message to modify
   * @param options Chat options
   */
  private _applyThinkingMode(systemMessage: QwenMessage | undefined, options: QwenChatOptions): void {
    if (!systemMessage) {
      return;
    }

    // Handle legacy enableThinking option
    if (options.enableThinking !== undefined) {
      if (options.enableThinking) {
        systemMessage.content = `${systemMessage.content}\n\nWhen solving complex problems, use <think></think> tags to show your reasoning process.`;
      }
      return;
    }

    // Handle new thinkingMode option
    if (options.thinkingMode) {
      switch (options.thinkingMode) {
        case 'always':
          systemMessage.content = `${systemMessage.content}\n\nAlways use <think></think> tags to show your reasoning process for all problems.`;
          break;
        case 'auto':
          systemMessage.content = `${systemMessage.content}\n\nWhen solving complex problems, use <think></think> tags to show your reasoning process. For simple tasks, respond directly.`;
          if (options.thinkingBudget) {
            systemMessage.content += `\n\nLimit your thinking to approximately ${options.thinkingBudget} tokens.`;
          }
          break;
        case 'never':
          // No thinking tags
          break;
      }
    }
  }

  /**
   * Clear the response cache
   */
  public clearCache(): void {
    this.cache.clear();
  }
}

```


---

### File: `src/cache.ts`

```typescript
/**
 * A simple cache implementation for storing API responses
 */
export class ResponseCache {
  private static instance: ResponseCache;
  private cache: Map<string, CacheEntry>;
  private maxEntries: number;
  private ttl: number; // Time to live in milliseconds

  private constructor(maxEntries: number = 100, ttlMinutes: number = 30) {
    this.cache = new Map();
    this.maxEntries = maxEntries;
    this.ttl = ttlMinutes * 60 * 1000;
  }

  /**
   * Get the singleton instance of the cache
   */
  public static getInstance(): ResponseCache {
    if (!ResponseCache.instance) {
      ResponseCache.instance = new ResponseCache();
    }
    return ResponseCache.instance;
  }

  /**
   * Set cache configuration
   * @param maxEntries Maximum number of entries to store
   * @param ttlMinutes Time to live in minutes
   */
  public configure(maxEntries: number, ttlMinutes: number): void {
    this.maxEntries = maxEntries;
    this.ttl = ttlMinutes * 60 * 1000;
    this.cleanup();
  }

  /**
   * Get a value from the cache
   * @param key Cache key
   * @returns The cached value or undefined if not found or expired
   */
  public get<T>(key: string): T | undefined {
    const entry = this.cache.get(key);
    
    if (!entry) {
      return undefined;
    }
    
    // Check if entry has expired
    if (Date.now() > entry.expiry) {
      this.cache.delete(key);
      return undefined;
    }
    
    // Update access time
    entry.lastAccessed = Date.now();
    
    return entry.value as T;
  }

  /**
   * Set a value in the cache
   * @param key Cache key
   * @param value Value to cache
   */
  public set<T>(key: string, value: T): void {
    // If cache is full, remove least recently used entry
    if (this.cache.size >= this.maxEntries) {
      this.removeLRU();
    }
    
    this.cache.set(key, {
      value,
      expiry: Date.now() + this.ttl,
      lastAccessed: Date.now()
    });
  }

  /**
   * Check if a key exists in the cache and is not expired
   * @param key Cache key
   * @returns True if the key exists and is not expired
   */
  public has(key: string): boolean {
    const entry = this.cache.get(key);
    
    if (!entry) {
      return false;
    }
    
    // Check if entry has expired
    if (Date.now() > entry.expiry) {
      this.cache.delete(key);
      return false;
    }
    
    return true;
  }

  /**
   * Remove a key from the cache
   * @param key Cache key
   */
  public delete(key: string): void {
    this.cache.delete(key);
  }

  /**
   * Clear the entire cache
   */
  public clear(): void {
    this.cache.clear();
  }

  /**
   * Get the number of entries in the cache
   */
  public size(): number {
    return this.cache.size;
  }

  /**
   * Remove expired entries from the cache
   */
  public cleanup(): void {
    const now = Date.now();
    for (const [key, entry] of this.cache.entries()) {
      if (now > entry.expiry) {
        this.cache.delete(key);
      }
    }
  }

  /**
   * Remove the least recently used entry from the cache
   */
  private removeLRU(): void {
    let oldest: string | null = null;
    let oldestTime = Date.now();
    
    for (const [key, entry] of this.cache.entries()) {
      if (entry.lastAccessed < oldestTime) {
        oldest = key;
        oldestTime = entry.lastAccessed;
      }
    }
    
    if (oldest) {
      this.cache.delete(oldest);
    }
  }
}

interface CacheEntry {
  value: unknown;
  expiry: number;
  lastAccessed: number;
}

/**
 * Generate a cache key from a request
 * @param prompt The prompt text
 * @param options Additional options that affect the response
 * @returns A string key for caching
 */
export function generateCacheKey(prompt: string, options: Record<string, any> = {}): string {
  // Create a stable representation of the options
  const optionsStr = Object.keys(options)
    .sort()
    .map(key => `${key}:${JSON.stringify(options[key])}`)
    .join('|');
  
  // Combine prompt and options into a single key
  return `${prompt}|${optionsStr}`;
}

```


---

### File: `src/webview/panel.ts`

```typescript
import * as vscode from 'vscode';
import { insertCodeIntoEditor } from '../responseFormatter';

export class QwenResponsePanel {
  public static currentPanel: QwenResponsePanel | undefined;
  private readonly _panel: vscode.WebviewPanel;
  private readonly _extensionUri: vscode.Uri;
  private _disposables: vscode.Disposable[] = [];

  public static createOrShow(extensionUri: vscode.Uri, title: string = 'Qwen Coder Response'): QwenResponsePanel {
    const column = vscode.window.activeTextEditor
      ? vscode.window.activeTextEditor.viewColumn
      : undefined;

    // If we already have a panel, show it
    if (QwenResponsePanel.currentPanel) {
      QwenResponsePanel.currentPanel._panel.reveal(column);
      QwenResponsePanel.currentPanel._panel.title = title;
      return QwenResponsePanel.currentPanel;
    }

    // Otherwise, create a new panel
    const panel = vscode.window.createWebviewPanel(
      'qwenResponse',
      title,
      column || vscode.ViewColumn.Beside,
      {
        enableScripts: true,
        localResourceRoots: [
          vscode.Uri.joinPath(extensionUri, 'media')
        ],
        retainContextWhenHidden: true
      }
    );

    QwenResponsePanel.currentPanel = new QwenResponsePanel(panel, extensionUri);
    return QwenResponsePanel.currentPanel;
  }

  private constructor(panel: vscode.WebviewPanel, extensionUri: vscode.Uri) {
    this._panel = panel;
    this._extensionUri = extensionUri;

    // Set the webview's initial html content
    this._update('');

    // Listen for when the panel is disposed
    // This happens when the user closes the panel or when the panel is closed programmatically
    this._panel.onDidDispose(() => this.dispose(), null, this._disposables);

    // Handle messages from the webview
    this._panel.webview.onDidReceiveMessage(
      message => {
        switch (message.command) {
          case 'copy':
            vscode.env.clipboard.writeText(message.text);
            vscode.window.showInformationMessage('Code copied to clipboard');
            break;
          case 'insert':
            insertCodeIntoEditor(message.text);
            vscode.window.showInformationMessage('Code inserted into editor');
            break;
        }
      },
      null,
      this._disposables
    );
  }

  public dispose(): void {
    QwenResponsePanel.currentPanel = undefined;

    // Clean up our resources
    this._panel.dispose();

    while (this._disposables.length) {
      const x = this._disposables.pop();
      if (x) {
        x.dispose();
      }
    }
  }

  public setContent(content: string): void {
    this._update(content);
  }

  /**
   * Append content to the existing content (for streaming)
   * @param chunk The content chunk to append
   * @param isComplete Whether this is the final chunk
   */
  public appendContent(chunk: string, isComplete: boolean): void {
    // Send a message to the webview to append content
    this._panel.webview.postMessage({
      command: 'append',
      text: chunk,
      isComplete
    });
  }

  private _update(content: string): void {
    const webview = this._panel.webview;

    // Get paths to resources
    const cssUri = webview.asWebviewUri(
      vscode.Uri.joinPath(this._extensionUri, 'media', 'styles.css')
    );
    const highlightJsUri = webview.asWebviewUri(
      vscode.Uri.joinPath(this._extensionUri, 'media', 'highlight.js')
    );

    // Create HTML content
    this._panel.webview.html = `
      <!DOCTYPE html>
      <html lang="en">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" href="${cssUri}">
        <title>Qwen Coder Response</title>
      </head>
      <body>
        <div id="response-container" class="response-container">
          ${this._formatMarkdown(content)}
        </div>
        <script src="${highlightJsUri}"></script>
        <script>
          const vscode = acquireVsCodeApi();
          let currentMarkdown = '';
          let isProcessingStream = false;
          const responseContainer = document.getElementById('response-container');

          // Listen for messages from the extension
          window.addEventListener('message', event => {
            const message = event.data;

            switch (message.command) {
              case 'append':
                // Handle streaming content
                currentMarkdown += message.text;
                responseContainer.innerHTML = formatMarkdown(currentMarkdown);

                // Apply syntax highlighting and add buttons to code blocks
                applyCodeFormatting();

                // If this is the final chunk, do any final processing
                if (message.isComplete) {
                  isProcessingStream = false;
                  // Final formatting pass
                  responseContainer.innerHTML = formatMarkdown(currentMarkdown);
                  applyCodeFormatting();
                }

                // Scroll to bottom to show new content
                window.scrollTo(0, document.body.scrollHeight);
                break;
            }
          });

          // Function to format markdown text to HTML
          function formatMarkdown(text) {
            if (!text) {
              return '<p>No response yet...</p>';
            }

            // Replace code blocks
            let html = text.replace(/\`\`\`(\w+)?\n([\s\S]*?)\`\`\`/g, (_, lang, code) => {
              return \`<pre><code class="language-\${lang || 'text'}">\${escapeHtml(code)}</code></pre>\`;
            });

            // Replace inline code
            html = html.replace(/\`([^\`]+)\`/g, '<code>$1</code>');

            // Replace headers
            html = html.replace(/^### (.*$)/gm, '<h3>$1</h3>');
            html = html.replace(/^## (.*$)/gm, '<h2>$1</h2>');
            html = html.replace(/^# (.*$)/gm, '<h1>$1</h1>');

            // Replace lists
            html = html.replace(/^\* (.*$)/gm, '<ul><li>$1</li></ul>');
            html = html.replace(/^- (.*$)/gm, '<ul><li>$1</li></ul>');
            html = html.replace(/^(\d+)\. (.*$)/gm, '<ol><li>$2</li></ol>');

            // Replace paragraphs
            html = html.replace(/^(?!<[hou]).+$/gm, '<p>$&</p>');

            // Fix nested lists
            html = html.replace(/<\/ul>\s*<ul>/g, '');
            html = html.replace(/<\/ol>\s*<ol>/g, '');

            return html;
          }

          // Function to escape HTML special characters
          function escapeHtml(text) {
            return text
              .replace(/&/g, '&amp;')
              .replace(/</g, '&lt;')
              .replace(/>/g, '&gt;')
              .replace(/"/g, '&quot;')
              .replace(/'/g, '&#039;');
          }

          // Function to apply syntax highlighting and add buttons to code blocks
          function applyCodeFormatting() {
            // Apply syntax highlighting to code blocks
            document.querySelectorAll('pre code').forEach((codeBlock) => {
              const language = codeBlock.className.replace('language-', '');
              if (language && language !== 'text') {
                const originalCode = codeBlock.textContent;
                try {
                  codeBlock.innerHTML = window.HighlightJS.highlight(originalCode, language);
                } catch (e) {
                  console.error('Error highlighting code:', e);
                }
              }
            });

            // Add copy and insert buttons to code blocks that don't already have them
            document.querySelectorAll('pre:not(.processed)').forEach((pre) => {
              pre.classList.add('processed');

              const container = document.createElement('div');
              container.className = 'code-block-container';
              pre.parentNode.insertBefore(container, pre);
              container.appendChild(pre);

              const copyButton = document.createElement('button');
              copyButton.className = 'copy-button';
              copyButton.textContent = 'Copy';
              copyButton.addEventListener('click', () => {
                const code = pre.textContent;
                vscode.postMessage({
                  command: 'copy',
                  text: code
                });
                copyButton.textContent = 'Copied!';
                setTimeout(() => {
                  copyButton.textContent = 'Copy';
                }, 2000);
              });

              const insertButton = document.createElement('button');
              insertButton.className = 'insert-button';
              insertButton.textContent = 'Insert';
              insertButton.addEventListener('click', () => {
                const code = pre.textContent;
                vscode.postMessage({
                  command: 'insert',
                  text: code
                });
              });

              container.appendChild(copyButton);
              container.appendChild(insertButton);
            });
          }

          // Initial formatting for any content that's already there
          applyCodeFormatting();
        </script>
      </body>
      </html>
    `;
  }

  private _formatMarkdown(text: string): string {
    if (!text) {
      return '<p>No response yet...</p>';
    }

    // Replace code blocks
    let html = text.replace(/```(\w+)?\n([\s\S]*?)```/g, (_, lang, code) => {
      return `<pre><code class="language-${lang || 'text'}">${this._escapeHtml(code)}</code></pre>`;
    });

    // Replace inline code
    html = html.replace(/`([^`]+)`/g, '<code>$1</code>');

    // Replace headers
    html = html.replace(/^### (.*$)/gm, '<h3>$1</h3>');
    html = html.replace(/^## (.*$)/gm, '<h2>$1</h2>');
    html = html.replace(/^# (.*$)/gm, '<h1>$1</h1>');

    // Replace lists
    html = html.replace(/^\* (.*$)/gm, '<ul><li>$1</li></ul>');
    html = html.replace(/^- (.*$)/gm, '<ul><li>$1</li></ul>');
    html = html.replace(/^(\d+)\. (.*$)/gm, '<ol><li>$2</li></ol>');

    // Replace paragraphs
    html = html.replace(/^(?!<[hou]).+$/gm, '<p>$&</p>');

    // Fix nested lists
    html = html.replace(/<\/ul>\s*<ul>/g, '');
    html = html.replace(/<\/ol>\s*<ol>/g, '');

    return html;
  }

  private _escapeHtml(text: string): string {
    return text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#039;');
  }
}

```


---

### File: `src/containers/containerManager.ts`

```typescript
/**
 * Container Manager
 * 
 * Handles the lifecycle of containerized MCP tools.
 */

import * as vscode from 'vscode';
import * as path from 'path';
import { getConfiguration } from '../configuration';

/**
 * Container information
 */
interface ContainerInfo {
  id: string;
  name: string;
  image: string;
  url: string;
  status: 'running' | 'stopped' | 'error';
  startTime: number;
  error?: string;
}

/**
 * Container configuration
 */
interface ContainerConfig {
  image: string;
  command: string;
  args: string[];
  env?: Record<string, string>;
  ports?: { internal: number, external: number }[];
}

/**
 * Container Manager class
 */
export class ContainerManager {
  private outputChannel: vscode.OutputChannel;
  private containerRegistry: Record<string, ContainerConfig>;
  private activeContainers: Record<string, ContainerInfo>;
  private statusBarItem: vscode.StatusBarItem;
  private healthCheckInterval: NodeJS.Timeout | null;

  /**
   * Constructor
   */
  constructor() {
    this.outputChannel = vscode.window.createOutputChannel('Container Manager');
    this.statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left);
    this.statusBarItem.text = '$(docker) MCP Tools';
    this.statusBarItem.tooltip = 'MCP Tools Status';
    this.statusBarItem.command = 'qwenCoder.showContainerStatus';
    
    this.containerRegistry = {
      'github': {
        image: 'qwen-mcp-github:latest',
        command: 'uvx',
        args: ['mcp-server-github'],
        ports: [{ internal: 8080, external: 0 }]
      },
      'docker': {
        image: 'qwen-mcp-docker:latest',
        command: 'uvx',
        args: ['mcp-server-docker'],
        ports: [{ internal: 8080, external: 0 }]
      },
      'testing': {
        image: 'qwen-mcp-testing:latest',
        command: 'uvx',
        args: ['mcp-server-testing'],
        ports: [{ internal: 8080, external: 0 }]
      },
      'ci_cd': {
        image: 'qwen-mcp-cicd:latest',
        command: 'uvx',
        args: ['mcp-server-cicd'],
        ports: [{ internal: 8080, external: 0 }]
      }
    };
    
    this.activeContainers = {};
    this.healthCheckInterval = null;
    
    this.outputChannel.appendLine('Container Manager initialized');
  }

  /**
   * Initialize the container manager
   */
  public async initialize(): Promise<void> {
    try {
      this.statusBarItem.show();
      
      // Check if Docker is available
      const dockerAvailable = await this._checkDockerAvailability();
      
      if (!dockerAvailable) {
        this.outputChannel.appendLine('Docker is not available. Container features will be disabled.');
        this.statusBarItem.text = '$(alert) Docker Not Available';
        this.statusBarItem.tooltip = 'Docker is not available. Container features are disabled.';
        return;
      }
      
      // Start health check interval
      this._startHealthCheck();
      
      // Auto-start containers if configured
      const config = getConfiguration();
      const autoStartContainers = config.get<boolean>('autoStartContainers', false);
      
      if (autoStartContainers) {
        this.outputChannel.appendLine('Auto-starting containers...');
        
        const containersToStart = config.get<string[]>('autoStartContainerList', ['github', 'docker']);
        
        for (const containerName of containersToStart) {
          try {
            await this.startContainer(containerName);
          } catch (error) {
            this.outputChannel.appendLine(`Error auto-starting container ${containerName}: ${error.message}`);
          }
        }
      }
    } catch (error) {
      this.outputChannel.appendLine(`Error initializing Container Manager: ${error.message}`);
      this.statusBarItem.text = '$(error) MCP Tools Error';
      this.statusBarItem.tooltip = `Error: ${error.message}`;
    }
  }

  /**
   * Start a containerized MCP tool
   * @param containerName The name of the container to start
   * @returns The URL for accessing the container
   */
  public async startContainer(containerName: string): Promise<string> {
    try {
      this.outputChannel.appendLine(`Starting container: ${containerName}`);
      
      // Check if container is already running
      if (this.activeContainers[containerName] && this.activeContainers[containerName].status === 'running') {
        this.outputChannel.appendLine(`Container ${containerName} is already running`);
        return this.activeContainers[containerName].url;
      }
      
      // Get container configuration
      const containerConfig = this.containerRegistry[containerName];
      if (!containerConfig) {
        throw new Error(`Unknown container: ${containerName}`);
      }
      
      // Check if Docker is available
      const dockerAvailable = await this._checkDockerAvailability();
      if (!dockerAvailable) {
        throw new Error('Docker is not available');
      }
      
      // Pull the image if needed
      await this._ensureImageAvailable(containerConfig.image);
      
      // Start the container
      const containerId = await this._startContainer(containerName, containerConfig);
      
      // Get container URL
      const url = await this._getContainerUrl(containerId, containerConfig);
      
      // Update active containers
      this.activeContainers[containerName] = {
        id: containerId,
        name: containerName,
        image: containerConfig.image,
        url,
        status: 'running',
        startTime: Date.now()
      };
      
      // Update status bar
      this._updateStatusBar();
      
      this.outputChannel.appendLine(`Container ${containerName} started successfully with URL: ${url}`);
      
      return url;
    } catch (error) {
      this.outputChannel.appendLine(`Error starting container ${containerName}: ${error.message}`);
      
      // Update active containers with error status
      this.activeContainers[containerName] = {
        id: '',
        name: containerName,
        image: this.containerRegistry[containerName]?.image || '',
        url: '',
        status: 'error',
        startTime: Date.now(),
        error: error.message
      };
      
      // Update status bar
      this._updateStatusBar();
      
      throw error;
    }
  }

  /**
   * Stop a containerized MCP tool
   * @param containerName The name of the container to stop
   */
  public async stopContainer(containerName: string): Promise<void> {
    try {
      this.outputChannel.appendLine(`Stopping container: ${containerName}`);
      
      // Check if container is running
      if (!this.activeContainers[containerName] || this.activeContainers[containerName].status !== 'running') {
        this.outputChannel.appendLine(`Container ${containerName} is not running`);
        return;
      }
      
      const containerId = this.activeContainers[containerName].id;
      
      // Stop and remove the container
      await this._stopContainer(containerId);
      
      // Update active containers
      this.activeContainers[containerName] = {
        ...this.activeContainers[containerName],
        status: 'stopped'
      };
      
      // Update status bar
      this._updateStatusBar();
      
      this.outputChannel.appendLine(`Container ${containerName} stopped successfully`);
    } catch (error) {
      this.outputChannel.appendLine(`Error stopping container ${containerName}: ${error.message}`);
      throw error;
    }
  }

  /**
   * Get the URL for a running container
   * @param containerName The name of the container
   * @returns The URL for accessing the container
   */
  public getContainerUrl(containerName: string): string {
    if (!this.activeContainers[containerName] || this.activeContainers[containerName].status !== 'running') {
      throw new Error(`Container ${containerName} is not running`);
    }
    
    return this.activeContainers[containerName].url;
  }

  /**
   * Get the status of all containers
   * @returns The status of all containers
   */
  public getContainerStatus(): Record<string, ContainerInfo> {
    return { ...this.activeContainers };
  }

  /**
   * Check if Docker is available
   * @returns Whether Docker is available
   */
  private async _checkDockerAvailability(): Promise<boolean> {
    try {
      // This is a placeholder for Docker availability check
      // In a real implementation, we would use the Docker SDK to check if Docker is running
      
      // For now, we'll assume Docker is available
      return true;
    } catch (error) {
      this.outputChannel.appendLine(`Error checking Docker availability: ${error.message}`);
      return false;
    }
  }

  /**
   * Ensure the Docker image is available
   * @param imageName The name of the image
   */
  private async _ensureImageAvailable(imageName: string): Promise<void> {
    try {
      this.outputChannel.appendLine(`Ensuring image is available: ${imageName}`);
      
      // This is a placeholder for image availability check
      // In a real implementation, we would use the Docker SDK to check if the image exists locally
      // and pull it if it doesn't
      
      // For now, we'll assume the image is available
    } catch (error) {
      this.outputChannel.appendLine(`Error ensuring image availability: ${error.message}`);
      throw error;
    }
  }

  /**
   * Start a container
   * @param containerName The name of the container
   * @param config The container configuration
   * @returns The container ID
   */
  private async _startContainer(containerName: string, config: ContainerConfig): Promise<string> {
    try {
      this.outputChannel.appendLine(`Starting container with image: ${config.image}`);
      
      // This is a placeholder for container start
      // In a real implementation, we would use the Docker SDK to start the container
      
      // For now, we'll return a fake container ID
      return `fake-container-id-${containerName}-${Date.now()}`;
    } catch (error) {
      this.outputChannel.appendLine(`Error starting container: ${error.message}`);
      throw error;
    }
  }

  /**
   * Stop a container
   * @param containerId The ID of the container
   */
  private async _stopContainer(containerId: string): Promise<void> {
    try {
      this.outputChannel.appendLine(`Stopping container: ${containerId}`);
      
      // This is a placeholder for container stop
      // In a real implementation, we would use the Docker SDK to stop and remove the container
    } catch (error) {
      this.outputChannel.appendLine(`Error stopping container: ${error.message}`);
      throw error;
    }
  }

  /**
   * Get the URL for a container
   * @param containerId The ID of the container
   * @param config The container configuration
   * @returns The URL for accessing the container
   */
  private async _getContainerUrl(containerId: string, config: ContainerConfig): Promise<string> {
    try {
      // This is a placeholder for getting the container URL
      // In a real implementation, we would use the Docker SDK to get the port mapping
      
      // For now, we'll return a fake URL
      return `http://localhost:${8080 + Math.floor(Math.random() * 1000)}`;
    } catch (error) {
      this.outputChannel.appendLine(`Error getting container URL: ${error.message}`);
      throw error;
    }
  }

  /**
   * Start health check interval
   */
  private _startHealthCheck(): void {
    if (this.healthCheckInterval) {
      clearInterval(this.healthCheckInterval);
    }
    
    this.healthCheckInterval = setInterval(async () => {
      try {
        for (const containerName in this.activeContainers) {
          const container = this.activeContainers[containerName];
          
          if (container.status === 'running') {
            // Check container health
            const isHealthy = await this._checkContainerHealth(container);
            
            if (!isHealthy) {
              this.outputChannel.appendLine(`Container ${containerName} is not healthy, attempting to restart`);
              
              // Attempt to restart the container
              try {
                await this.stopContainer(containerName);
                await this.startContainer(containerName);
                
                this.outputChannel.appendLine(`Container ${containerName} restarted successfully`);
              } catch (error) {
                this.outputChannel.appendLine(`Error restarting container ${containerName}: ${error.message}`);
              }
            }
          }
        }
        
        // Update status bar
        this._updateStatusBar();
      } catch (error) {
        this.outputChannel.appendLine(`Error in health check: ${error.message}`);
      }
    }, 60000); // Check every minute
  }

  /**
   * Check container health
   * @param container The container to check
   * @returns Whether the container is healthy
   */
  private async _checkContainerHealth(container: ContainerInfo): Promise<boolean> {
    try {
      // This is a placeholder for container health check
      // In a real implementation, we would use the Docker SDK to check the container health
      
      // For now, we'll assume the container is healthy
      return true;
    } catch (error) {
      this.outputChannel.appendLine(`Error checking container health: ${error.message}`);
      return false;
    }
  }

  /**
   * Update status bar
   */
  private _updateStatusBar(): void {
    const runningContainers = Object.values(this.activeContainers).filter(c => c.status === 'running').length;
    const totalContainers = Object.keys(this.activeContainers).length;
    
    if (runningContainers === 0) {
      this.statusBarItem.text = '$(docker) MCP Tools: None Running';
    } else {
      this.statusBarItem.text = `$(docker) MCP Tools: ${runningContainers}/${totalContainers} Running`;
    }
    
    // Update tooltip with container details
    let tooltip = 'MCP Tools Status:\n\n';
    
    for (const containerName in this.activeContainers) {
      const container = this.activeContainers[containerName];
      tooltip += `${containerName}: ${container.status}`;
      
      if (container.status === 'running') {
        tooltip += ` (${container.url})`;
      } else if (container.status === 'error') {
        tooltip += ` (${container.error})`;
      }
      
      tooltip += '\n';
    }
    
    this.statusBarItem.tooltip = tooltip;
  }

  /**
   * Stop all containers
   */
  public async stopAllContainers(): Promise<void> {
    try {
      this.outputChannel.appendLine('Stopping all containers');
      
      for (const containerName in this.activeContainers) {
        if (this.activeContainers[containerName].status === 'running') {
          try {
            await this.stopContainer(containerName);
          } catch (error) {
            this.outputChannel.appendLine(`Error stopping container ${containerName}: ${error.message}`);
          }
        }
      }
      
      this.outputChannel.appendLine('All containers stopped');
    } catch (error) {
      this.outputChannel.appendLine(`Error stopping all containers: ${error.message}`);
      throw error;
    }
  }

  /**
   * Dispose of resources
   */
  public dispose(): void {
    if (this.healthCheckInterval) {
      clearInterval(this.healthCheckInterval);
      this.healthCheckInterval = null;
    }
    
    this.stopAllContainers().catch(error => {
      this.outputChannel.appendLine(`Error stopping containers during disposal: ${error.message}`);
    });
    
    this.statusBarItem.dispose();
    this.outputChannel.dispose();
  }
}

```


---

### File: `src/ui/mcpServerConfigView.ts`

```typescript
import * as vscode from 'vscode';
import { McpServer, McpServerStatus } from '../mcp-client/types';
import { McpServerManager } from '../mcp-client/mcpServerManager';
import { OfficialMcpServersManager } from '../mcp-client/officialMcpServers';
import { ServerHealthMonitor } from '../mcp-client/serverHealthMonitor';

/**
 * WebView panel for configuring MCP servers
 */
export class McpServerConfigView {
  public static readonly viewType = 'qwenMcpServerConfig';
  private readonly _panel: vscode.WebviewPanel;
  private readonly _extensionUri: vscode.Uri;
  private readonly _serverManager: McpServerManager;
  private readonly _officialServersManager: OfficialMcpServersManager;
  private readonly _healthMonitor: ServerHealthMonitor;
  private _disposables: vscode.Disposable[] = [];
  private _currentServer: McpServer | undefined;

  /**
   * Create a new MCP server configuration view
   * @param extensionUri Extension URI
   * @param serverManager MCP server manager
   * @param officialServersManager Official MCP servers manager
   * @param healthMonitor Server health monitor
   * @param serverId Optional server ID to configure
   */
  private constructor(
    extensionUri: vscode.Uri,
    serverManager: McpServerManager,
    officialServersManager: OfficialMcpServersManager,
    healthMonitor: ServerHealthMonitor,
    serverId?: string
  ) {
    this._extensionUri = extensionUri;
    this._serverManager = serverManager;
    this._officialServersManager = officialServersManager;
    this._healthMonitor = healthMonitor;

    // Create the webview panel
    this._panel = vscode.window.createWebviewPanel(
      McpServerConfigView.viewType,
      'MCP Server Configuration',
      vscode.ViewColumn.One,
      {
        enableScripts: true,
        localResourceRoots: [vscode.Uri.joinPath(extensionUri, 'media')]
      }
    );

    // Set the webview's initial html content
    this._panel.webview.html = this._getHtmlForWebview(this._panel.webview);

    // Set the current server if provided
    if (serverId) {
      this._currentServer = this._serverManager.getServer(serverId);
    }

    // Update the webview content
    this._updateWebview();

    // Listen for when the panel is disposed
    // This happens when the user closes the panel or when the panel is closed programmatically
    this._panel.onDidDispose(() => this.dispose(), null, this._disposables);

    // Handle messages from the webview
    this._panel.webview.onDidReceiveMessage(
      message => {
        switch (message.command) {
          case 'saveConfig':
            this._saveServerConfig(message.serverId, message.config);
            return;
          case 'startServer':
            this._startServer(message.serverId);
            return;
          case 'stopServer':
            this._stopServer(message.serverId);
            return;
          case 'restartServer':
            this._restartServer(message.serverId);
            return;
          case 'checkHealth':
            this._checkServerHealth(message.serverId);
            return;
          case 'viewLogs':
            this._viewServerLogs(message.serverId);
            return;
          case 'addOfficialServer':
            this._addOfficialServer(message.serverType);
            return;
        }
      },
      null,
      this._disposables
    );

    // Listen for server changes
    this._serverManager.onDidChangeServers(() => {
      // Update the current server if it's still valid
      if (this._currentServer) {
        this._currentServer = this._serverManager.getServer(this._currentServer.id);
      }
      this._updateWebview();
    }, null, this._disposables);

    // Listen for health updates
    this._healthMonitor.onDidUpdateHealth(serverId => {
      if (this._currentServer && this._currentServer.id === serverId) {
        this._updateWebview();
      }
    }, null, this._disposables);
  }

  /**
   * Create and show a new MCP server configuration view
   * @param extensionUri Extension URI
   * @param serverManager MCP server manager
   * @param officialServersManager Official MCP servers manager
   * @param healthMonitor Server health monitor
   * @param serverId Optional server ID to configure
   * @returns The created view
   */
  public static createOrShow(
    extensionUri: vscode.Uri,
    serverManager: McpServerManager,
    officialServersManager: OfficialMcpServersManager,
    healthMonitor: ServerHealthMonitor,
    serverId?: string
  ): McpServerConfigView {
    return new McpServerConfigView(
      extensionUri,
      serverManager,
      officialServersManager,
      healthMonitor,
      serverId
    );
  }

  /**
   * Get the HTML for the webview
   * @param webview Webview
   * @returns HTML string
   */
  private _getHtmlForWebview(webview: vscode.Webview): string {
    // Local path to script and css for the webview
    const scriptUri = webview.asWebviewUri(
      vscode.Uri.joinPath(this._extensionUri, 'media', 'mcpServerConfig.js')
    );
    const styleUri = webview.asWebviewUri(
      vscode.Uri.joinPath(this._extensionUri, 'media', 'mcpServerConfig.css')
    );

    // Use a nonce to only allow specific scripts to be run
    const nonce = getNonce();

    return `<!DOCTYPE html>
    <html lang="en">
    <head>
      <meta charset="UTF-8">
      <meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src ${webview.cspSource}; script-src 'nonce-${nonce}';">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <link href="${styleUri}" rel="stylesheet">
      <title>MCP Server Configuration</title>
    </head>
    <body>
      <div id="app">
        <h1>MCP Server Configuration</h1>
        <div id="server-selector"></div>
        <div id="server-config"></div>
        <div id="official-servers">
          <h2>Add Official MCP Servers</h2>
          <div class="button-container">
            <button id="add-github">Add GitHub MCP Server</button>
            <button id="add-docker">Add Docker MCP Server</button>
            <button id="add-git">Add Git MCP Server</button>
            <button id="add-memory">Add Memory MCP Server</button>
            <button id="add-filesystem">Add Filesystem MCP Server</button>
            <button id="add-all">Add All Official Servers</button>
          </div>
        </div>
      </div>
      <script nonce="${nonce}" src="${scriptUri}"></script>
    </body>
    </html>`;
  }

  /**
   * Update the webview content
   */
  private _updateWebview(): void {
    if (!this._panel.visible) {
      return;
    }

    // Get all servers
    const servers = this._serverManager.getServers();

    // Send the servers to the webview
    this._panel.webview.postMessage({
      command: 'updateServers',
      servers,
      currentServerId: this._currentServer?.id
    });
  }

  /**
   * Save server configuration
   * @param serverId Server ID
   * @param config Server configuration
   */
  private async _saveServerConfig(serverId: string, config: any): Promise<void> {
    try {
      const server = this._serverManager.getServer(serverId);
      if (!server) {
        throw new Error(`Server ${serverId} not found`);
      }

      // Update server properties
      server.name = config.name || server.name;
      server.description = config.description || server.description;
      server.autoStart = config.autoStart !== undefined ? config.autoStart : server.autoStart;

      // Save the servers
      this._serverManager.saveServers();

      // Show a success message
      vscode.window.showInformationMessage(`Server ${server.name} configuration saved`);

      // Update the webview
      this._updateWebview();
    } catch (error) {
      vscode.window.showErrorMessage(`Error saving server configuration: ${error}`);
    }
  }

  /**
   * Start a server
   * @param serverId Server ID
   */
  private async _startServer(serverId: string): Promise<void> {
    try {
      await this._serverManager.startServer(serverId);
      vscode.window.showInformationMessage(`Server ${serverId} started`);
    } catch (error) {
      vscode.window.showErrorMessage(`Error starting server: ${error}`);
    }
  }

  /**
   * Stop a server
   * @param serverId Server ID
   */
  private async _stopServer(serverId: string): Promise<void> {
    try {
      await this._serverManager.stopServer(serverId);
      vscode.window.showInformationMessage(`Server ${serverId} stopped`);
    } catch (error) {
      vscode.window.showErrorMessage(`Error stopping server: ${error}`);
    }
  }

  /**
   * Restart a server
   * @param serverId Server ID
   */
  private async _restartServer(serverId: string): Promise<void> {
    try {
      await this._serverManager.restartServer(serverId);
      vscode.window.showInformationMessage(`Server ${serverId} restarted`);
    } catch (error) {
      vscode.window.showErrorMessage(`Error restarting server: ${error}`);
    }
  }

  /**
   * Check server health
   * @param serverId Server ID
   */
  private async _checkServerHealth(serverId: string): Promise<void> {
    try {
      await this._healthMonitor.checkServerHealth(serverId);
      const server = this._serverManager.getServer(serverId);
      if (server) {
        vscode.window.showInformationMessage(`Server ${serverId} health: ${server.healthStatus || 'unknown'}`);
      }
    } catch (error) {
      vscode.window.showErrorMessage(`Error checking server health: ${error}`);
    }
  }

  /**
   * View server logs
   * @param serverId Server ID
   */
  private _viewServerLogs(serverId: string): void {
    try {
      const server = this._serverManager.getServer(serverId);
      if (!server) {
        throw new Error(`Server ${serverId} not found`);
      }

      // Create a new untitled document with the logs
      vscode.workspace.openTextDocument({
        content: server.logs.join('\n'),
        language: 'log'
      }).then(doc => {
        vscode.window.showTextDocument(doc);
      });
    } catch (error) {
      vscode.window.showErrorMessage(`Error viewing server logs: ${error}`);
    }
  }

  /**
   * Add an official MCP server
   * @param serverType Server type
   */
  private async _addOfficialServer(serverType: string): Promise<void> {
    try {
      let serverId: string;

      switch (serverType.toUpperCase()) {
        case 'GITHUB':
          serverId = await this._officialServersManager.addGitHubServer();
          break;
        case 'DOCKER':
          serverId = await this._officialServersManager.addDockerServer();
          break;
        case 'GIT':
          serverId = await this._officialServersManager.addGitServer();
          break;
        case 'MEMORY':
          serverId = await this._officialServersManager.addMemoryServer();
          break;
        case 'FILESYSTEM':
          serverId = await this._officialServersManager.addFilesystemServer();
          break;
        case 'ALL':
          const serverIds = await this._officialServersManager.addAllOfficialServers();
          vscode.window.showInformationMessage(`Added ${serverIds.length} official MCP servers`);
          return;
        default:
          throw new Error(`Unknown server type: ${serverType}`);
      }

      // Set the current server to the newly added server
      this._currentServer = this._serverManager.getServer(serverId);

      // Show a success message
      vscode.window.showInformationMessage(`Added ${serverType} MCP server`);

      // Update the webview
      this._updateWebview();
    } catch (error) {
      vscode.window.showErrorMessage(`Error adding ${serverType} MCP server: ${error}`);
    }
  }

  /**
   * Dispose of the view
   */
  public dispose(): void {
    // Clean up resources
    this._panel.dispose();

    // Dispose of all disposables
    while (this._disposables.length) {
      const disposable = this._disposables.pop();
      if (disposable) {
        disposable.dispose();
      }
    }
  }
}

/**
 * Get a nonce string
 * @returns Random nonce string
 */
function getNonce(): string {
  let text = '';
  const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  for (let i = 0; i < 32; i++) {
    text += possible.charAt(Math.floor(Math.random() * possible.length));
  }
  return text;
}

```


---

### File: `src/ui/mcpServerTreeDataProvider.ts`

```typescript
import * as vscode from 'vscode';
import { McpServerManager } from '../mcp-client/mcpServerManager';
import { ServerHealthMonitor } from '../mcp-client/serverHealthMonitor';
import { McpServer, McpServerStatus } from '../mcp-client/types';

/**
 * Tree data provider for MCP servers
 */
export class McpServerTreeDataProvider implements vscode.TreeDataProvider<McpServerTreeItem> {
  private _onDidChangeTreeData = new vscode.EventEmitter<McpServerTreeItem | undefined>();

  /**
   * Event that fires when the tree data changes
   */
  public readonly onDidChangeTreeData = this._onDidChangeTreeData.event;

  /**
   * Create a new MCP server tree data provider
   * @param serverManager MCP server manager
   * @param healthMonitor Server health monitor
   */
  constructor(
    private serverManager: McpServerManager,
    private healthMonitor?: ServerHealthMonitor
  ) {
    // Listen for server changes
    serverManager.onDidChangeServers(() => {
      this._onDidChangeTreeData.fire(undefined);
    });

    // Listen for health updates if health monitor is provided
    if (healthMonitor) {
      healthMonitor.onDidUpdateHealth(() => {
        this._onDidChangeTreeData.fire(undefined);
      });
    }
  }

  /**
   * Get the tree item for an element
   * @param element Tree item
   * @returns Tree item
   */
  public getTreeItem(element: McpServerTreeItem): vscode.TreeItem {
    return element;
  }

  /**
   * Get the children of an element
   * @param element Parent element
   * @returns Children of the element
   */
  public getChildren(element?: McpServerTreeItem): Thenable<McpServerTreeItem[]> {
    if (!element) {
      // Root level - show all servers
      const servers = this.serverManager.getServers();
      return Promise.resolve(servers.map(server => new McpServerTreeItem(server)));
    }

    // No children for server items
    return Promise.resolve([]);
  }

  /**
   * Refresh the tree
   */
  public refresh(): void {
    this._onDidChangeTreeData.fire(undefined);
  }
}

/**
 * Tree item for an MCP server
 */
export class McpServerTreeItem extends vscode.TreeItem {
  /**
   * Create a new MCP server tree item
   * @param server MCP server
   */
  constructor(public readonly server: McpServer) {
    super(server.name, vscode.TreeItemCollapsibleState.None);

    // Set the context value for context menu filtering
    this.contextValue = `mcpServer-${server.status}${server.healthStatus ? `-${server.healthStatus}` : ''}`;

    // Set the description
    this.description = server.healthStatus
      ? `${server.status} (${server.healthStatus})`
      : server.status;

    // Set the tooltip
    let tooltip = `${server.name} (${server.status})
${server.description}
Repository: ${server.repoUrl}
Version: ${server.version}`;

    // Add health information if available
    if (server.healthStatus) {
      tooltip += `
Health: ${server.healthStatus}`;

      if (server.lastHealthCheck) {
        tooltip += `
Last health check: ${server.lastHealthCheck.toLocaleString()}`;
      }
    }

    // Add endpoint information if available
    if (server.endpoint) {
      tooltip += `
Endpoint: ${server.endpoint}`;
    }

    this.tooltip = tooltip;

    // Set the icon
    this.iconPath = this.getIconPath(server.status, server.healthStatus);
  }

  /**
   * Get the icon path for a server status
   * @param status Server status
   * @param healthStatus Server health status
   * @returns Icon path
   */
  private getIconPath(status: McpServerStatus, healthStatus?: string): vscode.ThemeIcon {
    // If the server is running and unhealthy, show a warning icon
    if (status === McpServerStatus.Running && healthStatus === 'unhealthy') {
      return new vscode.ThemeIcon('warning');
    }

    // Otherwise, show an icon based on the server status
    switch (status) {
      case McpServerStatus.Running:
        return new vscode.ThemeIcon('play');
      case McpServerStatus.Stopped:
        return new vscode.ThemeIcon('stop');
      case McpServerStatus.Starting:
        return new vscode.ThemeIcon('sync');
      case McpServerStatus.Stopping:
        return new vscode.ThemeIcon('sync');
      case McpServerStatus.Error:
        return new vscode.ThemeIcon('error');
      default:
        return new vscode.ThemeIcon('question');
    }
  }
}

```


---

### File: `src/ui/serverDiscoveryView.ts`

```typescript
import * as vscode from 'vscode';
import { ServerDiscovery, ServerDiscoveryResult } from '../mcp-client/discovery/serverDiscovery';
import { McpServerManager } from '../mcp-client/mcpServerManager';

/**
 * Server discovery view for MCP servers
 */
export class ServerDiscoveryView {
  private panel: vscode.WebviewPanel | undefined;
  private discovery: ServerDiscovery;
  private serverManager: McpServerManager;
  private disposables: vscode.Disposable[] = [];
  private searchResults: ServerDiscoveryResult[] = [];

  /**
   * Create a new server discovery view
   * @param discovery Server discovery
   * @param serverManager MCP server manager
   */
  constructor(discovery: ServerDiscovery, serverManager: McpServerManager) {
    this.discovery = discovery;
    this.serverManager = serverManager;

    // Listen for server discovery events
    this.disposables.push(
      this.discovery.onDidDiscoverServers(results => {
        this.searchResults = results;
        this.updateWebviewContent();
      })
    );

    // Listen for server manager events
    this.disposables.push(
      this.serverManager.onDidChangeServers(() => {
        this.updateWebviewContent();
      })
    );
  }

  /**
   * Create or show the server discovery view
   * @param extensionUri Extension URI
   */
  public static createOrShow(
    extensionUri: vscode.Uri,
    discovery: ServerDiscovery,
    serverManager: McpServerManager
  ): ServerDiscoveryView {
    const view = new ServerDiscoveryView(discovery, serverManager);
    view.createOrShowPanel(extensionUri);
    return view;
  }

  /**
   * Create or show the panel
   * @param extensionUri Extension URI
   */
  private createOrShowPanel(extensionUri: vscode.Uri): void {
    // If we already have a panel, show it
    if (this.panel) {
      this.panel.reveal();
      return;
    }

    // Create a new panel
    this.panel = vscode.window.createWebviewPanel(
      'mcpServerDiscovery',
      'MCP Server Discovery',
      vscode.ViewColumn.One,
      {
        enableScripts: true,
        retainContextWhenHidden: true,
        localResourceRoots: [extensionUri]
      }
    );

    // Set the webview's initial content
    this.panel.webview.html = this.getWebviewContent();

    // Handle messages from the webview
    this.panel.webview.onDidReceiveMessage(
      message => this.handleWebviewMessage(message),
      null,
      this.disposables
    );

    // Handle panel disposal
    this.panel.onDidDispose(() => {
      this.panel = undefined;
      this.disposeWebviewResources();
    }, null, this.disposables);
  }

  /**
   * Dispose of resources
   */
  public dispose(): void {
    if (this.panel) {
      this.panel.dispose();
      this.panel = undefined;
    }

    this.disposeWebviewResources();
  }

  /**
   * Dispose of webview resources
   */
  private disposeWebviewResources(): void {
    this.disposables.forEach(d => d.dispose());
    this.disposables = [];
  }

  /**
   * Update the webview content
   */
  private updateWebviewContent(): void {
    if (!this.panel) {
      return;
    }

    this.panel.webview.html = this.getWebviewContent();
  }

  /**
   * Get the webview content
   * @returns HTML content
   */
  private getWebviewContent(): string {
    return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MCP Server Discovery</title>
  <style>
    body {
      font-family: var(--vscode-font-family);
      font-size: var(--vscode-font-size);
      color: var(--vscode-foreground);
      background-color: var(--vscode-editor-background);
      padding: 20px;
      line-height: 1.5;
    }
    .container {
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }
    .search-container {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
    }
    .search-input {
      flex: 1;
      background-color: var(--vscode-input-background);
      color: var(--vscode-input-foreground);
      border: 1px solid var(--vscode-input-border);
      padding: 6px 12px;
      border-radius: 2px;
    }
    .search-button {
      background-color: var(--vscode-button-background);
      color: var(--vscode-button-foreground);
      border: none;
      padding: 6px 12px;
      cursor: pointer;
      border-radius: 2px;
    }
    .search-button:hover {
      background-color: var(--vscode-button-hoverBackground);
    }
    .filters {
      display: flex;
      gap: 20px;
      margin-bottom: 20px;
    }
    .filter-group {
      display: flex;
      align-items: center;
      gap: 5px;
    }
    .results-container {
      flex: 1;
      overflow-y: auto;
      background-color: var(--vscode-editor-background);
      border: 1px solid var(--vscode-panel-border);
      border-radius: 2px;
    }
    .results-table {
      width: 100%;
      border-collapse: collapse;
    }
    .results-table th, .results-table td {
      text-align: left;
      padding: 8px;
      border-bottom: 1px solid var(--vscode-panel-border);
    }
    .results-table th {
      background-color: var(--vscode-editor-background);
      position: sticky;
      top: 0;
      z-index: 1;
    }
    .results-table tr:hover {
      background-color: var(--vscode-list-hoverBackground);
    }
    .server-name {
      font-weight: bold;
    }
    .server-description {
      color: var(--vscode-descriptionForeground);
      max-width: 300px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .server-version {
      font-family: var(--vscode-editor-font-family);
    }
    .server-source {
      text-transform: capitalize;
    }
    .server-official {
      color: var(--vscode-terminal-ansiGreen);
    }
    .server-actions {
      display: flex;
      gap: 5px;
    }
    .action-button {
      background-color: var(--vscode-button-background);
      color: var(--vscode-button-foreground);
      border: none;
      padding: 4px 8px;
      cursor: pointer;
      border-radius: 2px;
      font-size: 12px;
    }
    .action-button:hover {
      background-color: var(--vscode-button-hoverBackground);
    }
    .action-button.installed {
      background-color: var(--vscode-badge-background);
      cursor: default;
    }
    .empty-results {
      text-align: center;
      padding: 20px;
      color: var(--vscode-descriptionForeground);
    }
    .loading {
      text-align: center;
      padding: 20px;
    }
    .spinner {
      width: 30px;
      height: 30px;
      border: 3px solid var(--vscode-button-background);
      border-top: 3px solid var(--vscode-editor-background);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 10px;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h2>MCP Server Discovery</h2>
    </div>
    
    <div class="search-container">
      <input type="text" id="search-input" class="search-input" placeholder="Search for MCP servers...">
      <button id="search-button" class="search-button">Search</button>
    </div>
    
    <div class="filters">
      <div class="filter-group">
        <input type="checkbox" id="filter-registry" checked>
        <label for="filter-registry">Registry</label>
      </div>
      <div class="filter-group">
        <input type="checkbox" id="filter-github" checked>
        <label for="filter-github">GitHub</label>
      </div>
      <div class="filter-group">
        <input type="checkbox" id="filter-local" checked>
        <label for="filter-local">Local</label>
      </div>
      <div class="filter-group">
        <input type="checkbox" id="filter-network" checked>
        <label for="filter-network">Network</label>
      </div>
      <div class="filter-group">
        <input type="checkbox" id="filter-official">
        <label for="filter-official">Official Only</label>
      </div>
    </div>
    
    <div class="results-container" id="results-container">
      ${this.renderSearchResults()}
    </div>
  </div>
  
  <script>
    (function() {
      const vscode = acquireVsCodeApi();
      const searchInput = document.getElementById('search-input');
      const searchButton = document.getElementById('search-button');
      const filterRegistry = document.getElementById('filter-registry');
      const filterGitHub = document.getElementById('filter-github');
      const filterLocal = document.getElementById('filter-local');
      const filterNetwork = document.getElementById('filter-network');
      const filterOfficial = document.getElementById('filter-official');
      const resultsContainer = document.getElementById('results-container');
      
      // Set up event listeners
      searchButton.addEventListener('click', () => {
        search();
      });
      
      searchInput.addEventListener('keydown', (event) => {
        if (event.key === 'Enter') {
          search();
        }
      });
      
      filterRegistry.addEventListener('change', () => {
        search();
      });
      
      filterGitHub.addEventListener('change', () => {
        search();
      });
      
      filterLocal.addEventListener('change', () => {
        search();
      });
      
      filterNetwork.addEventListener('change', () => {
        search();
      });
      
      filterOfficial.addEventListener('change', () => {
        search();
      });
      
      // Set up action button event listeners
      document.addEventListener('click', (event) => {
        if (event.target.classList.contains('action-button') && !event.target.classList.contains('installed')) {
          const serverId = event.target.dataset.serverId;
          const repoUrl = event.target.dataset.repoUrl;
          
          vscode.postMessage({
            command: 'addServer',
            repoUrl
          });
          
          // Show loading state
          event.target.textContent = 'Adding...';
          event.target.disabled = true;
        }
      });
      
      // Search function
      function search() {
        const query = searchInput.value.trim();
        const includeRegistry = filterRegistry.checked;
        const includeGitHub = filterGitHub.checked;
        const includeLocal = filterLocal.checked;
        const includeNetwork = filterNetwork.checked;
        const officialOnly = filterOfficial.checked;
        
        // Show loading state
        resultsContainer.innerHTML = \`
          <div class="loading">
            <div class="spinner"></div>
            <p>Searching for MCP servers...</p>
          </div>
        \`;
        
        vscode.postMessage({
          command: 'search',
          query,
          includeRegistry,
          includeGitHub,
          includeLocal,
          includeNetwork,
          officialOnly
        });
      }
      
      // Initial search
      search();
    })();
  </script>
</body>
</html>`;
  }

  /**
   * Render search results
   * @returns HTML content
   */
  private renderSearchResults(): string {
    if (this.searchResults.length === 0) {
      return `
        <div class="empty-results">
          <p>No MCP servers found. Try a different search query or adjust the filters.</p>
        </div>
      `;
    }

    // Get installed servers
    const installedServers = this.serverManager.getServers();
    const installedRepoUrls = new Set(installedServers.map(server => server.repoUrl));

    return `
      <table class="results-table">
        <thead>
          <tr>
            <th>Name</th>
            <th>Description</th>
            <th>Version</th>
            <th>Source</th>
            <th>Official</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody>
          ${this.searchResults.map(result => `
            <tr>
              <td class="server-name">${this.escapeHtml(result.name)}</td>
              <td class="server-description" title="${this.escapeHtml(result.description)}">${this.escapeHtml(result.description)}</td>
              <td class="server-version">${this.escapeHtml(result.version)}</td>
              <td class="server-source">${result.source}</td>
              <td class="server-official">${result.official ? '' : ''}</td>
              <td class="server-actions">
                ${result.installed
                  ? `<button class="action-button installed" disabled>Installed</button>`
                  : `<button class="action-button" data-repo-url="${this.escapeHtml(result.repoUrl)}">Add Server</button>`
                }
              </td>
            </tr>
          `).join('')}
        </tbody>
      </table>
    `;
  }

  /**
   * Escape HTML
   * @param str String to escape
   * @returns Escaped string
   */
  private escapeHtml(str: string): string {
    return str
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#039;');
  }

  /**
   * Handle a message from the webview
   * @param message Message
   */
  private async handleWebviewMessage(message: any): Promise<void> {
    switch (message.command) {
      case 'search':
        await this.handleSearch(message);
        break;
      case 'addServer':
        await this.handleAddServer(message);
        break;
    }
  }

  /**
   * Handle a search message
   * @param message Message
   */
  private async handleSearch(message: any): Promise<void> {
    try {
      const options = {
        includeRegistry: message.includeRegistry,
        includeGitHub: message.includeGitHub,
        includeLocal: message.includeLocal,
        includeNetwork: message.includeNetwork,
        searchQuery: message.query,
        maxResults: 100
      };

      // Discover servers
      const results = await this.discovery.discoverServers(options);

      // Filter by official if needed
      this.searchResults = message.officialOnly
        ? results.filter(result => result.official)
        : results;

      // Update the webview content
      this.updateWebviewContent();
    } catch (error) {
      console.error('Error searching for servers:', error);
      vscode.window.showErrorMessage(`Error searching for servers: ${error}`);
    }
  }

  /**
   * Handle an add server message
   * @param message Message
   */
  private async handleAddServer(message: any): Promise<void> {
    try {
      const repoUrl = message.repoUrl;

      // Add the server
      await this.serverManager.addServerFromGitHub(repoUrl);

      // Show a success message
      vscode.window.showInformationMessage(`Added MCP server from ${repoUrl}`);

      // Update the search results
      const result = this.searchResults.find(r => r.repoUrl === repoUrl);
      if (result) {
        result.installed = true;
      }

      // Update the webview content
      this.updateWebviewContent();
    } catch (error) {
      console.error('Error adding server:', error);
      vscode.window.showErrorMessage(`Error adding server: ${error}`);
    }
  }
}

```


---

### File: `src/ui/logViewer.ts`

```typescript
import * as vscode from 'vscode';
import { LogEntry, LogLevel, McpLogger } from '../mcp-client/logging/mcpLogger';
import { McpServer } from '../mcp-client/types';

/**
 * Log viewer for MCP servers
 */
export class LogViewer {
  private panel: vscode.WebviewPanel | undefined;
  private logger: McpLogger;
  private currentServerId: string | undefined;
  private disposables: vscode.Disposable[] = [];

  /**
   * Create a new log viewer
   * @param logger MCP logger
   */
  constructor(logger: McpLogger) {
    this.logger = logger;
  }

  /**
   * Show the log viewer for a server
   * @param server Server
   */
  public show(server: McpServer): void {
    const serverId = server.id;
    this.currentServerId = serverId;

    // Create or show the panel
    if (!this.panel) {
      this.panel = vscode.window.createWebviewPanel(
        'mcpServerLogs',
        `Logs: ${server.name}`,
        vscode.ViewColumn.Two,
        {
          enableScripts: true,
          retainContextWhenHidden: true,
          localResourceRoots: []
        }
      );

      // Handle panel disposal
      this.panel.onDidDispose(() => {
        this.panel = undefined;
        this.disposeWebviewResources();
      }, null, this.disposables);

      // Handle messages from the webview
      this.panel.webview.onDidReceiveMessage(
        message => this.handleWebviewMessage(message),
        null,
        this.disposables
      );

      // Listen for log events
      this.logger.onDidLog(entry => {
        if (this.panel && entry.serverId === this.currentServerId) {
          this.panel.webview.postMessage({ type: 'newLog', entry });
        }
      }, null, this.disposables);
    } else {
      // Update the panel title
      this.panel.title = `Logs: ${server.name}`;
      this.currentServerId = serverId;
    }

    // Update the webview content
    this.updateWebviewContent(server);

    // Show the panel
    this.panel.reveal();
  }

  /**
   * Dispose of resources
   */
  public dispose(): void {
    if (this.panel) {
      this.panel.dispose();
      this.panel = undefined;
    }

    this.disposeWebviewResources();
  }

  /**
   * Dispose of webview resources
   */
  private disposeWebviewResources(): void {
    this.disposables.forEach(d => d.dispose());
    this.disposables = [];
  }

  /**
   * Update the webview content
   * @param server Server
   */
  private updateWebviewContent(server: McpServer): void {
    if (!this.panel) {
      return;
    }

    // Get the log entries for the server
    const logEntries = this.logger.getLogEntries(server.id, 1000);

    // Set the webview content
    this.panel.webview.html = this.getWebviewContent(server, logEntries);
  }

  /**
   * Get the webview content
   * @param server Server
   * @param logEntries Log entries
   * @returns HTML content
   */
  private getWebviewContent(server: McpServer, logEntries: LogEntry[]): string {
    return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MCP Server Logs: ${server.name}</title>
  <style>
    body {
      font-family: var(--vscode-font-family);
      font-size: var(--vscode-font-size);
      color: var(--vscode-foreground);
      background-color: var(--vscode-editor-background);
      padding: 20px;
      line-height: 1.5;
    }
    .container {
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    .server-info {
      margin-bottom: 10px;
    }
    .server-info table {
      border-collapse: collapse;
      width: 100%;
    }
    .server-info th, .server-info td {
      text-align: left;
      padding: 8px;
      border-bottom: 1px solid var(--vscode-panel-border);
    }
    .log-controls {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
    }
    .log-controls button {
      background-color: var(--vscode-button-background);
      color: var(--vscode-button-foreground);
      border: none;
      padding: 6px 12px;
      cursor: pointer;
      border-radius: 2px;
    }
    .log-controls button:hover {
      background-color: var(--vscode-button-hoverBackground);
    }
    .log-controls select {
      background-color: var(--vscode-dropdown-background);
      color: var(--vscode-dropdown-foreground);
      border: 1px solid var(--vscode-dropdown-border);
      padding: 5px;
    }
    .log-container {
      flex: 1;
      overflow-y: auto;
      background-color: var(--vscode-editor-background);
      border: 1px solid var(--vscode-panel-border);
      padding: 10px;
      font-family: var(--vscode-editor-font-family);
      font-size: var(--vscode-editor-font-size);
    }
    .log-entry {
      margin-bottom: 5px;
      white-space: pre-wrap;
      word-break: break-all;
    }
    .log-entry.DEBUG {
      color: var(--vscode-debugIcon-startForeground);
    }
    .log-entry.INFO {
      color: var(--vscode-foreground);
    }
    .log-entry.WARNING {
      color: var(--vscode-editorWarning-foreground);
    }
    .log-entry.ERROR {
      color: var(--vscode-editorError-foreground);
    }
    .log-timestamp {
      color: var(--vscode-descriptionForeground);
      margin-right: 10px;
    }
    .log-level {
      font-weight: bold;
      margin-right: 10px;
    }
    .log-message {
      margin-right: 10px;
    }
    .log-data {
      color: var(--vscode-textPreformat-foreground);
      background-color: var(--vscode-textCodeBlock-background);
      padding: 5px;
      margin-top: 5px;
      border-radius: 3px;
      font-family: var(--vscode-editor-font-family);
      white-space: pre;
      overflow-x: auto;
    }
    .empty-logs {
      text-align: center;
      padding: 20px;
      color: var(--vscode-descriptionForeground);
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h2>MCP Server Logs: ${server.name}</h2>
    </div>
    
    <div class="server-info">
      <table>
        <tr>
          <th>Server ID</th>
          <td>${server.id}</td>
          <th>Status</th>
          <td>${server.status}</td>
        </tr>
        <tr>
          <th>Version</th>
          <td>${server.version}</td>
          <th>Health</th>
          <td>${server.healthStatus || 'unknown'}</td>
        </tr>
      </table>
    </div>
    
    <div class="log-controls">
      <button id="refresh-logs">Refresh</button>
      <button id="clear-logs">Clear Logs</button>
      <select id="log-level">
        <option value="DEBUG">Debug</option>
        <option value="INFO" selected>Info</option>
        <option value="WARNING">Warning</option>
        <option value="ERROR">Error</option>
      </select>
      <button id="export-logs">Export Logs</button>
    </div>
    
    <div class="log-container" id="log-container">
      ${this.renderLogEntries(logEntries)}
    </div>
  </div>
  
  <script>
    (function() {
      const vscode = acquireVsCodeApi();
      const logContainer = document.getElementById('log-container');
      const refreshButton = document.getElementById('refresh-logs');
      const clearButton = document.getElementById('clear-logs');
      const logLevelSelect = document.getElementById('log-level');
      const exportButton = document.getElementById('export-logs');
      
      // Store the current log entries
      let logEntries = ${JSON.stringify(logEntries)};
      
      // Set up event listeners
      refreshButton.addEventListener('click', () => {
        vscode.postMessage({ command: 'refresh' });
      });
      
      clearButton.addEventListener('click', () => {
        vscode.postMessage({ command: 'clear' });
      });
      
      logLevelSelect.addEventListener('change', () => {
        filterLogs();
      });
      
      exportButton.addEventListener('click', () => {
        vscode.postMessage({ command: 'export' });
      });
      
      // Handle messages from the extension
      window.addEventListener('message', event => {
        const message = event.data;
        
        switch (message.type) {
          case 'refreshLogs':
            logEntries = message.entries;
            renderLogs();
            break;
          case 'newLog':
            logEntries.push(message.entry);
            // Limit the number of entries to prevent performance issues
            if (logEntries.length > 1000) {
              logEntries.shift();
            }
            renderLogs();
            break;
          case 'clearLogs':
            logEntries = [];
            renderLogs();
            break;
        }
      });
      
      // Render the logs
      function renderLogs() {
        // Filter logs by level
        const filteredLogs = filterLogs();
        
        // Render the logs
        logContainer.innerHTML = filteredLogs.length > 0
          ? filteredLogs.map(entry => renderLogEntry(entry)).join('')
          : '<div class="empty-logs">No logs to display</div>';
        
        // Scroll to the bottom
        logContainer.scrollTop = logContainer.scrollHeight;
      }
      
      // Filter logs by level
      function filterLogs() {
        const selectedLevel = logLevelSelect.value;
        const levelPriority = {
          'DEBUG': 0,
          'INFO': 1,
          'WARNING': 2,
          'ERROR': 3
        };
        
        return logEntries.filter(entry => {
          return levelPriority[entry.level] >= levelPriority[selectedLevel];
        });
      }
      
      // Render a log entry
      function renderLogEntry(entry) {
        const timestamp = new Date(entry.timestamp).toLocaleTimeString();
        let html = \`
          <div class="log-entry \${entry.level}">
            <span class="log-timestamp">\${timestamp}</span>
            <span class="log-level">\${entry.level}</span>
            <span class="log-message">\${escapeHtml(entry.message)}</span>
        \`;
        
        if (entry.data) {
          let dataStr;
          try {
            dataStr = typeof entry.data === 'string'
              ? entry.data
              : JSON.stringify(entry.data, null, 2);
          } catch (error) {
            dataStr = \`[Error serializing data: \${error}]\`;
          }
          
          html += \`<div class="log-data">\${escapeHtml(dataStr)}</div>\`;
        }
        
        html += '</div>';
        return html;
      }
      
      // Escape HTML
      function escapeHtml(str) {
        return str
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#039;');
      }
    })();
  </script>
</body>
</html>`;
  }

  /**
   * Render log entries
   * @param entries Log entries
   * @returns HTML content
   */
  private renderLogEntries(entries: LogEntry[]): string {
    if (entries.length === 0) {
      return '<div class="empty-logs">No logs to display</div>';
    }

    return entries.map(entry => {
      const timestamp = new Date(entry.timestamp).toLocaleTimeString();
      let html = `
        <div class="log-entry ${entry.level}">
          <span class="log-timestamp">${timestamp}</span>
          <span class="log-level">${entry.level}</span>
          <span class="log-message">${this.escapeHtml(entry.message)}</span>
      `;

      if (entry.data) {
        let dataStr;
        try {
          dataStr = typeof entry.data === 'string'
            ? entry.data
            : JSON.stringify(entry.data, null, 2);
        } catch (error) {
          dataStr = `[Error serializing data: ${error}]`;
        }

        html += `<div class="log-data">${this.escapeHtml(dataStr)}</div>`;
      }

      html += '</div>';
      return html;
    }).join('');
  }

  /**
   * Escape HTML
   * @param str String to escape
   * @returns Escaped string
   */
  private escapeHtml(str: string): string {
    return str
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#039;');
  }

  /**
   * Handle a message from the webview
   * @param message Message
   */
  private handleWebviewMessage(message: any): void {
    if (!this.currentServerId) {
      return;
    }

    switch (message.command) {
      case 'refresh':
        this.refreshLogs();
        break;
      case 'clear':
        this.clearLogs();
        break;
      case 'export':
        this.exportLogs();
        break;
    }
  }

  /**
   * Refresh the logs
   */
  private refreshLogs(): void {
    if (!this.panel || !this.currentServerId) {
      return;
    }

    const server = this.getServerById(this.currentServerId);
    if (!server) {
      return;
    }

    const logEntries = this.logger.getLogEntries(this.currentServerId, 1000);
    this.panel.webview.postMessage({ type: 'refreshLogs', entries: logEntries });
  }

  /**
   * Clear the logs
   */
  private clearLogs(): void {
    if (!this.currentServerId) {
      return;
    }

    this.logger.clearLogs(this.currentServerId);

    if (this.panel) {
      this.panel.webview.postMessage({ type: 'clearLogs' });
    }
  }

  /**
   * Export the logs
   */
  private async exportLogs(): Promise<void> {
    if (!this.currentServerId) {
      return;
    }

    const server = this.getServerById(this.currentServerId);
    if (!server) {
      return;
    }

    // Get the log entries
    const logEntries = this.logger.getLogEntries(this.currentServerId, 10000);

    // Format the logs
    const formattedLogs = logEntries.map(entry => {
      const timestamp = new Date(entry.timestamp).toISOString();
      let line = `[${timestamp}] [${entry.level}] ${entry.message}`;

      if (entry.data) {
        try {
          const dataStr = typeof entry.data === 'string'
            ? entry.data
            : JSON.stringify(entry.data, null, 2);
          line += `\n${dataStr}`;
        } catch (error) {
          line += `\n[Error serializing data: ${error}]`;
        }
      }

      return line;
    }).join('\n');

    // Show a save dialog
    const uri = await vscode.window.showSaveDialog({
      defaultUri: vscode.Uri.file(`${server.name}_logs.txt`),
      filters: {
        'Text Files': ['txt'],
        'All Files': ['*']
      }
    });

    if (uri) {
      // Write the logs to the file
      await vscode.workspace.fs.writeFile(uri, Buffer.from(formattedLogs, 'utf8'));
      vscode.window.showInformationMessage(`Logs exported to ${uri.fsPath}`);
    }
  }

  /**
   * Get a server by ID
   * @param serverId Server ID
   * @returns Server or undefined
   */
  private getServerById(serverId: string): McpServer | undefined {
    // This is a placeholder - in a real implementation, you would get the server from the MCP server manager
    // For now, we'll just return a dummy server
    return {
      id: serverId,
      name: 'Unknown Server',
      description: '',
      repoUrl: '',
      version: '',
      status: 'unknown' as any,
      type: 'docker' as any,
      autoStart: false,
      logs: []
    };
  }
}

```


---

### File: `src/agents/developmentAgent.ts`

```typescript
/**
 * Development Agent
 * 
 * Specialized agent for code generation, refactoring, and documentation.
 */

import * as vscode from 'vscode';
import { AgentType, ModelSize, ThinkingMode, Subtask, AgentResult } from './types';
import { QwenApiClient } from '../qwenApi';
import { getContextForCurrentFile } from '../contextProvider';

/**
 * Development Agent class
 */
export class DevelopmentAgent {
  private id: string;
  private qwenApi: QwenApiClient;
  private modelSize: ModelSize;
  private thinkingMode: ThinkingMode;
  private outputChannel: vscode.OutputChannel;

  /**
   * Constructor
   * @param id The agent ID
   * @param qwenApi The Qwen API client
   * @param modelSize The model size to use
   * @param thinkingMode The thinking mode to use
   */
  constructor(
    id: string,
    qwenApi: QwenApiClient,
    modelSize: ModelSize,
    thinkingMode: ThinkingMode
  ) {
    this.id = id;
    this.qwenApi = qwenApi;
    this.modelSize = modelSize;
    this.thinkingMode = thinkingMode;
    this.outputChannel = vscode.window.createOutputChannel(`Development Agent ${id}`);
    
    this.outputChannel.appendLine(`Development Agent initialized with model ${modelSize} and thinking mode ${thinkingMode}`);
  }

  /**
   * Execute a subtask
   * @param subtask The subtask to execute
   * @returns The result of the execution
   */
  public async execute(subtask: Subtask): Promise<AgentResult> {
    try {
      this.outputChannel.appendLine(`Executing subtask: ${subtask.description}`);
      
      // Get context from the current file
      const context = await getContextForCurrentFile();
      
      // Prepare the system message
      const systemMessage = `
        You are a Development Agent specializing in writing high-quality code, refactoring, and documentation.
        Your task is to help with development-related activities in a DevOps workflow.
        
        You excel at:
        1. Writing clean, efficient, and well-documented code
        2. Refactoring existing code to improve quality and maintainability
        3. Implementing best practices and design patterns
        4. Creating comprehensive documentation
        5. Solving complex programming problems
        
        When writing code:
        - Follow language-specific conventions and best practices
        - Include appropriate error handling
        - Add clear comments explaining complex logic
        - Consider edge cases and potential issues
        - Optimize for readability and maintainability
        
        When providing explanations:
        - Be clear and concise
        - Use examples to illustrate concepts
        - Explain your reasoning and decision-making process
        - Highlight trade-offs and alternatives considered
      `;
      
      // Prepare the user message
      const userMessage = `
        I need help with the following development task: ${subtask.description}
        
        ${context ? `Here is the current context:\n\n${context}` : ''}
      `;
      
      // Prepare the messages for the API call
      const messages = [
        { role: 'system', content: systemMessage },
        { role: 'user', content: userMessage }
      ];
      
      // Call the Qwen API with the appropriate thinking mode
      const enableThinking = this.thinkingMode === ThinkingMode.Enabled;
      const response = await this.qwenApi.chat(messages, {
        enableThinking,
        temperature: 0.3,
        maxTokens: 4096,
        modelName: this.modelSize
      });
      
      this.outputChannel.appendLine('Subtask executed successfully');
      
      return {
        subtaskId: subtask.id,
        thinking: enableThinking ? this._extractThinking(response) : undefined,
        content: this._extractContent(response, enableThinking),
        status: 'success'
      };
    } catch (error) {
      this.outputChannel.appendLine(`Error executing subtask: ${error.message}`);
      
      return {
        subtaskId: subtask.id,
        content: '',
        status: 'error',
        error: error.message
      };
    }
  }

  /**
   * Extract thinking from response
   * @param response The API response
   * @returns The extracted thinking
   */
  private _extractThinking(response: string): string {
    const thinkingMatch = response.match(/<think>([\s\S]*?)<\/think>/);
    return thinkingMatch ? thinkingMatch[1].trim() : '';
  }

  /**
   * Extract content from response
   * @param response The API response
   * @param enableThinking Whether thinking mode was enabled
   * @returns The extracted content
   */
  private _extractContent(response: string, enableThinking: boolean): string {
    if (enableThinking) {
      // Remove thinking tags and content
      return response.replace(/<think>[\s\S]*?<\/think>/, '').trim();
    }
    
    return response.trim();
  }

  /**
   * Dispose of resources
   */
  public dispose(): void {
    this.outputChannel.dispose();
  }
}

```


---

### File: `src/agents/agentSelector.ts`

```typescript
/**
 * Agent Selector
 *
 * Chooses the most appropriate agent for each subtask based on expertise, complexity, and available resources.
 * Also provides dynamic agent selection based on task requirements.
 */

import * as vscode from 'vscode';
import { getConfiguration } from '../configuration';
import {
    AgentType,
    ModelSize,
    ResourceUsage,
    Subtask,
    TaskComplexity,
    ThinkingMode
} from './types';

/**
 * Agent Selector class
 */
export class AgentSelector {
  private outputChannel: vscode.OutputChannel;
  private agentConfigs: Record<AgentType, Record<TaskComplexity, { modelSize: ModelSize, thinkingMode: ThinkingMode }>>;
  private agents: Agent[] = [];
  private agentAvailability: Map<string, boolean> = new Map<string, boolean>();

  /**
   * Constructor
   */
  constructor() {
    this.outputChannel = vscode.window.createOutputChannel('Agent Selector');

    // Initialize agent configurations
    this.agentConfigs = {
      [AgentType.Coordinator]: {
        [TaskComplexity.High]: { modelSize: ModelSize.MoESmall, thinkingMode: ThinkingMode.Enabled },
        [TaskComplexity.Medium]: { modelSize: ModelSize.MoESmall, thinkingMode: ThinkingMode.Enabled },
        [TaskComplexity.Low]: { modelSize: ModelSize.XXLarge, thinkingMode: ThinkingMode.Enabled }
      },
      [AgentType.Development]: {
        [TaskComplexity.High]: { modelSize: ModelSize.MoESmall, thinkingMode: ThinkingMode.Enabled },
        [TaskComplexity.Medium]: { modelSize: ModelSize.XXLarge, thinkingMode: ThinkingMode.Enabled },
        [TaskComplexity.Low]: { modelSize: ModelSize.XLarge, thinkingMode: ThinkingMode.Disabled }
      },
      [AgentType.Testing]: {
        [TaskComplexity.High]: { modelSize: ModelSize.XLarge, thinkingMode: ThinkingMode.Enabled },
        [TaskComplexity.Medium]: { modelSize: ModelSize.Large, thinkingMode: ThinkingMode.Enabled },
        [TaskComplexity.Low]: { modelSize: ModelSize.Medium, thinkingMode: ThinkingMode.Disabled }
      },
      [AgentType.CICD]: {
        [TaskComplexity.High]: { modelSize: ModelSize.Large, thinkingMode: ThinkingMode.Enabled },
        [TaskComplexity.Medium]: { modelSize: ModelSize.Medium, thinkingMode: ThinkingMode.Disabled },
        [TaskComplexity.Low]: { modelSize: ModelSize.Small, thinkingMode: ThinkingMode.Disabled }
      },
      [AgentType.GitHub]: {
        [TaskComplexity.High]: { modelSize: ModelSize.Large, thinkingMode: ThinkingMode.Enabled },
        [TaskComplexity.Medium]: { modelSize: ModelSize.Medium, thinkingMode: ThinkingMode.Disabled },
        [TaskComplexity.Low]: { modelSize: ModelSize.Small, thinkingMode: ThinkingMode.Disabled }
      },
      [AgentType.Documentation]: {
        [TaskComplexity.High]: { modelSize: ModelSize.Large, thinkingMode: ThinkingMode.Enabled },
        [TaskComplexity.Medium]: { modelSize: ModelSize.Medium, thinkingMode: ThinkingMode.Enabled },
        [TaskComplexity.Low]: { modelSize: ModelSize.Small, thinkingMode: ThinkingMode.Disabled }
      },
      [AgentType.Architecture]: {
        [TaskComplexity.High]: { modelSize: ModelSize.MoESmall, thinkingMode: ThinkingMode.Enabled },
        [TaskComplexity.Medium]: { modelSize: ModelSize.XXLarge, thinkingMode: ThinkingMode.Enabled },
        [TaskComplexity.Low]: { modelSize: ModelSize.XLarge, thinkingMode: ThinkingMode.Enabled }
      },
      [AgentType.Security]: {
        [TaskComplexity.High]: { modelSize: ModelSize.XLarge, thinkingMode: ThinkingMode.Enabled },
        [TaskComplexity.Medium]: { modelSize: ModelSize.Large, thinkingMode: ThinkingMode.Enabled },
        [TaskComplexity.Low]: { modelSize: ModelSize.Medium, thinkingMode: ThinkingMode.Disabled }
      },
      [AgentType.Performance]: {
        [TaskComplexity.High]: { modelSize: ModelSize.XLarge, thinkingMode: ThinkingMode.Enabled },
        [TaskComplexity.Medium]: { modelSize: ModelSize.Large, thinkingMode: ThinkingMode.Enabled },
        [TaskComplexity.Low]: { modelSize: ModelSize.Medium, thinkingMode: ThinkingMode.Disabled }
      }
    };

    this.outputChannel.appendLine('Agent Selector initialized');
  }

  /**
   * Select appropriate agents for each subtask
   * @param subtasks The subtasks to assign agents to
   * @param availableResources Available system resources
   * @returns Agent assignments for each subtask
   */
  public async selectAgents(
    subtasks: Record<string, Subtask>,
    availableResources: ResourceUsage
  ): Promise<Record<string, { type: AgentType, modelSize: ModelSize, thinkingMode: ThinkingMode }>> {
    try {
      this.outputChannel.appendLine(`Selecting agents for ${Object.keys(subtasks).length} subtasks`);

      // Get user configuration
      const config = getConfiguration();
      const preferredModel = config.get<string>('preferredModel', 'auto');
      const preferThinking = config.get<boolean>('preferThinkingMode', true);

      // Initialize agent assignments
      const agentAssignments: Record<string, { type: AgentType, modelSize: ModelSize, thinkingMode: ThinkingMode }> = {};

      // Sort subtasks by dependencies (fewer dependencies first)
      const sortedSubtasks = Object.values(subtasks).sort((a, b) =>
        a.dependencies.length - b.dependencies.length
      );

      // Assign agents to each subtask
      for (const subtask of sortedSubtasks) {
        const expertise = subtask.expertise;
        const complexity = subtask.complexity;

        // Get the appropriate agent configuration
        let agentConfig = this.agentConfigs[expertise][complexity];

        // Apply user preferences
        if (preferredModel !== 'auto') {
          // Override model size based on user preference
          const userModelSize = this._getUserModelSize(preferredModel);
          if (userModelSize) {
            agentConfig = { ...agentConfig, modelSize: userModelSize };
          }
        }

        if (preferThinking) {
          // Prefer thinking mode if user has enabled it
          agentConfig = { ...agentConfig, thinkingMode: ThinkingMode.Enabled };
        }

        // Check if we have enough resources for this agent
        if (this._checkResources(agentConfig, availableResources)) {
          agentAssignments[subtask.id] = {
            type: expertise,
            modelSize: agentConfig.modelSize,
            thinkingMode: agentConfig.thinkingMode
          };
        } else {
          // Fallback to a smaller model if resources are constrained
          const fallbackAgent = this._getFallbackAgent(expertise, availableResources);
          agentAssignments[subtask.id] = fallbackAgent;
        }

        this.outputChannel.appendLine(`Assigned ${agentAssignments[subtask.id].type} agent with ${agentAssignments[subtask.id].modelSize} model to subtask ${subtask.id}`);
      }

      return agentAssignments;
    } catch (error) {
      this.outputChannel.appendLine(`Error selecting agents: ${error.message}`);
      throw error;
    }
  }

  /**
   * Check if we have enough resources for this agent
   * @param agentConfig The agent configuration
   * @param availableResources Available system resources
   * @returns Whether we have enough resources
   */
  private _checkResources(
    agentConfig: { modelSize: ModelSize, thinkingMode: ThinkingMode },
    availableResources: ResourceUsage
  ): boolean {
    // Calculate resource requirements based on model size and thinking mode
    let memoryRequirement = 0;
    let cpuRequirement = 0;

    // Memory requirements
    switch (agentConfig.modelSize) {
      case ModelSize.MoELarge:
        memoryRequirement = 0.8;
        break;
      case ModelSize.MoESmall:
        memoryRequirement = 0.5;
        break;
      case ModelSize.XXLarge:
        memoryRequirement = 0.4;
        break;
      case ModelSize.XLarge:
        memoryRequirement = 0.3;
        break;
      case ModelSize.Large:
        memoryRequirement = 0.2;
        break;
      case ModelSize.Medium:
        memoryRequirement = 0.1;
        break;
      case ModelSize.Small:
        memoryRequirement = 0.05;
        break;
      case ModelSize.Tiny:
        memoryRequirement = 0.02;
        break;
    }

    // CPU requirements
    switch (agentConfig.modelSize) {
      case ModelSize.MoELarge:
        cpuRequirement = 0.8;
        break;
      case ModelSize.MoESmall:
        cpuRequirement = 0.5;
        break;
      case ModelSize.XXLarge:
        cpuRequirement = 0.4;
        break;
      case ModelSize.XLarge:
        cpuRequirement = 0.3;
        break;
      case ModelSize.Large:
        cpuRequirement = 0.2;
        break;
      case ModelSize.Medium:
        cpuRequirement = 0.1;
        break;
      case ModelSize.Small:
        cpuRequirement = 0.05;
        break;
      case ModelSize.Tiny:
        cpuRequirement = 0.02;
        break;
    }

    // Adjust for thinking mode
    if (agentConfig.thinkingMode === ThinkingMode.Enabled) {
      memoryRequirement *= 1.5;
      cpuRequirement *= 1.5;
    }

    // Check if we have enough resources
    return (
      availableResources.memory >= memoryRequirement &&
      availableResources.cpu >= cpuRequirement
    );
  }

  /**
   * Get a fallback agent with lower resource requirements
   * @param expertise The required expertise
   * @param availableResources Available system resources
   * @returns A fallback agent configuration
   */
  private _getFallbackAgent(
    expertise: AgentType,
    availableResources: ResourceUsage
  ): { type: AgentType, modelSize: ModelSize, thinkingMode: ThinkingMode } {
    this.outputChannel.appendLine(`Finding fallback agent for ${expertise} due to resource constraints`);

    // Try progressively smaller models
    const modelSizes = [
      ModelSize.Medium,
      ModelSize.Small,
      ModelSize.Tiny
    ];

    // Try without thinking mode first
    for (const modelSize of modelSizes) {
      const config = { modelSize, thinkingMode: ThinkingMode.Disabled };
      if (this._checkResources(config, availableResources)) {
        return { type: expertise, ...config };
      }
    }

    // If all else fails, use the smallest possible configuration
    return {
      type: expertise,
      modelSize: ModelSize.Tiny,
      thinkingMode: ThinkingMode.Disabled
    };
  }

  /**
   * Convert user model preference to ModelSize
   * @param preferredModel The user's preferred model
   * @returns The corresponding ModelSize or undefined
   */
  private _getUserModelSize(preferredModel: string): ModelSize | undefined {
    switch (preferredModel.toLowerCase()) {
      case 'tiny':
        return ModelSize.Tiny;
      case 'small':
        return ModelSize.Small;
      case 'medium':
        return ModelSize.Medium;
      case 'large':
        return ModelSize.Large;
      case 'xlarge':
        return ModelSize.XLarge;
      case 'xxlarge':
        return ModelSize.XXLarge;
      case 'moesmall':
      case 'moe-small':
        return ModelSize.MoESmall;
      case 'moelarge':
      case 'moe-large':
        return ModelSize.MoELarge;
      default:
        return undefined;
    }
  }

  /**
   * Register an agent with the selector
   * @param agent The agent to register
   */
  public registerAgent(agent: Agent): void {
    this.agents.push(agent);
    this.outputChannel.appendLine(`Registered agent: ${agent.name}`);
  }

  /**
   * Select the most appropriate agent for a task
   * @param task The task to select an agent for
   * @returns The selected agent
   */
  public async selectAgent(task: Task): Promise<Agent> {
    try {
      this.outputChannel.appendLine(`Selecting agent for task: ${task.description}`);

      // Determine task complexity if not specified
      if (!task.complexity) {
        task.complexity = this.analyzeTaskComplexity(task.description);
        this.outputChannel.appendLine(`Inferred task complexity: ${task.complexity}`);
      }

      // Filter agents by availability
      const availableAgents = this.agents.filter(agent =>
        this.isAgentAvailable(agent.name)
      );

      if (availableAgents.length === 0) {
        throw new Error('No agents available');
      }

      // Filter agents by complexity
      const complexityMap: Record<TaskComplexity, number> = {
        [TaskComplexity.Simple]: 1,
        [TaskComplexity.Moderate]: 2,
        [TaskComplexity.Complex]: 3,
        [TaskComplexity.VeryComplex]: 4
      };

      const taskComplexityValue = complexityMap[task.complexity];

      const capableAgents = availableAgents.filter(agent => {
        const agentComplexityValue = complexityMap[agent.maxComplexity];
        return agentComplexityValue >= taskComplexityValue;
      });

      if (capableAgents.length === 0) {
        // Fallback to the agent with the highest complexity capability
        const fallbackAgent = availableAgents.sort((a, b) =>
          complexityMap[b.maxComplexity] - complexityMap[a.maxComplexity]
        )[0];

        this.outputChannel.appendLine(`No agent capable of handling complexity ${task.complexity}, falling back to ${fallbackAgent.name}`);
        return fallbackAgent;
      }

      // Filter by required capabilities
      let filteredAgents = capableAgents;

      if (task.requiresContext) {
        filteredAgents = filteredAgents.filter(agent =>
          agent.capabilities.includes('context')
        );
      }

      if (task.requiresTools) {
        filteredAgents = filteredAgents.filter(agent =>
          agent.capabilities.includes('tools')
        );
      }

      if (filteredAgents.length === 0) {
        this.outputChannel.appendLine(`No agent with required capabilities, falling back to most capable agent`);
        return capableAgents[0];
      }

      // Filter by domain specialization if specified
      if (task.domain && task.domain !== 'general') {
        const domainAgents = filteredAgents.filter(agent =>
          agent.specializations?.some(spec =>
            spec.toLowerCase().includes(task.domain!.toLowerCase())
          )
        );

        if (domainAgents.length > 0) {
          filteredAgents = domainAgents;
          this.outputChannel.appendLine(`Found ${domainAgents.length} agents specialized in ${task.domain}`);
        }
      }

      // Filter by required tools if specified
      if (task.requiredTools && task.requiredTools.length > 0) {
        // For this example, we'll just check if the agent has tools capability
        // In a real implementation, we would check if the agent supports the specific tools
        const toolAgents = filteredAgents.filter(agent =>
          agent.capabilities.includes('tools')
        );

        if (toolAgents.length > 0) {
          filteredAgents = toolAgents;
          this.outputChannel.appendLine(`Found ${toolAgents.length} agents with required tool support`);
        }
      }

      // Select the best agent from the filtered list
      // For now, we'll just take the first one
      // In a real implementation, we might use a more sophisticated selection algorithm
      const selectedAgent = filteredAgents[0];

      this.outputChannel.appendLine(`Selected agent: ${selectedAgent.name}`);
      return selectedAgent;
    } catch (error) {
      this.outputChannel.appendLine(`Error selecting agent: ${error instanceof Error ? error.message : String(error)}`);

      // Return a default agent as fallback
      const defaultAgent = this.agents.find(a => a.name === 'DevelopmentAgent') || this.agents[0];
      this.outputChannel.appendLine(`Falling back to default agent: ${defaultAgent.name}`);

      return defaultAgent;
    }
  }

  /**
   * Analyze task description to determine complexity
   * @param description Task description
   * @returns Inferred task complexity
   */
  private analyzeTaskComplexity(description: string): TaskComplexity {
    const description_lower = description.toLowerCase();

    // Check for keywords indicating very complex tasks
    const veryComplexKeywords = [
      'architecture', 'redesign', 'system design', 'microservice',
      'distributed', 'scale', 'optimize', 'performance', 'security',
      'refactor', 'monolithic'
    ];

    if (veryComplexKeywords.some(keyword => description_lower.includes(keyword))) {
      return TaskComplexity.Complex;
    }

    // Check for keywords indicating complex tasks
    const complexKeywords = [
      'implement', 'create', 'develop', 'build', 'design',
      'algorithm', 'feature', 'functionality', 'integration'
    ];

    if (complexKeywords.some(keyword => description_lower.includes(keyword))) {
      return TaskComplexity.Moderate;
    }

    // Check for keywords indicating simple tasks
    const simpleKeywords = [
      'fix', 'update', 'change', 'modify', 'add', 'remove',
      'format', 'rename', 'explain', 'help'
    ];

    if (simpleKeywords.some(keyword => description_lower.includes(keyword))) {
      return TaskComplexity.Simple;
    }

    // Default to moderate complexity
    return TaskComplexity.Moderate;
  }

  /**
   * Check if an agent is available
   * @param agentName Agent name
   * @returns Whether the agent is available
   */
  public isAgentAvailable(agentName: string): boolean {
    // If we have an explicit availability setting, use that
    if (this.agentAvailability.has(agentName)) {
      return this.agentAvailability.get(agentName)!;
    }

    // Otherwise, check the agent's default availability
    const agent = this.agents.find(a => a.name === agentName);
    return agent ? agent.available : false;
  }

  /**
   * Set agent availability
   * @param agentName Agent name
   * @param available Whether the agent is available
   */
  public setAgentAvailability(agentName: string, available: boolean): void {
    this.agentAvailability.set(agentName, available);
    this.outputChannel.appendLine(`Set ${agentName} availability to ${available}`);
  }

  /**
   * Dispose of resources
   */
  public dispose(): void {
    this.outputChannel.dispose();
  }
}

```


---

### File: `src/agents/dynamicAgentSelector.ts`

```typescript
/**
 * Dynamic Agent Selector
 * 
 * Selects the most appropriate agent for a task based on its requirements,
 * complexity, and domain.
 */

import * as vscode from 'vscode';
import {
  Agent,
  AgentCapability,
  AgentType,
  ModelSize,
  Task,
  TaskComplexity,
  TaskDomain,
  ThinkingMode
} from './types';

/**
 * Agent Selector class for dynamic agent selection
 */
export class AgentSelector {
  private outputChannel: vscode.OutputChannel;
  private agents: Agent[];
  private agentAvailability: Map<string, boolean>;

  /**
   * Constructor
   */
  constructor() {
    this.outputChannel = vscode.window.createOutputChannel('Dynamic Agent Selector');
    this.agentAvailability = new Map<string, boolean>();
    
    // Initialize available agents
    this.agents = [
      {
        name: 'SimpleAgent',
        type: AgentType.Simple,
        capabilities: ['code'],
        modelSize: ModelSize.Small,
        maxComplexity: TaskComplexity.Simple,
        systemPrompt: 'You are a simple coding assistant that helps with basic tasks.',
        available: true
      },
      {
        name: 'DevelopmentAgent',
        type: AgentType.Development,
        capabilities: ['code', 'context', 'reasoning'],
        modelSize: ModelSize.Large,
        maxComplexity: TaskComplexity.Complex,
        systemPrompt: 'You are a development assistant that helps with coding tasks.',
        available: true
      },
      {
        name: 'ArchitectAgent',
        type: AgentType.Architecture,
        capabilities: ['code', 'context', 'reasoning', 'architecture'],
        modelSize: ModelSize.XLarge,
        maxComplexity: TaskComplexity.VeryComplex,
        systemPrompt: 'You are an architecture assistant that helps with system design and architecture.',
        available: true
      },
      {
        name: 'DevOpsAgent',
        type: AgentType.DevOps,
        capabilities: ['code', 'tools', 'context'],
        modelSize: ModelSize.Large,
        maxComplexity: TaskComplexity.Complex,
        specializations: ['github', 'docker', 'ci-cd'],
        systemPrompt: 'You are a DevOps assistant that helps with CI/CD, deployment, and infrastructure.',
        available: true
      },
      {
        name: 'MLAgent',
        type: AgentType.ML,
        capabilities: ['code', 'context', 'reasoning'],
        modelSize: ModelSize.XLarge,
        maxComplexity: TaskComplexity.VeryComplex,
        specializations: ['machine-learning', 'data-science', 'neural-networks'],
        systemPrompt: 'You are a machine learning assistant that helps with ML models and algorithms.',
        available: true
      },
      {
        name: 'WebDevAgent',
        type: AgentType.WebDev,
        capabilities: ['code', 'context'],
        modelSize: ModelSize.Medium,
        maxComplexity: TaskComplexity.Complex,
        specializations: ['web-development', 'frontend', 'backend'],
        systemPrompt: 'You are a web development assistant that helps with frontend and backend tasks.',
        available: true
      }
    ];
    
    this.outputChannel.appendLine('Dynamic Agent Selector initialized with ' + this.agents.length + ' agents');
  }

  /**
   * Select the most appropriate agent for a task
   * @param task The task to select an agent for
   * @returns The selected agent
   */
  public async selectAgent(task: Task): Promise<Agent> {
    try {
      this.outputChannel.appendLine(`Selecting agent for task: ${task.description}`);
      
      // Determine task complexity if not specified
      if (!task.complexity) {
        task.complexity = this.analyzeTaskComplexity(task.description);
        this.outputChannel.appendLine(`Inferred task complexity: ${task.complexity}`);
      }
      
      // Filter agents by availability
      const availableAgents = this.agents.filter(agent => 
        this.isAgentAvailable(agent.name)
      );
      
      if (availableAgents.length === 0) {
        throw new Error('No agents available');
      }
      
      // Filter agents by complexity
      const complexityMap: Record<TaskComplexity, number> = {
        [TaskComplexity.Simple]: 1,
        [TaskComplexity.Moderate]: 2,
        [TaskComplexity.Complex]: 3,
        [TaskComplexity.VeryComplex]: 4
      };
      
      const taskComplexityValue = complexityMap[task.complexity];
      
      const capableAgents = availableAgents.filter(agent => {
        const agentComplexityValue = complexityMap[agent.maxComplexity];
        return agentComplexityValue >= taskComplexityValue;
      });
      
      if (capableAgents.length === 0) {
        // Fallback to the agent with the highest complexity capability
        const fallbackAgent = availableAgents.sort((a, b) => 
          complexityMap[b.maxComplexity] - complexityMap[a.maxComplexity]
        )[0];
        
        this.outputChannel.appendLine(`No agent capable of handling complexity ${task.complexity}, falling back to ${fallbackAgent.name}`);
        return fallbackAgent;
      }
      
      // Filter by required capabilities
      let filteredAgents = capableAgents;
      
      if (task.requiresContext) {
        filteredAgents = filteredAgents.filter(agent => 
          agent.capabilities.includes('context')
        );
      }
      
      if (task.requiresTools) {
        filteredAgents = filteredAgents.filter(agent => 
          agent.capabilities.includes('tools')
        );
      }
      
      if (filteredAgents.length === 0) {
        this.outputChannel.appendLine(`No agent with required capabilities, falling back to most capable agent`);
        return capableAgents[0];
      }
      
      // Filter by domain specialization if specified
      if (task.domain && task.domain !== 'general') {
        const domainAgents = filteredAgents.filter(agent => 
          agent.specializations?.some(spec => 
            spec.toLowerCase().includes(task.domain!.toLowerCase())
          )
        );
        
        if (domainAgents.length > 0) {
          filteredAgents = domainAgents;
          this.outputChannel.appendLine(`Found ${domainAgents.length} agents specialized in ${task.domain}`);
        }
      }
      
      // Filter by required tools if specified
      if (task.requiredTools && task.requiredTools.length > 0) {
        // For this example, we'll just check if the agent has tools capability
        // In a real implementation, we would check if the agent supports the specific tools
        const toolAgents = filteredAgents.filter(agent => 
          agent.capabilities.includes('tools')
        );
        
        if (toolAgents.length > 0) {
          filteredAgents = toolAgents;
          this.outputChannel.appendLine(`Found ${toolAgents.length} agents with required tool support`);
        }
      }
      
      // Select the best agent from the filtered list
      // For now, we'll just take the first one
      // In a real implementation, we might use a more sophisticated selection algorithm
      const selectedAgent = filteredAgents[0];
      
      this.outputChannel.appendLine(`Selected agent: ${selectedAgent.name}`);
      return selectedAgent;
    } catch (error) {
      this.outputChannel.appendLine(`Error selecting agent: ${error.message}`);
      
      // Return a default agent as fallback
      const defaultAgent = this.agents.find(a => a.name === 'DevelopmentAgent') || this.agents[0];
      this.outputChannel.appendLine(`Falling back to default agent: ${defaultAgent.name}`);
      
      return defaultAgent;
    }
  }

  /**
   * Analyze task description to determine complexity
   * @param description Task description
   * @returns Inferred task complexity
   */
  private analyzeTaskComplexity(description: string): TaskComplexity {
    const description_lower = description.toLowerCase();
    
    // Check for keywords indicating very complex tasks
    const veryComplexKeywords = [
      'architecture', 'redesign', 'system design', 'microservice', 
      'distributed', 'scale', 'optimize', 'performance', 'security',
      'refactor', 'monolithic'
    ];
    
    if (veryComplexKeywords.some(keyword => description_lower.includes(keyword))) {
      return TaskComplexity.Complex;
    }
    
    // Check for keywords indicating complex tasks
    const complexKeywords = [
      'implement', 'create', 'develop', 'build', 'design',
      'algorithm', 'feature', 'functionality', 'integration'
    ];
    
    if (complexKeywords.some(keyword => description_lower.includes(keyword))) {
      return TaskComplexity.Moderate;
    }
    
    // Check for keywords indicating simple tasks
    const simpleKeywords = [
      'fix', 'update', 'change', 'modify', 'add', 'remove',
      'format', 'rename', 'explain', 'help'
    ];
    
    if (simpleKeywords.some(keyword => description_lower.includes(keyword))) {
      return TaskComplexity.Simple;
    }
    
    // Default to moderate complexity
    return TaskComplexity.Moderate;
  }

  /**
   * Check if an agent is available
   * @param agentName Agent name
   * @returns Whether the agent is available
   */
  public isAgentAvailable(agentName: string): boolean {
    // If we have an explicit availability setting, use that
    if (this.agentAvailability.has(agentName)) {
      return this.agentAvailability.get(agentName)!;
    }
    
    // Otherwise, check the agent's default availability
    const agent = this.agents.find(a => a.name === agentName);
    return agent ? agent.available : false;
  }

  /**
   * Set agent availability
   * @param agentName Agent name
   * @param available Whether the agent is available
   */
  public setAgentAvailability(agentName: string, available: boolean): void {
    this.agentAvailability.set(agentName, available);
    this.outputChannel.appendLine(`Set ${agentName} availability to ${available}`);
  }

  /**
   * Dispose of resources
   */
  public dispose(): void {
    this.outputChannel.dispose();
  }
}

```


---

### File: `src/agents/agentCoordinator.ts`

```typescript
/**
 * Agent Coordinator
 *
 * The central component that orchestrates the hierarchical agent system.
 * Responsible for task decomposition, agent selection, and result aggregation.
 */

import * as vscode from 'vscode';
import { QwenApiClient } from '../qwenApi';
import { AgentSelector } from './agentSelector';
import { ResourceManager } from './resourceManager';
import { ResultAggregator } from './resultAggregator';
import { TaskDecomposer } from './taskDecomposer';
import {
    AgentResult,
    AgentType
} from './types';

/**
 * Agent Coordinator class
 */
export class AgentCoordinator {
  private taskDecomposer: TaskDecomposer;
  private agentSelector: AgentSelector;
  private resourceManager: ResourceManager;
  private resultAggregator: ResultAggregator;
  private qwenApi: QwenApiClient;
  private outputChannel: vscode.OutputChannel;
  private config: any;

  /**
   * Constructor
   */
  constructor() {
    this.outputChannel = vscode.window.createOutputChannel('Agent Coordinator');
    this.qwenApi = new QwenApiClient();
    this.taskDecomposer = new TaskDecomposer(this.qwenApi);
    this.agentSelector = new AgentSelector();
    this.resourceManager = new ResourceManager();
    this.resultAggregator = new ResultAggregator(this.qwenApi);

    this.outputChannel.appendLine('Agent Coordinator initialized');
  }

  /**
   * Update the configuration
   * @param config New configuration
   */
  public updateConfig(config: any): void {
    this.config = config;
    this.outputChannel.appendLine('Configuration updated');
  }

  /**
   * Process a user request
   * @param userRequest The user's request
   * @returns The final response
   */
  public async processRequest(userRequest: string): Promise<string> {
    try {
      this.outputChannel.appendLine(`Processing request: ${userRequest}`);

      // Get available resources
      const availableResources = await this.resourceManager.getAvailableResources();
      this.outputChannel.appendLine(`Available resources: ${JSON.stringify(availableResources)}`);

      // Decompose the task
      const subtasks = await this.taskDecomposer.decompose(userRequest, availableResources);
      this.outputChannel.appendLine(`Task decomposed into ${Object.keys(subtasks).length} subtasks`);

      // Select appropriate agents for each subtask
      const agentAssignments = await this.agentSelector.selectAgents(subtasks, availableResources);
      this.outputChannel.appendLine(`Agent assignments: ${JSON.stringify(agentAssignments)}`);

      // Execute subtasks with assigned agents
      const results: Record<string, AgentResult> = {};
      for (const subtaskId in agentAssignments) {
        const agentInfo = agentAssignments[subtaskId];
        const subtask = subtasks[subtaskId];

        this.outputChannel.appendLine(`Executing subtask ${subtaskId} with agent ${agentInfo.type}`);

        // Check if all dependencies are completed
        const dependenciesMet = subtask.dependencies.every(depId => results[depId] && results[depId].status === 'success');
        if (!dependenciesMet) {
          this.outputChannel.appendLine(`Skipping subtask ${subtaskId} due to unmet dependencies`);
          continue;
        }

        // Execute the subtask
        try {
          const agent = await this.instantiateAgent(agentInfo);
          results[subtaskId] = await agent.execute(subtask);
          this.outputChannel.appendLine(`Subtask ${subtaskId} completed successfully`);
        } catch (error) {
          this.outputChannel.appendLine(`Error executing subtask ${subtaskId}: ${error.message}`);
          results[subtaskId] = {
            subtaskId,
            content: '',
            status: 'error',
            error: error.message
          };
        }
      }

      // Aggregate results
      const finalResponse = await this.resultAggregator.aggregate(results, subtasks);
      this.outputChannel.appendLine('Request processing completed');

      return finalResponse;
    } catch (error) {
      this.outputChannel.appendLine(`Error processing request: ${error.message}`);
      throw error;
    }
  }

  /**
   * Instantiate an agent based on agent info
   * @param agentInfo The agent information
   * @returns The instantiated agent
   */
  private async instantiateAgent(agentInfo: any): Promise<any> {
    // This is a placeholder for agent instantiation
    // In a real implementation, we would dynamically import and instantiate the appropriate agent

    const agentType = agentInfo.type;
    const modelSize = agentInfo.modelSize;
    const thinkingMode = agentInfo.thinkingMode;

    this.outputChannel.appendLine(`Instantiating agent: ${agentType} with model ${modelSize} and thinking mode ${thinkingMode}`);

    // Register the agent with the resource manager
    const agentId = await this.resourceManager.registerAgent(agentType, {
      modelSize,
      thinkingMode
    });

    // Import the appropriate agent class
    try {
      switch (agentType) {
        case AgentType.Development:
          const { DevelopmentAgent } = await import('./developmentAgent');
          return new DevelopmentAgent(agentId, this.qwenApi, modelSize, thinkingMode);

        case AgentType.Testing:
          const { TestingAgent } = await import('./testingAgent');
          return new TestingAgent(agentId, this.qwenApi, modelSize, thinkingMode);

        case AgentType.CICD:
          const { CICDAgent } = await import('./cicdAgent');
          return new CICDAgent(agentId, this.qwenApi, modelSize, thinkingMode);

        case AgentType.GitHub:
          const { GitHubAgent } = await import('./githubAgent');
          return new GitHubAgent(agentId, this.qwenApi, modelSize, thinkingMode);

        default:
          throw new Error(`Unsupported agent type: ${agentType}`);
      }
    } catch (error) {
      this.outputChannel.appendLine(`Error instantiating agent: ${error.message}`);
      await this.resourceManager.unregisterAgent(agentId);
      throw error;
    }
  }

  /**
   * Dispose of resources
   */
  public dispose(): void {
    this.outputChannel.dispose();
  }
}

```


---

### File: `src/agents/agentSelectorTest.ts`

```typescript
/**
 * Standalone test for the dynamic agent selector
 * 
 * This file contains a simplified version of the agent selector that can be tested
 * without the VS Code extension API.
 */

// Agent types
enum AgentType {
  Simple = 'simple',
  Development = 'development',
  Architecture = 'architecture',
  DevOps = 'devops',
  ML = 'machine_learning',
  WebDev = 'web_development'
}

// Model sizes
enum ModelSize {
  Small = 'small',
  Medium = 'medium',
  Large = 'large',
  XLarge = 'xlarge'
}

// Task complexity levels
enum TaskComplexity {
  Simple = 'simple',
  Moderate = 'moderate',
  Complex = 'complex',
  VeryComplex = 'very_complex'
}

// Agent capabilities
type AgentCapability = 'context' | 'tools' | 'reasoning' | 'code' | 'testing' | 'documentation' | 'architecture';

// Agent definition
interface Agent {
  name: string;
  type: AgentType;
  capabilities: AgentCapability[];
  modelSize: ModelSize;
  maxComplexity: TaskComplexity;
  specializations?: string[];
  systemPrompt: string;
  available: boolean;
}

// Task domain types
type TaskDomain = 'general' | 'web-development' | 'machine-learning' | 'devops' | 'database' | 'mobile-development';

// Context scope types
type ContextScope = 'none' | 'file' | 'directory' | 'project' | 'deep';

// Task definition
interface Task {
  description: string;
  complexity?: TaskComplexity;
  requiresContext: boolean;
  requiresTools: boolean;
  contextScope?: ContextScope;
  requiredTools?: string[];
  domain?: TaskDomain;
}

/**
 * Agent Selector class for dynamic agent selection
 */
class AgentSelector {
  private agents: Agent[];
  private agentAvailability: Map<string, boolean>;

  /**
   * Constructor
   */
  constructor() {
    this.agentAvailability = new Map<string, boolean>();
    
    // Initialize available agents
    this.agents = [
      {
        name: 'SimpleAgent',
        type: AgentType.Simple,
        capabilities: ['code'],
        modelSize: ModelSize.Small,
        maxComplexity: TaskComplexity.Simple,
        systemPrompt: 'You are a simple coding assistant that helps with basic tasks.',
        available: true
      },
      {
        name: 'DevelopmentAgent',
        type: AgentType.Development,
        capabilities: ['code', 'context', 'reasoning'],
        modelSize: ModelSize.Large,
        maxComplexity: TaskComplexity.Complex,
        systemPrompt: 'You are a development assistant that helps with coding tasks.',
        available: true
      },
      {
        name: 'ArchitectAgent',
        type: AgentType.Architecture,
        capabilities: ['code', 'context', 'reasoning', 'architecture'],
        modelSize: ModelSize.XLarge,
        maxComplexity: TaskComplexity.VeryComplex,
        systemPrompt: 'You are an architecture assistant that helps with system design and architecture.',
        available: true
      },
      {
        name: 'DevOpsAgent',
        type: AgentType.DevOps,
        capabilities: ['code', 'tools', 'context'],
        modelSize: ModelSize.Large,
        maxComplexity: TaskComplexity.Complex,
        specializations: ['github', 'docker', 'ci-cd'],
        systemPrompt: 'You are a DevOps assistant that helps with CI/CD, deployment, and infrastructure.',
        available: true
      },
      {
        name: 'MLAgent',
        type: AgentType.ML,
        capabilities: ['code', 'context', 'reasoning'],
        modelSize: ModelSize.XLarge,
        maxComplexity: TaskComplexity.VeryComplex,
        specializations: ['machine-learning', 'data-science', 'neural-networks'],
        systemPrompt: 'You are a machine learning assistant that helps with ML models and algorithms.',
        available: true
      },
      {
        name: 'WebDevAgent',
        type: AgentType.WebDev,
        capabilities: ['code', 'context'],
        modelSize: ModelSize.Medium,
        maxComplexity: TaskComplexity.Complex,
        specializations: ['web-development', 'frontend', 'backend'],
        systemPrompt: 'You are a web development assistant that helps with frontend and backend tasks.',
        available: true
      }
    ];
    
    console.log('Dynamic Agent Selector initialized with ' + this.agents.length + ' agents');
  }

  /**
   * Select the most appropriate agent for a task
   * @param task The task to select an agent for
   * @returns The selected agent
   */
  public async selectAgent(task: Task): Promise<Agent> {
    try {
      console.log(`Selecting agent for task: ${task.description}`);
      
      // Determine task complexity if not specified
      if (!task.complexity) {
        task.complexity = this.analyzeTaskComplexity(task.description);
        console.log(`Inferred task complexity: ${task.complexity}`);
      }
      
      // Filter agents by availability
      const availableAgents = this.agents.filter(agent => 
        this.isAgentAvailable(agent.name)
      );
      
      if (availableAgents.length === 0) {
        throw new Error('No agents available');
      }
      
      // Filter agents by complexity
      const complexityMap: Record<TaskComplexity, number> = {
        [TaskComplexity.Simple]: 1,
        [TaskComplexity.Moderate]: 2,
        [TaskComplexity.Complex]: 3,
        [TaskComplexity.VeryComplex]: 4
      };
      
      const taskComplexityValue = complexityMap[task.complexity];
      
      const capableAgents = availableAgents.filter(agent => {
        const agentComplexityValue = complexityMap[agent.maxComplexity];
        return agentComplexityValue >= taskComplexityValue;
      });
      
      if (capableAgents.length === 0) {
        // Fallback to the agent with the highest complexity capability
        const fallbackAgent = availableAgents.sort((a, b) => 
          complexityMap[b.maxComplexity] - complexityMap[a.maxComplexity]
        )[0];
        
        console.log(`No agent capable of handling complexity ${task.complexity}, falling back to ${fallbackAgent.name}`);
        return fallbackAgent;
      }
      
      // Filter by required capabilities
      let filteredAgents = capableAgents;
      
      if (task.requiresContext) {
        filteredAgents = filteredAgents.filter(agent => 
          agent.capabilities.includes('context')
        );
      }
      
      if (task.requiresTools) {
        filteredAgents = filteredAgents.filter(agent => 
          agent.capabilities.includes('tools')
        );
      }
      
      if (filteredAgents.length === 0) {
        console.log(`No agent with required capabilities, falling back to most capable agent`);
        return capableAgents[0];
      }
      
      // Filter by domain specialization if specified
      if (task.domain && task.domain !== 'general') {
        const domainAgents = filteredAgents.filter(agent => 
          agent.specializations?.some(spec => 
            spec.toLowerCase().includes(task.domain!.toLowerCase())
          )
        );
        
        if (domainAgents.length > 0) {
          filteredAgents = domainAgents;
          console.log(`Found ${domainAgents.length} agents specialized in ${task.domain}`);
        }
      }
      
      // Filter by required tools if specified
      if (task.requiredTools && task.requiredTools.length > 0) {
        // For this example, we'll just check if the agent has tools capability
        // In a real implementation, we would check if the agent supports the specific tools
        const toolAgents = filteredAgents.filter(agent => 
          agent.capabilities.includes('tools')
        );
        
        if (toolAgents.length > 0) {
          filteredAgents = toolAgents;
          console.log(`Found ${toolAgents.length} agents with required tool support`);
        }
      }
      
      // Select the best agent from the filtered list
      // For now, we'll just take the first one
      // In a real implementation, we might use a more sophisticated selection algorithm
      const selectedAgent = filteredAgents[0];
      
      console.log(`Selected agent: ${selectedAgent.name}`);
      return selectedAgent;
    } catch (error) {
      console.error(`Error selecting agent: ${error instanceof Error ? error.message : String(error)}`);
      
      // Return a default agent as fallback
      const defaultAgent = this.agents.find(a => a.name === 'DevelopmentAgent') || this.agents[0];
      console.log(`Falling back to default agent: ${defaultAgent.name}`);
      
      return defaultAgent;
    }
  }

  /**
   * Analyze task description to determine complexity
   * @param description Task description
   * @returns Inferred task complexity
   */
  private analyzeTaskComplexity(description: string): TaskComplexity {
    const description_lower = description.toLowerCase();
    
    // Check for keywords indicating very complex tasks
    const veryComplexKeywords = [
      'architecture', 'redesign', 'system design', 'microservice', 
      'distributed', 'scale', 'optimize', 'performance', 'security',
      'refactor', 'monolithic'
    ];
    
    if (veryComplexKeywords.some(keyword => description_lower.includes(keyword))) {
      return TaskComplexity.Complex;
    }
    
    // Check for keywords indicating complex tasks
    const complexKeywords = [
      'implement', 'create', 'develop', 'build', 'design',
      'algorithm', 'feature', 'functionality', 'integration'
    ];
    
    if (complexKeywords.some(keyword => description_lower.includes(keyword))) {
      return TaskComplexity.Moderate;
    }
    
    // Check for keywords indicating simple tasks
    const simpleKeywords = [
      'fix', 'update', 'change', 'modify', 'add', 'remove',
      'format', 'rename', 'explain', 'help'
    ];
    
    if (simpleKeywords.some(keyword => description_lower.includes(keyword))) {
      return TaskComplexity.Simple;
    }
    
    // Default to moderate complexity
    return TaskComplexity.Moderate;
  }

  /**
   * Check if an agent is available
   * @param agentName Agent name
   * @returns Whether the agent is available
   */
  public isAgentAvailable(agentName: string): boolean {
    // If we have an explicit availability setting, use that
    if (this.agentAvailability.has(agentName)) {
      return this.agentAvailability.get(agentName)!;
    }
    
    // Otherwise, check the agent's default availability
    const agent = this.agents.find(a => a.name === agentName);
    return agent ? agent.available : false;
  }

  /**
   * Set agent availability
   * @param agentName Agent name
   * @param available Whether the agent is available
   */
  public setAgentAvailability(agentName: string, available: boolean): void {
    this.agentAvailability.set(agentName, available);
    console.log(`Set ${agentName} availability to ${available}`);
  }
}

// Run tests
async function runTests() {
  const agentSelector = new AgentSelector();
  
  // Test 1: Simple task
  const simpleTask = {
    description: 'Format this code snippet',
    complexity: TaskComplexity.Simple,
    requiresContext: false,
    requiresTools: false
  };
  
  const simpleAgent = await agentSelector.selectAgent(simpleTask);
  console.assert(simpleAgent.name === 'SimpleAgent', 'Should select SimpleAgent for simple tasks');
  
  // Test 2: Moderate task
  const moderateTask = {
    description: 'Explain how this algorithm works',
    complexity: TaskComplexity.Moderate,
    requiresContext: true,
    requiresTools: false
  };
  
  const moderateAgent = await agentSelector.selectAgent(moderateTask);
  console.assert(moderateAgent.name === 'DevelopmentAgent', 'Should select DevelopmentAgent for moderate tasks');
  
  // Test 3: Complex task
  const complexTask = {
    description: 'Refactor this code to use the factory pattern',
    complexity: TaskComplexity.Complex,
    requiresContext: true,
    requiresTools: false
  };
  
  const complexAgent = await agentSelector.selectAgent(complexTask);
  console.assert(complexAgent.name === 'ArchitectAgent', 'Should select ArchitectAgent for complex tasks');
  
  // Test 4: Task requiring tools
  const taskRequiringTools = {
    description: 'Create a pull request for these changes',
    complexity: TaskComplexity.Moderate,
    requiresContext: true,
    requiresTools: true,
    requiredTools: ['github.createPullRequest']
  };
  
  const toolAgent = await agentSelector.selectAgent(taskRequiringTools);
  console.assert(toolAgent.capabilities.includes('tools'), 'Selected agent should have tools capability');
  console.assert(toolAgent.name === 'DevOpsAgent', 'Should select DevOpsAgent for tasks requiring GitHub tools');
  
  // Test 5: Task requiring context
  const taskRequiringContext = {
    description: 'Explain the relationship between these classes',
    complexity: TaskComplexity.Moderate,
    requiresContext: true,
    requiresTools: false,
    contextScope: 'deep' as ContextScope
  };
  
  const contextAgent = await agentSelector.selectAgent(taskRequiringContext);
  console.assert(contextAgent.capabilities.includes('context'), 'Selected agent should have context capability');
  console.assert(contextAgent.name === 'DevelopmentAgent', 'Should select DevelopmentAgent for tasks requiring deep context');
  
  // Test 6: Domain-specific tasks
  const mlTask = {
    description: 'Optimize this machine learning model',
    complexity: TaskComplexity.Complex,
    requiresContext: true,
    requiresTools: false,
    domain: 'machine-learning' as TaskDomain
  };
  
  const mlAgent = await agentSelector.selectAgent(mlTask);
  console.assert(mlAgent.name === 'MLAgent', 'Should select MLAgent for machine learning tasks');
  
  const webTask = {
    description: 'Create a responsive layout for this component',
    complexity: TaskComplexity.Moderate,
    requiresContext: true,
    requiresTools: false,
    domain: 'web-development' as TaskDomain
  };
  
  const webAgent = await agentSelector.selectAgent(webTask);
  console.assert(webAgent.name === 'WebDevAgent', 'Should select WebDevAgent for web development tasks');
  
  // Test 7: Infer complexity from description
  const implicitComplexTask = {
    description: 'Refactor this monolithic application into a microservices architecture',
    requiresContext: true,
    requiresTools: false
  };
  
  const inferredComplexityAgent = await agentSelector.selectAgent(implicitComplexTask);
  console.assert(inferredComplexityAgent.name === 'ArchitectAgent', 'Should infer complexity from description and select appropriate agent');
  
  // Test 8: Handle agent unavailability
  agentSelector.setAgentAvailability('ArchitectAgent', false);
  
  const unavailableAgentTask = {
    description: 'Design a scalable system architecture',
    complexity: TaskComplexity.Complex,
    requiresContext: true,
    requiresTools: false
  };
  
  const fallbackAgent = await agentSelector.selectAgent(unavailableAgentTask);
  console.assert(fallbackAgent.name !== 'ArchitectAgent', 'Should not select unavailable agent');
  console.assert(fallbackAgent.name === 'DevelopmentAgent', 'Should select fallback agent when preferred agent is unavailable');
  
  console.log('All tests completed successfully!');
}

// Run the tests
runTests().catch(error => {
  console.error('Test failed:', error);
});

```


---

### File: `src/agents/types.ts`

```typescript
/**
 * Type definitions for the hierarchical agent system
 */

/**
 * Agent types supported by the system
 */
export enum AgentType {
  Coordinator = 'coordinator',
  Development = 'development',
  Testing = 'testing',
  CICD = 'ci_cd',
  GitHub = 'github',
  Documentation = 'documentation',
  Architecture = 'architecture',
  Security = 'security',
  Performance = 'performance',
  Simple = 'simple',
  DevOps = 'devops',
  ML = 'machine_learning',
  WebDev = 'web_development'
}

/**
 * Model sizes available for agents
 */
export enum ModelSize {
  Tiny = 'Qwen3-0.6B',
  Small = 'Qwen3-1.7B',
  Medium = 'Qwen3-4B',
  Large = 'Qwen3-8B',
  XLarge = 'Qwen3-14B',
  XXLarge = 'Qwen3-32B',
  MoESmall = 'Qwen3-30B-A3B',
  MoELarge = 'Qwen3-235B-A22B'
}

/**
 * Task complexity levels
 */
export enum TaskComplexity {
  Low = 'low',
  Medium = 'medium',
  High = 'high',
  // New complexity levels for dynamic agent selection
  Simple = 'simple',
  Moderate = 'moderate',
  Complex = 'complex',
  VeryComplex = 'very_complex'
}

/**
 * Thinking mode options
 */
export enum ThinkingMode {
  Enabled = 'enabled',
  Disabled = 'disabled',
  Auto = 'auto'
}

/**
 * Agent configuration
 */
export interface AgentConfig {
  type: AgentType;
  modelSize: ModelSize;
  thinkingMode: ThinkingMode;
  systemMessage: string;
  maxTokens: number;
}

/**
 * Subtask definition
 */
export interface Subtask {
  id: string;
  description: string;
  expertise: AgentType;
  complexity: TaskComplexity;
  dependencies: string[];
}

/**
 * Agent result
 */
export interface AgentResult {
  subtaskId: string;
  thinking?: string;
  content: string;
  status: 'success' | 'error';
  error?: string;
}

/**
 * Resource usage information
 */
export interface ResourceUsage {
  memory: number;
  cpu: number;
  activeAgents: number;
}

/**
 * Agent status
 */
export interface AgentStatus {
  id: string;
  type: AgentType;
  modelSize: ModelSize;
  thinkingMode: ThinkingMode;
  status: 'idle' | 'running' | 'completed' | 'failed';
  startTime: number;
  endTime?: number;
  error?: string;
}

/**
 * Agent capabilities
 */
export type AgentCapability = 'context' | 'tools' | 'reasoning' | 'code' | 'testing' | 'documentation' | 'architecture';

/**
 * Agent definition for dynamic selection
 */
export interface Agent {
  name: string;
  type: AgentType;
  capabilities: AgentCapability[];
  modelSize: ModelSize;
  maxComplexity: TaskComplexity;
  specializations?: string[];
  systemPrompt: string;
  available: boolean;
}

/**
 * Task domain types
 */
export type TaskDomain = 'general' | 'web-development' | 'machine-learning' | 'devops' | 'database' | 'mobile-development';

/**
 * Context scope types
 */
export type ContextScope = 'none' | 'file' | 'directory' | 'project' | 'deep';

/**
 * Task definition for agent selection
 */
export interface Task {
  description: string;
  complexity?: TaskComplexity;
  requiresContext: boolean;
  requiresTools: boolean;
  contextScope?: ContextScope;
  requiredTools?: string[];
  domain?: TaskDomain;
}

```


---

### File: `src/agents/resourceManager.ts`

```typescript
/**
 * Resource Manager
 * 
 * Monitors system resources and controls agent instantiation.
 */

import * as vscode from 'vscode';
import * as os from 'os';
import { v4 as uuidv4 } from 'uuid';
import { AgentType, ModelSize, ThinkingMode, ResourceUsage } from './types';

/**
 * Resource Manager class
 */
export class ResourceManager {
  private outputChannel: vscode.OutputChannel;
  private activeAgents: Record<string, {
    type: AgentType;
    modelSize: ModelSize;
    thinkingMode: ThinkingMode;
    startTime: number;
  }>;
  private maxMemoryUsage: number;
  private maxCpuUsage: number;
  private resourceCheckInterval: NodeJS.Timeout | null;

  /**
   * Constructor
   * @param maxMemoryUsage Maximum memory usage (0-1)
   * @param maxCpuUsage Maximum CPU usage (0-1)
   */
  constructor(maxMemoryUsage = 0.8, maxCpuUsage = 0.8) {
    this.outputChannel = vscode.window.createOutputChannel('Resource Manager');
    this.activeAgents = {};
    this.maxMemoryUsage = maxMemoryUsage;
    this.maxCpuUsage = maxCpuUsage;
    this.resourceCheckInterval = null;
    
    // Start resource monitoring
    this._startResourceMonitoring();
    
    this.outputChannel.appendLine('Resource Manager initialized');
  }

  /**
   * Get available system resources
   * @returns Available resources
   */
  public async getAvailableResources(): Promise<ResourceUsage> {
    try {
      // Get current system resource usage
      const currentMemoryUsage = this._getMemoryUsage();
      const currentCpuUsage = await this._getCpuUsage();
      
      // Calculate available resources
      const availableMemory = Math.max(0, this.maxMemoryUsage - currentMemoryUsage);
      const availableCpu = Math.max(0, this.maxCpuUsage - currentCpuUsage);
      
      const resources = {
        memory: availableMemory,
        cpu: availableCpu,
        activeAgents: Object.keys(this.activeAgents).length
      };
      
      this.outputChannel.appendLine(`Available resources: memory=${availableMemory.toFixed(2)}, cpu=${availableCpu.toFixed(2)}, activeAgents=${resources.activeAgents}`);
      
      return resources;
    } catch (error) {
      this.outputChannel.appendLine(`Error getting available resources: ${error.message}`);
      
      // Return conservative estimates in case of error
      return {
        memory: 0.2,
        cpu: 0.2,
        activeAgents: Object.keys(this.activeAgents).length
      };
    }
  }

  /**
   * Register a new agent with its resource requirements
   * @param type Agent type
   * @param requirements Resource requirements
   * @returns Agent ID
   */
  public async registerAgent(
    type: AgentType, 
    requirements: { modelSize: ModelSize, thinkingMode: ThinkingMode }
  ): Promise<string> {
    const agentId = uuidv4();
    
    this.activeAgents[agentId] = {
      type,
      modelSize: requirements.modelSize,
      thinkingMode: requirements.thinkingMode,
      startTime: Date.now()
    };
    
    this.outputChannel.appendLine(`Registered agent ${agentId} of type ${type} with model ${requirements.modelSize}`);
    
    return agentId;
  }

  /**
   * Unregister an agent when it's no longer needed
   * @param agentId Agent ID
   */
  public async unregisterAgent(agentId: string): Promise<void> {
    if (agentId in this.activeAgents) {
      const agent = this.activeAgents[agentId];
      const duration = (Date.now() - agent.startTime) / 1000;
      
      this.outputChannel.appendLine(`Unregistered agent ${agentId} of type ${agent.type} after ${duration.toFixed(2)}s`);
      
      delete this.activeAgents[agentId];
    }
  }

  /**
   * Get current memory usage
   * @returns Memory usage (0-1)
   */
  private _getMemoryUsage(): number {
    const totalMem = os.totalmem();
    const freeMem = os.freemem();
    const usedMem = totalMem - freeMem;
    
    return usedMem / totalMem;
  }

  /**
   * Get current CPU usage
   * @returns CPU usage (0-1)
   */
  private async _getCpuUsage(): Promise<number> {
    return new Promise<number>((resolve) => {
      const startMeasure = os.cpus().map(cpu => cpu.times);
      
      // Measure CPU usage over a short interval
      setTimeout(() => {
        const endMeasure = os.cpus().map(cpu => cpu.times);
        const cpuUsage = endMeasure.map((end, i) => {
          const start = startMeasure[i];
          const idle = end.idle - start.idle;
          const total = (end.user - start.user) + 
                        (end.nice - start.nice) + 
                        (end.sys - start.sys) + 
                        (end.irq - start.irq) + 
                        idle;
          
          return 1 - (idle / total);
        });
        
        // Average CPU usage across all cores
        const avgCpuUsage = cpuUsage.reduce((sum, usage) => sum + usage, 0) / cpuUsage.length;
        
        resolve(avgCpuUsage);
      }, 100);
    });
  }

  /**
   * Start resource monitoring
   */
  private _startResourceMonitoring(): void {
    if (this.resourceCheckInterval) {
      clearInterval(this.resourceCheckInterval);
    }
    
    this.resourceCheckInterval = setInterval(async () => {
      try {
        const resources = await this.getAvailableResources();
        
        // Log resource usage periodically
        if (Object.keys(this.activeAgents).length > 0) {
          this.outputChannel.appendLine(`Resource check: memory=${(1 - resources.memory).toFixed(2)}, cpu=${(1 - resources.cpu).toFixed(2)}, activeAgents=${resources.activeAgents}`);
        }
        
        // Check for resource constraints
        if (resources.memory < 0.1 || resources.cpu < 0.1) {
          this.outputChannel.appendLine('WARNING: System resources are critically low');
          
          // Notify the user
          vscode.window.showWarningMessage('System resources are running low. Some agent operations may be delayed.');
        }
      } catch (error) {
        this.outputChannel.appendLine(`Error monitoring resources: ${error.message}`);
      }
    }, 30000); // Check every 30 seconds
  }

  /**
   * Dispose of resources
   */
  public dispose(): void {
    if (this.resourceCheckInterval) {
      clearInterval(this.resourceCheckInterval);
      this.resourceCheckInterval = null;
    }
    
    this.outputChannel.dispose();
  }
}

```


---

### File: `src/agents/resultAggregator.ts`

```typescript
/**
 * Result Aggregator
 * 
 * Combines outputs from multiple agents into a coherent response.
 */

import * as vscode from 'vscode';
import { Subtask, AgentResult } from './types';
import { QwenApiClient } from '../qwenApi';

/**
 * Result Aggregator class
 */
export class ResultAggregator {
  private qwenApi: QwenApiClient;
  private outputChannel: vscode.OutputChannel;

  /**
   * Constructor
   * @param qwenApi The Qwen API client
   */
  constructor(qwenApi: QwenApiClient) {
    this.qwenApi = qwenApi;
    this.outputChannel = vscode.window.createOutputChannel('Result Aggregator');
  }

  /**
   * Aggregate results from multiple agents
   * @param results The results from each agent
   * @param subtasks The original subtasks
   * @returns The aggregated response
   */
  public async aggregate(
    results: Record<string, AgentResult>, 
    subtasks: Record<string, Subtask>
  ): Promise<string> {
    try {
      this.outputChannel.appendLine(`Aggregating results from ${Object.keys(results).length} agents`);
      
      // Check if we have any results
      if (Object.keys(results).length === 0) {
        return 'No results were generated. Please try again with a more specific request.';
      }
      
      // Check if we have only one result
      if (Object.keys(results).length === 1) {
        const result = Object.values(results)[0];
        return result.content;
      }
      
      // Prepare the system message
      const systemMessage = `
        You are a Result Aggregator. Your job is to combine outputs from multiple specialized agents into a coherent, unified response.
        Ensure that the final response is well-structured, consistent, and addresses all aspects of the original request.
        
        Follow these guidelines:
        1. Organize information logically, grouping related content together
        2. Eliminate redundancies while preserving important details
        3. Ensure a consistent tone and style throughout
        4. Highlight key insights and recommendations
        5. Format code snippets, commands, and technical information appropriately
        6. Provide a clear summary at the beginning if the response is lengthy
      `;
      
      // Prepare the context with all results
      let context = "Here are the results from different specialized agents:\n\n";
      
      // Sort subtasks by dependencies to maintain logical order
      const sortedSubtaskIds = this._sortSubtasksByDependencies(subtasks);
      
      // Add results in dependency order
      for (const subtaskId of sortedSubtaskIds) {
        if (results[subtaskId]) {
          const subtask = subtasks[subtaskId];
          const result = results[subtaskId];
          
          context += `## Subtask: ${subtask.description}\n`;
          context += `Expertise: ${subtask.expertise}\n`;
          context += `Status: ${result.status}\n`;
          
          if (result.status === 'error') {
            context += `Error: ${result.error}\n\n`;
          } else {
            context += `Result:\n${result.content}\n\n`;
          }
        }
      }
      
      // Prepare the user message
      const userMessage = `Please combine these results into a coherent response:\n\n${context}`;
      
      // Prepare the messages for the API call
      const messages = [
        { role: 'system', content: systemMessage },
        { role: 'user', content: userMessage }
      ];
      
      // Call the Qwen API with thinking mode enabled
      const response = await this.qwenApi.chat(messages, {
        enableThinking: true,
        temperature: 0.3,
        maxTokens: 4096
      });
      
      this.outputChannel.appendLine('Results aggregated successfully');
      
      return response;
    } catch (error) {
      this.outputChannel.appendLine(`Error aggregating results: ${error.message}`);
      
      // Fallback: concatenate results
      let fallbackResponse = '# Combined Agent Results\n\n';
      
      for (const subtaskId in results) {
        const result = results[subtaskId];
        const subtask = subtasks[subtaskId];
        
        fallbackResponse += `## ${subtask.description}\n\n`;
        
        if (result.status === 'error') {
          fallbackResponse += `**Error:** ${result.error}\n\n`;
        } else {
          fallbackResponse += `${result.content}\n\n`;
        }
      }
      
      return fallbackResponse;
    }
  }

  /**
   * Sort subtasks by dependencies
   * @param subtasks The subtasks to sort
   * @returns Sorted subtask IDs
   */
  private _sortSubtasksByDependencies(subtasks: Record<string, Subtask>): string[] {
    const visited = new Set<string>();
    const result: string[] = [];
    
    const visit = (id: string) => {
      if (visited.has(id)) {
        return;
      }
      
      visited.add(id);
      
      // Visit dependencies first
      for (const depId of subtasks[id].dependencies) {
        if (subtasks[depId]) {
          visit(depId);
        }
      }
      
      result.push(id);
    };
    
    // Visit all subtasks
    for (const id in subtasks) {
      visit(id);
    }
    
    return result;
  }

  /**
   * Dispose of resources
   */
  public dispose(): void {
    this.outputChannel.dispose();
  }
}

```


---

### File: `src/agents/taskDecomposer.ts`

```typescript
/**
 * Task Decomposer
 * 
 * Breaks down complex user requests into smaller, manageable subtasks.
 * Uses Qwen's thinking mode to perform detailed analysis.
 */

import * as vscode from 'vscode';
import { v4 as uuidv4 } from 'uuid';
import { AgentType, TaskComplexity, Subtask, ResourceUsage } from './types';
import { QwenApiClient } from '../qwenApi';

/**
 * Task Decomposer class
 */
export class TaskDecomposer {
  private qwenApi: QwenApiClient;
  private outputChannel: vscode.OutputChannel;

  /**
   * Constructor
   * @param qwenApi The Qwen API client
   */
  constructor(qwenApi: QwenApiClient) {
    this.qwenApi = qwenApi;
    this.outputChannel = vscode.window.createOutputChannel('Task Decomposer');
  }

  /**
   * Decompose a user request into subtasks
   * @param userRequest The user's request
   * @param availableResources Available system resources
   * @returns A record of subtasks
   */
  public async decompose(userRequest: string, availableResources: ResourceUsage): Promise<Record<string, Subtask>> {
    try {
      this.outputChannel.appendLine(`Decomposing request: ${userRequest}`);
      
      // Prepare the system message for task decomposition
      const systemMessage = `
        You are a task decomposition expert. Your job is to break down complex DevOps tasks into smaller, manageable subtasks.
        For each subtask, provide:
        1. A unique ID
        2. A clear description
        3. Required expertise (development, testing, ci_cd, github, documentation, architecture, security, performance)
        4. Estimated complexity (low, medium, high)
        5. Dependencies on other subtasks (if any)
        
        Format your response as a JSON object with the following structure:
        {
          "subtasks": [
            {
              "id": "unique_id",
              "description": "Clear description of the subtask",
              "expertise": "One of: development, testing, ci_cd, github, documentation, architecture, security, performance",
              "complexity": "One of: low, medium, high",
              "dependencies": ["id_of_dependency_1", "id_of_dependency_2"]
            },
            ...
          ]
        }
        
        Consider the available system resources when decomposing the task:
        - Memory: ${availableResources.memory * 100}%
        - CPU: ${availableResources.cpu * 100}%
        - Active Agents: ${availableResources.activeAgents}
        
        If resources are limited, prioritize essential subtasks and reduce complexity.
      `;
      
      // Prepare the messages for the API call
      const messages = [
        { role: 'system', content: systemMessage },
        { role: 'user', content: `Please decompose the following DevOps task into subtasks: ${userRequest}` }
      ];
      
      // Call the Qwen API with thinking mode enabled
      const response = await this.qwenApi.chat(messages, {
        enableThinking: true,
        temperature: 0.2,
        maxTokens: 2048
      });
      
      // Parse the response to extract subtasks
      const subtasks = this._parseSubtasks(response);
      
      // Validate subtasks and ensure they're within resource constraints
      const validatedSubtasks = this._validateSubtasks(subtasks, availableResources);
      
      this.outputChannel.appendLine(`Decomposed into ${Object.keys(validatedSubtasks).length} subtasks`);
      return validatedSubtasks;
    } catch (error) {
      this.outputChannel.appendLine(`Error decomposing task: ${error.message}`);
      throw error;
    }
  }

  /**
   * Parse the LLM response to extract subtasks
   * @param response The LLM response
   * @returns A record of subtasks
   */
  private _parseSubtasks(response: string): Record<string, Subtask> {
    try {
      // Extract JSON from the response
      const jsonMatch = response.match(/```json\n([\s\S]*?)\n```/) || 
                        response.match(/{[\s\S]*?}/);
      
      if (!jsonMatch) {
        throw new Error('No valid JSON found in the response');
      }
      
      const jsonStr = jsonMatch[0].startsWith('```') ? jsonMatch[1] : jsonMatch[0];
      const parsed = JSON.parse(jsonStr);
      
      if (!parsed.subtasks || !Array.isArray(parsed.subtasks)) {
        throw new Error('Invalid subtasks format in the response');
      }
      
      // Convert array to record
      const subtasks: Record<string, Subtask> = {};
      for (const subtask of parsed.subtasks) {
        // Ensure the subtask has a valid ID
        const id = subtask.id || uuidv4();
        
        // Ensure the subtask has valid dependencies
        const dependencies = Array.isArray(subtask.dependencies) ? subtask.dependencies : [];
        
        // Create the subtask object
        subtasks[id] = {
          id,
          description: subtask.description || '',
          expertise: this._validateExpertise(subtask.expertise),
          complexity: this._validateComplexity(subtask.complexity),
          dependencies
        };
      }
      
      return subtasks;
    } catch (error) {
      this.outputChannel.appendLine(`Error parsing subtasks: ${error.message}`);
      
      // Fallback: create a single subtask
      const id = uuidv4();
      return {
        [id]: {
          id,
          description: 'Execute the requested task',
          expertise: AgentType.Development,
          complexity: TaskComplexity.Medium,
          dependencies: []
        }
      };
    }
  }

  /**
   * Validate the expertise field
   * @param expertise The expertise string
   * @returns A valid AgentType
   */
  private _validateExpertise(expertise: string): AgentType {
    if (!expertise || typeof expertise !== 'string') {
      return AgentType.Development;
    }
    
    const normalized = expertise.toLowerCase();
    
    switch (normalized) {
      case 'development':
        return AgentType.Development;
      case 'testing':
        return AgentType.Testing;
      case 'ci_cd':
      case 'cicd':
        return AgentType.CICD;
      case 'github':
        return AgentType.GitHub;
      case 'documentation':
        return AgentType.Documentation;
      case 'architecture':
        return AgentType.Architecture;
      case 'security':
        return AgentType.Security;
      case 'performance':
        return AgentType.Performance;
      default:
        return AgentType.Development;
    }
  }

  /**
   * Validate the complexity field
   * @param complexity The complexity string
   * @returns A valid TaskComplexity
   */
  private _validateComplexity(complexity: string): TaskComplexity {
    if (!complexity || typeof complexity !== 'string') {
      return TaskComplexity.Medium;
    }
    
    const normalized = complexity.toLowerCase();
    
    switch (normalized) {
      case 'low':
        return TaskComplexity.Low;
      case 'medium':
        return TaskComplexity.Medium;
      case 'high':
        return TaskComplexity.High;
      default:
        return TaskComplexity.Medium;
    }
  }

  /**
   * Validate subtasks and ensure they're within resource constraints
   * @param subtasks The subtasks to validate
   * @param availableResources Available system resources
   * @returns Validated subtasks
   */
  private _validateSubtasks(subtasks: Record<string, Subtask>, availableResources: ResourceUsage): Record<string, Subtask> {
    // Check if we have enough resources for all subtasks
    const totalSubtasks = Object.keys(subtasks).length;
    
    if (totalSubtasks > 10 && availableResources.memory < 0.5) {
      // If resources are limited, reduce the number of subtasks
      this.outputChannel.appendLine('Limited resources detected, reducing number of subtasks');
      
      // Sort subtasks by dependencies (fewer dependencies first)
      const sortedSubtasks = Object.values(subtasks).sort((a, b) => 
        a.dependencies.length - b.dependencies.length
      );
      
      // Keep only the first 5-10 subtasks
      const maxSubtasks = Math.max(5, Math.min(10, Math.floor(availableResources.memory * 20)));
      const reducedSubtasks: Record<string, Subtask> = {};
      
      for (let i = 0; i < Math.min(maxSubtasks, sortedSubtasks.length); i++) {
        const subtask = sortedSubtasks[i];
        reducedSubtasks[subtask.id] = subtask;
      }
      
      return reducedSubtasks;
    }
    
    // Check for circular dependencies
    const visited = new Set<string>();
    const visiting = new Set<string>();
    
    const hasCycle = (id: string): boolean => {
      if (visiting.has(id)) {
        return true;
      }
      
      if (visited.has(id)) {
        return false;
      }
      
      visiting.add(id);
      
      for (const depId of subtasks[id].dependencies) {
        if (!subtasks[depId]) {
          // Remove invalid dependency
          subtasks[id].dependencies = subtasks[id].dependencies.filter(d => d !== depId);
          continue;
        }
        
        if (hasCycle(depId)) {
          return true;
        }
      }
      
      visiting.delete(id);
      visited.add(id);
      
      return false;
    };
    
    // Check each subtask for cycles
    for (const id in subtasks) {
      if (hasCycle(id)) {
        // Remove circular dependencies
        this.outputChannel.appendLine(`Circular dependency detected in subtask ${id}, removing dependencies`);
        subtasks[id].dependencies = [];
      }
    }
    
    return subtasks;
  }

  /**
   * Dispose of resources
   */
  public dispose(): void {
    this.outputChannel.dispose();
  }
}

```


---

### File: `src/test/mcpQwenIntegrationTest.ts`

```typescript
/**
 * Test for MCP-Qwen integration
 */

import * as vscode from 'vscode';
import { QwenApiClient } from '../qwenApi';
import { McpClient } from '../mcp/mcpClient';
import { McpQwenBridge } from '../mcp/mcpQwenBridge';
import { ContainerManager } from '../containers/containerManager';
import { getConfiguration } from '../configuration';

/**
 * Run the MCP-Qwen integration test
 */
export async function runMcpQwenIntegrationTest(): Promise<void> {
  // Create output channel
  const outputChannel = vscode.window.createOutputChannel('MCP-Qwen Integration Test');
  outputChannel.show();
  
  try {
    outputChannel.appendLine('Starting MCP-Qwen integration test...');
    
    // Get configuration
    const config = getConfiguration();
    outputChannel.appendLine(`Using API endpoint: ${config.apiEndpoint}`);
    
    // Create Qwen API client
    const qwenClient = new QwenApiClient(config);
    outputChannel.appendLine('Created Qwen API client');
    
    // Create container manager
    const containerManager = new ContainerManager();
    outputChannel.appendLine('Created container manager');
    
    // Create MCP client
    const mcpClient = new McpClient(containerManager);
    await mcpClient.initialize();
    outputChannel.appendLine('Initialized MCP client');
    
    // Create MCP-Qwen bridge
    const mcpQwenBridge = new McpQwenBridge(qwenClient, mcpClient);
    outputChannel.appendLine('Created MCP-Qwen bridge');
    
    // Get available tools
    const tools = await mcpClient.getAllTools();
    outputChannel.appendLine(`Found ${tools.length} tools:`);
    tools.forEach(tool => {
      outputChannel.appendLine(`- ${tool.serverId}.${tool.tool.name}: ${tool.tool.description}`);
    });
    
    // Test message processing
    outputChannel.appendLine('\nTesting message processing...');
    const message = 'What files are in the current workspace?';
    
    // Process message
    const response = await mcpQwenBridge.processMessage(message, {
      systemPrompt: 'You are a helpful assistant that can use tools to answer questions.',
      thinkingMode: 'auto',
      gatherContext: true
    });
    
    outputChannel.appendLine('\nResponse:');
    outputChannel.appendLine(response);
    
    // Test streaming message processing
    outputChannel.appendLine('\nTesting streaming message processing...');
    const streamingMessage = 'What is the current git branch?';
    
    // Process message with streaming
    let streamingResponse = '';
    await mcpQwenBridge.processMessageStream(
      streamingMessage,
      {
        systemPrompt: 'You are a helpful assistant that can use tools to answer questions.',
        thinkingMode: 'auto',
        gatherContext: true
      },
      (chunk, done) => {
        if (chunk) {
          outputChannel.append(chunk);
          streamingResponse += chunk;
        }
        
        if (done) {
          outputChannel.appendLine('\n\nStreaming complete');
        }
      }
    );
    
    outputChannel.appendLine('\nTest completed successfully');
  } catch (error) {
    outputChannel.appendLine(`\nError: ${error}`);
  }
}

/**
 * Register the MCP-Qwen integration test command
 */
export function registerMcpQwenIntegrationTestCommand(context: vscode.ExtensionContext): void {
  const disposable = vscode.commands.registerCommand('qwen-coder-assistant.testMcpQwenIntegration', async () => {
    await runMcpQwenIntegrationTest();
  });
  
  context.subscriptions.push(disposable);
}

```


---

### File: `src/test/mcpQwenBridgeTest.ts`

```typescript
/**
 * Test file for MCP-Qwen Bridge
 *
 * This file contains a simple test for the MCP-Qwen Bridge.
 * It can be run manually to verify the implementation.
 */

import * as vscode from 'vscode';
import { getConfiguration } from '../configuration';
import { ContainerManager } from '../containers/containerManager';
import { McpClient } from '../mcp/mcpClient';
import { McpQwenBridge } from '../mcp/mcpQwenBridge';
import { QwenApiClient } from '../qwenApi';

/**
 * Run the test
 */
export async function runMcpQwenBridgeTest(): Promise<void> {
  try {
    // Get configuration
    const config = getConfiguration();

    // Create Qwen API client
    const qwenClient = new QwenApiClient(config);

    // Create container manager
    const containerManager = new ContainerManager();

    // Create MCP client
    const mcpClient = new McpClient(containerManager);
    await mcpClient.initialize();

    // Create MCP-Qwen bridge
    const mcpQwenBridge = new McpQwenBridge(qwenClient, mcpClient);

    // Get available tools
    const tools = await mcpClient.getAllTools();
    console.log(`Found ${tools.length} tools`);

    // Process a test message
    if (tools.length > 0) {
      const response = await mcpQwenBridge.processMessage(
        `I need to use the following tools: ${tools.map(t => t.tool.name).join(', ')}. Please show me how to use them.`,
        {
          systemPrompt: 'You are a helpful assistant that can use MCP tools. When using tools, think step by step about what you need to do.',
          thinkingMode: 'auto',
          thinkingBudget: 1000
        }
      );

      // Show the response
      vscode.window.showInformationMessage('Test completed successfully!');
      console.log('Response:', response);

      // Create output channel to show the response
      const outputChannel = vscode.window.createOutputChannel('MCP-Qwen Bridge Test');
      outputChannel.appendLine('Available Tools:');
      tools.forEach(tool => {
        outputChannel.appendLine(`- ${tool.serverId}.${tool.tool.name}: ${tool.tool.description}`);
      });
      outputChannel.appendLine('\nResponse:');
      outputChannel.appendLine(response);
      outputChannel.show();
    } else {
      console.log('No tools available for testing');
      vscode.window.showWarningMessage('No MCP tools available for testing. Please start some MCP servers first.');
    }

    // Clean up
    mcpQwenBridge.dispose();
    mcpClient.dispose();
  } catch (error) {
    console.error('Error running MCP-Qwen bridge test:', error);
  }
}

// Run the test if this file is executed directly
if (require.main === module) {
  runMcpQwenBridgeTest().then(() => {
    console.log('Test completed');
  });
}

```


---

### File: `src/test/runTest.ts`

```typescript
import * as path from 'path';
import { runTests } from '@vscode/test-electron';

async function main() {
  try {
    // The folder containing the Extension Manifest package.json
    // Passed to `--extensionDevelopmentPath`
    const extensionDevelopmentPath = path.resolve(__dirname, '../../');

    // The path to the extension test script
    // Passed to --extensionTestsPath
    const extensionTestsPath = path.resolve(__dirname, './suite/index');

    // Download VS Code, unzip it and run the integration test
    await runTests({ extensionDevelopmentPath, extensionTestsPath });
  } catch (err) {
    console.error('Failed to run tests', err);
    process.exit(1);
  }
}

main();

```


---

### File: `src/test/dynamicAgentSelectorTest.ts`

```typescript
import * as assert from 'assert';
import { AgentSelector } from '../agents/dynamicAgentSelector';
import { TaskComplexity } from '../agents/types';

describe('Dynamic Agent Selection', () => {
  let agentSelector: AgentSelector;

  beforeEach(() => {
    agentSelector = new AgentSelector();
  });

  it('should select appropriate agent based on task complexity', async () => {
    // Test simple task
    const simpleTask = {
      description: 'Format this code snippet',
      complexity: TaskComplexity.Simple,
      requiresContext: false,
      requiresTools: false
    };

    const simpleAgent = await agentSelector.selectAgent(simpleTask);
    assert.strictEqual(simpleAgent.name, 'SimpleAgent', 'Should select SimpleAgent for simple tasks');

    // Test moderate task
    const moderateTask = {
      description: 'Explain how this algorithm works',
      complexity: TaskComplexity.Moderate,
      requiresContext: true,
      requiresTools: false
    };

    const moderateAgent = await agentSelector.selectAgent(moderateTask);
    assert.strictEqual(moderateAgent.name, 'DevelopmentAgent', 'Should select DevelopmentAgent for moderate tasks');

    // Test complex task
    const complexTask = {
      description: 'Refactor this code to use the factory pattern',
      complexity: TaskComplexity.Complex,
      requiresContext: true,
      requiresTools: false
    };

    const complexAgent = await agentSelector.selectAgent(complexTask);
    assert.strictEqual(complexAgent.name, 'ArchitectAgent', 'Should select ArchitectAgent for complex tasks');
  });

  it('should select agent with tool capabilities when tools are required', async () => {
    const taskRequiringTools = {
      description: 'Create a pull request for these changes',
      complexity: TaskComplexity.Moderate,
      requiresContext: true,
      requiresTools: true,
      requiredTools: ['github.createPullRequest']
    };

    const agent = await agentSelector.selectAgent(taskRequiringTools);
    assert.ok(agent.capabilities.includes('tools'), 'Selected agent should have tools capability');
    assert.strictEqual(agent.name, 'DevOpsAgent', 'Should select DevOpsAgent for tasks requiring GitHub tools');
  });

  it('should select agent with context capabilities when context is required', async () => {
    const taskRequiringContext = {
      description: 'Explain the relationship between these classes',
      complexity: TaskComplexity.Moderate,
      requiresContext: true,
      requiresTools: false,
      contextScope: 'deep' as ContextScope
    };

    const agent = await agentSelector.selectAgent(taskRequiringContext);
    assert.ok(agent.capabilities.includes('context'), 'Selected agent should have context capability');
    assert.strictEqual(agent.name, 'DevelopmentAgent', 'Should select DevelopmentAgent for tasks requiring deep context');
  });

  it('should select specialized agent for domain-specific tasks', async () => {
    const mlTask = {
      description: 'Optimize this machine learning model',
      complexity: TaskComplexity.Complex,
      requiresContext: true,
      requiresTools: false,
      domain: 'machine-learning' as TaskDomain
    };

    const agent = await agentSelector.selectAgent(mlTask);
    assert.strictEqual(agent.name, 'MLAgent', 'Should select MLAgent for machine learning tasks');

    const webTask = {
      description: 'Create a responsive layout for this component',
      complexity: TaskComplexity.Moderate,
      requiresContext: true,
      requiresTools: false,
      domain: 'web-development' as TaskDomain
    };

    const webAgent = await agentSelector.selectAgent(webTask);
    assert.strictEqual(webAgent.name, 'WebDevAgent', 'Should select WebDevAgent for web development tasks');
  });

  it('should analyze task description to determine complexity when not specified', async () => {
    const implicitComplexTask = {
      description: 'Refactor this monolithic application into a microservices architecture',
      requiresContext: true,
      requiresTools: false
    };

    const agent = await agentSelector.selectAgent(implicitComplexTask);
    assert.strictEqual(agent.name, 'ArchitectAgent', 'Should infer complexity from description and select appropriate agent');
  });

  it('should handle agent unavailability by selecting fallback agent', async () => {
    // Mock unavailable agent
    agentSelector.setAgentAvailability('ArchitectAgent', false);

    const complexTask = {
      description: 'Design a scalable system architecture',
      complexity: TaskComplexity.Complex,
      requiresContext: true,
      requiresTools: false
    };

    const agent = await agentSelector.selectAgent(complexTask);
    assert.notStrictEqual(agent.name, 'ArchitectAgent', 'Should not select unavailable agent');
    assert.strictEqual(agent.name, 'DevelopmentAgent', 'Should select fallback agent when preferred agent is unavailable');
  });
});

```


---

### File: `src/test/runDynamicAgentSelectorTest.ts`

```typescript
import Mocha from 'mocha';
import * as path from 'path';

async function run(): Promise<void> {
  // Create the mocha test
  const mocha = new Mocha({
    ui: 'bdd',
    color: true
  });

  // Add the test file
  mocha.addFile(path.resolve(__dirname, 'dynamicAgentSelectorTest.js'));

  // Run the tests
  return new Promise<void>((resolve, reject) => {
    mocha.run((failures: number) => {
      if (failures > 0) {
        reject(new Error(`${failures} tests failed.`));
      } else {
        resolve();
      }
    });
  });
}

// Run the tests
run().catch(err => {
  console.error('Test run failed:', err);
  process.exit(1);
});

```


---

### File: `src/test/suite/agentSelector.test.ts`

```typescript
import * as assert from 'assert';
import { AgentSelector } from '../../agents/agentSelector';
import {
    AgentType,
    ContextScope,
    ModelSize,
    Task,
    TaskComplexity,
    TaskDomain
} from '../../agents/types';

suite('Agent Selector Test Suite', () => {
  let agentSelector: AgentSelector;

  setup(() => {
    agentSelector = new AgentSelector();

    // Add test agents to the selector
    agentSelector.registerAgent({
      name: 'SimpleAgent',
      type: AgentType.Simple,
      capabilities: ['code'],
      modelSize: ModelSize.Small,
      maxComplexity: TaskComplexity.Simple,
      systemPrompt: 'You are a simple coding assistant that helps with basic tasks.',
      available: true
    });

    agentSelector.registerAgent({
      name: 'DevelopmentAgent',
      type: AgentType.Development,
      capabilities: ['code', 'context', 'reasoning'],
      modelSize: ModelSize.Large,
      maxComplexity: TaskComplexity.Complex,
      systemPrompt: 'You are a development assistant that helps with coding tasks.',
      available: true
    });

    agentSelector.registerAgent({
      name: 'ArchitectAgent',
      type: AgentType.Architecture,
      capabilities: ['code', 'context', 'reasoning', 'architecture'],
      modelSize: ModelSize.XLarge,
      maxComplexity: TaskComplexity.VeryComplex,
      systemPrompt: 'You are an architecture assistant that helps with system design and architecture.',
      available: true
    });

    agentSelector.registerAgent({
      name: 'DevOpsAgent',
      type: AgentType.DevOps,
      capabilities: ['code', 'tools', 'context'],
      modelSize: ModelSize.Large,
      maxComplexity: TaskComplexity.Complex,
      specializations: ['github', 'docker', 'ci-cd'],
      systemPrompt: 'You are a DevOps assistant that helps with CI/CD, deployment, and infrastructure.',
      available: true
    });

    agentSelector.registerAgent({
      name: 'MLAgent',
      type: AgentType.ML,
      capabilities: ['code', 'context', 'reasoning'],
      modelSize: ModelSize.XLarge,
      maxComplexity: TaskComplexity.VeryComplex,
      specializations: ['machine-learning', 'data-science', 'neural-networks'],
      systemPrompt: 'You are a machine learning assistant that helps with ML models and algorithms.',
      available: true
    });

    agentSelector.registerAgent({
      name: 'WebDevAgent',
      type: AgentType.WebDev,
      capabilities: ['code', 'context'],
      modelSize: ModelSize.Medium,
      maxComplexity: TaskComplexity.Complex,
      specializations: ['web-development', 'frontend', 'backend'],
      systemPrompt: 'You are a web development assistant that helps with frontend and backend tasks.',
      available: true
    });
  });

  test('Should select appropriate agent based on task complexity', async () => {
    // Test simple task
    const simpleTask: Task = {
      description: 'Format this code snippet',
      complexity: TaskComplexity.Simple,
      requiresContext: false,
      requiresTools: false
    };

    const simpleAgent = await agentSelector.selectAgent(simpleTask);
    assert.strictEqual(simpleAgent.name, 'SimpleAgent', 'Should select SimpleAgent for simple tasks');

    // Test moderate task
    const moderateTask: Task = {
      description: 'Explain how this algorithm works',
      complexity: TaskComplexity.Moderate,
      requiresContext: true,
      requiresTools: false
    };

    const moderateAgent = await agentSelector.selectAgent(moderateTask);
    assert.strictEqual(moderateAgent.name, 'DevelopmentAgent', 'Should select DevelopmentAgent for moderate tasks');

    // Test complex task
    const complexTask: Task = {
      description: 'Refactor this code to use the factory pattern',
      complexity: TaskComplexity.Complex,
      requiresContext: true,
      requiresTools: false
    };

    const complexAgent = await agentSelector.selectAgent(complexTask);
    assert.strictEqual(complexAgent.name, 'ArchitectAgent', 'Should select ArchitectAgent for complex tasks');
  });

  test('Should select agent with tool capabilities when tools are required', async () => {
    const taskRequiringTools: Task = {
      description: 'Create a pull request for these changes',
      complexity: TaskComplexity.Moderate,
      requiresContext: true,
      requiresTools: true,
      requiredTools: ['github.createPullRequest']
    };

    const agent = await agentSelector.selectAgent(taskRequiringTools);
    assert.ok(agent.capabilities.includes('tools'), 'Selected agent should have tools capability');
    assert.strictEqual(agent.name, 'DevOpsAgent', 'Should select DevOpsAgent for tasks requiring GitHub tools');
  });

  test('Should select agent with context capabilities when context is required', async () => {
    const taskRequiringContext: Task = {
      description: 'Explain the relationship between these classes',
      complexity: TaskComplexity.Moderate,
      requiresContext: true,
      requiresTools: false,
      contextScope: 'deep' as ContextScope
    };

    const agent = await agentSelector.selectAgent(taskRequiringContext);
    assert.ok(agent.capabilities.includes('context'), 'Selected agent should have context capability');
    assert.strictEqual(agent.name, 'DevelopmentAgent', 'Should select DevelopmentAgent for tasks requiring deep context');
  });

  test('Should select specialized agent for domain-specific tasks', async () => {
    const mlTask: Task = {
      description: 'Optimize this machine learning model',
      complexity: TaskComplexity.Complex,
      requiresContext: true,
      requiresTools: false,
      domain: 'machine-learning' as TaskDomain
    };

    const agent = await agentSelector.selectAgent(mlTask);
    assert.strictEqual(agent.name, 'MLAgent', 'Should select MLAgent for machine learning tasks');

    const webTask: Task = {
      description: 'Create a responsive layout for this component',
      complexity: TaskComplexity.Moderate,
      requiresContext: true,
      requiresTools: false,
      domain: 'web-development' as TaskDomain
    };

    const webAgent = await agentSelector.selectAgent(webTask);
    assert.strictEqual(webAgent.name, 'WebDevAgent', 'Should select WebDevAgent for web development tasks');
  });

  test('Should analyze task description to determine complexity when not specified', async () => {
    const implicitComplexTask: Task = {
      description: 'Refactor this monolithic application into a microservices architecture',
      requiresContext: true,
      requiresTools: false
    };

    const agent = await agentSelector.selectAgent(implicitComplexTask);
    assert.strictEqual(agent.name, 'ArchitectAgent', 'Should infer complexity from description and select appropriate agent');
  });

  test('Should handle agent unavailability by selecting fallback agent', async () => {
    // Mock unavailable agent
    agentSelector.setAgentAvailability('ArchitectAgent', false);

    const complexTask: Task = {
      description: 'Design a scalable system architecture',
      complexity: TaskComplexity.Complex,
      requiresContext: true,
      requiresTools: false
    };

    const agent = await agentSelector.selectAgent(complexTask);
    assert.notStrictEqual(agent.name, 'ArchitectAgent', 'Should not select unavailable agent');
    assert.strictEqual(agent.name, 'DevelopmentAgent', 'Should select fallback agent when preferred agent is unavailable');
  });
});

```


---

### File: `src/test/suite/contextEngine.test.ts`

```typescript
import * as assert from 'assert';
import * as vscode from 'vscode';
import * as sinon from 'sinon';
import { ContextEngine } from '../../context/contextEngine';
import { VectorStore } from '../../context/vectorStore';
import { FileIndexer } from '../../context/fileIndexer';
import { EmbeddingService } from '../../context/embeddingService';

suite('Context Engine Test Suite', () => {
  let contextEngine: ContextEngine;
  let mockVectorStore: sinon.SinonStubbedInstance<VectorStore>;
  let mockFileIndexer: sinon.SinonStubbedInstance<FileIndexer>;
  let mockEmbeddingService: sinon.SinonStubbedInstance<EmbeddingService>;
  
  setup(() => {
    // Create mock instances
    mockVectorStore = sinon.createStubInstance(VectorStore);
    mockFileIndexer = sinon.createStubInstance(FileIndexer);
    mockEmbeddingService = sinon.createStubInstance(EmbeddingService);
    
    // Initialize context engine with mocks
    contextEngine = new ContextEngine(
      mockVectorStore as unknown as VectorStore,
      mockFileIndexer as unknown as FileIndexer,
      mockEmbeddingService as unknown as EmbeddingService
    );
  });
  
  teardown(() => {
    sinon.restore();
  });
  
  test('Should initialize context engine', async () => {
    // Setup
    mockVectorStore.initialize.resolves();
    
    // Execute
    await contextEngine.initialize();
    
    // Verify
    assert.strictEqual(mockVectorStore.initialize.calledOnce, true, 'Vector store should be initialized');
  });
  
  test('Should get context for query', async () => {
    // Setup
    const query = 'How does the context engine work?';
    const mockEmbedding = [0.1, 0.2, 0.3];
    const mockResults = [
      { content: 'Context engine processes queries', score: 0.9, filePath: 'src/context/contextEngine.ts' },
      { content: 'Vector store manages embeddings', score: 0.8, filePath: 'src/context/vectorStore.ts' }
    ];
    
    mockEmbeddingService.getEmbedding.resolves(mockEmbedding);
    mockVectorStore.search.resolves(mockResults);
    
    // Execute
    const context = await contextEngine.getContextForQuery(query);
    
    // Verify
    assert.strictEqual(mockEmbeddingService.getEmbedding.calledOnce, true, 'Should get embedding for query');
    assert.strictEqual(mockVectorStore.search.calledOnce, true, 'Should search vector store');
    assert.ok(context.includes('Context engine processes queries'), 'Context should include relevant content');
    assert.ok(context.includes('Vector store manages embeddings'), 'Context should include relevant content');
  });
  
  test('Should index workspace files', async () => {
    // Setup
    const mockFiles = [
      vscode.Uri.file('/workspace/src/file1.ts'),
      vscode.Uri.file('/workspace/src/file2.ts')
    ];
    const mockChunks = [
      { content: 'File content 1', embedding: [0.1, 0.2], filePath: '/workspace/src/file1.ts', startLine: 1, endLine: 10 },
      { content: 'File content 2', embedding: [0.3, 0.4], filePath: '/workspace/src/file2.ts', startLine: 1, endLine: 10 }
    ];
    
    // Mock workspace.findFiles
    sinon.stub(vscode.workspace, 'findFiles').resolves(mockFiles);
    
    // Mock file indexer
    mockFileIndexer.indexFile.resolves(mockChunks);
    
    // Mock vector store
    mockVectorStore.addChunks.resolves();
    
    // Execute
    await contextEngine.indexWorkspace();
    
    // Verify
    assert.strictEqual(mockFileIndexer.indexFile.callCount, 2, 'Should index each file');
    assert.strictEqual(mockVectorStore.addChunks.callCount, 2, 'Should add chunks to vector store');
  });
  
  test('Should dispose resources', async () => {
    // Setup
    mockVectorStore.dispose.resolves();
    
    // Execute
    await contextEngine.dispose();
    
    // Verify
    assert.strictEqual(mockVectorStore.dispose.calledOnce, true, 'Vector store should be disposed');
  });
});

```


---

### File: `src/test/suite/vectorStore.test.ts`

```typescript
import * as assert from 'assert';
import * as sinon from 'sinon';
import { VectorStore } from '../../context/vectorStore';
import { CodeChunk } from '../../context/types';

suite('Vector Store Test Suite', () => {
  let vectorStore: VectorStore;
  
  setup(() => {
    vectorStore = new VectorStore();
  });
  
  teardown(() => {
    sinon.restore();
  });
  
  test('Should add chunks to vector store', async () => {
    // Setup
    const chunks: CodeChunk[] = [
      {
        content: 'function test() { return true; }',
        embedding: [0.1, 0.2, 0.3],
        filePath: 'src/test.ts',
        startLine: 1,
        endLine: 3,
        language: 'typescript'
      },
      {
        content: 'class Example { constructor() {} }',
        embedding: [0.4, 0.5, 0.6],
        filePath: 'src/example.ts',
        startLine: 1,
        endLine: 3,
        language: 'typescript'
      }
    ];
    
    // Execute
    await vectorStore.addChunks(chunks);
    
    // Verify - we can't directly access private members, so we'll test via search
    const results = await vectorStore.search([0.1, 0.2, 0.3], 5);
    assert.strictEqual(results.length, 2, 'Should return added chunks');
    assert.strictEqual(results[0].content, 'function test() { return true; }', 'Should return correct content');
  });
  
  test('Should search for similar chunks', async () => {
    // Setup
    const chunks: CodeChunk[] = [
      {
        content: 'function calculateDistance(a, b) { return Math.sqrt(a*a + b*b); }',
        embedding: [0.1, 0.2, 0.3],
        filePath: 'src/math.ts',
        startLine: 1,
        endLine: 3,
        language: 'typescript'
      },
      {
        content: 'class User { constructor(name) { this.name = name; } }',
        embedding: [0.7, 0.8, 0.9],
        filePath: 'src/user.ts',
        startLine: 1,
        endLine: 3,
        language: 'typescript'
      }
    ];
    
    await vectorStore.addChunks(chunks);
    
    // Execute - search with embedding closer to the first chunk
    const results = await vectorStore.search([0.15, 0.25, 0.35], 1);
    
    // Verify
    assert.strictEqual(results.length, 1, 'Should return requested number of results');
    assert.strictEqual(results[0].content.includes('calculateDistance'), true, 'Should return most similar chunk');
  });
  
  test('Should clear vector store', async () => {
    // Setup
    const chunks: CodeChunk[] = [
      {
        content: 'function test() { return true; }',
        embedding: [0.1, 0.2, 0.3],
        filePath: 'src/test.ts',
        startLine: 1,
        endLine: 3,
        language: 'typescript'
      }
    ];
    
    await vectorStore.addChunks(chunks);
    
    // Execute
    await vectorStore.clear();
    
    // Verify
    const results = await vectorStore.search([0.1, 0.2, 0.3], 5);
    assert.strictEqual(results.length, 0, 'Should return no results after clearing');
  });
  
  test('Should filter search results by file path', async () => {
    // Setup
    const chunks: CodeChunk[] = [
      {
        content: 'function test1() { return true; }',
        embedding: [0.1, 0.2, 0.3],
        filePath: 'src/test1.ts',
        startLine: 1,
        endLine: 3,
        language: 'typescript'
      },
      {
        content: 'function test2() { return false; }',
        embedding: [0.15, 0.25, 0.35],
        filePath: 'src/test2.ts',
        startLine: 1,
        endLine: 3,
        language: 'typescript'
      }
    ];
    
    await vectorStore.addChunks(chunks);
    
    // Execute
    const results = await vectorStore.search([0.1, 0.2, 0.3], 5, 'src/test1.ts');
    
    // Verify
    assert.strictEqual(results.length, 1, 'Should return only results matching file path');
    assert.strictEqual(results[0].filePath, 'src/test1.ts', 'Should return correct file');
  });
});

```


---

### File: `src/test/suite/index.ts`

```typescript
import glob from 'glob';
import Mocha from 'mocha';
import * as path from 'path';

export function run(): Promise<void> {
  // Create the mocha test
  const mocha = new Mocha({
    ui: 'tdd',
    color: true
  });

  const testsRoot = path.resolve(__dirname, '..');

  return new Promise<void>((c, e) => {
    glob('**/**.test.js', { cwd: testsRoot }, (err: any, files: string[]) => {
      if (err) {
        return e(err);
      }

      // Add files to the test suite
      files.forEach((f: string) => {
        console.log(`Adding test file: ${f}`);
        mocha.addFile(path.resolve(testsRoot, f));
      });

      try {
        // Run the mocha test
        mocha.run((failures: number) => {
          if (failures > 0) {
            e(new Error(`${failures} tests failed.`));
          } else {
            c();
          }
        });
      } catch (err) {
        console.error(err);
        e(err);
      }
    });
  });
}

```


---

### File: `src/test/suite/symbolExtractor.test.ts`

```typescript
import * as assert from 'assert';
import { SymbolExtractor } from '../../context/symbolExtractor';

suite('Symbol Extractor Test Suite', () => {
  let symbolExtractor: SymbolExtractor;

  setup(() => {
    symbolExtractor = new SymbolExtractor();
  });

  test('JavaScript Symbol Extraction', async () => {
    const jsCode = `
      import { useState } from 'react';
      import axios from 'axios';
      
      function calculateTotal(items) {
        return items.reduce((total, item) => total + item.price, 0);
      }
      
      class ShoppingCart {
        constructor(items = []) {
          this.items = items;
        }
        
        addItem(item) {
          this.items.push(item);
        }
        
        getTotal() {
          return calculateTotal(this.items);
        }
      }
      
      const cart = new ShoppingCart();
      const fetchItems = async () => {
        const response = await axios.get('/api/items');
        return response.data;
      };
    `;
    
    const result = await symbolExtractor.extractSymbols(jsCode, 'javascript');
    
    // Check symbols
    assert.ok(result.symbols.includes('calculateTotal'), 'Should extract function declaration');
    assert.ok(result.symbols.includes('ShoppingCart'), 'Should extract class declaration');
    assert.ok(result.symbols.includes('cart'), 'Should extract variable declaration');
    assert.ok(result.symbols.includes('fetchItems'), 'Should extract arrow function');
    assert.ok(result.symbols.includes('addItem'), 'Should extract method declaration');
    assert.ok(result.symbols.includes('getTotal'), 'Should extract method declaration');
    
    // Check imports
    assert.ok(result.imports.includes('react'), 'Should extract ES module import');
    assert.ok(result.imports.includes('axios'), 'Should extract default import');
  });

  test('Python Symbol Extraction', async () => {
    const pyCode = `
      import os
      import sys
      from datetime import datetime
      
      CONSTANT_VALUE = 42
      
      def calculate_age(birth_date):
          today = datetime.now()
          age = today.year - birth_date.year
          return age
      
      class Person:
          def __init__(self, name, birth_date):
              self.name = name
              self.birth_date = birth_date
          
          def get_age(self):
              return calculate_age(self.birth_date)
      
      @staticmethod
      def format_date(date):
          return date.strftime("%Y-%m-%d")
    `;
    
    const result = await symbolExtractor.extractSymbols(pyCode, 'python');
    
    // Check symbols
    assert.ok(result.symbols.includes('CONSTANT_VALUE'), 'Should extract constant');
    assert.ok(result.symbols.includes('calculate_age'), 'Should extract function declaration');
    assert.ok(result.symbols.includes('Person'), 'Should extract class declaration');
    assert.ok(result.symbols.includes('get_age'), 'Should extract method declaration');
    assert.ok(result.symbols.includes('format_date'), 'Should extract decorated function');
    
    // Check imports
    assert.ok(result.imports.includes('os'), 'Should extract simple import');
    assert.ok(result.imports.includes('sys'), 'Should extract simple import');
    assert.ok(result.imports.includes('datetime'), 'Should extract from import');
  });

  test('Java Symbol Extraction', async () => {
    const javaCode = `
      package com.example.app;
      
      import java.util.List;
      import java.util.ArrayList;
      
      public class UserManager {
          private List<User> users;
          
          public UserManager() {
              this.users = new ArrayList<>();
          }
          
          public void addUser(User user) {
              users.add(user);
          }
          
          public User findUserById(int id) {
              return users.stream()
                  .filter(user -> user.getId() == id)
                  .findFirst()
                  .orElse(null);
          }
      }
    `;
    
    const result = await symbolExtractor.extractSymbols(javaCode, 'java');
    
    // Check symbols
    assert.ok(result.symbols.includes('UserManager'), 'Should extract class declaration');
    assert.ok(result.symbols.includes('users'), 'Should extract field declaration');
    assert.ok(result.symbols.includes('addUser'), 'Should extract method declaration');
    assert.ok(result.symbols.includes('findUserById'), 'Should extract method declaration');
    
    // Check imports
    assert.ok(result.imports.includes('java.util.List'), 'Should extract import');
    assert.ok(result.imports.includes('java.util.ArrayList'), 'Should extract import');
  });

  test('Language Detection from Path', () => {
    assert.strictEqual(SymbolExtractor.detectLanguageFromPath('/path/to/file.js'), 'javascript');
    assert.strictEqual(SymbolExtractor.detectLanguageFromPath('/path/to/file.ts'), 'typescript');
    assert.strictEqual(SymbolExtractor.detectLanguageFromPath('/path/to/file.py'), 'python');
    assert.strictEqual(SymbolExtractor.detectLanguageFromPath('/path/to/file.java'), 'java');
    assert.strictEqual(SymbolExtractor.detectLanguageFromPath('/path/to/file.cpp'), 'cpp');
    assert.strictEqual(SymbolExtractor.detectLanguageFromPath('/path/to/file.cs'), 'csharp');
    assert.strictEqual(SymbolExtractor.detectLanguageFromPath('/path/to/file.go'), 'go');
    assert.strictEqual(SymbolExtractor.detectLanguageFromPath('/path/to/file.rb'), 'ruby');
    assert.strictEqual(SymbolExtractor.detectLanguageFromPath('/path/to/file.php'), 'php');
    assert.strictEqual(SymbolExtractor.detectLanguageFromPath('/path/to/file.rs'), 'rust');
    assert.strictEqual(SymbolExtractor.detectLanguageFromPath('/path/to/file.swift'), 'swift');
    assert.strictEqual(SymbolExtractor.detectLanguageFromPath('/path/to/file.kt'), 'kotlin');
    assert.strictEqual(SymbolExtractor.detectLanguageFromPath('/path/to/file.html'), 'html');
    assert.strictEqual(SymbolExtractor.detectLanguageFromPath('/path/to/file.css'), 'css');
    assert.strictEqual(SymbolExtractor.detectLanguageFromPath('/path/to/file.json'), 'json');
    assert.strictEqual(SymbolExtractor.detectLanguageFromPath('/path/to/file.xml'), 'xml');
    assert.strictEqual(SymbolExtractor.detectLanguageFromPath('/path/to/file.yaml'), 'yaml');
    assert.strictEqual(SymbolExtractor.detectLanguageFromPath('/path/to/file.md'), 'markdown');
  });
});

```


---

### File: `src/test/suite/contextProvider.test.ts`

```typescript
import * as assert from 'assert';
import * as sinon from 'sinon';
import * as vscode from 'vscode';
import { ContextProvider } from '../../contextProvider';
import { ContextEngine } from '../../context/contextEngine';

suite('Context Provider Test Suite', () => {
  let contextProvider: ContextProvider;
  let mockContextEngine: sinon.SinonStubbedInstance<ContextEngine>;
  let mockEditor: vscode.TextEditor;
  
  setup(() => {
    // Create mock context engine
    mockContextEngine = sinon.createStubInstance(ContextEngine);
    
    // Create mock text editor
    mockEditor = {
      document: {
        fileName: '/workspace/src/test.ts',
        languageId: 'typescript',
        getText: sinon.stub().returns('function test() {\n  return true;\n}'),
        lineAt: sinon.stub().callsFake((line: number) => {
          const lines = ['function test() {', '  return true;', '}'];
          return { text: lines[line] };
        }),
        uri: vscode.Uri.file('/workspace/src/test.ts')
      },
      selection: new vscode.Selection(0, 0, 2, 1)
    } as unknown as vscode.TextEditor;
    
    // Stub active editor
    sinon.stub(vscode.window, 'activeTextEditor').value(mockEditor);
    
    // Initialize context provider with mock
    contextProvider = new ContextProvider(mockContextEngine as unknown as ContextEngine);
  });
  
  teardown(() => {
    sinon.restore();
  });
  
  test('Should get context for query', async () => {
    // Setup
    const query = 'How does the test function work?';
    mockContextEngine.getContextForQuery.resolves('Context for test function');
    
    // Execute
    const context = await contextProvider.getContextForQuery(query);
    
    // Verify
    assert.strictEqual(mockContextEngine.getContextForQuery.calledOnce, true, 'Should call context engine');
    assert.strictEqual(context, 'Context for test function', 'Should return context from engine');
  });
  
  test('Should get context for current file', async () => {
    // Setup
    mockContextEngine.getContextForFile.resolves('Context for current file');
    
    // Execute
    const context = await contextProvider.getContextForCurrentFile();
    
    // Verify
    assert.strictEqual(mockContextEngine.getContextForFile.calledOnce, true, 'Should call context engine');
    assert.strictEqual(context, 'Context for current file', 'Should return context from engine');
    
    // Verify file path was passed correctly
    const filePathArg = mockContextEngine.getContextForFile.firstCall.args[0];
    assert.strictEqual(filePathArg, '/workspace/src/test.ts', 'Should pass correct file path');
  });
  
  test('Should get context for selected code', async () => {
    // Setup
    mockContextEngine.getContextForCode.resolves('Context for selected code');
    
    // Execute
    const context = await contextProvider.getContextForSelectedCode();
    
    // Verify
    assert.strictEqual(mockContextEngine.getContextForCode.calledOnce, true, 'Should call context engine');
    assert.strictEqual(context, 'Context for selected code', 'Should return context from engine');
    
    // Verify selected code was passed correctly
    const codeArg = mockContextEngine.getContextForCode.firstCall.args[0];
    assert.strictEqual(codeArg, 'function test() {\n  return true;\n}', 'Should pass selected code');
  });
  
  test('Should handle no active editor', async () => {
    // Setup - simulate no active editor
    sinon.stub(vscode.window, 'activeTextEditor').value(undefined);
    
    // Execute and verify
    const context = await contextProvider.getContextForCurrentFile();
    assert.strictEqual(context, '', 'Should return empty string when no active editor');
    assert.strictEqual(mockContextEngine.getContextForFile.called, false, 'Should not call context engine');
  });
  
  test('Should handle no selection', async () => {
    // Setup - simulate empty selection
    const editorWithEmptySelection = {
      ...mockEditor,
      selection: new vscode.Selection(0, 0, 0, 0)
    };
    sinon.stub(vscode.window, 'activeTextEditor').value(editorWithEmptySelection);
    
    // Execute
    const context = await contextProvider.getContextForSelectedCode();
    
    // Verify
    assert.strictEqual(context, '', 'Should return empty string for empty selection');
    assert.strictEqual(mockContextEngine.getContextForCode.called, false, 'Should not call context engine');
  });
  
  test('Should get context with depth parameter', async () => {
    // Setup
    mockContextEngine.getContextForQuery.resolves('Deep context for query');
    
    // Execute
    const context = await contextProvider.getContextForQuery('Complex query', 'deep');
    
    // Verify
    assert.strictEqual(mockContextEngine.getContextForQuery.calledOnce, true, 'Should call context engine');
    
    // Verify depth parameter was passed correctly
    const depthArg = mockContextEngine.getContextForQuery.firstCall.args[1];
    assert.strictEqual(depthArg, 'deep', 'Should pass depth parameter');
  });
  
  test('Should get context for symbol under cursor', async () => {
    // Setup
    mockContextEngine.getContextForSymbol.resolves('Context for symbol');
    
    // Execute
    const context = await contextProvider.getContextForSymbolUnderCursor();
    
    // Verify
    assert.strictEqual(mockContextEngine.getContextForSymbol.calledOnce, true, 'Should call context engine');
    assert.strictEqual(context, 'Context for symbol', 'Should return context from engine');
  });
});

```


---

### File: `src/test/suite/extension.test.ts`

```typescript
import * as assert from 'assert';
import * as vscode from 'vscode';

suite('Extension Test Suite', () => {
  vscode.window.showInformationMessage('Start all tests.');

  test('Extension should be present', () => {
    assert.ok(vscode.extensions.getExtension('qwen-coder-assistant'));
  });

  test('Extension should activate', async () => {
    const extension = vscode.extensions.getExtension('qwen-coder-assistant');
    if (!extension) {
      assert.fail('Extension not found');
      return;
    }
    
    await extension.activate();
    assert.ok(extension.isActive);
  });

  test('Commands should be registered', async () => {
    const commands = await vscode.commands.getCommands();
    assert.ok(commands.includes('qwen-coder-assistant.askQwen'));
    assert.ok(commands.includes('qwen-coder-assistant.explainCode'));
    assert.ok(commands.includes('qwen-coder-assistant.generateCode'));
  });
});

```


---

### File: `src/test/suite/responseFormatter.test.ts`

```typescript
import * as assert from 'assert';
import * as sinon from 'sinon';
import * as vscode from 'vscode';
import { ResponseFormatter } from '../../responseFormatter';

suite('Response Formatter Test Suite', () => {
  let responseFormatter: ResponseFormatter;
  let mockWebviewPanel: vscode.WebviewPanel;
  
  setup(() => {
    // Create mock webview panel
    mockWebviewPanel = {
      webview: {
        html: '',
        onDidReceiveMessage: sinon.stub(),
        postMessage: sinon.stub().resolves()
      },
      onDidDispose: sinon.stub(),
      reveal: sinon.stub(),
      dispose: sinon.stub()
    } as unknown as vscode.WebviewPanel;
    
    // Create stub for webview panel creation
    sinon.stub(vscode.window, 'createWebviewPanel').returns(mockWebviewPanel);
    
    // Initialize response formatter
    responseFormatter = new ResponseFormatter();
  });
  
  teardown(() => {
    sinon.restore();
  });
  
  test('Should format markdown response', () => {
    // Setup
    const markdown = '# Heading\n\nThis is a paragraph with **bold** and *italic* text.\n\n```javascript\nconst x = 1;\n```';
    
    // Execute
    const formatted = responseFormatter.formatMarkdown(markdown);
    
    // Verify
    assert.strictEqual(formatted.includes('<h1>Heading</h1>'), true, 'Should convert heading');
    assert.strictEqual(formatted.includes('<strong>bold</strong>'), true, 'Should convert bold text');
    assert.strictEqual(formatted.includes('<em>italic</em>'), true, 'Should convert italic text');
    assert.strictEqual(formatted.includes('<pre><code class="language-javascript">'), true, 'Should format code blocks');
  });
  
  test('Should format code response', () => {
    // Setup
    const code = 'function test() {\n  return true;\n}';
    const language = 'javascript';
    
    // Execute
    const formatted = responseFormatter.formatCode(code, language);
    
    // Verify
    assert.strictEqual(formatted.includes('<pre><code class="language-javascript">'), true, 'Should include language class');
    assert.strictEqual(formatted.includes('function test()'), true, 'Should include code content');
  });
  
  test('Should display response in webview panel', async () => {
    // Setup
    const response = 'This is a test response';
    
    // Execute
    await responseFormatter.displayResponse(response, 'Test Response');
    
    // Verify
    assert.strictEqual(vscode.window.createWebviewPanel.calledOnce, true, 'Should create webview panel');
    assert.strictEqual(mockWebviewPanel.webview.html.includes(response), true, 'Should set HTML content');
    assert.strictEqual(mockWebviewPanel.reveal.calledOnce, true, 'Should reveal panel');
  });
  
  test('Should handle code explanation display', async () => {
    // Setup
    const code = 'function test() {\n  return true;\n}';
    const explanation = 'This function always returns true';
    
    // Execute
    await responseFormatter.displayCodeExplanation(code, 'javascript', explanation);
    
    // Verify
    assert.strictEqual(vscode.window.createWebviewPanel.calledOnce, true, 'Should create webview panel');
    assert.strictEqual(mockWebviewPanel.webview.html.includes(code), true, 'Should include code');
    assert.strictEqual(mockWebviewPanel.webview.html.includes(explanation), true, 'Should include explanation');
  });
  
  test('Should handle generated code display', async () => {
    // Setup
    const request = 'Generate a function that returns true';
    const generatedCode = 'function alwaysTrue() {\n  return true;\n}';
    
    // Execute
    await responseFormatter.displayGeneratedCode(request, 'javascript', generatedCode);
    
    // Verify
    assert.strictEqual(vscode.window.createWebviewPanel.calledOnce, true, 'Should create webview panel');
    assert.strictEqual(mockWebviewPanel.webview.html.includes(request), true, 'Should include request');
    assert.strictEqual(mockWebviewPanel.webview.html.includes(generatedCode), true, 'Should include generated code');
    assert.strictEqual(mockWebviewPanel.webview.html.includes('Insert Code'), true, 'Should include insert button');
  });
  
  test('Should handle error display', async () => {
    // Setup
    const error = 'API Error: Rate limit exceeded';
    
    // Execute
    await responseFormatter.displayError(error);
    
    // Verify
    assert.strictEqual(vscode.window.createWebviewPanel.calledOnce, true, 'Should create webview panel');
    assert.strictEqual(mockWebviewPanel.webview.html.includes(error), true, 'Should include error message');
    assert.strictEqual(mockWebviewPanel.webview.html.includes('Error'), true, 'Should indicate error status');
  });
  
  test('Should handle streaming response updates', async () => {
    // Setup
    const initialResponse = 'This is ';
    const updatedResponse = 'This is a complete response';
    
    // Create panel first
    await responseFormatter.displayResponse(initialResponse, 'Streaming Response');
    
    // Reset the HTML to simulate starting fresh
    mockWebviewPanel.webview.html = '';
    
    // Execute - update with streaming content
    await responseFormatter.updateStreamingResponse(updatedResponse);
    
    // Verify
    assert.strictEqual(mockWebviewPanel.webview.postMessage.called, true, 'Should post message to webview');
    
    // The actual HTML update would be handled by the webview's JavaScript,
    // so we're verifying the message was sent with the updated content
    const messageArg = mockWebviewPanel.webview.postMessage.firstCall.args[0];
    assert.strictEqual(messageArg.type, 'update', 'Should send update message type');
    assert.strictEqual(messageArg.content, updatedResponse, 'Should send updated content');
  });
});

```


---

### File: `src/test/suite/qwenApi.test.ts`

```typescript
import * as assert from 'assert';
import * as sinon from 'sinon';
import axios from 'axios';
import { QwenApiClient } from '../../qwenApi';
import { QwenMessage, QwenResponse } from '../../qwenApi';

suite('Qwen API Client Test Suite', () => {
  let qwenApiClient: QwenApiClient;
  let axiosStub: sinon.SinonStub;
  
  setup(() => {
    // Create API client with test configuration
    qwenApiClient = new QwenApiClient({
      apiKey: 'test-api-key',
      apiEndpoint: 'https://test-api-endpoint.com',
      model: 'qwen-test-model'
    });
    
    // Stub axios to prevent actual API calls
    axiosStub = sinon.stub(axios, 'post');
  });
  
  teardown(() => {
    sinon.restore();
  });
  
  test('Should send chat completion request', async () => {
    // Setup mock response
    const mockResponse = {
      data: {
        id: 'test-response-id',
        object: 'chat.completion',
        created: Date.now(),
        model: 'qwen-test-model',
        choices: [
          {
            index: 0,
            message: {
              role: 'assistant',
              content: 'This is a test response'
            },
            finish_reason: 'stop'
          }
        ]
      }
    };
    
    axiosStub.resolves(mockResponse);
    
    // Create test messages
    const messages: QwenMessage[] = [
      { role: 'system', content: 'You are a helpful assistant' },
      { role: 'user', content: 'Hello, how are you?' }
    ];
    
    // Execute
    const response = await qwenApiClient.getChatCompletion(messages);
    
    // Verify
    assert.strictEqual(axiosStub.calledOnce, true, 'Should make API call');
    assert.strictEqual(response.choices[0].message.content, 'This is a test response', 'Should return correct response');
    
    // Verify request format
    const requestArg = axiosStub.firstCall.args[1];
    assert.strictEqual(requestArg.messages.length, 2, 'Should send correct number of messages');
    assert.strictEqual(requestArg.model, 'qwen-test-model', 'Should use configured model');
  });
  
  test('Should handle streaming responses', async () => {
    // Setup
    const mockStreamingResponse = {
      data: {
        id: 'test-stream-id',
        object: 'chat.completion.chunk',
        created: Date.now(),
        model: 'qwen-test-model',
        choices: [
          {
            index: 0,
            delta: {
              content: 'This is '
            },
            finish_reason: null
          }
        ]
      }
    };
    
    // Create a mock for the streaming response
    const mockStream = {
      [Symbol.asyncIterator]: () => {
        let count = 0;
        const chunks = [
          { data: JSON.stringify(mockStreamingResponse.data) },
          { 
            data: JSON.stringify({
              ...mockStreamingResponse.data,
              choices: [
                {
                  index: 0,
                  delta: {
                    content: 'a test'
                  },
                  finish_reason: null
                }
              ]
            })
          },
          { 
            data: JSON.stringify({
              ...mockStreamingResponse.data,
              choices: [
                {
                  index: 0,
                  delta: {
                    content: ' response'
                  },
                  finish_reason: 'stop'
                }
              ]
            })
          }
        ];
        
        return {
          next: () => {
            if (count < chunks.length) {
              return Promise.resolve({ value: chunks[count++], done: false });
            }
            return Promise.resolve({ done: true });
          }
        };
      }
    };
    
    // Stub axios to return the mock stream
    axiosStub.returns(Promise.resolve({ data: mockStream }));
    
    // Create test messages
    const messages: QwenMessage[] = [
      { role: 'system', content: 'You are a helpful assistant' },
      { role: 'user', content: 'Hello, how are you?' }
    ];
    
    // Create a callback to collect streaming responses
    const streamingResponses: string[] = [];
    const onChunk = (chunk: string) => {
      streamingResponses.push(chunk);
    };
    
    // Execute
    await qwenApiClient.getStreamingChatCompletion(messages, onChunk);
    
    // Verify
    assert.strictEqual(axiosStub.calledOnce, true, 'Should make API call');
    assert.strictEqual(streamingResponses.length, 3, 'Should receive all chunks');
    assert.strictEqual(streamingResponses.join(''), 'This is a test response', 'Should concatenate to full response');
    
    // Verify request format
    const requestArg = axiosStub.firstCall.args[1];
    assert.strictEqual(requestArg.stream, true, 'Should set stream parameter');
  });
  
  test('Should handle API errors', async () => {
    // Setup - simulate API error
    axiosStub.rejects({
      response: {
        status: 401,
        data: {
          error: 'Invalid API key'
        }
      }
    });
    
    // Create test messages
    const messages: QwenMessage[] = [
      { role: 'user', content: 'Hello' }
    ];
    
    // Execute and verify
    try {
      await qwenApiClient.getChatCompletion(messages);
      assert.fail('Should throw an error');
    } catch (error) {
      assert.strictEqual(error.message.includes('Invalid API key'), true, 'Should include error message from API');
    }
  });
  
  test('Should handle tool calls in responses', async () => {
    // Setup mock response with tool calls
    const mockResponse = {
      data: {
        id: 'test-response-id',
        object: 'chat.completion',
        created: Date.now(),
        model: 'qwen-test-model',
        choices: [
          {
            index: 0,
            message: {
              role: 'assistant',
              content: null,
              tool_calls: [
                {
                  id: 'tool-call-1',
                  type: 'function',
                  function: {
                    name: 'get_weather',
                    arguments: '{"location":"New York","unit":"celsius"}'
                  }
                }
              ]
            },
            finish_reason: 'tool_calls'
          }
        ]
      }
    };
    
    axiosStub.resolves(mockResponse);
    
    // Create test messages
    const messages: QwenMessage[] = [
      { role: 'user', content: 'What\'s the weather in New York?' }
    ];
    
    // Execute
    const response = await qwenApiClient.getChatCompletion(messages);
    
    // Verify
    assert.strictEqual(response.choices[0].message.tool_calls?.length, 1, 'Should include tool calls');
    assert.strictEqual(response.choices[0].message.tool_calls?.[0].function.name, 'get_weather', 'Should have correct tool name');
    assert.strictEqual(response.choices[0].finish_reason, 'tool_calls', 'Should have correct finish reason');
  });
});

```


---

### File: `src/test/suite/dynamicAgentSelection.test.ts`

```typescript
import * as assert from 'assert';
import { AgentSelector } from '../../agents/dynamicAgentSelector';
import { TaskComplexity } from '../../agents/types';

suite('Dynamic Agent Selection Test Suite', () => {
  let agentSelector: AgentSelector;

  setup(() => {
    agentSelector = new AgentSelector();
  });

  test('Should select appropriate agent based on task complexity', async () => {
    // Test simple task
    const simpleTask = {
      description: 'Format this code snippet',
      complexity: TaskComplexity.Simple,
      requiresContext: false,
      requiresTools: false
    };

    const simpleAgent = await agentSelector.selectAgent(simpleTask);
    assert.strictEqual(simpleAgent.name, 'SimpleAgent', 'Should select SimpleAgent for simple tasks');

    // Test moderate task
    const moderateTask = {
      description: 'Explain how this algorithm works',
      complexity: TaskComplexity.Moderate,
      requiresContext: true,
      requiresTools: false
    };

    const moderateAgent = await agentSelector.selectAgent(moderateTask);
    assert.strictEqual(moderateAgent.name, 'DevelopmentAgent', 'Should select DevelopmentAgent for moderate tasks');

    // Test complex task
    const complexTask = {
      description: 'Refactor this code to use the factory pattern',
      complexity: TaskComplexity.Complex,
      requiresContext: true,
      requiresTools: false
    };

    const complexAgent = await agentSelector.selectAgent(complexTask);
    assert.strictEqual(complexAgent.name, 'ArchitectAgent', 'Should select ArchitectAgent for complex tasks');
  });

  test('Should select agent with tool capabilities when tools are required', async () => {
    const taskRequiringTools = {
      description: 'Create a pull request for these changes',
      complexity: TaskComplexity.Moderate,
      requiresContext: true,
      requiresTools: true,
      requiredTools: ['github.createPullRequest']
    };

    const agent = await agentSelector.selectAgent(taskRequiringTools);
    assert.ok(agent.capabilities.includes('tools'), 'Selected agent should have tools capability');
    assert.strictEqual(agent.name, 'DevOpsAgent', 'Should select DevOpsAgent for tasks requiring GitHub tools');
  });

  test('Should select agent with context capabilities when context is required', async () => {
    const taskRequiringContext = {
      description: 'Explain the relationship between these classes',
      complexity: TaskComplexity.Moderate,
      requiresContext: true,
      requiresTools: false,
      contextScope: 'deep' as ContextScope
    };

    const agent = await agentSelector.selectAgent(taskRequiringContext);
    assert.ok(agent.capabilities.includes('context'), 'Selected agent should have context capability');
    assert.strictEqual(agent.name, 'DevelopmentAgent', 'Should select DevelopmentAgent for tasks requiring deep context');
  });

  test('Should select specialized agent for domain-specific tasks', async () => {
    const mlTask = {
      description: 'Optimize this machine learning model',
      complexity: TaskComplexity.Complex,
      requiresContext: true,
      requiresTools: false,
      domain: 'machine-learning' as TaskDomain
    };

    const agent = await agentSelector.selectAgent(mlTask);
    assert.strictEqual(agent.name, 'MLAgent', 'Should select MLAgent for machine learning tasks');

    const webTask = {
      description: 'Create a responsive layout for this component',
      complexity: TaskComplexity.Moderate,
      requiresContext: true,
      requiresTools: false,
      domain: 'web-development' as TaskDomain
    };

    const webAgent = await agentSelector.selectAgent(webTask);
    assert.strictEqual(webAgent.name, 'WebDevAgent', 'Should select WebDevAgent for web development tasks');
  });

  test('Should analyze task description to determine complexity when not specified', async () => {
    const implicitComplexTask = {
      description: 'Refactor this monolithic application into a microservices architecture',
      requiresContext: true,
      requiresTools: false
    };

    const agent = await agentSelector.selectAgent(implicitComplexTask);
    assert.strictEqual(agent.name, 'ArchitectAgent', 'Should infer complexity from description and select appropriate agent');
  });

  test('Should handle agent unavailability by selecting fallback agent', async () => {
    // Mock unavailable agent
    agentSelector.setAgentAvailability('ArchitectAgent', false);

    const complexTask = {
      description: 'Design a scalable system architecture',
      complexity: TaskComplexity.Complex,
      requiresContext: true,
      requiresTools: false
    };

    const agent = await agentSelector.selectAgent(complexTask);
    assert.notStrictEqual(agent.name, 'ArchitectAgent', 'Should not select unavailable agent');
    assert.strictEqual(agent.name, 'DevelopmentAgent', 'Should select fallback agent when preferred agent is unavailable');
  });
});

```


---

### File: `src/test/suite/fileIndexer.test.ts`

```typescript
import * as assert from 'assert';
import * as sinon from 'sinon';
import * as vscode from 'vscode';
import { FileIndexer } from '../../context/fileIndexer';
import { EmbeddingService } from '../../context/embeddingService';
import { SymbolExtractor } from '../../context/symbolExtractor';

suite('File Indexer Test Suite', () => {
  let fileIndexer: FileIndexer;
  let mockEmbeddingService: sinon.SinonStubbedInstance<EmbeddingService>;
  let mockSymbolExtractor: sinon.SinonStubbedInstance<SymbolExtractor>;
  let mockTextDocument: vscode.TextDocument;
  
  setup(() => {
    // Create mock instances
    mockEmbeddingService = sinon.createStubInstance(EmbeddingService);
    mockSymbolExtractor = sinon.createStubInstance(SymbolExtractor);
    
    // Mock text document
    mockTextDocument = {
      fileName: '/workspace/src/test.ts',
      languageId: 'typescript',
      lineCount: 10,
      getText: sinon.stub().returns('function test() {\n  return true;\n}'),
      lineAt: sinon.stub().callsFake((line: number) => {
        const lines = ['function test() {', '  return true;', '}'];
        return { text: lines[line] };
      }),
      uri: vscode.Uri.file('/workspace/src/test.ts')
    } as unknown as vscode.TextDocument;
    
    // Initialize file indexer with mocks
    fileIndexer = new FileIndexer(
      mockEmbeddingService as unknown as EmbeddingService,
      mockSymbolExtractor as unknown as SymbolExtractor
    );
  });
  
  teardown(() => {
    sinon.restore();
  });
  
  test('Should index TypeScript file', async () => {
    // Setup
    const mockEmbedding = [0.1, 0.2, 0.3];
    mockEmbeddingService.getEmbedding.resolves(mockEmbedding);
    
    // Mock document loading
    sinon.stub(vscode.workspace, 'openTextDocument').resolves(mockTextDocument);
    
    // Execute
    const chunks = await fileIndexer.indexFile(vscode.Uri.file('/workspace/src/test.ts'));
    
    // Verify
    assert.strictEqual(chunks.length > 0, true, 'Should return chunks');
    assert.strictEqual(chunks[0].filePath, '/workspace/src/test.ts', 'Should set correct file path');
    assert.strictEqual(chunks[0].language, 'typescript', 'Should set correct language');
    assert.strictEqual(chunks[0].embedding, mockEmbedding, 'Should set embedding');
    assert.strictEqual(mockEmbeddingService.getEmbedding.called, true, 'Should get embedding for chunk');
  });
  
  test('Should extract symbols from file', async () => {
    // Setup
    const mockSymbols = [
      { name: 'test', kind: vscode.SymbolKind.Function, range: new vscode.Range(0, 0, 2, 1) }
    ];
    
    mockSymbolExtractor.extractSymbols.resolves(mockSymbols);
    mockEmbeddingService.getEmbedding.resolves([0.1, 0.2, 0.3]);
    
    // Mock document loading
    sinon.stub(vscode.workspace, 'openTextDocument').resolves(mockTextDocument);
    
    // Execute
    const chunks = await fileIndexer.indexFile(vscode.Uri.file('/workspace/src/test.ts'));
    
    // Verify
    assert.strictEqual(mockSymbolExtractor.extractSymbols.called, true, 'Should extract symbols');
    assert.strictEqual(chunks.some(chunk => chunk.symbol), true, 'Should include symbol information in chunks');
  });
  
  test('Should handle unsupported file types', async () => {
    // Setup - create a binary file mock
    const binaryDocument = {
      fileName: '/workspace/src/image.png',
      languageId: 'binary',
      lineCount: 0,
      getText: sinon.stub().returns(''),
      uri: vscode.Uri.file('/workspace/src/image.png')
    } as unknown as vscode.TextDocument;
    
    // Mock document loading
    sinon.stub(vscode.workspace, 'openTextDocument').resolves(binaryDocument);
    
    // Execute
    const chunks = await fileIndexer.indexFile(vscode.Uri.file('/workspace/src/image.png'));
    
    // Verify
    assert.strictEqual(chunks.length, 0, 'Should return empty array for unsupported file types');
  });
  
  test('Should handle large files by chunking', async () => {
    // Setup - create a large file mock
    const largeFileContent = Array(1000).fill('console.log("test");').join('\n');
    const largeDocument = {
      fileName: '/workspace/src/large.ts',
      languageId: 'typescript',
      lineCount: 1000,
      getText: sinon.stub().returns(largeFileContent),
      lineAt: sinon.stub().callsFake((line: number) => {
        return { text: 'console.log("test");' };
      }),
      uri: vscode.Uri.file('/workspace/src/large.ts')
    } as unknown as vscode.TextDocument;
    
    // Mock document loading
    sinon.stub(vscode.workspace, 'openTextDocument').resolves(largeDocument);
    mockEmbeddingService.getEmbedding.resolves([0.1, 0.2, 0.3]);
    
    // Execute
    const chunks = await fileIndexer.indexFile(vscode.Uri.file('/workspace/src/large.ts'));
    
    // Verify
    assert.strictEqual(chunks.length > 1, true, 'Should split large file into multiple chunks');
  });
});

```


---

### File: `src/test/suite/dynamicAgentSelector.test.ts`

```typescript
import * as assert from 'assert';
import { AgentSelector } from '../../agents/agentSelector';
import {
    Agent,
    AgentCapability,
    AgentType,
    ContextScope,
    ModelSize,
    Task,
    TaskComplexity,
    TaskDomain,
    ThinkingMode
} from '../../agents/types';

suite('Dynamic Agent Selection Test Suite', () => {
  let agentSelector: AgentSelector;

  setup(() => {
    agentSelector = new AgentSelector();
    
    // Add test agents to the selector
    agentSelector.registerAgent({
      name: 'SimpleAgent',
      type: AgentType.Simple,
      capabilities: ['code'],
      modelSize: ModelSize.Small,
      maxComplexity: TaskComplexity.Simple,
      systemPrompt: 'You are a simple coding assistant that helps with basic tasks.',
      available: true
    });
    
    agentSelector.registerAgent({
      name: 'DevelopmentAgent',
      type: AgentType.Development,
      capabilities: ['code', 'context', 'reasoning'],
      modelSize: ModelSize.Large,
      maxComplexity: TaskComplexity.Complex,
      systemPrompt: 'You are a development assistant that helps with coding tasks.',
      available: true
    });
    
    agentSelector.registerAgent({
      name: 'ArchitectAgent',
      type: AgentType.Architecture,
      capabilities: ['code', 'context', 'reasoning', 'architecture'],
      modelSize: ModelSize.XLarge,
      maxComplexity: TaskComplexity.VeryComplex,
      systemPrompt: 'You are an architecture assistant that helps with system design and architecture.',
      available: true
    });
    
    agentSelector.registerAgent({
      name: 'DevOpsAgent',
      type: AgentType.DevOps,
      capabilities: ['code', 'tools', 'context'],
      modelSize: ModelSize.Large,
      maxComplexity: TaskComplexity.Complex,
      specializations: ['github', 'docker', 'ci-cd'],
      systemPrompt: 'You are a DevOps assistant that helps with CI/CD, deployment, and infrastructure.',
      available: true
    });
    
    agentSelector.registerAgent({
      name: 'MLAgent',
      type: AgentType.ML,
      capabilities: ['code', 'context', 'reasoning'],
      modelSize: ModelSize.XLarge,
      maxComplexity: TaskComplexity.VeryComplex,
      specializations: ['machine-learning', 'data-science', 'neural-networks'],
      systemPrompt: 'You are a machine learning assistant that helps with ML models and algorithms.',
      available: true
    });
    
    agentSelector.registerAgent({
      name: 'WebDevAgent',
      type: AgentType.WebDev,
      capabilities: ['code', 'context'],
      modelSize: ModelSize.Medium,
      maxComplexity: TaskComplexity.Complex,
      specializations: ['web-development', 'frontend', 'backend'],
      systemPrompt: 'You are a web development assistant that helps with frontend and backend tasks.',
      available: true
    });
  });

  test('Should select appropriate agent based on task complexity', async () => {
    // Test simple task
    const simpleTask: Task = {
      description: 'Format this code snippet',
      complexity: TaskComplexity.Simple,
      requiresContext: false,
      requiresTools: false
    };
    
    const simpleAgent = await agentSelector.selectAgent(simpleTask);
    assert.strictEqual(simpleAgent.name, 'SimpleAgent', 'Should select SimpleAgent for simple tasks');
    
    // Test moderate task
    const moderateTask: Task = {
      description: 'Explain how this algorithm works',
      complexity: TaskComplexity.Moderate,
      requiresContext: true,
      requiresTools: false
    };
    
    const moderateAgent = await agentSelector.selectAgent(moderateTask);
    assert.strictEqual(moderateAgent.name, 'DevelopmentAgent', 'Should select DevelopmentAgent for moderate tasks');
    
    // Test complex task
    const complexTask: Task = {
      description: 'Refactor this code to use the factory pattern',
      complexity: TaskComplexity.Complex,
      requiresContext: true,
      requiresTools: false
    };
    
    const complexAgent = await agentSelector.selectAgent(complexTask);
    assert.strictEqual(complexAgent.name, 'ArchitectAgent', 'Should select ArchitectAgent for complex tasks');
  });

  test('Should select agent with tool capabilities when tools are required', async () => {
    const taskRequiringTools: Task = {
      description: 'Create a pull request for these changes',
      complexity: TaskComplexity.Moderate,
      requiresContext: true,
      requiresTools: true,
      requiredTools: ['github.createPullRequest']
    };
    
    const agent = await agentSelector.selectAgent(taskRequiringTools);
    assert.ok(agent.capabilities.includes('tools'), 'Selected agent should have tools capability');
    assert.strictEqual(agent.name, 'DevOpsAgent', 'Should select DevOpsAgent for tasks requiring GitHub tools');
  });

  test('Should select agent with context capabilities when context is required', async () => {
    const taskRequiringContext: Task = {
      description: 'Explain the relationship between these classes',
      complexity: TaskComplexity.Moderate,
      requiresContext: true,
      requiresTools: false,
      contextScope: 'deep' as ContextScope
    };
    
    const agent = await agentSelector.selectAgent(taskRequiringContext);
    assert.ok(agent.capabilities.includes('context'), 'Selected agent should have context capability');
    assert.strictEqual(agent.name, 'DevelopmentAgent', 'Should select DevelopmentAgent for tasks requiring deep context');
  });

  test('Should select specialized agent for domain-specific tasks', async () => {
    const mlTask: Task = {
      description: 'Optimize this machine learning model',
      complexity: TaskComplexity.Complex,
      requiresContext: true,
      requiresTools: false,
      domain: 'machine-learning' as TaskDomain
    };
    
    const agent = await agentSelector.selectAgent(mlTask);
    assert.strictEqual(agent.name, 'MLAgent', 'Should select MLAgent for machine learning tasks');
    
    const webTask: Task = {
      description: 'Create a responsive layout for this component',
      complexity: TaskComplexity.Moderate,
      requiresContext: true,
      requiresTools: false,
      domain: 'web-development' as TaskDomain
    };
    
    const webAgent = await agentSelector.selectAgent(webTask);
    assert.strictEqual(webAgent.name, 'WebDevAgent', 'Should select WebDevAgent for web development tasks');
  });

  test('Should analyze task description to determine complexity when not specified', async () => {
    const implicitComplexTask: Task = {
      description: 'Refactor this monolithic application into a microservices architecture',
      requiresContext: true,
      requiresTools: false
    };
    
    const agent = await agentSelector.selectAgent(implicitComplexTask);
    assert.strictEqual(agent.name, 'ArchitectAgent', 'Should infer complexity from description and select appropriate agent');
  });

  test('Should handle agent unavailability by selecting fallback agent', async () => {
    // Mock unavailable agent
    agentSelector.setAgentAvailability('ArchitectAgent', false);
    
    const complexTask: Task = {
      description: 'Design a scalable system architecture',
      complexity: TaskComplexity.Complex,
      requiresContext: true,
      requiresTools: false
    };
    
    const agent = await agentSelector.selectAgent(complexTask);
    assert.notStrictEqual(agent.name, 'ArchitectAgent', 'Should not select unavailable agent');
    assert.strictEqual(agent.name, 'DevelopmentAgent', 'Should select fallback agent when preferred agent is unavailable');
  });
});

```


---

### File: `src/github-integration/githubRepoManager.ts`

```typescript
import * as fs from 'fs';
import * as path from 'path';
import * as simpleGit from 'simple-git';
import { GitHubOptions } from '../configuration';

/**
 * Repository information
 */
export interface RepoInfo {
  name: string;
  description?: string;
  version?: string;
  localPath: string;
  hasMcpSchema: boolean;
  hasDockerfile: boolean;
  schemaPath?: string;
  dockerfilePath?: string;
}

/**
 * Manager for GitHub repositories
 */
export class GitHubRepoManager {
  private options: GitHubOptions;

  /**
   * Create a new GitHub repository manager
   * @param options GitHub options
   */
  constructor(options: GitHubOptions) {
    this.options = options;
  }

  /**
   * Clone a repository
   * @param repoUrl Repository URL
   * @param targetDir Target directory
   * @returns Promise that resolves to the repository information
   */
  public async cloneRepository(repoUrl: string, targetDir: string): Promise<RepoInfo> {
    try {
      // Parse the repository URL to get the name
      const repoName = this.getRepoNameFromUrl(repoUrl);

      // Create the target directory if it doesn't exist
      if (!fs.existsSync(targetDir)) {
        fs.mkdirSync(targetDir, { recursive: true });
      }

      // Set the local path
      const localPath = path.join(targetDir, repoName);

      // Check if the repository already exists
      if (fs.existsSync(localPath)) {
        // Pull the latest changes
        const git = simpleGit.simpleGit(localPath);
        await git.pull();
      } else {
        // Clone the repository
        const git = simpleGit.simpleGit();
        const cloneOptions = {
          '--depth': 1
        };

        // Add token if provided
        if (this.options.token) {
          const tokenUrl = this.addTokenToUrl(repoUrl, this.options.token);
          await git.clone(tokenUrl, localPath, cloneOptions);
        } else {
          await git.clone(repoUrl, localPath, cloneOptions);
        }
      }

      // Get repository information
      const info: RepoInfo = {
        name: repoName,
        localPath,
        hasMcpSchema: false,
        hasDockerfile: false
      };

      // Check for MCP schema file
      const schemaFiles = [
        'mcp-schema.json',
        'schema.json',
        'mcp.json',
        'mcp-schema.yaml',
        'schema.yaml',
        'mcp.yaml'
      ];

      for (const schemaFile of schemaFiles) {
        const schemaPath = path.join(localPath, schemaFile);
        if (fs.existsSync(schemaPath)) {
          info.hasMcpSchema = true;
          info.schemaPath = schemaPath;
          break;
        }
      }

      // Check for Dockerfile
      const dockerfileFiles = [
        'Dockerfile',
        'docker/Dockerfile',
        '.docker/Dockerfile'
      ];

      for (const dockerfileFile of dockerfileFiles) {
        const dockerfilePath = path.join(localPath, dockerfileFile);
        if (fs.existsSync(dockerfilePath)) {
          info.hasDockerfile = true;
          info.dockerfilePath = dockerfilePath;
          break;
        }
      }

      // Try to get description and version from package.json or pyproject.toml
      const packageJsonPath = path.join(localPath, 'package.json');
      const pyprojectTomlPath = path.join(localPath, 'pyproject.toml');

      if (fs.existsSync(packageJsonPath)) {
        const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
        info.description = packageJson.description;
        info.version = packageJson.version;
      } else if (fs.existsSync(pyprojectTomlPath)) {
        const pyprojectToml = fs.readFileSync(pyprojectTomlPath, 'utf8');

        // Try to parse the version from pyproject.toml
        const versionMatch = pyprojectToml.match(/version\s*=\s*["']([^"']+)["']/);
        if (versionMatch) {
          info.version = versionMatch[1];
        }

        // Try to parse the description from pyproject.toml
        const descriptionMatch = pyprojectToml.match(/description\s*=\s*["']([^"']+)["']/);
        if (descriptionMatch) {
          info.description = descriptionMatch[1];
        }
      }

      return info;
    } catch (error) {
      console.error('Error cloning repository:', error);
      throw error;
    }
  }

  /**
   * Get the repository name from a URL
   * @param repoUrl Repository URL
   * @returns Repository name
   */
  private getRepoNameFromUrl(repoUrl: string): string {
    // Remove .git extension if present
    const url = repoUrl.endsWith('.git') ? repoUrl.slice(0, -4) : repoUrl;

    // Get the last part of the URL
    const parts = url.split('/');
    return parts[parts.length - 1];
  }

  /**
   * Add a token to a URL
   * @param url URL
   * @param token Token
   * @returns URL with token
   */
  private addTokenToUrl(url: string, token: string): string {
    // Check if the URL is an HTTPS URL
    if (url.startsWith('https://')) {
      // Add the token to the URL
      return url.replace('https://', `https://${token}@`);
    }

    return url;
  }
}

```


---

### File: `src/mcp/contextGatherer.ts`

```typescript
/**
 * Context Gatherer for MCP Servers
 * 
 * Gathers context from MCP servers to provide to Qwen
 */

import * as vscode from 'vscode';
import { McpClient } from './mcpClient';
import { QwenMessage } from '../qwenApi';

/**
 * Context Gatherer class
 */
export class ContextGatherer {
  private outputChannel: vscode.OutputChannel;

  /**
   * Constructor
   * @param mcpClient MCP client
   */
  constructor(private mcpClient: McpClient) {
    this.outputChannel = vscode.window.createOutputChannel('MCP Context Gatherer');
  }

  /**
   * Gather context from MCP servers
   * @param userMessage User message
   * @returns Context messages
   */
  public async gatherContext(userMessage: string): Promise<QwenMessage[]> {
    try {
      this.outputChannel.appendLine(`Gathering context for message: ${userMessage.substring(0, 100)}...`);
      
      const contextMessages: QwenMessage[] = [];
      
      // Get available tools
      const tools = await this.mcpClient.getAllTools();
      
      // Get workspace context if available
      const workspaceContext = await this.getWorkspaceContext();
      if (workspaceContext) {
        contextMessages.push({
          role: 'system',
          content: `Workspace context:\n${workspaceContext}`
        });
      }
      
      // Get git context if available
      const gitContext = await this.getGitContext();
      if (gitContext) {
        contextMessages.push({
          role: 'system',
          content: `Git context:\n${gitContext}`
        });
      }
      
      // Get file context if available
      const fileContext = await this.getFileContext(userMessage);
      if (fileContext) {
        contextMessages.push({
          role: 'system',
          content: `File context:\n${fileContext}`
        });
      }
      
      this.outputChannel.appendLine(`Gathered ${contextMessages.length} context messages`);
      
      return contextMessages;
    } catch (error) {
      this.outputChannel.appendLine(`Error gathering context: ${error}`);
      return [];
    }
  }
  
  /**
   * Get workspace context
   * @returns Workspace context
   */
  private async getWorkspaceContext(): Promise<string | null> {
    try {
      // Check if we have a filesystem tool
      const filesystemTool = await this.mcpClient.findTool('filesystem');
      if (!filesystemTool) {
        return null;
      }
      
      // Get workspace folders
      const workspaceFolders = vscode.workspace.workspaceFolders;
      if (!workspaceFolders || workspaceFolders.length === 0) {
        return null;
      }
      
      // Get workspace root
      const workspaceRoot = workspaceFolders[0].uri.fsPath;
      
      // Get workspace structure
      const result = await this.mcpClient.callFunction(
        filesystemTool.serverId,
        'filesystem',
        'listDirectory',
        { path: workspaceRoot, recursive: false, maxDepth: 2 }
      );
      
      if (result.status === 'error' || !result.result) {
        return null;
      }
      
      // Format workspace structure
      const files = result.result.files || [];
      const directories = result.result.directories || [];
      
      let context = `Workspace root: ${workspaceRoot}\n\n`;
      context += 'Directories:\n';
      context += directories.map((dir: string) => `- ${dir}`).join('\n');
      context += '\n\nFiles:\n';
      context += files.map((file: string) => `- ${file}`).join('\n');
      
      return context;
    } catch (error) {
      this.outputChannel.appendLine(`Error getting workspace context: ${error}`);
      return null;
    }
  }
  
  /**
   * Get git context
   * @returns Git context
   */
  private async getGitContext(): Promise<string | null> {
    try {
      // Check if we have a git tool
      const gitTool = await this.mcpClient.findTool('git');
      if (!gitTool) {
        return null;
      }
      
      // Get current branch
      const branchResult = await this.mcpClient.callFunction(
        gitTool.serverId,
        'git',
        'getCurrentBranch',
        {}
      );
      
      if (branchResult.status === 'error' || !branchResult.result) {
        return null;
      }
      
      // Get status
      const statusResult = await this.mcpClient.callFunction(
        gitTool.serverId,
        'git',
        'getStatus',
        {}
      );
      
      if (statusResult.status === 'error' || !statusResult.result) {
        return null;
      }
      
      // Format git context
      let context = `Current branch: ${branchResult.result}\n\n`;
      context += 'Git status:\n';
      
      const status = statusResult.result;
      if (status.modified && status.modified.length > 0) {
        context += 'Modified files:\n';
        context += status.modified.map((file: string) => `- ${file}`).join('\n');
        context += '\n\n';
      }
      
      if (status.added && status.added.length > 0) {
        context += 'Added files:\n';
        context += status.added.map((file: string) => `- ${file}`).join('\n');
        context += '\n\n';
      }
      
      if (status.deleted && status.deleted.length > 0) {
        context += 'Deleted files:\n';
        context += status.deleted.map((file: string) => `- ${file}`).join('\n');
        context += '\n\n';
      }
      
      return context;
    } catch (error) {
      this.outputChannel.appendLine(`Error getting git context: ${error}`);
      return null;
    }
  }
  
  /**
   * Get file context
   * @param userMessage User message
   * @returns File context
   */
  private async getFileContext(userMessage: string): Promise<string | null> {
    try {
      // Check if we have a filesystem tool
      const filesystemTool = await this.mcpClient.findTool('filesystem');
      if (!filesystemTool) {
        return null;
      }
      
      // Get active editor
      const editor = vscode.window.activeTextEditor;
      if (!editor) {
        return null;
      }
      
      // Get file path
      const filePath = editor.document.uri.fsPath;
      
      // Get file content
      const result = await this.mcpClient.callFunction(
        filesystemTool.serverId,
        'filesystem',
        'readFile',
        { path: filePath }
      );
      
      if (result.status === 'error' || !result.result) {
        return null;
      }
      
      // Get file content
      const content = result.result.content || '';
      
      // Get selection if any
      let selection = '';
      if (!editor.selection.isEmpty) {
        selection = editor.document.getText(editor.selection);
      }
      
      // Format file context
      let context = `Active file: ${filePath}\n\n`;
      
      if (selection) {
        context += 'Selected text:\n```\n';
        context += selection;
        context += '\n```\n\n';
      }
      
      // Only include file content if it's not too large
      if (content.length < 10000) {
        context += 'File content:\n```\n';
        context += content;
        context += '\n```';
      } else {
        context += 'File content is too large to include in context.';
      }
      
      return context;
    } catch (error) {
      this.outputChannel.appendLine(`Error getting file context: ${error}`);
      return null;
    }
  }
  
  /**
   * Dispose of resources
   */
  public dispose(): void {
    this.outputChannel.dispose();
  }
}

```


---

### File: `src/mcp/mcpTypes.ts`

```typescript
/**
 * Types for MCP client and server management
 */

/**
 * MCP function schema
 */
export interface MCPFunctionSchema {
  name: string;
  description: string;
  parameters: {
    type: string;
    properties: Record<string, {
      type: string;
      description: string;
      enum?: string[];
    }>;
    required: string[];
  };
}

/**
 * MCP tool schema
 */
export interface MCPToolSchema {
  name: string;
  description: string;
  functions: MCPFunctionSchema[];
}

/**
 * MCP function call result
 */
export interface MCPFunctionCallResult {
  status: 'success' | 'error';
  result?: any;
  error?: string;
}

/**
 * MCP tool parameter
 */
export interface MCPToolParameter {
  name: string;
  description: string;
  type: string;
  required: boolean;
  default?: any;
}

/**
 * MCP tool return
 */
export interface MCPToolReturn {
  description: string;
  type: string;
}

```


---

### File: `src/mcp/mcpQwenBridge.ts`

```typescript
import * as vscode from 'vscode';
import { QwenApiClient, QwenMessage, QwenResponse, QwenTool, QwenToolCall } from '../qwenApi';
import { ContextGatherer } from './contextGatherer';
import { McpClient } from './mcpClient';
import { MCPToolSchema } from './mcpTypes';

/**
 * Type for streaming response handler
 */
export type StreamingResponseHandler = (chunk: string, done: boolean, toolCalls?: QwenToolCall[]) => void;

/**
 * Bridge between MCP and Qwen
 * Handles converting MCP tools to Qwen tools and processing tool calls
 */
export class McpQwenBridge {
  private outputChannel: vscode.OutputChannel;
  private contextGatherer: ContextGatherer;

  constructor(
    private qwenClient: QwenApiClient,
    private mcpClient: McpClient
  ) {
    this.outputChannel = vscode.window.createOutputChannel('MCP-Qwen Bridge');
    this.contextGatherer = new ContextGatherer(mcpClient);
  }

  /**
   * Process a user message with MCP tools
   * @param message User message
   * @param options Options for processing
   * @returns Response from Qwen with tool results if applicable
   */
  public async processMessage(
    message: string,
    options: {
      systemPrompt?: string;
      thinkingMode?: 'auto' | 'always' | 'never';
      thinkingBudget?: number;
      temperature?: number;
      maxTokens?: number;
      modelName?: string;
      contextMessages?: QwenMessage[];
      gatherContext?: boolean;
    } = {}
  ): Promise<string> {
    try {
      this.outputChannel.appendLine(`Processing message: ${message.substring(0, 100)}...`);

      // Get available tools from MCP servers
      const mcpTools = await this.mcpClient.getAllTools();
      this.outputChannel.appendLine(`Found ${mcpTools.length} MCP tools`);

      // Convert MCP tools to Qwen tools
      const qwenTools = mcpTools.map(tool => this.convertToolToQwenFormat(tool));

      // Create messages array
      const messages: QwenMessage[] = [];

      // Add system message if provided
      if (options.systemPrompt) {
        messages.push({
          role: 'system',
          content: options.systemPrompt
        });
      }

      // Add context messages if provided
      if (options.contextMessages && options.contextMessages.length > 0) {
        messages.push(...options.contextMessages);
      }

      // Gather context if enabled
      if (options.gatherContext !== false) {
        try {
          const contextMessages = await this.contextGatherer.gatherContext(message);
          if (contextMessages.length > 0) {
            this.outputChannel.appendLine(`Adding ${contextMessages.length} context messages`);
            messages.push(...contextMessages);
          }
        } catch (error) {
          this.outputChannel.appendLine(`Error gathering context: ${error}`);
        }
      }

      // Add user message
      messages.push({
        role: 'user',
        content: message
      });

      // Call Qwen API with tools
      const response = await this.qwenClient.chatWithTools(messages, {
        thinkingMode: options.thinkingMode || 'auto',
        thinkingBudget: options.thinkingBudget,
        temperature: options.temperature,
        maxTokens: options.maxTokens,
        modelName: options.modelName,
        tools: qwenTools
      });

      // Process tool calls if present
      if (response.tool_calls && response.tool_calls.length > 0) {
        return await this.processToolCallsAndGetFinalResponse(response, messages);
      }

      return response.text;
    } catch (error) {
      this.outputChannel.appendLine(`Error processing message: ${error}`);
      return `Error: ${error}`;
    }
  }

  /**
   * Process a user message with MCP tools using streaming
   * @param message User message
   * @param options Options for processing
   * @param onChunk Callback function to handle streaming chunks
   */
  public async processMessageStream(
    message: string,
    options: {
      systemPrompt?: string;
      thinkingMode?: 'auto' | 'always' | 'never';
      thinkingBudget?: number;
      temperature?: number;
      maxTokens?: number;
      modelName?: string;
      contextMessages?: QwenMessage[];
      gatherContext?: boolean;
    } = {},
    onChunk: StreamingResponseHandler
  ): Promise<void> {
    try {
      this.outputChannel.appendLine(`Processing message with streaming: ${message.substring(0, 100)}...`);

      // Get available tools from MCP servers
      const mcpTools = await this.mcpClient.getAllTools();
      this.outputChannel.appendLine(`Found ${mcpTools.length} MCP tools`);

      // Convert MCP tools to Qwen tools
      const qwenTools = mcpTools.map(tool => this.convertToolToQwenFormat(tool));

      // Create messages array
      const messages: QwenMessage[] = [];

      // Add system message if provided
      if (options.systemPrompt) {
        messages.push({
          role: 'system',
          content: options.systemPrompt
        });
      }

      // Add context messages if provided
      if (options.contextMessages && options.contextMessages.length > 0) {
        messages.push(...options.contextMessages);
      }

      // Gather context if enabled
      if (options.gatherContext !== false) {
        try {
          const contextMessages = await this.contextGatherer.gatherContext(message);
          if (contextMessages.length > 0) {
            this.outputChannel.appendLine(`Adding ${contextMessages.length} context messages`);
            messages.push(...contextMessages);
          }
        } catch (error) {
          this.outputChannel.appendLine(`Error gathering context: ${error}`);
        }
      }

      // Add user message
      messages.push({
        role: 'user',
        content: message
      });

      // Accumulate the full response and tool calls
      let fullResponse = '';
      let toolCalls: QwenToolCall[] = [];

      // Call Qwen API with tools and streaming
      await this.qwenClient.chatStreamWithTools(
        messages,
        {
          thinkingMode: options.thinkingMode || 'auto',
          thinkingBudget: options.thinkingBudget,
          temperature: options.temperature,
          maxTokens: options.maxTokens,
          modelName: options.modelName,
          tools: qwenTools
        },
        async (chunk, done, chunkToolCalls) => {
          // Accumulate the response
          fullResponse += chunk;

          // Update tool calls if present
          if (chunkToolCalls && chunkToolCalls.length > 0) {
            toolCalls = chunkToolCalls;
          }

          // Pass to the original handler
          onChunk(chunk, false, toolCalls);

          // When streaming is complete, process tool calls if present
          if (done && toolCalls.length > 0) {
            // Add assistant message with tool calls
            messages.push({
              role: 'assistant',
              content: fullResponse,
              tool_calls: toolCalls
            });

            // Process tool calls
            await this.processToolCallsAndStreamFinalResponse(toolCalls, messages, onChunk);
          } else if (done) {
            // Signal completion if no tool calls
            onChunk('', true);
          }
        }
      );
    } catch (error) {
      this.outputChannel.appendLine(`Error processing message with streaming: ${error}`);
      onChunk(`Error: ${error}`, true);
    }
  }

  /**
   * Process tool calls and get a final response
   * @param initialResponse Initial response with tool calls
   * @param messages Conversation messages
   * @returns Final response after tool execution
   */
  private async processToolCallsAndGetFinalResponse(
    initialResponse: QwenResponse,
    messages: QwenMessage[]
  ): Promise<string> {
    if (!initialResponse.tool_calls || initialResponse.tool_calls.length === 0) {
      return initialResponse.text;
    }

    this.outputChannel.appendLine(`Processing ${initialResponse.tool_calls.length} tool calls`);

    // Add assistant message with tool calls
    messages.push({
      role: 'assistant',
      content: initialResponse.text,
      tool_calls: initialResponse.tool_calls
    });

    // Process each tool call
    const toolResults = await Promise.all(
      initialResponse.tool_calls.map(async (toolCall) => {
        try {
          const result = await this.executeToolCall(toolCall);
          return {
            tool_call_id: toolCall.id,
            role: 'tool' as const,
            name: toolCall.function.name,
            content: typeof result === 'string' ? result : JSON.stringify(result)
          };
        } catch (error) {
          return {
            tool_call_id: toolCall.id,
            role: 'tool' as const,
            name: toolCall.function.name,
            content: `Error: ${error}`
          };
        }
      })
    );

    // Add tool results to messages
    messages.push(...toolResults);

    // Get final response from Qwen
    const finalResponse = await this.qwenClient.chat(messages);
    return finalResponse;
  }

  /**
   * Process tool calls and stream the final response
   * @param toolCalls Tool calls to process
   * @param messages Conversation messages
   * @param onChunk Callback function to handle streaming chunks
   */
  private async processToolCallsAndStreamFinalResponse(
    toolCalls: QwenToolCall[],
    messages: QwenMessage[],
    onChunk: StreamingResponseHandler
  ): Promise<void> {
    try {
      this.outputChannel.appendLine(`Processing ${toolCalls.length} tool calls for streaming response`);

      // Process each tool call
      const toolResults = await Promise.all(
        toolCalls.map(async (toolCall) => {
          try {
            const result = await this.executeToolCall(toolCall);
            return {
              tool_call_id: toolCall.id,
              role: 'tool' as const,
              name: toolCall.function.name,
              content: typeof result === 'string' ? result : JSON.stringify(result)
            };
          } catch (error) {
            return {
              tool_call_id: toolCall.id,
              role: 'tool' as const,
              name: toolCall.function.name,
              content: `Error: ${error}`
            };
          }
        })
      );

      // Add tool results to messages
      messages.push(...toolResults);

      // Stream final response from Qwen
      await this.qwenClient.chatStream(
        messages,
        {},
        (chunk, done) => {
          onChunk(chunk, done);
        }
      );
    } catch (error) {
      this.outputChannel.appendLine(`Error processing tool calls for streaming: ${error}`);
      onChunk(`Error: ${error}`, true);
    }
  }

  /**
   * Execute a tool call
   * @param toolCall Tool call to execute
   * @returns Result of the tool call
   */
  private async executeToolCall(toolCall: QwenToolCall): Promise<any> {
    try {
      this.outputChannel.appendLine(`Executing tool call: ${toolCall.function.name}`);

      // Parse the function name (format: serverId.toolName.functionName)
      const [serverId, toolName, functionName] = toolCall.function.name.split('.');

      if (!serverId || !toolName || !functionName) {
        throw new Error(`Invalid function name format: ${toolCall.function.name}`);
      }

      // Parse arguments
      let args: Record<string, any>;
      try {
        args = JSON.parse(toolCall.function.arguments);
      } catch (error) {
        throw new Error(`Invalid arguments: ${error}`);
      }

      // Call the function
      const result = await this.mcpClient.callFunction(serverId, toolName, functionName, args);

      // Check for errors
      if (result.status === 'error') {
        throw new Error(result.error || 'Unknown error');
      }

      this.outputChannel.appendLine(`Tool call executed successfully`);
      return result.result;
    } catch (error) {
      this.outputChannel.appendLine(`Error executing tool call: ${error}`);
      throw error;
    }
  }

  /**
   * Convert MCP tool to Qwen tool format
   * @param mcpTool MCP tool
   * @returns Qwen tool
   */
  private convertToolToQwenFormat(mcpTool: { serverId: string; tool: MCPToolSchema }): QwenTool {
    try {
      const { serverId, tool } = mcpTool;

      // Create a tool for each function in the MCP tool
      return {
        type: 'function',
        function: {
          name: `${serverId}.${tool.name}`,
          description: tool.description || `Tool provided by ${serverId}`,
          parameters: {
            type: 'object',
            properties: this.convertParametersToQwenFormat(tool.parameters || []),
            required: tool.parameters
              ?.filter(param => param.required)
              .map(param => param.name) || []
          }
        }
      };
    } catch (error) {
      this.outputChannel.appendLine(`Error converting MCP tool to Qwen format: ${error}`);
      throw error;
    }
  }

  /**
   * Convert MCP parameters to Qwen format
   * @param parameters MCP parameters
   * @returns Qwen parameters
   */
  private convertParametersToQwenFormat(
    parameters: Array<{
      name: string;
      type: string;
      description?: string;
      required?: boolean;
      enum?: string[];
    }>
  ): Record<string, any> {
    const result: Record<string, any> = {};

    for (const param of parameters) {
      result[param.name] = {
        type: this.mapMcpTypeToQwenType(param.type),
        description: param.description || `Parameter ${param.name}`
      };

      // Add enum if available
      if (param.enum && param.enum.length > 0) {
        result[param.name].enum = param.enum;
      }
    }

    return result;
  }

  /**
   * Map MCP type to Qwen type
   * @param mcpType MCP type
   * @returns Qwen type
   */
  private mapMcpTypeToQwenType(mcpType: string): string {
    // Convert MCP types to Qwen types
    switch (mcpType.toLowerCase()) {
      case 'string':
      case 'text':
      case 'char':
        return 'string';
      case 'integer':
      case 'int':
      case 'long':
      case 'short':
      case 'byte':
      case 'float':
      case 'double':
      case 'decimal':
      case 'number':
        return 'number';
      case 'boolean':
      case 'bool':
        return 'boolean';
      case 'array':
      case 'list':
      case 'collection':
        return 'array';
      case 'object':
      case 'map':
      case 'dict':
      case 'dictionary':
        return 'object';
      case 'null':
        return 'null';
      default:
        // Default to string for unknown types
        this.outputChannel.appendLine(`Unknown MCP type: ${mcpType}, defaulting to string`);
        return 'string';
    }
  }

  /**
   * Dispose of resources
   */
  public dispose(): void {
    this.outputChannel.dispose();
    this.contextGatherer.dispose();
  }
}

```


---

### File: `src/mcp/mcpClient.ts`

```typescript
/**
 * MCP Client
 *
 * Client for interacting with Model-Control-Protocol (MCP) tools.
 */

import axios from 'axios';
import * as vscode from 'vscode';
import { ContainerManager } from '../containers/containerManager';
import { MCPFunctionCallResult, MCPFunctionSchema, MCPToolSchema } from './mcpTypes';

/**
 * MCP Client class
 */
export class MCPClient {
  private containerManager: ContainerManager;
  private outputChannel: vscode.OutputChannel;
  private toolSchemas: Record<string, MCPToolSchema>;

  /**
   * Constructor
   * @param containerManager The container manager
   */
  constructor(containerManager: ContainerManager) {
    this.containerManager = containerManager;
    this.outputChannel = vscode.window.createOutputChannel('MCP Client');
    this.toolSchemas = {};

    this.outputChannel.appendLine('MCP Client initialized');
  }

  /**
   * Initialize the MCP client
   */
  public async initialize(): Promise<void> {
    try {
      this.outputChannel.appendLine('Initializing MCP client');

      // Get active containers
      const containerStatus = this.containerManager.getContainerStatus();

      // Fetch schemas for running containers
      for (const containerName in containerStatus) {
        const container = containerStatus[containerName];

        if (container.status === 'running') {
          try {
            await this.fetchToolSchema(containerName);
          } catch (error) {
            this.outputChannel.appendLine(`Error fetching schema for ${containerName}: ${error.message}`);
          }
        }
      }

      this.outputChannel.appendLine('MCP client initialized');
    } catch (error) {
      this.outputChannel.appendLine(`Error initializing MCP client: ${error.message}`);
      throw error;
    }
  }

  /**
   * Fetch the schema for a tool
   * @param toolName The name of the tool
   * @returns The tool schema
   */
  public async fetchToolSchema(toolName: string): Promise<MCPToolSchema> {
    try {
      this.outputChannel.appendLine(`Fetching schema for tool: ${toolName}`);

      // Get container URL
      const url = this.containerManager.getContainerUrl(toolName);

      // Fetch schema
      const response = await axios.get(`${url}/schema`);
      const schema = response.data;

      // Validate schema
      if (!schema.name || !schema.functions || !Array.isArray(schema.functions)) {
        throw new Error(`Invalid schema for tool ${toolName}`);
      }

      // Store schema
      this.toolSchemas[toolName] = schema;

      this.outputChannel.appendLine(`Schema fetched for tool ${toolName}: ${schema.functions.length} functions available`);

      return schema;
    } catch (error) {
      this.outputChannel.appendLine(`Error fetching schema for tool ${toolName}: ${error.message}`);
      throw error;
    }
  }

  /**
   * Get the schema for a tool
   * @param toolName The name of the tool
   * @returns The tool schema
   */
  public getToolSchema(toolName: string): MCPToolSchema | undefined {
    return this.toolSchemas[toolName];
  }

  /**
   * Get all available tools
   * @returns The available tools
   */
  public getAvailableTools(): string[] {
    return Object.keys(this.toolSchemas);
  }

  /**
   * Get all tools with their schemas
   * @returns Array of tools with their schemas and server IDs
   */
  public async getAllTools(): Promise<Array<{ serverId: string; tool: MCPToolSchema }>> {
    try {
      this.outputChannel.appendLine('Getting all tools');

      // Get active containers
      const containerStatus = this.containerManager.getContainerStatus();
      const tools: Array<{ serverId: string; tool: MCPToolSchema }> = [];

      // Fetch schemas for running containers if not already fetched
      for (const containerId in containerStatus) {
        const container = containerStatus[containerId];

        if (container.status === 'running') {
          try {
            // Get or fetch schema
            let schema = this.toolSchemas[containerId];
            if (!schema) {
              schema = await this.fetchToolSchema(containerId);
            }

            // Add to tools list
            tools.push({
              serverId: containerId,
              tool: schema
            });
          } catch (error) {
            this.outputChannel.appendLine(`Error getting schema for ${containerId}: ${error.message}`);
          }
        }
      }

      this.outputChannel.appendLine(`Found ${tools.length} tools`);
      return tools;
    } catch (error) {
      this.outputChannel.appendLine(`Error getting all tools: ${error.message}`);
      return [];
    }
  }

  /**
   * Call a function on a tool
   * @param toolName The name of the tool
   * @param functionName The name of the function
   * @param parameters The function parameters
   * @returns The function call result
   */
  public async callFunction(
    toolName: string,
    functionName: string,
    parameters: Record<string, any>
  ): Promise<MCPFunctionCallResult> {
    try {
      this.outputChannel.appendLine(`Calling function ${functionName} on tool ${toolName}`);

      // Check if tool is available
      if (!this.toolSchemas[toolName]) {
        // Try to fetch schema
        try {
          await this.fetchToolSchema(toolName);
        } catch (error) {
          throw new Error(`Tool ${toolName} is not available: ${error.message}`);
        }
      }

      // Check if function exists
      const functionSchema = this.toolSchemas[toolName].functions.find(f => f.name === functionName);
      if (!functionSchema) {
        throw new Error(`Function ${functionName} not found in tool ${toolName}`);
      }

      // Validate parameters
      this._validateParameters(parameters, functionSchema);

      // Get container URL
      const url = this.containerManager.getContainerUrl(toolName);

      // Call function
      const response = await axios.post(`${url}/invoke`, {
        function: functionName,
        parameters
      });

      const result = response.data;

      this.outputChannel.appendLine(`Function ${functionName} called successfully on tool ${toolName}`);

      return result;
    } catch (error) {
      this.outputChannel.appendLine(`Error calling function ${functionName} on tool ${toolName}: ${error.message}`);

      return {
        status: 'error',
        error: error.message
      };
    }
  }

  /**
   * Call a function on a tool with server ID
   * @param serverId The ID of the server
   * @param toolName The name of the tool
   * @param functionName The name of the function
   * @param parameters The function parameters
   * @returns The function call result
   */
  public async callFunction(
    serverId: string,
    toolName: string,
    functionName: string,
    parameters: Record<string, any>
  ): Promise<MCPFunctionCallResult> {
    try {
      this.outputChannel.appendLine(`Calling function ${functionName} on tool ${toolName} (server: ${serverId})`);

      // For now, we assume serverId is the same as toolName
      // In the future, we'll need to update this to support multiple servers
      return this.callFunction(toolName, functionName, parameters);
    } catch (error) {
      this.outputChannel.appendLine(`Error calling function ${functionName} on tool ${toolName} (server: ${serverId}): ${error.message}`);

      return {
        status: 'error',
        error: error.message
      };
    }
  }

  /**
   * Validate function parameters
   * @param parameters The parameters to validate
   * @param functionSchema The function schema
   */
  private _validateParameters(parameters: Record<string, any>, functionSchema: MCPFunctionSchema): void {
    // Check required parameters
    for (const requiredParam of functionSchema.parameters.required) {
      if (parameters[requiredParam] === undefined) {
        throw new Error(`Missing required parameter: ${requiredParam}`);
      }
    }

    // Check parameter types
    for (const paramName in parameters) {
      const paramSchema = functionSchema.parameters.properties[paramName];

      if (!paramSchema) {
        throw new Error(`Unknown parameter: ${paramName}`);
      }

      // Basic type checking
      const paramValue = parameters[paramName];
      const paramType = paramSchema.type;

      if (paramType === 'string' && typeof paramValue !== 'string') {
        throw new Error(`Parameter ${paramName} should be a string`);
      } else if (paramType === 'number' && typeof paramValue !== 'number') {
        throw new Error(`Parameter ${paramName} should be a number`);
      } else if (paramType === 'boolean' && typeof paramValue !== 'boolean') {
        throw new Error(`Parameter ${paramName} should be a boolean`);
      } else if (paramType === 'array' && !Array.isArray(paramValue)) {
        throw new Error(`Parameter ${paramName} should be an array`);
      } else if (paramType === 'object' && (typeof paramValue !== 'object' || paramValue === null || Array.isArray(paramValue))) {
        throw new Error(`Parameter ${paramName} should be an object`);
      }

      // Check enum values
      if (paramSchema.enum && !paramSchema.enum.includes(paramValue)) {
        throw new Error(`Parameter ${paramName} should be one of: ${paramSchema.enum.join(', ')}`);
      }
    }
  }

  /**
   * Find a tool by name
   * @param toolName The name of the tool to find
   * @returns The tool with server ID if found, null otherwise
   */
  public async findTool(toolName: string): Promise<{ serverId: string; tool: MCPToolSchema } | null> {
    try {
      this.outputChannel.appendLine(`Finding tool: ${toolName}`);

      // Get all tools
      const tools = await this.getAllTools();

      // Find tool by name
      const tool = tools.find(t => t.tool.name.toLowerCase() === toolName.toLowerCase());

      if (tool) {
        this.outputChannel.appendLine(`Found tool ${toolName} on server ${tool.serverId}`);
        return tool;
      }

      this.outputChannel.appendLine(`Tool ${toolName} not found`);
      return null;
    } catch (error) {
      this.outputChannel.appendLine(`Error finding tool ${toolName}: ${error.message}`);
      return null;
    }
  }

  /**
   * Dispose of resources
   */
  public dispose(): void {
    this.outputChannel.dispose();
  }
}

```


---

### File: `src/context/embeddingService.ts`

```typescript
import axios from 'axios';
import { getConfiguration } from '../configuration';

export class EmbeddingService {
  private apiEndpoint: string;
  private apiKey: string;
  
  constructor() {
    const config = getConfiguration();
    this.apiEndpoint = config.apiEndpoint;
    this.apiKey = config.apiKey;
  }
  
  public async generateEmbedding(text: string): Promise<number[]> {
    try {
      const response = await axios.post(
        `${this.apiEndpoint}/embeddings`,
        {
          input: text,
          model: 'qwen3-embedding'
        },
        {
          headers: {
            'Authorization': `Bearer ${this.apiKey}`,
            'Content-Type': 'application/json'
          }
        }
      );
      
      return response.data.data[0].embedding;
    } catch (error) {
      console.error('Error generating embedding:', error);
      throw new Error('Failed to generate embedding');
    }
  }
  
  public async generateBatchEmbeddings(texts: string[]): Promise<number[][]> {
    try {
      const response = await axios.post(
        `${this.apiEndpoint}/embeddings`,
        {
          input: texts,
          model: 'qwen3-embedding'
        },
        {
          headers: {
            'Authorization': `Bearer ${this.apiKey}`,
            'Content-Type': 'application/json'
          }
        }
      );
      
      return response.data.data.map((item: any) => item.embedding);
    } catch (error) {
      console.error('Error generating batch embeddings:', error);
      throw new Error('Failed to generate batch embeddings');
    }
  }
}

```


---

### File: `src/context/contextEngine.ts`

```typescript
import * as vscode from 'vscode';
import { ContextComposer } from './contextComposer';
import { DependencyGraph } from './dependencyGraph';
import { EmbeddingService } from './embeddingService';
import { FileIndexer } from './fileIndexer';
import { SemanticSearch } from './semanticSearch';
import { SymbolExtractor } from './symbolExtractor';
import { CodeChunk } from './types';
import { VectorStore } from './vectorStore';

export class ContextEngine {
  private fileIndexer: FileIndexer;
  private embeddingService: EmbeddingService;
  private vectorStore: VectorStore;
  private symbolExtractor: SymbolExtractor;
  private contextComposer: ContextComposer;
  private dependencyGraph: DependencyGraph;
  private semanticSearch: SemanticSearch;
  private isInitialized: boolean = false;

  constructor() {
    this.embeddingService = new EmbeddingService();
    this.symbolExtractor = new SymbolExtractor();

    // Get configuration for context engine
    const config = getConfiguration().contextEngine;

    // Use persistent vector store if enabled in configuration
    if (config.persistEmbeddings) {
      console.log('Using persistent vector store for embeddings');
      this.vectorStore = new PersistentVectorStore(
        this.embeddingService,
        config.databasePath || undefined,
        config.autoSaveIntervalMs
      );
    } else {
      console.log('Using in-memory vector store for embeddings');
      this.vectorStore = new VectorStore(this.embeddingService);
    }

    this.contextComposer = new ContextComposer();
    this.dependencyGraph = new DependencyGraph();
    this.semanticSearch = new SemanticSearch(this.vectorStore, this.embeddingService);
    this.fileIndexer = new FileIndexer(
      this.symbolExtractor,
      this.embeddingService,
      this.vectorStore
    );
  }

  public async initialize(): Promise<void> {
    if (this.isInitialized) {
      return;
    }

    // Initialize the persistent vector store if needed
    if (this.vectorStore instanceof PersistentVectorStore) {
      console.log('Initializing persistent vector store');
      await (this.vectorStore as PersistentVectorStore).initialize();
    }

    // Only index the workspace if the vector store is empty
    const existingChunks = await this.vectorStore.findSimilarChunks('', 10);
    if (existingChunks.length === 0) {
      console.log('Vector store is empty, indexing workspace');
      await this.fileIndexer.indexWorkspace();
    } else {
      console.log(`Found ${existingChunks.length} existing chunks in vector store, skipping indexing`);
    }

    // Build dependency graph
    const allChunks = await this.vectorStore.findSimilarChunks('', 10000);
    for (const chunk of allChunks) {
      this.dependencyGraph.addChunk(chunk);
    }
    this.dependencyGraph.buildGraph();

    this.isInitialized = true;
  }

  public async getContext(query: string, tokenLimit: number = 4000): Promise<string> {
    if (!this.isInitialized) {
      await this.initialize();
    }

    // Find relevant chunks using semantic search
    const relevantChunks = await this.semanticSearch.search(query, 10);

    // Extract symbols from the query
    const symbols = this.extractSymbolsFromQuery(query);

    // If we found symbols, add chunks related to those symbols
    if (symbols.length > 0) {
      for (const symbol of symbols) {
        const symbolChunks = await this.semanticSearch.searchBySymbol(symbol, 5);

        // Add symbol chunks to relevant chunks, avoiding duplicates
        const existingIds = new Set(relevantChunks.map(chunk => chunk.id));
        for (const chunk of symbolChunks) {
          if (!existingIds.has(chunk.id)) {
            relevantChunks.push(chunk);
            existingIds.add(chunk.id);
          }
        }
      }
    }

    // Get the active editor file path
    const activeEditor = vscode.window.activeTextEditor;
    if (activeEditor) {
      const filePath = activeEditor.document.uri.fsPath;

      // Get related files from dependency graph
      const relatedFiles = this.dependencyGraph.getRelatedFiles(filePath, 1);

      // Add chunks from related files
      for (const relatedFile of relatedFiles) {
        const fileChunks = await this.getChunksForFile(relatedFile);

        // Add file chunks to relevant chunks, avoiding duplicates
        const existingIds = new Set(relevantChunks.map(chunk => chunk.id));
        for (const chunk of fileChunks) {
          if (!existingIds.has(chunk.id)) {
            relevantChunks.push(chunk);
            existingIds.add(chunk.id);
          }
        }
      }
    }

    // Compose context
    return this.contextComposer.composeContext(query, relevantChunks, tokenLimit);
  }

  public async getContextForFile(filePath: string, tokenLimit: number = 4000): Promise<string> {
    if (!this.isInitialized) {
      await this.initialize();
    }

    // Get chunks for this file
    const fileChunks = await this.getChunksForFile(filePath);

    // Get related files from dependency graph
    const relatedFiles = this.dependencyGraph.getRelatedFiles(filePath, 1);

    // Add chunks from related files
    const allChunks = [...fileChunks];
    const existingIds = new Set(allChunks.map(chunk => chunk.id));

    for (const relatedFile of relatedFiles) {
      const relatedChunks = await this.getChunksForFile(relatedFile);

      for (const chunk of relatedChunks) {
        if (!existingIds.has(chunk.id)) {
          allChunks.push(chunk);
          existingIds.add(chunk.id);
        }
      }
    }

    // Compose context
    return this.contextComposer.composeContext(`File: ${filePath}`, allChunks, tokenLimit);
  }

  public async getContextForSymbol(symbol: string, tokenLimit: number = 4000): Promise<string> {
    if (!this.isInitialized) {
      await this.initialize();
    }

    // Find chunks related to this symbol
    const symbolChunks = await this.semanticSearch.searchBySymbol(symbol, 10);

    // Compose context
    return this.contextComposer.composeContext(`Symbol: ${symbol}`, symbolChunks, tokenLimit);
  }

  private async getChunksForFile(filePath: string): Promise<CodeChunk[]> {
    // Find chunks for this file
    const allChunks = await this.vectorStore.findSimilarChunks('', 10000);
    return allChunks.filter(chunk => chunk.filePath === filePath);
  }

  private extractSymbolsFromQuery(query: string): string[] {
    // Extract potential symbols from the query
    // This is a simplified implementation
    const words = query.split(/\s+/);
    const symbols: string[] = [];

    for (const word of words) {
      // Clean up the word
      const cleanWord = word.replace(/[^\w]/g, '');

      // Check if it looks like a symbol (camelCase, PascalCase, snake_case)
      if (cleanWord.length > 0 &&
          (cleanWord.match(/[a-z][A-Z]/) || // camelCase
           cleanWord.match(/^[A-Z][a-z]/) || // PascalCase
           cleanWord.includes('_'))) { // snake_case
        symbols.push(cleanWord);
      }
    }

    return symbols;
  }

  public async dispose(): Promise<void> {
    // Dispose the file indexer
    this.fileIndexer.dispose();

    // Dispose the persistent vector store if needed
    if (this.vectorStore instanceof PersistentVectorStore) {
      console.log('Disposing persistent vector store');
      await (this.vectorStore as PersistentVectorStore).dispose();
    }
  }
}

```


---

### File: `src/context/symbolExtractor.ts`

```typescript

/**
 * Language-specific symbol extractor for code files.
 * Extracts symbols, imports, and dependencies from code content.
 */
export class SymbolExtractor {
  // Map of file extensions to language IDs
  private static readonly extensionToLanguage: Record<string, string> = {
    // JavaScript/TypeScript
    '.js': 'javascript',
    '.jsx': 'javascriptreact',
    '.ts': 'typescript',
    '.tsx': 'typescriptreact',
    // Python
    '.py': 'python',
    '.pyw': 'python',
    '.ipynb': 'python',
    // Java
    '.java': 'java',
    // C/C++
    '.c': 'c',
    '.cpp': 'cpp',
    '.cc': 'cpp',
    '.h': 'c',
    '.hpp': 'cpp',
    // C#
    '.cs': 'csharp',
    // Go
    '.go': 'go',
    // Ruby
    '.rb': 'ruby',
    // PHP
    '.php': 'php',
    // Rust
    '.rs': 'rust',
    // Swift
    '.swift': 'swift',
    // Kotlin
    '.kt': 'kotlin',
    // HTML/CSS
    '.html': 'html',
    '.css': 'css',
    '.scss': 'scss',
    '.sass': 'sass',
    // Other
    '.json': 'json',
    '.xml': 'xml',
    '.yaml': 'yaml',
    '.yml': 'yaml',
    '.md': 'markdown'
  };

  /**
   * Detect language from file extension
   * @param filePath Path to the file
   * @returns Language ID or undefined if not detected
   */
  public static detectLanguageFromPath(filePath: string): string | undefined {
    const extension = filePath.substring(filePath.lastIndexOf('.')).toLowerCase();
    return SymbolExtractor.extensionToLanguage[extension];
  }

  /**
   * Extract symbols, imports, and dependencies from code content
   * @param content Code content
   * @param language Language ID
   * @returns Object containing symbols, imports, and dependencies
   */
  public async extractSymbols(content: string, language: string): Promise<{
    symbols: string[];
    imports: string[];
    dependencies: string[];
  }> {
    const symbols: string[] = [];
    const imports: string[] = [];
    const dependencies: string[] = [];

    // Extract based on language
    switch (language) {
      // JavaScript family
      case 'javascript':
      case 'typescript':
      case 'javascriptreact':
      case 'typescriptreact':
        this.extractJavaScriptSymbols(content, symbols, imports, dependencies);
        break;

      // Python
      case 'python':
        this.extractPythonSymbols(content, symbols, imports, dependencies);
        break;

      // Java
      case 'java':
        this.extractJavaSymbols(content, symbols, imports, dependencies);
        break;

      // C/C++
      case 'c':
      case 'cpp':
        this.extractCppSymbols(content, symbols, imports, dependencies);
        break;

      // C#
      case 'csharp':
        this.extractCSharpSymbols(content, symbols, imports, dependencies);
        break;

      // Go
      case 'go':
        this.extractGoSymbols(content, symbols, imports, dependencies);
        break;

      // Ruby
      case 'ruby':
        this.extractRubySymbols(content, symbols, imports, dependencies);
        break;

      // PHP
      case 'php':
        this.extractPhpSymbols(content, symbols, imports, dependencies);
        break;

      // Rust
      case 'rust':
        this.extractRustSymbols(content, symbols, imports, dependencies);
        break;

      // Swift
      case 'swift':
        this.extractSwiftSymbols(content, symbols, imports, dependencies);
        break;

      // Kotlin
      case 'kotlin':
        this.extractKotlinSymbols(content, symbols, imports, dependencies);
        break;

      // HTML/CSS
      case 'html':
      case 'css':
      case 'scss':
      case 'sass':
        this.extractWebSymbols(content, symbols, imports, dependencies, language);
        break;

      // Data formats
      case 'json':
      case 'yaml':
      case 'xml':
        this.extractDataFormatSymbols(content, symbols, imports, dependencies, language);
        break;

      // Default fallback
      default:
        // Use regex-based fallback for unknown languages
        this.extractGenericSymbols(content, symbols, imports, dependencies);
    }

    // Remove duplicates
    return {
      symbols: [...new Set(symbols)],
      imports: [...new Set(imports)],
      dependencies: [...new Set(dependencies)]
    };
  }

  /**
   * Extract symbols from JavaScript/TypeScript code
   */
  private extractJavaScriptSymbols(
    content: string,
    symbols: string[],
    imports: string[],
    dependencies: string[]
  ): void {
    // Extract function declarations (both regular and arrow functions)
    const functionRegex = /(?:function\s+([a-zA-Z_$][a-zA-Z0-9_$]*)|(?:const|let|var)\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\s*=\s*(?:async\s*)?\([^)]*\)\s*=>)/g;
    let match;
    while ((match = functionRegex.exec(content)) !== null) {
      if (match[1]) {
        symbols.push(match[1]);
      } else if (match[2]) {
        symbols.push(match[2]);
      }
    }

    // Extract class declarations
    const classRegex = /class\s+([a-zA-Z_$][a-zA-Z0-9_$]*)/g;
    while ((match = classRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract method declarations
    const methodRegex = /(?:async\s+)?([a-zA-Z_$][a-zA-Z0-9_$]*)\s*\([^)]*\)\s*{/g;
    while ((match = methodRegex.exec(content)) !== null) {
      // Filter out common keywords that might be matched
      const keywords = ['if', 'for', 'while', 'switch', 'catch'];
      if (!keywords.includes(match[1])) {
        symbols.push(match[1]);
      }
    }

    // Extract variable declarations
    const varRegex = /(?:const|let|var)\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\s*(?:[=;]|$)/g;
    while ((match = varRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract interface and type declarations (TypeScript)
    const typeRegex = /(?:interface|type)\s+([a-zA-Z_$][a-zA-Z0-9_$]*)/g;
    while ((match = typeRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract imports (ES modules)
    const importRegex = /import\s+(?:{([^}]*)}\s+from\s+['"]([^'"]+)['"]|.*?from\s+['"]([^'"]+)['"])/g;
    while ((match = importRegex.exec(content)) !== null) {
      // Extract the module path
      const modulePath = match[2] || match[3];
      if (modulePath) {
        imports.push(modulePath);
        dependencies.push(modulePath);
      }

      // Extract named imports if available
      if (match[1]) {
        const namedImports = match[1].split(',').map(s => s.trim());
        for (const namedImport of namedImports) {
          // Handle "as" aliases
          const importName = namedImport.split(' as ')[0].trim();
          if (importName) {
            symbols.push(importName);
          }
        }
      }
    }

    // Extract CommonJS requires
    const requireRegex = /(?:const|let|var)\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\s*=\s*require\s*\(\s*['"]([^'"]+)['"]\s*\)/g;
    while ((match = requireRegex.exec(content)) !== null) {
      symbols.push(match[1]); // The variable name
      imports.push(match[2]); // The module path
      dependencies.push(match[2]);
    }
  }

  /**
   * Extract symbols from Python code
   */
  private extractPythonSymbols(
    content: string,
    symbols: string[],
    imports: string[],
    dependencies: string[]
  ): void {
    // Extract function declarations
    const functionRegex = /def\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/g;
    let match;
    while ((match = functionRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract class declarations
    const classRegex = /class\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*(?:\(|:)/g;
    while ((match = classRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract variable assignments (global level)
    const varRegex = /^([A-Z_][A-Z0-9_]*)\s*=/gm;
    while ((match = varRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract imports - from X import Y
    const fromImportRegex = /from\s+([a-zA-Z0-9_.]+)\s+import\s+([^#\n]+)/g;
    while ((match = fromImportRegex.exec(content)) !== null) {
      const module = match[1];
      imports.push(module);
      dependencies.push(module);

      // Extract imported symbols
      const importedSymbols = match[2].split(',').map(s => s.trim());
      for (const importedSymbol of importedSymbols) {
        // Handle "as" aliases
        const symbolName = importedSymbol.split(' as ')[0].trim();
        if (symbolName && symbolName !== '*') {
          symbols.push(symbolName);
        }
      }
    }

    // Extract imports - import X
    const importRegex = /import\s+([^#\n]+)/g;
    while ((match = importRegex.exec(content)) !== null) {
      const importedModules = match[1].split(',').map(s => s.trim());
      for (const importedModule of importedModules) {
        // Handle "as" aliases
        const moduleName = importedModule.split(' as ')[0].trim();
        if (moduleName) {
          imports.push(moduleName);
          dependencies.push(moduleName);

          // Also add the module name as a symbol (since it can be used directly)
          const alias = importedModule.includes(' as ')
            ? importedModule.split(' as ')[1].trim()
            : moduleName.split('.').pop() || '';
          if (alias) {
            symbols.push(alias);
          }
        }
      }
    }

    // Extract decorated functions and classes
    const decoratorRegex = /@[^\n]+\s+(?:def|class)\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
    while ((match = decoratorRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }
  }

  /**
   * Extract symbols from Java code
   */
  private extractJavaSymbols(
    content: string,
    symbols: string[],
    imports: string[],
    dependencies: string[]
  ): void {
    // Extract class and interface declarations
    const classRegex = /(?:public|private|protected)?\s*(?:abstract|final)?\s*(?:class|interface|enum)\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
    let match;
    while ((match = classRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract method declarations
    const methodRegex = /(?:public|private|protected)?\s*(?:static|final|abstract)?\s*(?:<[^>]+>\s*)?(?:[a-zA-Z_][a-zA-Z0-9_.<>]*)\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/g;
    while ((match = methodRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract field declarations
    const fieldRegex = /(?:public|private|protected)?\s*(?:static|final)?\s*(?:[a-zA-Z_][a-zA-Z0-9_.<>]*)\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*(?:=|;)/g;
    while ((match = fieldRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract imports
    const importRegex = /import\s+([a-zA-Z0-9_.]+(?:\.[a-zA-Z0-9_*]+)*);/g;
    while ((match = importRegex.exec(content)) !== null) {
      imports.push(match[1]);
      dependencies.push(match[1]);
    }

    // Extract package declaration
    const packageRegex = /package\s+([a-zA-Z0-9_.]+);/g;
    while ((match = packageRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }
  }

  /**
   * Extract symbols from C/C++ code
   */
  private extractCppSymbols(
    content: string,
    symbols: string[],
    imports: string[],
    dependencies: string[]
  ): void {
    // Extract function declarations
    const functionRegex = /(?:(?:static|inline|extern|const)\s+)*(?:[a-zA-Z_][a-zA-Z0-9_:]*\s+)+([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/g;
    let match;
    while ((match = functionRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract class/struct/enum declarations
    const classRegex = /(?:class|struct|enum|union)\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
    while ((match = classRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract namespace declarations
    const namespaceRegex = /namespace\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
    while ((match = namespaceRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract #include directives
    const includeRegex = /#include\s+[<"]([^>"]+)[>"]/g;
    while ((match = includeRegex.exec(content)) !== null) {
      imports.push(match[1]);
      dependencies.push(match[1]);
    }

    // Extract typedefs
    const typedefRegex = /typedef\s+(?:[a-zA-Z_][a-zA-Z0-9_:]*\s+)+([a-zA-Z_][a-zA-Z0-9_]*)/g;
    while ((match = typedefRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract #define macros
    const defineRegex = /#define\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
    while ((match = defineRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }
  }

  /**
   * Extract symbols from C# code
   */
  private extractCSharpSymbols(
    content: string,
    symbols: string[],
    imports: string[],
    dependencies: string[]
  ): void {
    // Extract class, interface, struct, enum declarations
    const classRegex = /(?:public|private|protected|internal)?\s*(?:abstract|sealed|static)?\s*(?:class|interface|struct|enum|record)\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
    let match;
    while ((match = classRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract method declarations
    const methodRegex = /(?:public|private|protected|internal)?\s*(?:static|virtual|abstract|override|sealed)?\s*(?:[a-zA-Z_][a-zA-Z0-9_.<>]*)\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/g;
    while ((match = methodRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract property declarations
    const propertyRegex = /(?:public|private|protected|internal)?\s*(?:static|virtual|abstract|override|sealed)?\s*(?:[a-zA-Z_][a-zA-Z0-9_.<>]*)\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*\{/g;
    while ((match = propertyRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract using directives
    const usingRegex = /using\s+([a-zA-Z0-9_.]+);/g;
    while ((match = usingRegex.exec(content)) !== null) {
      imports.push(match[1]);
      dependencies.push(match[1]);
    }

    // Extract namespace declarations
    const namespaceRegex = /namespace\s+([a-zA-Z0-9_.]+)/g;
    while ((match = namespaceRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }
  }

  /**
   * Extract symbols from Go code
   */
  private extractGoSymbols(
    content: string,
    symbols: string[],
    imports: string[],
    dependencies: string[]
  ): void {
    // Extract function declarations
    const functionRegex = /func\s+(?:\([^)]*\)\s+)?([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/g;
    let match;
    while ((match = functionRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract type declarations
    const typeRegex = /type\s+([a-zA-Z_][a-zA-Z0-9_]*)\s+(?:struct|interface|[a-zA-Z_][a-zA-Z0-9_]*)/g;
    while ((match = typeRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract const declarations
    const constRegex = /const\s+([a-zA-Z_][a-zA-Z0-9_]*)\s+/g;
    while ((match = constRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract var declarations
    const varRegex = /var\s+([a-zA-Z_][a-zA-Z0-9_]*)\s+/g;
    while ((match = varRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract imports
    const importRegex = /import\s+(?:\(\s*((?:[^)]+))\s*\)|["']([^"']+)["'])/g;
    while ((match = importRegex.exec(content)) !== null) {
      if (match[1]) {
        // Multi-line import
        const importLines = match[1].split('\n');
        for (const line of importLines) {
          const importMatch = line.match(/["']([^"']+)["']/);
          if (importMatch) {
            imports.push(importMatch[1]);
            dependencies.push(importMatch[1]);
          }
        }
      } else if (match[2]) {
        // Single import
        imports.push(match[2]);
        dependencies.push(match[2]);
      }
    }

    // Extract package declaration
    const packageRegex = /package\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
    while ((match = packageRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }
  }

  /**
   * Extract symbols from Ruby code
   */
  private extractRubySymbols(
    content: string,
    symbols: string[],
    imports: string[],
    dependencies: string[]
  ): void {
    // Extract class declarations
    const classRegex = /class\s+([A-Z][a-zA-Z0-9_]*)/g;
    let match;
    while ((match = classRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract module declarations
    const moduleRegex = /module\s+([A-Z][a-zA-Z0-9_]*)/g;
    while ((match = moduleRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract method declarations
    const methodRegex = /def\s+(?:self\.)?([a-zA-Z_][a-zA-Z0-9_?!]*)/g;
    while ((match = methodRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract constant declarations
    const constRegex = /([A-Z][A-Z0-9_]*)\s*=/g;
    while ((match = constRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract requires
    const requireRegex = /require\s+['"]([^'"]+)['"]/g;
    while ((match = requireRegex.exec(content)) !== null) {
      imports.push(match[1]);
      dependencies.push(match[1]);
    }

    // Extract includes
    const includeRegex = /include\s+([A-Z][a-zA-Z0-9_]*)/g;
    while ((match = includeRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }
  }

  /**
   * Extract symbols from PHP code
   */
  private extractPhpSymbols(
    content: string,
    symbols: string[],
    imports: string[],
    dependencies: string[]
  ): void {
    // Extract class declarations
    const classRegex = /class\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
    let match;
    while ((match = classRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract interface declarations
    const interfaceRegex = /interface\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
    while ((match = interfaceRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract function declarations
    const functionRegex = /function\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/g;
    while ((match = functionRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract method declarations
    const methodRegex = /(?:public|private|protected)?\s*(?:static)?\s*function\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/g;
    while ((match = methodRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract namespace declarations
    const namespaceRegex = /namespace\s+([a-zA-Z_][a-zA-Z0-9_\\]*)/g;
    while ((match = namespaceRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract use statements (imports)
    const useRegex = /use\s+([a-zA-Z_][a-zA-Z0-9_\\]*)/g;
    while ((match = useRegex.exec(content)) !== null) {
      imports.push(match[1]);
      dependencies.push(match[1]);
    }

    // Extract require/include statements
    const requireRegex = /(?:require|include)(?:_once)?\s*\(\s*['"]([^'"]+)['"]\s*\)/g;
    while ((match = requireRegex.exec(content)) !== null) {
      imports.push(match[1]);
      dependencies.push(match[1]);
    }
  }

  /**
   * Extract symbols from Rust code
   */
  private extractRustSymbols(
    content: string,
    symbols: string[],
    imports: string[],
    dependencies: string[]
  ): void {
    // Extract function declarations
    const functionRegex = /fn\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*(?:<[^>]*>)?\s*\(/g;
    let match;
    while ((match = functionRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract struct declarations
    const structRegex = /struct\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
    while ((match = structRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract enum declarations
    const enumRegex = /enum\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
    while ((match = enumRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract trait declarations
    const traitRegex = /trait\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
    while ((match = traitRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract impl blocks
    const implRegex = /impl(?:<[^>]*>)?\s+(?:[^{]*\s+)?([a-zA-Z_][a-zA-Z0-9_]*)/g;
    while ((match = implRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract const declarations
    const constRegex = /const\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*:/g;
    while ((match = constRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract static declarations
    const staticRegex = /static\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*:/g;
    while ((match = staticRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract use statements (imports)
    const useRegex = /use\s+([a-zA-Z0-9_:{}]+);/g;
    while ((match = useRegex.exec(content)) !== null) {
      imports.push(match[1]);
      dependencies.push(match[1]);
    }

    // Extract mod declarations
    const modRegex = /mod\s+([a-zA-Z_][a-zA-Z0-9_]*);/g;
    while ((match = modRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }
  }

  /**
   * Extract symbols from Swift code
   */
  private extractSwiftSymbols(
    content: string,
    symbols: string[],
    imports: string[],
    dependencies: string[]
  ): void {
    // Extract class declarations
    const classRegex = /class\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
    let match;
    while ((match = classRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract struct declarations
    const structRegex = /struct\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
    while ((match = structRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract enum declarations
    const enumRegex = /enum\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
    while ((match = enumRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract protocol declarations
    const protocolRegex = /protocol\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
    while ((match = protocolRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract function declarations
    const functionRegex = /func\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*(?:<[^>]*>)?\s*\(/g;
    while ((match = functionRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract variable declarations
    const varRegex = /(?:var|let)\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*:/g;
    while ((match = varRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract import statements
    const importRegex = /import\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
    while ((match = importRegex.exec(content)) !== null) {
      imports.push(match[1]);
      dependencies.push(match[1]);
    }

    // Extract extension declarations
    const extensionRegex = /extension\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
    while ((match = extensionRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }
  }

  /**
   * Extract symbols from Kotlin code
   */
  private extractKotlinSymbols(
    content: string,
    symbols: string[],
    imports: string[],
    dependencies: string[]
  ): void {
    // Extract class declarations
    const classRegex = /class\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
    let match;
    while ((match = classRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract interface declarations
    const interfaceRegex = /interface\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
    while ((match = interfaceRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract function declarations
    const functionRegex = /fun\s+(?:<[^>]*>\s+)?([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/g;
    while ((match = functionRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract property declarations
    const propertyRegex = /(?:val|var)\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*(?::|=)/g;
    while ((match = propertyRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract object declarations
    const objectRegex = /object\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
    while ((match = objectRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }

    // Extract import statements
    const importRegex = /import\s+([a-zA-Z0-9_.]*(?:\.[a-zA-Z0-9_*]+)*)/g;
    while ((match = importRegex.exec(content)) !== null) {
      imports.push(match[1]);
      dependencies.push(match[1]);
    }

    // Extract package declaration
    const packageRegex = /package\s+([a-zA-Z0-9_.]+)/g;
    while ((match = packageRegex.exec(content)) !== null) {
      symbols.push(match[1]);
    }
  }

  /**
   * Extract symbols from HTML/CSS/SCSS/SASS code
   */
  private extractWebSymbols(
    content: string,
    symbols: string[],
    imports: string[],
    dependencies: string[],
    language: string
  ): void {
    if (language === 'html') {
      // Extract IDs
      const idRegex = /id=["']([^"']+)["']/g;
      let match;
      while ((match = idRegex.exec(content)) !== null) {
        symbols.push(match[1]);
      }

      // Extract classes
      const classRegex = /class=["']([^"']+)["']/g;
      while ((match = classRegex.exec(content)) !== null) {
        const classes = match[1].split(/\s+/);
        for (const cls of classes) {
          if (cls) {
            symbols.push(cls);
          }
        }
      }

      // Extract custom elements
      const customElementRegex = /<([a-z]+-[a-z-]+)/g;
      while ((match = customElementRegex.exec(content)) !== null) {
        symbols.push(match[1]);
      }

      // Extract script src and link href
      const linkRegex = /(?:src|href)=["']([^"']+)["']/g;
      while ((match = linkRegex.exec(content)) !== null) {
        imports.push(match[1]);
        dependencies.push(match[1]);
      }
    } else {
      // CSS/SCSS/SASS

      // Extract selectors
      const selectorRegex = /([.#][a-zA-Z_-][a-zA-Z0-9_-]*)/g;
      let match;
      while ((match = selectorRegex.exec(content)) !== null) {
        symbols.push(match[1]);
      }

      // Extract custom properties
      const customPropRegex = /(--[a-zA-Z0-9_-]+)\s*:/g;
      while ((match = customPropRegex.exec(content)) !== null) {
        symbols.push(match[1]);
      }

      // Extract @import statements
      const importRegex = /@import\s+["']([^"']+)["']/g;
      while ((match = importRegex.exec(content)) !== null) {
        imports.push(match[1]);
        dependencies.push(match[1]);
      }

      // Extract SCSS/SASS variables
      if (language === 'scss' || language === 'sass') {
        const varRegex = /\$([a-zA-Z_-][a-zA-Z0-9_-]*)\s*:/g;
        while ((match = varRegex.exec(content)) !== null) {
          symbols.push('$' + match[1]);
        }

        // Extract mixins
        const mixinRegex = /@mixin\s+([a-zA-Z_-][a-zA-Z0-9_-]*)/g;
        while ((match = mixinRegex.exec(content)) !== null) {
          symbols.push(match[1]);
        }
      }
    }
  }

  /**
   * Extract symbols from data formats (JSON, YAML, XML)
   */
  private extractDataFormatSymbols(
    content: string,
    symbols: string[],
    imports: string[],
    dependencies: string[],
    language: string
  ): void {
    if (language === 'json') {
      // Extract property names from JSON
      const propRegex = /"([a-zA-Z_][a-zA-Z0-9_]*)"\s*:/g;
      let match;
      while ((match = propRegex.exec(content)) !== null) {
        symbols.push(match[1]);
      }
    } else if (language === 'yaml') {
      // Extract keys from YAML
      const keyRegex = /^([a-zA-Z_][a-zA-Z0-9_]*)\s*:/gm;
      let match;
      while ((match = keyRegex.exec(content)) !== null) {
        symbols.push(match[1]);
      }
    } else if (language === 'xml') {
      // Extract tag names from XML
      const tagRegex = /<([a-zA-Z_][a-zA-Z0-9_:-]*)(?:\s|>|\/)/g;
      let match;
      while ((match = tagRegex.exec(content)) !== null) {
        symbols.push(match[1]);
      }

      // Extract attribute names
      const attrRegex = /\s([a-zA-Z_][a-zA-Z0-9_:-]*)=/g;
      while ((match = attrRegex.exec(content)) !== null) {
        symbols.push(match[1]);
      }
    }
  }

  /**
   * Generic symbol extraction for unsupported languages
   */
  private extractGenericSymbols(
    content: string,
    symbols: string[],
    imports: string[],
    dependencies: string[]
  ): void {
    // Generic symbol extraction using regex
    // This is a fallback for languages we don't have specific parsers for

    // Extract words that look like symbols (camelCase, PascalCase, snake_case)
    const symbolRegex = /\b([a-zA-Z_][a-zA-Z0-9_]*)\b/g;
    let match;
    while ((match = symbolRegex.exec(content)) !== null) {
      // Filter out common keywords across languages
      const keywords = [
        // Common programming keywords
        'if', 'else', 'for', 'while', 'do', 'switch', 'case', 'break', 'continue',
        'return', 'function', 'class', 'struct', 'enum', 'interface', 'namespace',
        'public', 'private', 'protected', 'static', 'final', 'const', 'var', 'let',
        'void', 'int', 'float', 'double', 'string', 'bool', 'true', 'false', 'null',
        'this', 'super', 'new', 'delete', 'try', 'catch', 'finally', 'throw'
      ];

      if (!keywords.includes(match[1])) {
        // Prioritize symbols that look like identifiers
        // - PascalCase (class/type names)
        // - camelCase (method/variable names)
        // - snake_case (variable names in some languages)
        // - UPPER_CASE (constants)
        if (
          /^[A-Z][a-z0-9]+[A-Z]/.test(match[1]) || // PascalCase
          /^[a-z]+[A-Z]/.test(match[1]) || // camelCase
          match[1].includes('_') || // snake_case or UPPER_CASE
          /^[A-Z][A-Z0-9_]+$/.test(match[1]) // UPPER_CASE constants
        ) {
          symbols.push(match[1]);
        }
      }
    }

    // Try to extract imports based on common patterns across languages
    const importRegex = /(?:import|include|require|using|from|#include)\s+['"]?([a-zA-Z0-9_./\\<>]+)['"]?/g;
    while ((match = importRegex.exec(content)) !== null) {
      imports.push(match[1]);
      dependencies.push(match[1]);
    }
  }
}

```


---

### File: `src/context/vectorStore.ts`

```typescript
import { CodeChunk } from './types';
import { EmbeddingService } from './embeddingService';

export class VectorStore {
  private chunks: CodeChunk[] = [];
  private embeddingService: EmbeddingService;
  
  constructor(embeddingService: EmbeddingService) {
    this.embeddingService = embeddingService;
  }
  
  public async addChunk(chunk: CodeChunk): Promise<void> {
    // If the chunk doesn't have an embedding, generate one
    if (!chunk.embedding) {
      chunk.embedding = await this.embeddingService.generateEmbedding(chunk.content);
    }
    
    // Check if chunk already exists (by ID)
    const existingIndex = this.chunks.findIndex(c => c.id === chunk.id);
    if (existingIndex >= 0) {
      // Replace existing chunk
      this.chunks[existingIndex] = chunk;
    } else {
      // Add new chunk
      this.chunks.push(chunk);
    }
  }
  
  public async findSimilarChunks(query: string, limit: number = 5): Promise<CodeChunk[]> {
    // Generate embedding for the query
    const queryEmbedding = await this.embeddingService.generateEmbedding(query);
    
    // Find similar chunks
    return this.findSimilarChunksByEmbedding(queryEmbedding, limit);
  }
  
  public async findSimilarChunksByEmbedding(embedding: number[], limit: number = 5): Promise<CodeChunk[]> {
    // Calculate cosine similarity for each chunk
    const chunksWithSimilarity = this.chunks.map(chunk => {
      const similarity = this.cosineSimilarity(embedding, chunk.embedding!);
      return { chunk, similarity };
    });
    
    // Sort by similarity (descending)
    chunksWithSimilarity.sort((a, b) => b.similarity - a.similarity);
    
    // Return top N chunks
    return chunksWithSimilarity.slice(0, limit).map(item => item.chunk);
  }
  
  public async deleteChunk(id: string): Promise<void> {
    this.chunks = this.chunks.filter(chunk => chunk.id !== id);
  }
  
  public async clear(): Promise<void> {
    this.chunks = [];
  }
  
  private cosineSimilarity(a: number[], b: number[]): number {
    if (a.length !== b.length) {
      throw new Error('Vectors must have the same length');
    }
    
    let dotProduct = 0;
    let normA = 0;
    let normB = 0;
    
    for (let i = 0; i < a.length; i++) {
      dotProduct += a[i] * b[i];
      normA += a[i] * a[i];
      normB += b[i] * b[i];
    }
    
    return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
  }
}

```


---

### File: `src/context/semanticSearch.ts`

```typescript
import { VectorStore } from './vectorStore';
import { EmbeddingService } from './embeddingService';
import { CodeChunk } from './types';

export class SemanticSearch {
  private vectorStore: VectorStore;
  private embeddingService: EmbeddingService;
  
  constructor(vectorStore: VectorStore, embeddingService: EmbeddingService) {
    this.vectorStore = vectorStore;
    this.embeddingService = embeddingService;
  }
  
  public async search(query: string, limit: number = 10): Promise<CodeChunk[]> {
    // Generate embedding for the query
    const queryEmbedding = await this.embeddingService.generateEmbedding(query);
    
    // Find similar chunks
    return this.vectorStore.findSimilarChunksByEmbedding(queryEmbedding, limit);
  }
  
  public async searchBySymbol(symbol: string, limit: number = 10): Promise<CodeChunk[]> {
    // First, try to find exact symbol matches
    const allChunks = await this.vectorStore.findSimilarChunks('', 1000);
    const exactMatches = allChunks.filter(chunk => 
      chunk.symbols.includes(symbol) || 
      chunk.content.includes(`function ${symbol}`) ||
      chunk.content.includes(`class ${symbol}`) ||
      chunk.content.includes(`def ${symbol}`)
    );
    
    if (exactMatches.length >= limit) {
      return exactMatches.slice(0, limit);
    }
    
    // If we don't have enough exact matches, supplement with semantic search
    const semanticMatches = await this.search(symbol, limit - exactMatches.length);
    
    // Combine results, removing duplicates
    const combinedResults: CodeChunk[] = [...exactMatches];
    const existingIds = new Set(combinedResults.map(chunk => chunk.id));
    
    for (const match of semanticMatches) {
      if (!existingIds.has(match.id)) {
        combinedResults.push(match);
        existingIds.add(match.id);
      }
    }
    
    return combinedResults;
  }
}

```


---

### File: `src/context/persistentVectorStore.ts`

```typescript
import * as path from 'path';
import * as fs from 'fs';
import * as vscode from 'vscode';
import * as sqlite3 from 'sqlite3';
import { Database, open } from 'sqlite';
import { CodeChunk } from './types';
import { EmbeddingService } from './embeddingService';
import { VectorStore } from './vectorStore';

/**
 * A vector store that persists embeddings to disk using SQLite
 */
export class PersistentVectorStore extends VectorStore {
  private dbPath: string;
  private db: Database | null = null;
  private autoSaveInterval: NodeJS.Timeout | null = null;
  private isDirty: boolean = false;
  private isInitialized: boolean = false;
  
  /**
   * Create a new persistent vector store
   * @param embeddingService The embedding service to use
   * @param dbPath Path to the SQLite database file (optional, defaults to extension storage path)
   * @param autoSaveIntervalMs Interval in milliseconds to auto-save changes (optional, defaults to 60000)
   */
  constructor(
    embeddingService: EmbeddingService, 
    dbPath?: string,
    autoSaveIntervalMs: number = 60000
  ) {
    super(embeddingService);
    
    // If no dbPath is provided, use the extension's storage path
    if (!dbPath) {
      const storagePath = this.getStoragePath();
      if (!storagePath) {
        throw new Error('Could not determine storage path for persistent vector store');
      }
      
      // Ensure the directory exists
      if (!fs.existsSync(storagePath)) {
        fs.mkdirSync(storagePath, { recursive: true });
      }
      
      this.dbPath = path.join(storagePath, 'vector-store.db');
    } else {
      this.dbPath = dbPath;
    }
    
    // Set up auto-save if interval is positive
    if (autoSaveIntervalMs > 0) {
      this.autoSaveInterval = setInterval(() => {
        if (this.isDirty) {
          this.saveToDatabase().catch(error => {
            console.error('Error auto-saving vector store:', error);
          });
        }
      }, autoSaveIntervalMs);
    }
  }
  
  /**
   * Initialize the database
   */
  public async initialize(): Promise<void> {
    if (this.isInitialized) {
      return;
    }
    
    try {
      // Open the database
      this.db = await open({
        filename: this.dbPath,
        driver: sqlite3.Database
      });
      
      // Create tables if they don't exist
      await this.db.exec(`
        CREATE TABLE IF NOT EXISTS chunks (
          id TEXT PRIMARY KEY,
          filePath TEXT NOT NULL,
          content TEXT NOT NULL,
          startLine INTEGER NOT NULL,
          endLine INTEGER NOT NULL,
          language TEXT NOT NULL,
          symbols TEXT,
          imports TEXT
        );
        
        CREATE TABLE IF NOT EXISTS embeddings (
          chunk_id TEXT PRIMARY KEY,
          embedding BLOB NOT NULL,
          FOREIGN KEY (chunk_id) REFERENCES chunks (id) ON DELETE CASCADE
        );
        
        CREATE INDEX IF NOT EXISTS idx_chunks_filePath ON chunks (filePath);
      `);
      
      // Load existing chunks from the database
      await this.loadFromDatabase();
      
      this.isInitialized = true;
    } catch (error) {
      console.error('Error initializing persistent vector store:', error);
      throw error;
    }
  }
  
  /**
   * Add a chunk to the vector store
   * @param chunk The chunk to add
   */
  public async addChunk(chunk: CodeChunk): Promise<void> {
    // Call the parent method to add the chunk to memory
    await super.addChunk(chunk);
    
    // Mark as dirty to trigger auto-save
    this.isDirty = true;
  }
  
  /**
   * Delete a chunk from the vector store
   * @param id The ID of the chunk to delete
   */
  public async deleteChunk(id: string): Promise<void> {
    // Call the parent method to delete the chunk from memory
    await super.deleteChunk(id);
    
    // Delete from database if initialized
    if (this.db) {
      try {
        await this.db.run('DELETE FROM chunks WHERE id = ?', id);
        await this.db.run('DELETE FROM embeddings WHERE chunk_id = ?', id);
      } catch (error) {
        console.error(`Error deleting chunk ${id} from database:`, error);
      }
    }
    
    // Mark as dirty to trigger auto-save
    this.isDirty = true;
  }
  
  /**
   * Clear the vector store
   */
  public async clear(): Promise<void> {
    // Call the parent method to clear the in-memory store
    await super.clear();
    
    // Clear the database if initialized
    if (this.db) {
      try {
        await this.db.exec('DELETE FROM embeddings');
        await this.db.exec('DELETE FROM chunks');
      } catch (error) {
        console.error('Error clearing database:', error);
      }
    }
    
    // Mark as dirty to trigger auto-save
    this.isDirty = true;
  }
  
  /**
   * Save all chunks to the database
   */
  public async saveToDatabase(): Promise<void> {
    if (!this.db) {
      await this.initialize();
    }
    
    if (!this.db) {
      throw new Error('Database not initialized');
    }
    
    try {
      // Start a transaction
      await this.db.exec('BEGIN TRANSACTION');
      
      // Get all chunks
      const chunks = await this.getAllChunks();
      
      // Insert or update each chunk
      for (const chunk of chunks) {
        // Insert or replace the chunk
        await this.db.run(
          `INSERT OR REPLACE INTO chunks (id, filePath, content, startLine, endLine, language, symbols, imports)
           VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
          chunk.id,
          chunk.filePath,
          chunk.content,
          chunk.startLine,
          chunk.endLine,
          chunk.language,
          JSON.stringify(chunk.symbols),
          JSON.stringify(chunk.imports)
        );
        
        // Insert or replace the embedding if it exists
        if (chunk.embedding) {
          await this.db.run(
            `INSERT OR REPLACE INTO embeddings (chunk_id, embedding)
             VALUES (?, ?)`,
            chunk.id,
            Buffer.from(new Float32Array(chunk.embedding).buffer)
          );
        }
      }
      
      // Commit the transaction
      await this.db.exec('COMMIT');
      
      // Reset dirty flag
      this.isDirty = false;
      
      console.log(`Saved ${chunks.length} chunks to database`);
    } catch (error) {
      // Rollback the transaction on error
      if (this.db) {
        await this.db.exec('ROLLBACK');
      }
      
      console.error('Error saving to database:', error);
      throw error;
    }
  }
  
  /**
   * Load chunks from the database
   */
  private async loadFromDatabase(): Promise<void> {
    if (!this.db) {
      throw new Error('Database not initialized');
    }
    
    try {
      // Get all chunks from the database
      const rows = await this.db.all(`
        SELECT c.id, c.filePath, c.content, c.startLine, c.endLine, c.language, c.symbols, c.imports, e.embedding
        FROM chunks c
        LEFT JOIN embeddings e ON c.id = e.chunk_id
      `);
      
      // Clear existing chunks
      await super.clear();
      
      // Add each chunk to the in-memory store
      for (const row of rows) {
        const chunk: CodeChunk = {
          id: row.id,
          filePath: row.filePath,
          content: row.content,
          startLine: row.startLine,
          endLine: row.endLine,
          language: row.language,
          symbols: row.symbols ? JSON.parse(row.symbols) : [],
          imports: row.imports ? JSON.parse(row.imports) : []
        };
        
        // Add embedding if it exists
        if (row.embedding) {
          const buffer = Buffer.from(row.embedding);
          const float32Array = new Float32Array(buffer.buffer, buffer.byteOffset, buffer.byteLength / 4);
          chunk.embedding = Array.from(float32Array);
        }
        
        // Add to in-memory store without saving to database
        await super.addChunk(chunk);
      }
      
      console.log(`Loaded ${rows.length} chunks from database`);
    } catch (error) {
      console.error('Error loading from database:', error);
      throw error;
    }
  }
  
  /**
   * Get the storage path for the extension
   */
  private getStoragePath(): string | undefined {
    // Get the extension context
    const extension = vscode.extensions.getExtension('qwen-coder-assistant');
    if (extension) {
      return extension.extensionPath;
    }
    
    // Fallback to the workspace storage path
    if (vscode.workspace.workspaceFolders && vscode.workspace.workspaceFolders.length > 0) {
      return path.join(vscode.workspace.workspaceFolders[0].uri.fsPath, '.vscode');
    }
    
    return undefined;
  }
  
  /**
   * Dispose of resources
   */
  public async dispose(): Promise<void> {
    // Clear auto-save interval
    if (this.autoSaveInterval) {
      clearInterval(this.autoSaveInterval);
      this.autoSaveInterval = null;
    }
    
    // Save any pending changes
    if (this.isDirty && this.db) {
      try {
        await this.saveToDatabase();
      } catch (error) {
        console.error('Error saving vector store during disposal:', error);
      }
    }
    
    // Close the database
    if (this.db) {
      await this.db.close();
      this.db = null;
    }
  }
}

```


---

### File: `src/context/contextComposer.ts`

```typescript
import { CodeChunk } from './types';
import * as path from 'path';

export class ContextComposer {
  private readonly MAX_TOKENS_PER_CHUNK = 1000;
  
  public async composeContext(query: string, relevantChunks: CodeChunk[], tokenLimit: number = 4000): Promise<string> {
    // Sort chunks by relevance (assuming they're already sorted)
    // Group chunks by file
    const chunksByFile: { [filePath: string]: CodeChunk[] } = {};
    for (const chunk of relevantChunks) {
      if (!chunksByFile[chunk.filePath]) {
        chunksByFile[chunk.filePath] = [];
      }
      chunksByFile[chunk.filePath].push(chunk);
    }
    
    // Sort chunks within each file by line number
    for (const filePath in chunksByFile) {
      chunksByFile[filePath].sort((a, b) => a.startLine - b.startLine);
    }
    
    // Compose context
    let context = `Query: ${query}\n\n`;
    let tokenCount = this.estimateTokens(context);
    
    // Add file contexts until we reach the token limit
    for (const filePath in chunksByFile) {
      const fileName = path.basename(filePath);
      const fileContext = `File: ${fileName} (${filePath})\n`;
      tokenCount += this.estimateTokens(fileContext);
      
      if (tokenCount > tokenLimit) {
        break;
      }
      
      context += fileContext;
      
      // Add chunks from this file
      for (const chunk of chunksByFile[filePath]) {
        const chunkHeader = `Lines ${chunk.startLine}-${chunk.endLine}:\n`;
        const chunkContent = chunk.content;
        const chunkTokens = this.estimateTokens(chunkHeader + chunkContent);
        
        if (tokenCount + chunkTokens > tokenLimit) {
          // If adding this chunk would exceed the token limit, skip it
          continue;
        }
        
        context += chunkHeader + chunkContent + '\n\n';
        tokenCount += chunkTokens;
      }
      
      context += '\n';
    }
    
    // Add a summary of symbols found in the context
    const allSymbols = new Set<string>();
    const allImports = new Set<string>();
    
    for (const chunk of relevantChunks) {
      chunk.symbols.forEach(symbol => allSymbols.add(symbol));
      chunk.imports.forEach(imp => allImports.add(imp));
    }
    
    const symbolSummary = `Symbols: ${Array.from(allSymbols).join(', ')}\n`;
    const importSummary = `Imports: ${Array.from(allImports).join(', ')}\n`;
    
    if (tokenCount + this.estimateTokens(symbolSummary + importSummary) <= tokenLimit) {
      context += '\nSummary:\n' + symbolSummary + importSummary;
    }
    
    return context;
  }
  
  private estimateTokens(text: string): number {
    // A very rough estimate: 1 token  4 characters
    return Math.ceil(text.length / 4);
  }
}

```


---

### File: `src/context/types.ts`

```typescript
export interface CodeChunk {
  id: string;
  filePath: string;
  content: string;
  startLine: number;
  endLine: number;
  symbols: string[];
  imports: string[];
  language: string;
  embedding?: number[];
}

```


---

### File: `src/context/fileIndexer.ts`

```typescript
import * as vscode from 'vscode';
import { EmbeddingService } from './embeddingService';
import { SymbolExtractor } from './symbolExtractor';
import { CodeChunk } from './types';
import { VectorStore } from './vectorStore';

export class FileIndexer {
  private symbolExtractor: SymbolExtractor;
  private embeddingService: EmbeddingService;
  private vectorStore: VectorStore;
  private fileWatcher: vscode.FileSystemWatcher;
  private indexingStatus: vscode.StatusBarItem;

  constructor(
    symbolExtractor: SymbolExtractor,
    embeddingService: EmbeddingService,
    vectorStore: VectorStore
  ) {
    this.symbolExtractor = symbolExtractor;
    this.embeddingService = embeddingService;
    this.vectorStore = vectorStore;

    // Create status bar item
    this.indexingStatus = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 100);

    // Set up file watcher
    this.fileWatcher = vscode.workspace.createFileSystemWatcher('**/*.*');
    this.fileWatcher.onDidChange(this.handleFileChange.bind(this));
    this.fileWatcher.onDidCreate(this.handleFileCreate.bind(this));
    this.fileWatcher.onDidDelete(this.handleFileDelete.bind(this));
  }

  /**
   * Index the entire workspace
   */
  public async indexWorkspace(): Promise<void> {
    this.indexingStatus.text = '$(sync~spin) Indexing workspace...';
    this.indexingStatus.show();

    try {
      // Expanded file pattern to include more languages
      const files = await vscode.workspace.findFiles(
        '**/*.{js,ts,jsx,tsx,py,java,c,cpp,h,hpp,cs,go,rb,php,rs,swift,kt,html,css,scss,sass,json,yaml,yml,xml,md}',
        '{**/node_modules/**,**/dist/**,**/build/**,**/.git/**,**/venv/**,**/__pycache__/**}'
      );

      let processedFiles = 0;
      const totalFiles = files.length;

      // Process files in batches to avoid blocking the UI
      const batchSize = 20;
      for (let i = 0; i < totalFiles; i += batchSize) {
        const batch = files.slice(i, i + batchSize);

        // Process batch in parallel
        await Promise.all(batch.map(file => this.indexFile(file)));

        processedFiles += batch.length;
        this.indexingStatus.text = `$(sync~spin) Indexing workspace... ${processedFiles}/${totalFiles}`;

        // Yield to the event loop to keep the UI responsive
        await new Promise(resolve => setTimeout(resolve, 0));
      }

      this.indexingStatus.text = `$(check) Workspace indexed (${totalFiles} files)`;
      setTimeout(() => {
        this.indexingStatus.hide();
      }, 3000);
    } catch (error) {
      this.indexingStatus.text = '$(error) Indexing failed';
      console.error('Error indexing workspace:', error);
    }
  }

  /**
   * Index a single file
   * @param uri File URI
   */
  private async indexFile(uri: vscode.Uri): Promise<void> {
    try {
      // Get file path
      const filePath = uri.fsPath;

      // Try to detect language from file extension
      let language = SymbolExtractor.detectLanguageFromPath(filePath);

      // If we can't detect the language from the path, try to open the document
      if (!language) {
        try {
          const document = await vscode.workspace.openTextDocument(uri);
          language = document.languageId;
        } catch (e) {
          // If we can't open the document, use a generic language
          language = 'text';
        }
      }

      // Read file content
      let content: string;
      try {
        const document = await vscode.workspace.openTextDocument(uri);
        content = document.getText();
      } catch (e) {
        // If we can't open the document, skip this file
        console.warn(`Skipping file ${filePath}: Unable to read content`);
        return;
      }

      // Skip empty files or files that are too large
      if (content.length === 0) {
        console.log(`Skipping empty file: ${filePath}`);
        return;
      }

      if (content.length > 1000000) {
        console.log(`Skipping large file (${content.length} bytes): ${filePath}`);
        return;
      }

      // Skip binary files
      if (this.isBinaryContent(content)) {
        console.log(`Skipping binary file: ${filePath}`);
        return;
      }

      // Split file into chunks
      const chunks = this.chunkFile(content, filePath, language);

      // Process each chunk
      for (const chunk of chunks) {
        try {
          // Extract symbols
          const { symbols, imports, dependencies } = await this.symbolExtractor.extractSymbols(chunk.content, language);
          chunk.symbols = symbols;
          chunk.imports = imports;

          // Generate embedding
          chunk.embedding = await this.embeddingService.generateEmbedding(chunk.content);

          // Add to vector store
          await this.vectorStore.addChunk(chunk);
        } catch (chunkError) {
          console.error(`Error processing chunk ${chunk.id}:`, chunkError);
        }
      }
    } catch (error) {
      console.error(`Error indexing file ${uri.fsPath}:`, error);
    }
  }

  /**
   * Check if content appears to be binary
   * @param content File content
   * @returns True if the content appears to be binary
   */
  private isBinaryContent(content: string): boolean {
    // Check for null bytes or a high percentage of non-printable characters
    if (content.includes('\0')) {
      return true;
    }

    // Check the first 1000 characters
    const sampleSize = Math.min(1000, content.length);
    const sample = content.substring(0, sampleSize);

    // Count non-printable characters
    let nonPrintableCount = 0;
    for (let i = 0; i < sample.length; i++) {
      const charCode = sample.charCodeAt(i);
      if ((charCode < 32 && charCode !== 9 && charCode !== 10 && charCode !== 13) || charCode > 126) {
        nonPrintableCount++;
      }
    }

    // If more than 10% of characters are non-printable, consider it binary
    return nonPrintableCount > sampleSize * 0.1;
  }

  /**
   * Split a file into chunks based on its content and language
   * @param content File content
   * @param filePath File path
   * @param language Language ID
   * @returns Array of code chunks
   */
  private chunkFile(content: string, filePath: string, language: string): CodeChunk[] {
    const chunks: CodeChunk[] = [];
    const lines = content.split('\n');

    // For very small files, use a single chunk
    if (lines.length <= 50) {
      chunks.push({
        id: `${filePath}:0-${lines.length}`,
        filePath,
        content,
        startLine: 0,
        endLine: lines.length,
        symbols: [],
        imports: [],
        language
      });
      return chunks;
    }

    // For medium-sized files, use a single chunk if it's not code
    if (lines.length <= 200 && this.isDataOrDocFile(language)) {
      chunks.push({
        id: `${filePath}:0-${lines.length}`,
        filePath,
        content,
        startLine: 0,
        endLine: lines.length,
        symbols: [],
        imports: [],
        language
      });
      return chunks;
    }

    // For larger files, use language-specific chunking
    switch (language) {
      case 'javascript':
      case 'typescript':
      case 'javascriptreact':
      case 'typescriptreact':
        return this.chunkJavaScriptFile(content, filePath, language, lines);

      case 'python':
        return this.chunkPythonFile(content, filePath, language, lines);

      case 'java':
      case 'csharp':
      case 'cpp':
      case 'c':
        return this.chunkCStyleFile(content, filePath, language, lines);

      default:
        return this.chunkGenericFile(content, filePath, language, lines);
    }
  }

  /**
   * Check if the file is a data or documentation file
   * @param language Language ID
   * @returns True if the file is a data or documentation file
   */
  private isDataOrDocFile(language: string): boolean {
    return ['json', 'yaml', 'xml', 'markdown', 'html', 'css', 'scss', 'sass'].includes(language);
  }

  /**
   * Chunk a JavaScript/TypeScript file
   */
  private chunkJavaScriptFile(content: string, filePath: string, language: string, lines: string[]): CodeChunk[] {
    const chunks: CodeChunk[] = [];
    let chunkStart = 0;
    let braceBalance = 0;
    let inFunction = false;
    let inClass = false;

    // Always include imports in the first chunk
    let importsEndLine = 0;
    for (let i = 0; i < Math.min(50, lines.length); i++) {
      if (lines[i].includes('import ') || lines[i].includes('require(')) {
        importsEndLine = i + 1;
      }
    }

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();

      // Track brace balance
      braceBalance += (line.match(/{/g) || []).length;
      braceBalance -= (line.match(/}/g) || []).length;

      // Detect function or class start
      if (!inFunction && !inClass) {
        if (line.includes('function ') || line.includes('=>') || line.includes('class ')) {
          inFunction = line.includes('function ') || line.includes('=>');
          inClass = line.includes('class ');
        }
      }

      // Check if we should end the current chunk
      const isBlockEnd = (braceBalance === 0 && (inFunction || inClass)) ||
                         i === lines.length - 1;

      if (isBlockEnd || (i - chunkStart > 200)) {
        // Create a chunk
        const chunkEndLine = i + 1;
        const chunkContent = lines.slice(chunkStart, chunkEndLine).join('\n');

        // For the first chunk, include imports
        if (chunkStart === 0 && importsEndLine > 0 && chunkStart !== importsEndLine) {
          const importsContent = lines.slice(0, importsEndLine).join('\n');
          chunks.push({
            id: `${filePath}:0-${importsEndLine}`,
            filePath,
            content: importsContent,
            startLine: 0,
            endLine: importsEndLine,
            symbols: [],
            imports: [],
            language
          });

          // If the first chunk is just imports, continue to the next chunk
          if (chunkEndLine <= importsEndLine) {
            chunkStart = chunkEndLine;
            inFunction = false;
            inClass = false;
            continue;
          }
        }

        chunks.push({
          id: `${filePath}:${chunkStart}-${chunkEndLine}`,
          filePath,
          content: chunkContent,
          startLine: chunkStart,
          endLine: chunkEndLine,
          symbols: [],
          imports: [],
          language
        });

        chunkStart = chunkEndLine;
        inFunction = false;
        inClass = false;
      }
    }

    return chunks;
  }

  /**
   * Chunk a Python file
   */
  private chunkPythonFile(content: string, filePath: string, language: string, lines: string[]): CodeChunk[] {
    const chunks: CodeChunk[] = [];
    let chunkStart = 0;
    let indentLevel = 0;
    let inFunction = false;
    let inClass = false;

    // Always include imports in the first chunk
    let importsEndLine = 0;
    for (let i = 0; i < Math.min(50, lines.length); i++) {
      if (lines[i].includes('import ') || lines[i].includes('from ')) {
        importsEndLine = i + 1;
      }
    }

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const trimmedLine = line.trim();

      // Skip empty lines and comments
      if (trimmedLine === '' || trimmedLine.startsWith('#')) {
        continue;
      }

      // Calculate indent level
      const currentIndent = line.length - line.trimStart().length;

      // Detect function or class start
      if (currentIndent === 0 && !inFunction && !inClass) {
        if (trimmedLine.startsWith('def ') || trimmedLine.startsWith('class ')) {
          inFunction = trimmedLine.startsWith('def ');
          inClass = trimmedLine.startsWith('class ');
          indentLevel = currentIndent;
        }
      }

      // Check if we should end the current chunk
      const isBlockEnd = (currentIndent <= indentLevel && (inFunction || inClass) && i > chunkStart) ||
                         i === lines.length - 1;

      if (isBlockEnd || (i - chunkStart > 200)) {
        // Create a chunk
        const chunkEndLine = i;
        const chunkContent = lines.slice(chunkStart, chunkEndLine).join('\n');

        // For the first chunk, include imports
        if (chunkStart === 0 && importsEndLine > 0 && chunkStart !== importsEndLine) {
          const importsContent = lines.slice(0, importsEndLine).join('\n');
          chunks.push({
            id: `${filePath}:0-${importsEndLine}`,
            filePath,
            content: importsContent,
            startLine: 0,
            endLine: importsEndLine,
            symbols: [],
            imports: [],
            language
          });

          // If the first chunk is just imports, continue to the next chunk
          if (chunkEndLine <= importsEndLine) {
            chunkStart = chunkEndLine;
            inFunction = false;
            inClass = false;
            indentLevel = 0;
            continue;
          }
        }

        chunks.push({
          id: `${filePath}:${chunkStart}-${chunkEndLine}`,
          filePath,
          content: chunkContent,
          startLine: chunkStart,
          endLine: chunkEndLine,
          symbols: [],
          imports: [],
          language
        });

        chunkStart = chunkEndLine;
        inFunction = false;
        inClass = false;
        indentLevel = 0;
      }
    }

    // Handle the case where the file ends without a block end
    if (chunkStart < lines.length) {
      const chunkContent = lines.slice(chunkStart).join('\n');
      chunks.push({
        id: `${filePath}:${chunkStart}-${lines.length}`,
        filePath,
        content: chunkContent,
        startLine: chunkStart,
        endLine: lines.length,
        symbols: [],
        imports: [],
        language
      });
    }

    return chunks;
  }

  /**
   * Chunk a C-style file (Java, C#, C, C++)
   */
  private chunkCStyleFile(content: string, filePath: string, language: string, lines: string[]): CodeChunk[] {
    const chunks: CodeChunk[] = [];
    let chunkStart = 0;
    let braceBalance = 0;
    let inFunction = false;
    let inClass = false;

    // Always include imports/includes in the first chunk
    let importsEndLine = 0;
    for (let i = 0; i < Math.min(50, lines.length); i++) {
      if (lines[i].includes('import ') || lines[i].includes('#include ') ||
          lines[i].includes('using ') || lines[i].includes('package ')) {
        importsEndLine = i + 1;
      }
    }

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();

      // Track brace balance
      braceBalance += (line.match(/{/g) || []).length;
      braceBalance -= (line.match(/}/g) || []).length;

      // Detect function or class start
      if (!inFunction && !inClass && braceBalance === 0) {
        if ((line.includes('(') && line.includes(')') && !line.includes(';')) ||
            line.includes('class ') || line.includes('interface ') ||
            line.includes('struct ') || line.includes('enum ')) {
          inFunction = line.includes('(') && line.includes(')') && !line.includes(';');
          inClass = line.includes('class ') || line.includes('interface ') ||
                   line.includes('struct ') || line.includes('enum ');
        }
      }

      // Check if we should end the current chunk
      const isBlockEnd = (braceBalance === 0 && (inFunction || inClass) && i > chunkStart) ||
                         i === lines.length - 1;

      if (isBlockEnd || (i - chunkStart > 200)) {
        // Create a chunk
        const chunkEndLine = i + 1;
        const chunkContent = lines.slice(chunkStart, chunkEndLine).join('\n');

        // For the first chunk, include imports
        if (chunkStart === 0 && importsEndLine > 0 && chunkStart !== importsEndLine) {
          const importsContent = lines.slice(0, importsEndLine).join('\n');
          chunks.push({
            id: `${filePath}:0-${importsEndLine}`,
            filePath,
            content: importsContent,
            startLine: 0,
            endLine: importsEndLine,
            symbols: [],
            imports: [],
            language
          });

          // If the first chunk is just imports, continue to the next chunk
          if (chunkEndLine <= importsEndLine) {
            chunkStart = chunkEndLine;
            inFunction = false;
            inClass = false;
            braceBalance = 0;
            continue;
          }
        }

        chunks.push({
          id: `${filePath}:${chunkStart}-${chunkEndLine}`,
          filePath,
          content: chunkContent,
          startLine: chunkStart,
          endLine: chunkEndLine,
          symbols: [],
          imports: [],
          language
        });

        chunkStart = chunkEndLine;
        inFunction = false;
        inClass = false;
        braceBalance = 0;
      }
    }

    return chunks;
  }

  /**
   * Chunk a generic file (fallback for unsupported languages)
   */
  private chunkGenericFile(content: string, filePath: string, language: string, lines: string[]): CodeChunk[] {
    const chunks: CodeChunk[] = [];
    const maxChunkSize = 100; // lines

    // For data files, use larger chunks
    const chunkSize = this.isDataOrDocFile(language) ? 200 : maxChunkSize;

    for (let i = 0; i < lines.length; i += chunkSize) {
      const chunkEndLine = Math.min(i + chunkSize, lines.length);
      const chunkContent = lines.slice(i, chunkEndLine).join('\n');

      chunks.push({
        id: `${filePath}:${i}-${chunkEndLine}`,
        filePath,
        content: chunkContent,
        startLine: i,
        endLine: chunkEndLine,
        symbols: [],
        imports: [],
        language
      });
    }

    return chunks;
  }

  private async handleFileChange(uri: vscode.Uri): Promise<void> {
    // Delete existing chunks for this file
    await this.deleteFileChunks(uri.fsPath);

    // Re-index the file
    await this.indexFile(uri);
  }

  private async handleFileCreate(uri: vscode.Uri): Promise<void> {
    await this.indexFile(uri);
  }

  private async handleFileDelete(uri: vscode.Uri): Promise<void> {
    await this.deleteFileChunks(uri.fsPath);
  }

  /**
   * Delete all chunks for a file
   * @param filePath File path
   */
  private async deleteFileChunks(filePath: string): Promise<void> {
    try {
      // Get all chunks from the vector store
      const allChunks = await this.vectorStore.findSimilarChunks('', 10000);

      // Filter chunks for this file
      const fileChunks = allChunks.filter(chunk => chunk.filePath === filePath);

      // Delete each chunk
      for (const chunk of fileChunks) {
        await this.vectorStore.deleteChunk(chunk.id);
      }

      console.log(`Deleted ${fileChunks.length} chunks for file: ${filePath}`);
    } catch (error) {
      console.error(`Error deleting chunks for file ${filePath}:`, error);
    }
  }

  public dispose(): void {
    this.fileWatcher.dispose();
    this.indexingStatus.dispose();
  }
}

```


---

### File: `src/context/dependencyGraph.ts`

```typescript
import { CodeChunk } from './types';

interface DependencyNode {
  id: string;
  filePath: string;
  symbols: string[];
  imports: string[];
  dependencies: string[];
  dependents: string[];
}

export class DependencyGraph {
  private nodes: Map<string, DependencyNode> = new Map();
  
  public addChunk(chunk: CodeChunk): void {
    const nodeId = chunk.filePath;
    
    if (!this.nodes.has(nodeId)) {
      this.nodes.set(nodeId, {
        id: nodeId,
        filePath: chunk.filePath,
        symbols: [...chunk.symbols],
        imports: [...chunk.imports],
        dependencies: [],
        dependents: []
      });
    } else {
      // Update existing node
      const node = this.nodes.get(nodeId)!;
      chunk.symbols.forEach(symbol => {
        if (!node.symbols.includes(symbol)) {
          node.symbols.push(symbol);
        }
      });
      chunk.imports.forEach(imp => {
        if (!node.imports.includes(imp)) {
          node.imports.push(imp);
        }
      });
    }
  }
  
  public buildGraph(): void {
    // Clear existing dependencies
    for (const node of this.nodes.values()) {
      node.dependencies = [];
      node.dependents = [];
    }
    
    // Build dependencies based on imports and symbols
    for (const [id, node] of this.nodes.entries()) {
      for (const [otherId, otherNode] of this.nodes.entries()) {
        if (id === otherId) {
          continue;
        }
        
        // Check if this node imports symbols from the other node
        for (const imp of node.imports) {
          if (otherNode.symbols.some(symbol => imp.includes(symbol))) {
            if (!node.dependencies.includes(otherId)) {
              node.dependencies.push(otherId);
            }
            if (!otherNode.dependents.includes(id)) {
              otherNode.dependents.push(id);
            }
          }
        }
      }
    }
  }
  
  public getRelatedFiles(filePath: string, depth: number = 1): string[] {
    const node = this.nodes.get(filePath);
    if (!node) {
      return [];
    }
    
    const visited = new Set<string>();
    const result: string[] = [];
    
    // Add direct dependencies
    this.traverseGraph(node, visited, result, depth, true);
    
    // Add direct dependents
    this.traverseGraph(node, visited, result, depth, false);
    
    return result;
  }
  
  private traverseGraph(
    node: DependencyNode,
    visited: Set<string>,
    result: string[],
    depth: number,
    isDependency: boolean
  ): void {
    if (depth <= 0 || visited.has(node.id)) {
      return;
    }
    
    visited.add(node.id);
    if (node.id !== result[0]) { // Don't add the starting node
      result.push(node.id);
    }
    
    const nextNodes = isDependency ? node.dependencies : node.dependents;
    for (const nextId of nextNodes) {
      const nextNode = this.nodes.get(nextId);
      if (nextNode) {
        this.traverseGraph(nextNode, visited, result, depth - 1, isDependency);
      }
    }
  }
}

```


---

### File: `src/container-manager/dockerContainerManager.ts`

```typescript
import * as Docker from 'dockerode';
import * as path from 'path';
import { DockerOptions } from '../configuration';

/**
 * Manager for Docker containers
 */
export class DockerContainerManager {
  private docker: Docker;
  private options: DockerOptions;

  /**
   * Create a new Docker container manager
   * @param options Docker options
   */
  constructor(options: DockerOptions) {
    this.options = options;
    this.docker = new Docker({
      socketPath: options.socketPath
    });
  }

  /**
   * Start a container from a Dockerfile
   * @param name Container name
   * @param dockerfilePath Path to the directory containing the Dockerfile
   * @param actualDockerfilePath Optional path to the actual Dockerfile if it's not in the root directory
   * @returns Promise that resolves to the container ID
   */
  public async startContainer(name: string, dockerfilePath: string, actualDockerfilePath?: string): Promise<string> {
    try {
      console.log(`Starting container for ${name} from ${dockerfilePath}`);

      // Determine the context and Dockerfile path
      let context = dockerfilePath;
      let dockerfile = 'Dockerfile';

      if (actualDockerfilePath) {
        // If the Dockerfile is not in the root directory, we need to adjust the paths
        const relativePath = path.relative(dockerfilePath, actualDockerfilePath);
        if (relativePath.includes('..')) {
          // If the Dockerfile is outside the context, we need to use its directory as context
          context = path.dirname(actualDockerfilePath);
          dockerfile = path.basename(actualDockerfilePath);
        } else {
          // If the Dockerfile is inside the context, we just need to specify its relative path
          dockerfile = relativePath;
        }
      }

      console.log(`Building image with context: ${context}, dockerfile: ${dockerfile}`);

      // Build the image
      const stream = await this.docker.buildImage({
        context,
        src: [dockerfile]
      }, {
        t: `mcp-server-${name}`,
        dockerfile
      });

      // Wait for the build to complete
      await new Promise((resolve, reject) => {
        this.docker.modem.followProgress(stream, (err: any, res: any) => {
          if (err) {
            console.error('Error building image:', err);
            reject(err);
          } else {
            console.log('Image built successfully');
            resolve(res);
          }
        });
      });

      // Check if a container with the same name already exists
      const containers = await this.docker.listContainers({ all: true });
      const existingContainer = containers.find(c => c.Names.includes(`/mcp-server-${name}`));

      if (existingContainer) {
        console.log(`Container with name mcp-server-${name} already exists, removing it`);
        const container = this.docker.getContainer(existingContainer.Id);
        if (existingContainer.State === 'running') {
          await container.stop();
        }
        await container.remove();
      }

      // Create the container
      console.log(`Creating container for ${name}`);
      const container = await this.docker.createContainer({
        Image: `mcp-server-${name}`,
        name: `mcp-server-${name}`,
        ExposedPorts: {
          '8000/tcp': {}
        },
        HostConfig: {
          PortBindings: {
            '8000/tcp': [
              {
                HostPort: '0' // Let Docker assign a random port
              }
            ]
          },
          Memory: this.options.memory * 1024 * 1024, // Convert MB to bytes
          NanoCpus: this.options.cpus * 1000000000, // Convert CPUs to nanoCPUs
          RestartPolicy: {
            Name: 'on-failure',
            MaximumRetryCount: 3
          }
        }
      });

      // Start the container
      console.log(`Starting container for ${name}`);
      await container.start();

      // Wait a moment to ensure the container is running
      await new Promise(resolve => setTimeout(resolve, 2000));

      // Check if the container is running
      const info = await container.inspect();
      if (!info.State.Running) {
        throw new Error(`Container failed to start: ${info.State.Error || 'Unknown error'}`);
      }

      console.log(`Container for ${name} started successfully with ID ${container.id}`);
      return container.id;
    } catch (error) {
      console.error('Error starting container:', error);
      throw error;
    }
  }

  /**
   * Stop a container
   * @param containerId Container ID
   * @returns Promise that resolves when the container is stopped
   */
  public async stopContainer(containerId: string): Promise<void> {
    try {
      const container = this.docker.getContainer(containerId);
      await container.stop();
      await container.remove();
    } catch (error) {
      console.error('Error stopping container:', error);
      throw error;
    }
  }

  /**
   * Get the endpoint for a container
   * @param containerId Container ID
   * @returns Promise that resolves to the container endpoint
   */
  public async getContainerEndpoint(containerId: string): Promise<string> {
    try {
      const container = this.docker.getContainer(containerId);
      const info = await container.inspect();

      // Get the host port
      const hostPort = info.NetworkSettings.Ports['8000/tcp'][0].HostPort;

      return `http://localhost:${hostPort}`;
    } catch (error) {
      console.error('Error getting container endpoint:', error);
      throw error;
    }
  }

  /**
   * Get the logs for a container
   * @param containerId Container ID
   * @returns Promise that resolves to the container logs
   */
  public async getContainerLogs(containerId: string): Promise<string> {
    try {
      const container = this.docker.getContainer(containerId);
      const logs = await container.logs({
        stdout: true,
        stderr: true,
        tail: 100
      });

      return logs.toString();
    } catch (error) {
      console.error('Error getting container logs:', error);
      throw error;
    }
  }

  /**
   * Check if a container is running
   * @param containerId Container ID
   * @returns Promise that resolves to true if the container is running
   */
  public async isContainerRunning(containerId: string): Promise<boolean> {
    try {
      const container = this.docker.getContainer(containerId);
      const info = await container.inspect();

      return info.State.Running;
    } catch (error) {
      console.error('Error checking if container is running:', error);
      return false;
    }
  }
}

```


---

### File: `src/mcp-client/mcpServerManager.ts`

```typescript
import * as fs from 'fs';
import * as path from 'path';
import * as vscode from 'vscode';
import { getConfiguration } from '../configuration';
import { DockerContainerManager } from '../container-manager/dockerContainerManager';
import { GitHubRepoManager } from '../github-integration/githubRepoManager';
import { McpServer, McpServerStatus, McpServerType, McpToolInvocation, McpToolResponse } from './types';

/**
 * Manager for MCP servers
 */
export class McpServerManager implements vscode.Disposable {
  private servers: Map<string, McpServer> = new Map();
  private dockerManager: DockerContainerManager;
  private githubManager: GitHubRepoManager;
  private storageDir: string;
  private configFile: string;
  private _onDidChangeServers = new vscode.EventEmitter<void>();

  /**
   * Event that fires when the servers list changes
   */
  public readonly onDidChangeServers = this._onDidChangeServers.event;

  /**
   * Create a new MCP server manager
   */
  constructor() {
    const config = getConfiguration();
    this.dockerManager = new DockerContainerManager(config.mcpServers.dockerOptions);
    this.githubManager = new GitHubRepoManager(config.mcpServers.githubOptions);

    // Set up storage directory
    this.storageDir = this.getStorageDir(config.mcpServers.storagePath);
    this.configFile = path.join(this.storageDir, 'mcp-servers.json');

    // Create storage directory if it doesn't exist
    if (!fs.existsSync(this.storageDir)) {
      fs.mkdirSync(this.storageDir, { recursive: true });
    }

    // Load servers from config file
    this.loadServers();
  }

  /**
   * Get the storage directory
   * @param configPath Path from configuration
   * @returns Storage directory path
   */
  private getStorageDir(configPath: string): string {
    if (configPath) {
      return configPath;
    }

    // Use the extension's global storage path
    const context = vscode.extensions.getExtension('qwen-coder-assistant')?.extensionUri;
    if (context) {
      return path.join(context.fsPath, 'mcp-servers');
    }

    // Fallback to the workspace storage path
    if (vscode.workspace.workspaceFolders && vscode.workspace.workspaceFolders.length > 0) {
      return path.join(vscode.workspace.workspaceFolders[0].uri.fsPath, '.vscode', 'mcp-servers');
    }

    throw new Error('Could not determine storage directory for MCP servers');
  }

  /**
   * Load servers from config file
   */
  private loadServers(): void {
    try {
      if (fs.existsSync(this.configFile)) {
        const data = fs.readFileSync(this.configFile, 'utf8');
        const servers = JSON.parse(data) as McpServer[];

        // Reset status for all servers
        for (const server of servers) {
          server.status = McpServerStatus.Stopped;
          server.logs = server.logs || [];
          this.servers.set(server.id, server);
        }

        this._onDidChangeServers.fire();
      }
    } catch (error) {
      console.error('Error loading MCP servers:', error);
      vscode.window.showErrorMessage(`Error loading MCP servers: ${error}`);
    }
  }

  /**
   * Save servers to config file
   */
  private saveServers(): void {
    try {
      const servers = Array.from(this.servers.values());
      fs.writeFileSync(this.configFile, JSON.stringify(servers, null, 2), 'utf8');
    } catch (error) {
      console.error('Error saving MCP servers:', error);
      vscode.window.showErrorMessage(`Error saving MCP servers: ${error}`);
    }
  }

  /**
   * Get all servers
   * @returns Array of MCP servers
   */
  public getServers(): McpServer[] {
    return Array.from(this.servers.values());
  }

  /**
   * Get a server by ID
   * @param id Server ID
   * @returns MCP server or undefined if not found
   */
  public getServer(id: string): McpServer | undefined {
    return this.servers.get(id);
  }

  /**
   * Add a new server from a GitHub repository
   * @param repoUrl GitHub repository URL
   * @returns Promise that resolves to the new server
   */
  public async addServerFromGitHub(repoUrl: string): Promise<McpServer> {
    try {
      // Clone the repository
      const repoInfo = await this.githubManager.cloneRepository(repoUrl, this.storageDir);

      // Check if the repository has a Dockerfile
      if (!repoInfo.hasDockerfile) {
        throw new Error('Repository does not contain a Dockerfile');
      }

      // Check if the repository has an MCP schema file
      if (!repoInfo.hasMcpSchema) {
        throw new Error('Repository does not contain an MCP schema file');
      }

      // Read the schema file
      const schemaData = fs.readFileSync(repoInfo.schemaPath!, 'utf8');
      let schema;

      // Parse the schema file based on its extension
      if (repoInfo.schemaPath!.endsWith('.json')) {
        schema = JSON.parse(schemaData);
      } else if (repoInfo.schemaPath!.endsWith('.yaml') || repoInfo.schemaPath!.endsWith('.yml')) {
        // For YAML files, we would need a YAML parser
        // This is a placeholder - in a real implementation, you would use a YAML parser
        throw new Error('YAML schema files are not yet supported');
      } else {
        throw new Error('Unsupported schema file format');
      }

      // Validate the schema
      if (!schema.name || !schema.description || !schema.tools || !Array.isArray(schema.tools)) {
        throw new Error('Invalid MCP schema: missing required fields (name, description, tools)');
      }

      // Create a new server
      const server: McpServer = {
        id: repoInfo.name,
        name: schema.name || repoInfo.name,
        description: schema.description || repoInfo.description || '',
        repoUrl,
        version: repoInfo.version || schema.version || '0.0.1',
        status: McpServerStatus.Stopped,
        type: McpServerType.Docker,
        autoStart: false,
        schema,
        logs: [],
        localPath: repoInfo.localPath,
        dockerfilePath: repoInfo.dockerfilePath
      };

      // Add the server to the list
      this.servers.set(server.id, server);

      // Save the servers
      this.saveServers();

      // Notify listeners
      this._onDidChangeServers.fire();

      // Add log entry
      server.logs.push(`[${new Date().toISOString()}] Server added from GitHub repository: ${repoUrl}`);

      return server;
    } catch (error) {
      console.error('Error adding server from GitHub:', error);
      throw error;
    }
  }

  /**
   * Remove a server
   * @param id Server ID
   * @returns Promise that resolves when the server is removed
   */
  public async removeServer(id: string): Promise<void> {
    const server = this.servers.get(id);
    if (!server) {
      throw new Error(`Server ${id} not found`);
    }

    // Stop the server if it's running
    if (server.status === McpServerStatus.Running) {
      await this.stopServer(id);
    }

    // Remove the server from the list
    this.servers.delete(id);

    // Save the servers
    this.saveServers();

    // Notify listeners
    this._onDidChangeServers.fire();
  }

  /**
   * Start a server
   * @param id Server ID
   * @returns Promise that resolves when the server is started
   */
  public async startServer(id: string): Promise<void> {
    const server = this.servers.get(id);
    if (!server) {
      throw new Error(`Server ${id} not found`);
    }

    // Update server status
    server.status = McpServerStatus.Starting;
    server.error = undefined;
    this._onDidChangeServers.fire();

    try {
      // Start the server based on its type
      if (server.type === McpServerType.Docker) {
        // Get the repository path
        const repoPath = server.localPath || path.join(this.storageDir, server.id);

        // Start the Docker container
        const containerId = await this.dockerManager.startContainer(
          server.id,
          repoPath,
          server.dockerfilePath
        );

        // Update server information
        server.containerId = containerId;
        server.status = McpServerStatus.Running;
        server.lastStarted = new Date();
        server.endpoint = await this.dockerManager.getContainerEndpoint(containerId);
        server.healthStatus = 'unknown';
        server.lastHealthCheck = new Date();

        // Add log entry
        server.logs.push(`[${new Date().toISOString()}] Server started with endpoint ${server.endpoint}`);

        // Check server health
        try {
          const isHealthy = await this.checkServerHealth(server.id);
          server.healthStatus = isHealthy ? 'healthy' : 'unhealthy';

          if (!isHealthy) {
            server.logs.push(`[${new Date().toISOString()}] Warning: Server health check failed`);
          } else {
            server.logs.push(`[${new Date().toISOString()}] Server health check passed`);
          }
        } catch (healthError) {
          server.logs.push(`[${new Date().toISOString()}] Error checking server health: ${healthError}`);
          server.healthStatus = 'unknown';
        }

        // Save the servers
        this.saveServers();

        // Notify listeners
        this._onDidChangeServers.fire();
      } else {
        throw new Error(`Unsupported server type: ${server.type}`);
      }
    } catch (error) {
      console.error(`Error starting server ${id}:`, error);

      // Update server status
      server.status = McpServerStatus.Error;
      server.error = `${error}`;

      // Add log entry
      server.logs.push(`[${new Date().toISOString()}] Error starting server: ${error}`);

      // Save the servers
      this.saveServers();

      // Notify listeners
      this._onDidChangeServers.fire();

      throw error;
    }
  }

  /**
   * Stop a server
   * @param id Server ID
   * @returns Promise that resolves when the server is stopped
   */
  public async stopServer(id: string): Promise<void> {
    const server = this.servers.get(id);
    if (!server) {
      throw new Error(`Server ${id} not found`);
    }

    // Update server status
    server.status = McpServerStatus.Stopping;
    this._onDidChangeServers.fire();

    try {
      // Stop the server based on its type
      if (server.type === McpServerType.Docker) {
        // Stop the Docker container
        if (server.containerId) {
          await this.dockerManager.stopContainer(server.containerId);
        }

        // Update server information
        server.status = McpServerStatus.Stopped;
        server.lastStopped = new Date();
        server.endpoint = undefined;

        // Add log entry
        server.logs.push(`[${new Date().toISOString()}] Server stopped`);

        // Save the servers
        this.saveServers();

        // Notify listeners
        this._onDidChangeServers.fire();
      } else {
        throw new Error(`Unsupported server type: ${server.type}`);
      }
    } catch (error) {
      console.error(`Error stopping server ${id}:`, error);

      // Update server status
      server.status = McpServerStatus.Error;
      server.error = `${error}`;

      // Add log entry
      server.logs.push(`[${new Date().toISOString()}] Error stopping server: ${error}`);

      // Save the servers
      this.saveServers();

      // Notify listeners
      this._onDidChangeServers.fire();

      throw error;
    }
  }

  /**
   * Restart a server
   * @param id Server ID
   * @returns Promise that resolves when the server is restarted
   */
  public async restartServer(id: string): Promise<void> {
    await this.stopServer(id);
    await this.startServer(id);
  }

  /**
   * Get the logs for a server
   * @param id Server ID
   * @returns Server logs
   */
  public getServerLogs(id: string): string[] {
    const server = this.servers.get(id);
    if (!server) {
      throw new Error(`Server ${id} not found`);
    }

    return server.logs;
  }

  /**
   * Invoke a tool on a server
   * @param serverId Server ID
   * @param invocation Tool invocation
   * @param authHeaders Optional authentication headers
   * @returns Promise that resolves to the tool response
   */
  public async invokeTool(
    serverId: string,
    invocation: McpToolInvocation,
    authHeaders?: Record<string, string>
  ): Promise<McpToolResponse> {
    const server = this.servers.get(serverId);
    if (!server) {
      return {
        status: 'error',
        error: `Server ${serverId} not found`
      };
    }

    if (server.status !== McpServerStatus.Running) {
      return {
        status: 'error',
        error: `Server ${serverId} is not running (current status: ${server.status})`
      };
    }

    if (!server.endpoint) {
      return {
        status: 'error',
        error: `Server ${serverId} has no endpoint`
      };
    }

    try {
      // Log the invocation
      server.logs.push(`[${new Date().toISOString()}] Invoking tool ${invocation.tool} with parameters: ${JSON.stringify(invocation.parameters)}`);

      // Check server health before invoking the tool
      const isHealthy = await this.checkServerHealth(serverId);
      if (!isHealthy) {
        server.logs.push(`[${new Date().toISOString()}] Warning: Server health check failed before tool invocation`);
      }

      // Determine the correct endpoint URL
      let endpointUrl = `${server.endpoint}/tools/${invocation.tool}`;

      // Some MCP servers use a different endpoint format
      if (server.schema?.apiVersion === 'v2') {
        endpointUrl = `${server.endpoint}/v2/tools/${invocation.tool}`;
      } else if (server.schema?.apiVersion === 'v1') {
        endpointUrl = `${server.endpoint}/v1/tools/${invocation.tool}`;
      }

      // Prepare headers
      const headers: Record<string, string> = {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      };

      // Add authentication headers if provided
      if (authHeaders) {
        Object.assign(headers, authHeaders);
        server.logs.push(`[${new Date().toISOString()}] Using authentication for tool invocation`);
      }

      // Invoke the tool on the server
      const response = await fetch(endpointUrl, {
        method: 'POST',
        headers,
        body: JSON.stringify(invocation.parameters),
        timeout: 30000 // 30 second timeout
      });

      if (!response.ok) {
        const errorText = await response.text();
        server.logs.push(`[${new Date().toISOString()}] Error invoking tool ${invocation.tool}: ${errorText}`);

        // Check for authentication errors
        if (response.status === 401 || response.status === 403) {
          return {
            status: 'error',
            error: `Authentication error: ${errorText}`
          };
        }

        return {
          status: 'error',
          error: `Error invoking tool: ${errorText}`
        };
      }

      const result = await response.json();

      // Log the result (truncated if too large)
      const resultStr = JSON.stringify(result);
      const truncatedResult = resultStr.length > 500 ? resultStr.substring(0, 500) + '...' : resultStr;
      server.logs.push(`[${new Date().toISOString()}] Tool ${invocation.tool} invocation successful. Result: ${truncatedResult}`);

      // Save the servers to persist the logs
      this.saveServers();

      return {
        status: 'success',
        result
      };
    } catch (error) {
      console.error(`Error invoking tool ${invocation.tool} on server ${serverId}:`, error);

      // Log the error
      server.logs.push(`[${new Date().toISOString()}] Error invoking tool ${invocation.tool}: ${error}`);

      // Save the servers to persist the logs
      this.saveServers();

      return {
        status: 'error',
        error: `${error}`
      };
    }
  }

  /**
   * Start all auto-start servers
   * @returns Promise that resolves when all auto-start servers are started
   */
  public async startAutoStartServers(): Promise<void> {
    const config = getConfiguration();

    // Get the list of servers to auto-start
    const autoStartList = config.mcpServers.autoStartList;

    // If auto-start is disabled, return
    if (!config.mcpServers.autoStart || autoStartList.length === 0) {
      return;
    }

    // Start each server in the list
    for (const serverId of autoStartList) {
      const server = this.servers.get(serverId);
      if (server && server.status === McpServerStatus.Stopped) {
        try {
          await this.startServer(serverId);
        } catch (error) {
          console.error(`Error auto-starting server ${serverId}:`, error);
        }
      }
    }
  }

  /**
   * Check the health of a server
   * @param id Server ID
   * @returns Promise that resolves to true if the server is healthy
   */
  public async checkServerHealth(id: string): Promise<boolean> {
    const server = this.servers.get(id);
    if (!server) {
      throw new Error(`Server ${id} not found`);
    }

    if (server.status !== McpServerStatus.Running) {
      return false;
    }

    if (!server.endpoint) {
      return false;
    }

    try {
      // Try to fetch the server's health endpoint
      const response = await fetch(`${server.endpoint}/health`, {
        method: 'GET',
        headers: {
          'Accept': 'application/json'
        },
        timeout: 5000 // 5 second timeout
      });

      // Update server health status
      server.healthStatus = response.ok ? 'healthy' : 'unhealthy';
      server.lastHealthCheck = new Date();

      // Save the servers
      this.saveServers();

      return response.ok;
    } catch (error) {
      console.error(`Error checking server health for ${id}:`, error);

      // Update server health status
      server.healthStatus = 'unhealthy';
      server.lastHealthCheck = new Date();

      // Save the servers
      this.saveServers();

      return false;
    }
  }

  /**
   * Check the health of all running servers
   * @returns Promise that resolves when all servers have been checked
   */
  public async checkAllServersHealth(): Promise<void> {
    for (const server of this.servers.values()) {
      if (server.status === McpServerStatus.Running) {
        try {
          await this.checkServerHealth(server.id);
        } catch (error) {
          console.error(`Error checking server health for ${server.id}:`, error);
        }
      }
    }
  }

  /**
   * Dispose of resources
   */
  public dispose(): void {
    // Stop all running servers
    for (const server of this.servers.values()) {
      if (server.status === McpServerStatus.Running) {
        try {
          this.stopServer(server.id);
        } catch (error) {
          console.error(`Error stopping server ${server.id} during disposal:`, error);
        }
      }
    }

    // Dispose of event emitter
    this._onDidChangeServers.dispose();
  }
}

```


---

### File: `src/mcp-client/officialMcpServers.ts`

```typescript
import * as vscode from 'vscode';
import { McpServerManager } from './mcpServerManager';

/**
 * Official MCP server repository URLs
 */
export const OFFICIAL_MCP_SERVERS = {
  GITHUB: 'https://github.com/modelcontextprotocol/mcp-server-github',
  DOCKER: 'https://github.com/modelcontextprotocol/mcp-server-docker',
  GIT: 'https://github.com/modelcontextprotocol/mcp-server-git',
  MEMORY: 'https://github.com/modelcontextprotocol/mcp-server-memory',
  FILESYSTEM: 'https://github.com/modelcontextprotocol/mcp-server-filesystem'
};

/**
 * Manager for official MCP servers
 */
export class OfficialMcpServersManager {
  private serverManager: McpServerManager;

  /**
   * Create a new official MCP servers manager
   * @param serverManager MCP server manager
   */
  constructor(serverManager: McpServerManager) {
    this.serverManager = serverManager;
  }

  /**
   * Add the GitHub MCP server
   * @returns Promise that resolves to the server ID
   */
  public async addGitHubServer(): Promise<string> {
    try {
      const server = await this.serverManager.addServerFromGitHub(OFFICIAL_MCP_SERVERS.GITHUB);
      return server.id;
    } catch (error) {
      console.error('Error adding GitHub MCP server:', error);
      throw new Error(`Failed to add GitHub MCP server: ${error}`);
    }
  }

  /**
   * Add the Docker MCP server
   * @returns Promise that resolves to the server ID
   */
  public async addDockerServer(): Promise<string> {
    try {
      const server = await this.serverManager.addServerFromGitHub(OFFICIAL_MCP_SERVERS.DOCKER);
      return server.id;
    } catch (error) {
      console.error('Error adding Docker MCP server:', error);
      throw new Error(`Failed to add Docker MCP server: ${error}`);
    }
  }

  /**
   * Add the Git MCP server
   * @returns Promise that resolves to the server ID
   */
  public async addGitServer(): Promise<string> {
    try {
      const server = await this.serverManager.addServerFromGitHub(OFFICIAL_MCP_SERVERS.GIT);
      return server.id;
    } catch (error) {
      console.error('Error adding Git MCP server:', error);
      throw new Error(`Failed to add Git MCP server: ${error}`);
    }
  }

  /**
   * Add the Memory MCP server
   * @returns Promise that resolves to the server ID
   */
  public async addMemoryServer(): Promise<string> {
    try {
      const server = await this.serverManager.addServerFromGitHub(OFFICIAL_MCP_SERVERS.MEMORY);
      return server.id;
    } catch (error) {
      console.error('Error adding Memory MCP server:', error);
      throw new Error(`Failed to add Memory MCP server: ${error}`);
    }
  }

  /**
   * Add the Filesystem MCP server
   * @returns Promise that resolves to the server ID
   */
  public async addFilesystemServer(): Promise<string> {
    try {
      const server = await this.serverManager.addServerFromGitHub(OFFICIAL_MCP_SERVERS.FILESYSTEM);
      return server.id;
    } catch (error) {
      console.error('Error adding Filesystem MCP server:', error);
      throw new Error(`Failed to add Filesystem MCP server: ${error}`);
    }
  }

  /**
   * Add all official MCP servers
   * @returns Promise that resolves to an array of server IDs
   */
  public async addAllOfficialServers(): Promise<string[]> {
    const serverIds: string[] = [];

    try {
      // Add GitHub server
      const githubId = await this.addGitHubServer();
      serverIds.push(githubId);
    } catch (error) {
      console.error('Error adding GitHub MCP server:', error);
    }

    try {
      // Add Docker server
      const dockerId = await this.addDockerServer();
      serverIds.push(dockerId);
    } catch (error) {
      console.error('Error adding Docker MCP server:', error);
    }

    try {
      // Add Git server
      const gitId = await this.addGitServer();
      serverIds.push(gitId);
    } catch (error) {
      console.error('Error adding Git MCP server:', error);
    }

    try {
      // Add Memory server
      const memoryId = await this.addMemoryServer();
      serverIds.push(memoryId);
    } catch (error) {
      console.error('Error adding Memory MCP server:', error);
    }

    try {
      // Add Filesystem server
      const filesystemId = await this.addFilesystemServer();
      serverIds.push(filesystemId);
    } catch (error) {
      console.error('Error adding Filesystem MCP server:', error);
    }

    return serverIds;
  }

  /**
   * Check if a server is an official MCP server
   * @param repoUrl Repository URL
   * @returns True if the server is an official MCP server
   */
  public isOfficialMcpServer(repoUrl: string): boolean {
    const officialUrls = Object.values(OFFICIAL_MCP_SERVERS);
    return officialUrls.includes(repoUrl);
  }

  /**
   * Get the type of an official MCP server
   * @param repoUrl Repository URL
   * @returns Server type or undefined if not an official server
   */
  public getOfficialServerType(repoUrl: string): string | undefined {
    for (const [type, url] of Object.entries(OFFICIAL_MCP_SERVERS)) {
      if (url === repoUrl) {
        return type.toLowerCase();
      }
    }
    return undefined;
  }
}

```


---

### File: `src/mcp-client/serverHealthMonitor.ts`

```typescript
import * as vscode from 'vscode';
import { McpServer, McpServerStatus } from './types';
import { McpServerManager } from './mcpServerManager';

/**
 * Health status of an MCP server
 */
export type ServerHealthStatus = 'healthy' | 'unhealthy' | 'unknown';

/**
 * Health information for an MCP server
 */
export interface ServerHealth {
  status: ServerHealthStatus;
  lastChecked: Date;
  error?: string;
}

/**
 * Monitor for MCP server health
 */
export class ServerHealthMonitor implements vscode.Disposable {
  private serverManager: McpServerManager;
  private intervalId: NodeJS.Timeout | undefined;
  private checkIntervalMs: number;
  private autoRecoveryEnabled: boolean;
  private _onDidUpdateHealth = new vscode.EventEmitter<string>();

  /**
   * Event that fires when a server's health is updated
   */
  public readonly onDidUpdateHealth = this._onDidUpdateHealth.event;

  /**
   * Create a new server health monitor
   * @param serverManager MCP server manager
   * @param checkIntervalMs Interval between health checks in milliseconds (default: 60000)
   * @param autoRecoveryEnabled Whether to automatically recover unhealthy servers (default: true)
   */
  constructor(
    serverManager: McpServerManager,
    checkIntervalMs: number = 60000,
    autoRecoveryEnabled: boolean = true
  ) {
    this.serverManager = serverManager;
    this.checkIntervalMs = checkIntervalMs;
    this.autoRecoveryEnabled = autoRecoveryEnabled;
  }

  /**
   * Start monitoring server health
   */
  public start(): void {
    // Stop any existing interval
    this.stop();

    // Start a new interval
    this.intervalId = setInterval(() => this.checkAllServersHealth(), this.checkIntervalMs);

    // Do an initial health check
    this.checkAllServersHealth();
  }

  /**
   * Stop monitoring server health
   */
  public stop(): void {
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = undefined;
    }
  }

  /**
   * Check the health of all running servers
   */
  private async checkAllServersHealth(): Promise<void> {
    const servers = this.serverManager.getServers();
    
    for (const server of servers) {
      if (server.status === McpServerStatus.Running) {
        await this.checkServerHealth(server.id);
      }
    }
  }

  /**
   * Check the health of a server
   * @param serverId Server ID
   */
  public async checkServerHealth(serverId: string): Promise<void> {
    try {
      const isHealthy = await this.serverManager.checkServerHealth(serverId);
      const server = this.serverManager.getServer(serverId);
      
      if (!server) {
        return;
      }

      // Notify listeners
      this._onDidUpdateHealth.fire(serverId);

      // If the server is unhealthy and auto-recovery is enabled, try to recover it
      if (!isHealthy && this.autoRecoveryEnabled && server.status === McpServerStatus.Running) {
        await this.recoverServer(serverId);
      }
    } catch (error) {
      console.error(`Error checking health for server ${serverId}:`, error);
    }
  }

  /**
   * Recover an unhealthy server
   * @param serverId Server ID
   */
  private async recoverServer(serverId: string): Promise<void> {
    try {
      const server = this.serverManager.getServer(serverId);
      if (!server) {
        return;
      }

      console.log(`Attempting to recover unhealthy server ${serverId}`);
      
      // Add log entry
      server.logs.push(`[${new Date().toISOString()}] Server is unhealthy, attempting recovery...`);
      
      // Restart the server
      await this.serverManager.restartServer(serverId);
      
      // Add log entry
      server.logs.push(`[${new Date().toISOString()}] Server recovery completed`);
      
      // Check health again after recovery
      setTimeout(() => this.checkServerHealth(serverId), 5000);
    } catch (error) {
      console.error(`Error recovering server ${serverId}:`, error);
      
      const server = this.serverManager.getServer(serverId);
      if (server) {
        server.logs.push(`[${new Date().toISOString()}] Error during server recovery: ${error}`);
      }
    }
  }

  /**
   * Set whether auto-recovery is enabled
   * @param enabled Whether auto-recovery is enabled
   */
  public setAutoRecoveryEnabled(enabled: boolean): void {
    this.autoRecoveryEnabled = enabled;
  }

  /**
   * Set the health check interval
   * @param intervalMs Interval between health checks in milliseconds
   */
  public setCheckInterval(intervalMs: number): void {
    this.checkIntervalMs = intervalMs;
    
    // Restart the interval with the new timing
    if (this.intervalId) {
      this.start();
    }
  }

  /**
   * Dispose of the health monitor
   */
  public dispose(): void {
    this.stop();
    this._onDidUpdateHealth.dispose();
  }
}

```


---

### File: `src/mcp-client/types.ts`

```typescript
/**
 * Types for MCP client and server management
 */

/**
 * Status of an MCP server
 */
export enum McpServerStatus {
  Running = 'running',
  Stopped = 'stopped',
  Starting = 'starting',
  Stopping = 'stopping',
  Error = 'error',
  Unknown = 'unknown'
}

/**
 * Type of MCP server
 */
export enum McpServerType {
  Docker = 'docker',
  Process = 'process'
}

/**
 * Authentication type for MCP servers
 */
export type McpServerAuthType = 'token' | 'basic' | 'api_key' | 'oauth2' | 'none';

/**
 * Base authentication configuration for MCP servers
 */
export interface McpServerAuthConfigBase {
  type: McpServerAuthType;
}

/**
 * Token authentication configuration
 */
export interface McpServerTokenAuthConfig extends McpServerAuthConfigBase {
  type: 'token';
  token: string;
}

/**
 * Basic authentication configuration
 */
export interface McpServerBasicAuthConfig extends McpServerAuthConfigBase {
  type: 'basic';
  username: string;
  password: string;
}

/**
 * API key authentication configuration
 */
export interface McpServerApiKeyAuthConfig extends McpServerAuthConfigBase {
  type: 'api_key';
  apiKey: string;
  headerName?: string;
}

/**
 * OAuth2 authentication configuration
 */
export interface McpServerOAuth2AuthConfig extends McpServerAuthConfigBase {
  type: 'oauth2';
  clientId: string;
  clientSecret: string;
  authUrl: string;
  tokenUrl: string;
  scopes: string[];
  accessToken: string;
  refreshToken: string;
  expiresAt?: string;
}

/**
 * No authentication configuration
 */
export interface McpServerNoAuthConfig extends McpServerAuthConfigBase {
  type: 'none';
}

/**
 * Authentication configuration for MCP servers
 */
export type McpServerAuthConfig =
  | McpServerTokenAuthConfig
  | McpServerBasicAuthConfig
  | McpServerApiKeyAuthConfig
  | McpServerOAuth2AuthConfig
  | McpServerNoAuthConfig;

/**
 * MCP server information
 */
export interface McpServer {
  id: string;
  name: string;
  description: string;
  repoUrl: string;
  version: string;
  status: McpServerStatus;
  type: McpServerType;
  endpoint?: string;
  containerId?: string;
  processId?: number;
  error?: string;
  lastStarted?: Date;
  lastStopped?: Date;
  autoStart: boolean;
  schema?: McpServerSchema;
  logs: string[];
  localPath?: string;
  dockerfilePath?: string;
  healthStatus?: 'healthy' | 'unhealthy' | 'unknown';
  lastHealthCheck?: Date;
}

/**
 * MCP server schema
 */
export interface McpServerSchema {
  name: string;
  description: string;
  version: string;
  apiVersion?: 'v1' | 'v2';
  tools: McpTool[];
  resources?: any[];
  authentication?: {
    type: McpServerAuthType;
    required: boolean;
    scopes?: string[];
    authUrl?: string;
    tokenUrl?: string;
  };
}

/**
 * MCP tool
 */
export interface McpTool {
  name: string;
  description: string;
  parameters: McpToolParameter[];
  returns: McpToolReturn;
}

/**
 * MCP tool parameter
 */
export interface McpToolParameter {
  name: string;
  description: string;
  type: string;
  required: boolean;
  default?: any;
}

/**
 * MCP tool return
 */
export interface McpToolReturn {
  description: string;
  type: string;
}

/**
 * MCP tool invocation
 */
export interface McpToolInvocation {
  tool: string;
  parameters: Record<string, any>;
}

/**
 * MCP tool response
 */
export interface McpToolResponse {
  status: 'success' | 'error';
  result?: any;
  error?: string;
}

```


---

### File: `src/mcp-client/mcpClient.ts`

```typescript
import * as vscode from 'vscode';
import { AuthManager } from './authentication/authManager';
import { McpServerManager } from './mcpServerManager';
import { McpTool, McpToolInvocation, McpToolResponse } from './types';

/**
 * Client for MCP servers
 */
export class McpClient implements vscode.Disposable {
  private serverManager: McpServerManager;
  private authManager?: AuthManager;

  /**
   * Create a new MCP client
   * @param serverManager MCP server manager
   * @param authManager Authentication manager (optional)
   */
  constructor(serverManager: McpServerManager, authManager?: AuthManager) {
    this.serverManager = serverManager;
    this.authManager = authManager;
  }

  /**
   * Get all available tools from all running servers
   * @returns Promise that resolves to an array of tools
   */
  public async getAllTools(): Promise<{ serverId: string; tool: McpTool }[]> {
    const servers = this.serverManager.getServers();
    const tools: { serverId: string; tool: McpTool }[] = [];

    for (const server of servers) {
      if (server.status === 'running' && server.schema?.tools) {
        for (const tool of server.schema.tools) {
          tools.push({
            serverId: server.id,
            tool
          });
        }
      }
    }

    return tools;
  }

  /**
   * Invoke a tool
   * @param serverId Server ID
   * @param toolName Tool name
   * @param parameters Tool parameters
   * @returns Promise that resolves to the tool response
   */
  public async invokeTool(serverId: string, toolName: string, parameters: Record<string, any>): Promise<McpToolResponse> {
    try {
      // Get the server
      const server = this.serverManager.getServer(serverId);
      if (!server) {
        return {
          status: 'error',
          error: `Server ${serverId} not found`
        };
      }

      // Check if the server is running
      if (server.status !== 'running') {
        return {
          status: 'error',
          error: `Server ${serverId} is not running`
        };
      }

      // Check if the server has a schema
      if (!server.schema) {
        return {
          status: 'error',
          error: `Server ${serverId} has no schema`
        };
      }

      // Find the tool in the schema
      const tool = server.schema.tools.find(t => t.name === toolName);
      if (!tool) {
        return {
          status: 'error',
          error: `Tool ${toolName} not found in server ${serverId}`
        };
      }

      // Validate parameters
      const validationResult = this.validateParameters(tool, parameters);
      if (validationResult.status === 'error') {
        return validationResult;
      }

      // Handle authentication if needed
      if (this.authManager && server.schema.authentication?.required) {
        try {
          // Check if we have authentication configured
          const hasAuth = await this.authManager.hasAuthConfig(serverId);
          if (!hasAuth) {
            // Prompt for authentication
            await this.authManager.promptForAuthentication(server);
          }

          // Check if token needs refresh
          const needsRefresh = await this.authManager.needsTokenRefresh(serverId);
          if (needsRefresh) {
            await this.authManager.refreshOAuthToken(serverId);
          }
        } catch (authError) {
          console.error(`Authentication error for server ${serverId}:`, authError);
          return {
            status: 'error',
            error: `Authentication error: ${authError}`
          };
        }
      }

      // Create the invocation
      const invocation: McpToolInvocation = {
        tool: toolName,
        parameters
      };

      // Get authentication headers if available
      let authHeaders: Record<string, string> | undefined;
      if (this.authManager) {
        authHeaders = await this.authManager.getAuthHeaders(serverId);
      }

      // Invoke the tool with authentication headers
      return this.serverManager.invokeTool(serverId, invocation, authHeaders);
    } catch (error) {
      console.error(`Error invoking tool ${toolName} on server ${serverId}:`, error);
      return {
        status: 'error',
        error: `Error invoking tool: ${error}`
      };
    }
  }

  /**
   * Validate parameters against a tool's schema
   * @param tool Tool schema
   * @param parameters Parameters to validate
   * @returns Validation result
   */
  private validateParameters(tool: McpTool, parameters: Record<string, any>): McpToolResponse {
    try {
      // Check for required parameters
      for (const param of tool.parameters) {
        if (param.required && parameters[param.name] === undefined) {
          return {
            status: 'error',
            error: `Missing required parameter: ${param.name}`
          };
        }
      }

      // Check parameter types (basic validation)
      for (const paramName in parameters) {
        const param = tool.parameters.find(p => p.name === paramName);
        if (!param) {
          return {
            status: 'error',
            error: `Unknown parameter: ${paramName}`
          };
        }

        // Basic type checking
        const value = parameters[paramName];

        if (param.type === 'string' && typeof value !== 'string') {
          return {
            status: 'error',
            error: `Parameter ${paramName} should be a string`
          };
        } else if (param.type === 'number' && typeof value !== 'number') {
          return {
            status: 'error',
            error: `Parameter ${paramName} should be a number`
          };
        } else if (param.type === 'boolean' && typeof value !== 'boolean') {
          return {
            status: 'error',
            error: `Parameter ${paramName} should be a boolean`
          };
        } else if (param.type === 'array' && !Array.isArray(value)) {
          return {
            status: 'error',
            error: `Parameter ${paramName} should be an array`
          };
        } else if (param.type === 'object' && (typeof value !== 'object' || value === null || Array.isArray(value))) {
          return {
            status: 'error',
            error: `Parameter ${paramName} should be an object`
          };
        }
      }

      return { status: 'success' };
    } catch (error) {
      console.error('Error validating parameters:', error);
      return {
        status: 'error',
        error: `Error validating parameters: ${error}`
      };
    }
  }

  /**
   * Find a tool by name
   * @param toolName Tool name
   * @returns Promise that resolves to the tool and server ID, or undefined if not found
   */
  public async findTool(toolName: string): Promise<{ serverId: string; tool: McpTool } | undefined> {
    const tools = await this.getAllTools();
    return tools.find(t => t.tool.name === toolName);
  }

  /**
   * Dispose of resources
   */
  public dispose(): void {
    // Nothing to dispose
  }
}

```


---

### File: `src/mcp-client/updates/updateManager.ts`

```typescript
import * as vscode from 'vscode';
import * as semver from 'semver';
import { McpServer } from '../types';
import { McpServerManager } from '../mcpServerManager';
import { GitHubRepoManager } from '../../github-integration/githubRepoManager';

/**
 * Update information
 */
export interface UpdateInfo {
  serverId: string;
  serverName: string;
  currentVersion: string;
  latestVersion: string;
  releaseUrl: string;
  releaseDate: string;
  releaseNotes: string;
  updateAvailable: boolean;
}

/**
 * Update history entry
 */
export interface UpdateHistoryEntry {
  serverId: string;
  serverName: string;
  fromVersion: string;
  toVersion: string;
  updateDate: string;
  success: boolean;
  errorMessage?: string;
}

/**
 * Update manager for MCP servers
 */
export class UpdateManager implements vscode.Disposable {
  private serverManager: McpServerManager;
  private githubManager: GitHubRepoManager;
  private updateHistory: UpdateHistoryEntry[] = [];
  private _onDidCheckForUpdates = new vscode.EventEmitter<UpdateInfo[]>();
  private _onDidUpdateServer = new vscode.EventEmitter<UpdateHistoryEntry>();

  /**
   * Event that fires when updates are checked
   */
  public readonly onDidCheckForUpdates = this._onDidCheckForUpdates.event;

  /**
   * Event that fires when a server is updated
   */
  public readonly onDidUpdateServer = this._onDidUpdateServer.event;

  /**
   * Create a new update manager
   * @param serverManager MCP server manager
   * @param githubManager GitHub repository manager
   */
  constructor(serverManager: McpServerManager, githubManager: GitHubRepoManager) {
    this.serverManager = serverManager;
    this.githubManager = githubManager;
  }

  /**
   * Dispose of resources
   */
  public dispose(): void {
    this._onDidCheckForUpdates.dispose();
    this._onDidUpdateServer.dispose();
  }

  /**
   * Check for updates for all servers
   * @returns Promise that resolves to update information for all servers
   */
  public async checkForUpdates(): Promise<UpdateInfo[]> {
    const servers = this.serverManager.getServers();
    const updateInfos: UpdateInfo[] = [];

    for (const server of servers) {
      try {
        const updateInfo = await this.checkForServerUpdate(server.id);
        if (updateInfo) {
          updateInfos.push(updateInfo);
        }
      } catch (error) {
        console.error(`Error checking for updates for server ${server.id}:`, error);
      }
    }

    // Notify listeners
    this._onDidCheckForUpdates.fire(updateInfos);

    return updateInfos;
  }

  /**
   * Check for updates for a server
   * @param serverId Server ID
   * @returns Promise that resolves to update information for the server
   */
  public async checkForServerUpdate(serverId: string): Promise<UpdateInfo | undefined> {
    const server = this.serverManager.getServer(serverId);
    if (!server) {
      throw new Error(`Server ${serverId} not found`);
    }

    try {
      // Get the latest release from GitHub
      const repoInfo = this.parseGitHubUrl(server.repoUrl);
      if (!repoInfo) {
        throw new Error(`Invalid GitHub URL: ${server.repoUrl}`);
      }

      const latestRelease = await this.githubManager.getLatestRelease(repoInfo.owner, repoInfo.repo);
      if (!latestRelease) {
        return undefined;
      }

      // Check if an update is available
      const currentVersion = server.version;
      const latestVersion = latestRelease.tag_name.startsWith('v')
        ? latestRelease.tag_name.substring(1)
        : latestRelease.tag_name;

      const updateAvailable = this.isUpdateAvailable(currentVersion, latestVersion);

      // Create update information
      const updateInfo: UpdateInfo = {
        serverId: server.id,
        serverName: server.name,
        currentVersion,
        latestVersion,
        releaseUrl: latestRelease.html_url,
        releaseDate: latestRelease.published_at,
        releaseNotes: latestRelease.body || '',
        updateAvailable
      };

      return updateInfo;
    } catch (error) {
      console.error(`Error checking for updates for server ${serverId}:`, error);
      return undefined;
    }
  }

  /**
   * Update a server
   * @param serverId Server ID
   * @returns Promise that resolves when the server is updated
   */
  public async updateServer(serverId: string): Promise<void> {
    const server = this.serverManager.getServer(serverId);
    if (!server) {
      throw new Error(`Server ${serverId} not found`);
    }

    // Check if an update is available
    const updateInfo = await this.checkForServerUpdate(serverId);
    if (!updateInfo || !updateInfo.updateAvailable) {
      throw new Error(`No update available for server ${serverId}`);
    }

    // Create an update history entry
    const historyEntry: UpdateHistoryEntry = {
      serverId: server.id,
      serverName: server.name,
      fromVersion: server.version,
      toVersion: updateInfo.latestVersion,
      updateDate: new Date().toISOString(),
      success: false
    };

    try {
      // Stop the server if it's running
      const wasRunning = server.status === 'running';
      if (wasRunning) {
        await this.serverManager.stopServer(serverId);
      }

      // Update the server
      await this.serverManager.updateServer(serverId);

      // Restart the server if it was running
      if (wasRunning) {
        await this.serverManager.startServer(serverId);
      }

      // Update the history entry
      historyEntry.success = true;

      // Add the entry to the update history
      this.updateHistory.push(historyEntry);

      // Notify listeners
      this._onDidUpdateServer.fire(historyEntry);
    } catch (error) {
      // Update the history entry
      historyEntry.success = false;
      historyEntry.errorMessage = `${error}`;

      // Add the entry to the update history
      this.updateHistory.push(historyEntry);

      // Notify listeners
      this._onDidUpdateServer.fire(historyEntry);

      // Re-throw the error
      throw error;
    }
  }

  /**
   * Get the update history
   * @returns Update history
   */
  public getUpdateHistory(): UpdateHistoryEntry[] {
    return [...this.updateHistory];
  }

  /**
   * Get the update history for a server
   * @param serverId Server ID
   * @returns Update history for the server
   */
  public getServerUpdateHistory(serverId: string): UpdateHistoryEntry[] {
    return this.updateHistory.filter(entry => entry.serverId === serverId);
  }

  /**
   * Clear the update history
   */
  public clearUpdateHistory(): void {
    this.updateHistory = [];
  }

  /**
   * Check if an update is available
   * @param currentVersion Current version
   * @param latestVersion Latest version
   * @returns True if an update is available
   */
  private isUpdateAvailable(currentVersion: string, latestVersion: string): boolean {
    try {
      // Clean the versions to ensure they are valid semver
      const cleanCurrentVersion = semver.valid(semver.coerce(currentVersion));
      const cleanLatestVersion = semver.valid(semver.coerce(latestVersion));

      if (!cleanCurrentVersion || !cleanLatestVersion) {
        // If we can't parse the versions, assume no update is available
        return false;
      }

      // Compare the versions
      return semver.gt(cleanLatestVersion, cleanCurrentVersion);
    } catch (error) {
      console.error('Error comparing versions:', error);
      return false;
    }
  }

  /**
   * Parse a GitHub URL
   * @param url GitHub URL
   * @returns Owner and repository
   */
  private parseGitHubUrl(url: string): { owner: string; repo: string } | undefined {
    try {
      // Parse the URL
      const parsedUrl = new URL(url);
      if (parsedUrl.hostname !== 'github.com') {
        return undefined;
      }

      // Extract the owner and repository
      const parts = parsedUrl.pathname.split('/').filter(part => part.length > 0);
      if (parts.length < 2) {
        return undefined;
      }

      return {
        owner: parts[0],
        repo: parts[1]
      };
    } catch (error) {
      console.error('Error parsing GitHub URL:', error);
      return undefined;
    }
  }
}

```


---

### File: `src/mcp-client/authentication/authManager.ts`

```typescript
import * as vscode from 'vscode';
import { McpServer, McpServerAuthConfig } from '../types';

/**
 * Authentication manager for MCP servers
 */
export class AuthManager implements vscode.Disposable {
  private static readonly SECRET_STORAGE_PREFIX = 'qwen-coder-assistant.mcp-auth.';
  private secretStorage: vscode.SecretStorage;
  private _onDidChangeAuth = new vscode.EventEmitter<string>();

  /**
   * Event that fires when authentication changes for a server
   */
  public readonly onDidChangeAuth = this._onDidChangeAuth.event;

  /**
   * Create a new authentication manager
   * @param context Extension context
   */
  constructor(context: vscode.ExtensionContext) {
    this.secretStorage = context.secrets;
  }

  /**
   * Dispose of resources
   */
  public dispose(): void {
    this._onDidChangeAuth.dispose();
  }

  /**
   * Get the authentication configuration for a server
   * @param serverId Server ID
   * @returns Promise that resolves to the authentication configuration
   */
  public async getAuthConfig(serverId: string): Promise<McpServerAuthConfig | undefined> {
    try {
      const authJson = await this.secretStorage.get(`${AuthManager.SECRET_STORAGE_PREFIX}${serverId}`);
      if (!authJson) {
        return undefined;
      }

      return JSON.parse(authJson) as McpServerAuthConfig;
    } catch (error) {
      console.error(`Error getting auth config for server ${serverId}:`, error);
      return undefined;
    }
  }

  /**
   * Set the authentication configuration for a server
   * @param serverId Server ID
   * @param config Authentication configuration
   * @returns Promise that resolves when the configuration is saved
   */
  public async setAuthConfig(serverId: string, config: McpServerAuthConfig): Promise<void> {
    try {
      await this.secretStorage.store(
        `${AuthManager.SECRET_STORAGE_PREFIX}${serverId}`,
        JSON.stringify(config)
      );

      // Notify listeners
      this._onDidChangeAuth.fire(serverId);
    } catch (error) {
      console.error(`Error setting auth config for server ${serverId}:`, error);
      throw error;
    }
  }

  /**
   * Delete the authentication configuration for a server
   * @param serverId Server ID
   * @returns Promise that resolves when the configuration is deleted
   */
  public async deleteAuthConfig(serverId: string): Promise<void> {
    try {
      await this.secretStorage.delete(`${AuthManager.SECRET_STORAGE_PREFIX}${serverId}`);

      // Notify listeners
      this._onDidChangeAuth.fire(serverId);
    } catch (error) {
      console.error(`Error deleting auth config for server ${serverId}:`, error);
      throw error;
    }
  }

  /**
   * Check if a server has authentication configured
   * @param serverId Server ID
   * @returns Promise that resolves to true if the server has authentication configured
   */
  public async hasAuthConfig(serverId: string): Promise<boolean> {
    try {
      const authJson = await this.secretStorage.get(`${AuthManager.SECRET_STORAGE_PREFIX}${serverId}`);
      return !!authJson;
    } catch (error) {
      console.error(`Error checking auth config for server ${serverId}:`, error);
      return false;
    }
  }

  /**
   * Get authentication headers for a server
   * @param serverId Server ID
   * @returns Promise that resolves to the authentication headers
   */
  public async getAuthHeaders(serverId: string): Promise<Record<string, string> | undefined> {
    try {
      const config = await this.getAuthConfig(serverId);
      if (!config) {
        return undefined;
      }

      switch (config.type) {
        case 'token':
          return {
            'Authorization': `Bearer ${config.token}`
          };
        case 'basic':
          const credentials = Buffer.from(`${config.username}:${config.password}`).toString('base64');
          return {
            'Authorization': `Basic ${credentials}`
          };
        case 'api_key':
          return {
            [config.headerName || 'X-API-Key']: config.apiKey
          };
        case 'oauth2':
          return {
            'Authorization': `Bearer ${config.accessToken}`
          };
        default:
          return undefined;
      }
    } catch (error) {
      console.error(`Error getting auth headers for server ${serverId}:`, error);
      return undefined;
    }
  }

  /**
   * Check if a token needs to be refreshed
   * @param serverId Server ID
   * @returns Promise that resolves to true if the token needs to be refreshed
   */
  public async needsTokenRefresh(serverId: string): Promise<boolean> {
    try {
      const config = await this.getAuthConfig(serverId);
      if (!config || config.type !== 'oauth2' || !config.expiresAt) {
        return false;
      }

      // Check if the token expires in less than 5 minutes
      const expiresAt = new Date(config.expiresAt).getTime();
      const now = Date.now();
      const fiveMinutesMs = 5 * 60 * 1000;

      return expiresAt - now < fiveMinutesMs;
    } catch (error) {
      console.error(`Error checking token refresh for server ${serverId}:`, error);
      return false;
    }
  }

  /**
   * Refresh an OAuth2 token
   * @param serverId Server ID
   * @returns Promise that resolves when the token is refreshed
   */
  public async refreshOAuthToken(serverId: string): Promise<void> {
    try {
      const config = await this.getAuthConfig(serverId);
      if (!config || config.type !== 'oauth2' || !config.refreshToken || !config.tokenUrl) {
        throw new Error('Invalid OAuth2 configuration');
      }

      // Prepare the request
      const params = new URLSearchParams();
      params.append('grant_type', 'refresh_token');
      params.append('refresh_token', config.refreshToken);
      if (config.clientId) {
        params.append('client_id', config.clientId);
      }
      if (config.clientSecret) {
        params.append('client_secret', config.clientSecret);
      }

      // Make the request
      const response = await fetch(config.tokenUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded'
        },
        body: params.toString()
      });

      if (!response.ok) {
        throw new Error(`Token refresh failed: ${response.statusText}`);
      }

      // Parse the response
      const data = await response.json();
      if (!data.access_token) {
        throw new Error('Token refresh response missing access_token');
      }

      // Update the configuration
      const updatedConfig: McpServerAuthConfig = {
        ...config,
        accessToken: data.access_token,
        expiresAt: data.expires_in ? new Date(Date.now() + data.expires_in * 1000).toISOString() : undefined,
        refreshToken: data.refresh_token || config.refreshToken
      };

      // Save the updated configuration
      await this.setAuthConfig(serverId, updatedConfig);
    } catch (error) {
      console.error(`Error refreshing OAuth token for server ${serverId}:`, error);
      throw error;
    }
  }

  /**
   * Handle authentication for a server
   * @param server Server
   * @returns Promise that resolves when authentication is handled
   */
  public async handleAuthentication(server: McpServer): Promise<void> {
    try {
      // Check if the server requires authentication
      if (!server.schema?.authentication?.required) {
        return;
      }

      // Check if we have authentication configured
      const hasAuth = await this.hasAuthConfig(server.id);
      if (!hasAuth) {
        // Prompt the user to configure authentication
        const configureNow = 'Configure Now';
        const response = await vscode.window.showWarningMessage(
          `Server ${server.name} requires authentication. Would you like to configure it now?`,
          configureNow
        );

        if (response === configureNow) {
          await this.promptForAuthentication(server);
        } else {
          throw new Error('Authentication required but not configured');
        }
      }

      // Check if we need to refresh the token
      const needsRefresh = await this.needsTokenRefresh(server.id);
      if (needsRefresh) {
        await this.refreshOAuthToken(server.id);
      }
    } catch (error) {
      console.error(`Error handling authentication for server ${server.id}:`, error);
      throw error;
    }
  }

  /**
   * Prompt the user to configure authentication for a server
   * @param server Server
   * @returns Promise that resolves when authentication is configured
   */
  public async promptForAuthentication(server: McpServer): Promise<void> {
    try {
      // Check if the server has authentication information
      if (!server.schema?.authentication) {
        throw new Error('Server does not have authentication information');
      }

      const authType = server.schema.authentication.type;

      switch (authType) {
        case 'token':
          await this.promptForTokenAuth(server);
          break;
        case 'basic':
          await this.promptForBasicAuth(server);
          break;
        case 'api_key':
          await this.promptForApiKeyAuth(server);
          break;
        case 'oauth2':
          await this.promptForOAuth2Auth(server);
          break;
        default:
          throw new Error(`Unsupported authentication type: ${authType}`);
      }
    } catch (error) {
      console.error(`Error prompting for authentication for server ${server.id}:`, error);
      throw error;
    }
  }

  /**
   * Prompt the user for token authentication
   * @param server Server
   * @returns Promise that resolves when authentication is configured
   */
  private async promptForTokenAuth(server: McpServer): Promise<void> {
    const token = await vscode.window.showInputBox({
      prompt: `Enter token for ${server.name}`,
      password: true,
      ignoreFocusOut: true
    });

    if (!token) {
      throw new Error('Token is required');
    }

    const config: McpServerAuthConfig = {
      type: 'token',
      token
    };

    await this.setAuthConfig(server.id, config);
  }

  /**
   * Prompt the user for basic authentication
   * @param server Server
   * @returns Promise that resolves when authentication is configured
   */
  private async promptForBasicAuth(server: McpServer): Promise<void> {
    const username = await vscode.window.showInputBox({
      prompt: `Enter username for ${server.name}`,
      ignoreFocusOut: true
    });

    if (!username) {
      throw new Error('Username is required');
    }

    const password = await vscode.window.showInputBox({
      prompt: `Enter password for ${server.name}`,
      password: true,
      ignoreFocusOut: true
    });

    if (!password) {
      throw new Error('Password is required');
    }

    const config: McpServerAuthConfig = {
      type: 'basic',
      username,
      password
    };

    await this.setAuthConfig(server.id, config);
  }

  /**
   * Prompt the user for API key authentication
   * @param server Server
   * @returns Promise that resolves when authentication is configured
   */
  private async promptForApiKeyAuth(server: McpServer): Promise<void> {
    const apiKey = await vscode.window.showInputBox({
      prompt: `Enter API key for ${server.name}`,
      password: true,
      ignoreFocusOut: true
    });

    if (!apiKey) {
      throw new Error('API key is required');
    }

    const headerName = await vscode.window.showInputBox({
      prompt: `Enter header name for API key (default: X-API-Key)`,
      value: 'X-API-Key',
      ignoreFocusOut: true
    });

    const config: McpServerAuthConfig = {
      type: 'api_key',
      apiKey,
      headerName: headerName || 'X-API-Key'
    };

    await this.setAuthConfig(server.id, config);
  }

  /**
   * Prompt the user for OAuth2 authentication
   * @param server Server
   * @returns Promise that resolves when authentication is configured
   */
  private async promptForOAuth2Auth(server: McpServer): Promise<void> {
    // This is a simplified implementation
    // A real implementation would use the OAuth2 flow with a web view

    const clientId = await vscode.window.showInputBox({
      prompt: `Enter client ID for ${server.name}`,
      ignoreFocusOut: true
    });

    if (!clientId) {
      throw new Error('Client ID is required');
    }

    const clientSecret = await vscode.window.showInputBox({
      prompt: `Enter client secret for ${server.name}`,
      password: true,
      ignoreFocusOut: true
    });

    if (!clientSecret) {
      throw new Error('Client secret is required');
    }

    const authUrl = await vscode.window.showInputBox({
      prompt: `Enter authorization URL for ${server.name}`,
      ignoreFocusOut: true
    });

    if (!authUrl) {
      throw new Error('Authorization URL is required');
    }

    const tokenUrl = await vscode.window.showInputBox({
      prompt: `Enter token URL for ${server.name}`,
      ignoreFocusOut: true
    });

    if (!tokenUrl) {
      throw new Error('Token URL is required');
    }

    const scopes = await vscode.window.showInputBox({
      prompt: `Enter scopes for ${server.name} (space-separated)`,
      ignoreFocusOut: true
    });

    // In a real implementation, we would now start the OAuth2 flow
    // For now, we'll just store the configuration without the tokens

    const config: McpServerAuthConfig = {
      type: 'oauth2',
      clientId,
      clientSecret,
      authUrl,
      tokenUrl,
      scopes: scopes?.split(' ') || [],
      accessToken: '',
      refreshToken: '',
      expiresAt: new Date(Date.now()).toISOString()
    };

    await this.setAuthConfig(server.id, config);

    // Show a message to the user
    vscode.window.showInformationMessage(
      'OAuth2 configuration saved. You will need to authenticate the first time you use this server.'
    );
  }
}

```


---

### File: `src/mcp-client/telemetry/telemetryManager.ts`

```typescript
import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';
import { McpServer } from '../types';

/**
 * Telemetry event type
 */
export enum TelemetryEventType {
  SERVER_START = 'server_start',
  SERVER_STOP = 'server_stop',
  SERVER_ERROR = 'server_error',
  TOOL_INVOCATION = 'tool_invocation',
  TOOL_ERROR = 'tool_error',
  HEALTH_CHECK = 'health_check',
  AUTHENTICATION = 'authentication'
}

/**
 * Telemetry event
 */
export interface TelemetryEvent {
  type: TelemetryEventType;
  timestamp: string;
  serverId: string;
  serverName: string;
  serverVersion: string;
  duration?: number;
  success?: boolean;
  errorMessage?: string;
  toolName?: string;
  toolParameters?: Record<string, any>;
  healthStatus?: string;
  authType?: string;
}

/**
 * Server usage statistics
 */
export interface ServerUsageStats {
  serverId: string;
  serverName: string;
  startCount: number;
  stopCount: number;
  errorCount: number;
  toolInvocations: number;
  toolErrors: number;
  healthChecks: number;
  uptime: number;
  lastStarted?: string;
  lastStopped?: string;
  lastError?: string;
  lastToolInvocation?: string;
  lastHealthCheck?: string;
  toolUsage: Record<string, number>;
}

/**
 * Telemetry manager for MCP servers
 */
export class TelemetryManager implements vscode.Disposable {
  private telemetryEnabled: boolean;
  private telemetryDir: string;
  private maxEventsPerFile: number;
  private events: Map<string, TelemetryEvent[]> = new Map();
  private stats: Map<string, ServerUsageStats> = new Map();
  private _onDidCollectTelemetry = new vscode.EventEmitter<TelemetryEvent>();

  /**
   * Event that fires when telemetry is collected
   */
  public readonly onDidCollectTelemetry = this._onDidCollectTelemetry.event;

  /**
   * Create a new telemetry manager
   * @param context Extension context
   * @param options Telemetry options
   */
  constructor(
    context: vscode.ExtensionContext,
    options: {
      telemetryEnabled?: boolean;
      telemetryDir?: string;
      maxEventsPerFile?: number;
    } = {}
  ) {
    this.telemetryEnabled = options.telemetryEnabled !== false;
    this.telemetryDir = options.telemetryDir || path.join(context.globalStorageUri.fsPath, 'telemetry');
    this.maxEventsPerFile = options.maxEventsPerFile || 1000;

    // Create telemetry directory if it doesn't exist
    if (this.telemetryEnabled && !fs.existsSync(this.telemetryDir)) {
      fs.mkdirSync(this.telemetryDir, { recursive: true });
    }

    // Load existing telemetry data
    this.loadTelemetry();

    // Register the telemetry manager with the extension context
    context.subscriptions.push(this);
  }

  /**
   * Dispose of resources
   */
  public dispose(): void {
    this._onDidCollectTelemetry.dispose();

    // Save telemetry data
    this.saveTelemetry();
  }

  /**
   * Track a server start event
   * @param server Server
   */
  public trackServerStart(server: McpServer): void {
    if (!this.telemetryEnabled) {
      return;
    }

    const event: TelemetryEvent = {
      type: TelemetryEventType.SERVER_START,
      timestamp: new Date().toISOString(),
      serverId: server.id,
      serverName: server.name,
      serverVersion: server.version
    };

    this.trackEvent(event);
    this.updateStats(server.id, stats => {
      stats.startCount++;
      stats.lastStarted = event.timestamp;
    });
  }

  /**
   * Track a server stop event
   * @param server Server
   * @param duration Duration in milliseconds
   */
  public trackServerStop(server: McpServer, duration: number): void {
    if (!this.telemetryEnabled) {
      return;
    }

    const event: TelemetryEvent = {
      type: TelemetryEventType.SERVER_STOP,
      timestamp: new Date().toISOString(),
      serverId: server.id,
      serverName: server.name,
      serverVersion: server.version,
      duration
    };

    this.trackEvent(event);
    this.updateStats(server.id, stats => {
      stats.stopCount++;
      stats.lastStopped = event.timestamp;
      stats.uptime += duration;
    });
  }

  /**
   * Track a server error event
   * @param server Server
   * @param errorMessage Error message
   */
  public trackServerError(server: McpServer, errorMessage: string): void {
    if (!this.telemetryEnabled) {
      return;
    }

    const event: TelemetryEvent = {
      type: TelemetryEventType.SERVER_ERROR,
      timestamp: new Date().toISOString(),
      serverId: server.id,
      serverName: server.name,
      serverVersion: server.version,
      errorMessage
    };

    this.trackEvent(event);
    this.updateStats(server.id, stats => {
      stats.errorCount++;
      stats.lastError = event.timestamp;
    });
  }

  /**
   * Track a tool invocation event
   * @param server Server
   * @param toolName Tool name
   * @param toolParameters Tool parameters
   * @param success Whether the invocation was successful
   * @param errorMessage Error message if the invocation failed
   * @param duration Duration in milliseconds
   */
  public trackToolInvocation(
    server: McpServer,
    toolName: string,
    toolParameters: Record<string, any>,
    success: boolean,
    errorMessage?: string,
    duration?: number
  ): void {
    if (!this.telemetryEnabled) {
      return;
    }

    const event: TelemetryEvent = {
      type: success ? TelemetryEventType.TOOL_INVOCATION : TelemetryEventType.TOOL_ERROR,
      timestamp: new Date().toISOString(),
      serverId: server.id,
      serverName: server.name,
      serverVersion: server.version,
      toolName,
      toolParameters,
      success,
      errorMessage,
      duration
    };

    this.trackEvent(event);
    this.updateStats(server.id, stats => {
      if (success) {
        stats.toolInvocations++;
        stats.lastToolInvocation = event.timestamp;
      } else {
        stats.toolErrors++;
      }

      // Update tool usage
      stats.toolUsage[toolName] = (stats.toolUsage[toolName] || 0) + 1;
    });
  }

  /**
   * Track a health check event
   * @param server Server
   * @param healthStatus Health status
   */
  public trackHealthCheck(server: McpServer, healthStatus: string): void {
    if (!this.telemetryEnabled) {
      return;
    }

    const event: TelemetryEvent = {
      type: TelemetryEventType.HEALTH_CHECK,
      timestamp: new Date().toISOString(),
      serverId: server.id,
      serverName: server.name,
      serverVersion: server.version,
      healthStatus
    };

    this.trackEvent(event);
    this.updateStats(server.id, stats => {
      stats.healthChecks++;
      stats.lastHealthCheck = event.timestamp;
    });
  }

  /**
   * Track an authentication event
   * @param server Server
   * @param authType Authentication type
   * @param success Whether the authentication was successful
   * @param errorMessage Error message if the authentication failed
   */
  public trackAuthentication(
    server: McpServer,
    authType: string,
    success: boolean,
    errorMessage?: string
  ): void {
    if (!this.telemetryEnabled) {
      return;
    }

    const event: TelemetryEvent = {
      type: TelemetryEventType.AUTHENTICATION,
      timestamp: new Date().toISOString(),
      serverId: server.id,
      serverName: server.name,
      serverVersion: server.version,
      authType,
      success,
      errorMessage
    };

    this.trackEvent(event);
  }

  /**
   * Get usage statistics for all servers
   * @returns Server usage statistics
   */
  public getUsageStats(): ServerUsageStats[] {
    return Array.from(this.stats.values());
  }

  /**
   * Get usage statistics for a server
   * @param serverId Server ID
   * @returns Server usage statistics
   */
  public getServerUsageStats(serverId: string): ServerUsageStats | undefined {
    return this.stats.get(serverId);
  }

  /**
   * Get telemetry events for a server
   * @param serverId Server ID
   * @param maxEvents Maximum number of events to return
   * @returns Telemetry events
   */
  public getServerEvents(serverId: string, maxEvents: number = 100): TelemetryEvent[] {
    const events = this.events.get(serverId) || [];
    return events.slice(-maxEvents);
  }

  /**
   * Clear telemetry data for a server
   * @param serverId Server ID
   */
  public clearServerTelemetry(serverId: string): void {
    this.events.delete(serverId);
    this.stats.delete(serverId);

    // Delete telemetry files
    const eventsFilePath = this.getEventsFilePath(serverId);
    const statsFilePath = this.getStatsFilePath(serverId);

    if (fs.existsSync(eventsFilePath)) {
      fs.unlinkSync(eventsFilePath);
    }

    if (fs.existsSync(statsFilePath)) {
      fs.unlinkSync(statsFilePath);
    }
  }

  /**
   * Enable or disable telemetry
   * @param enabled Whether telemetry is enabled
   */
  public setTelemetryEnabled(enabled: boolean): void {
    this.telemetryEnabled = enabled;

    if (enabled) {
      // Create telemetry directory if it doesn't exist
      if (!fs.existsSync(this.telemetryDir)) {
        fs.mkdirSync(this.telemetryDir, { recursive: true });
      }

      // Load existing telemetry data
      this.loadTelemetry();
    } else {
      // Clear in-memory telemetry data
      this.events.clear();
      this.stats.clear();
    }
  }

  /**
   * Track a telemetry event
   * @param event Telemetry event
   */
  private trackEvent(event: TelemetryEvent): void {
    // Add the event to the in-memory store
    const serverId = event.serverId;
    const serverEvents = this.events.get(serverId) || [];
    serverEvents.push(event);

    // Limit the number of events in memory
    if (serverEvents.length > this.maxEventsPerFile) {
      serverEvents.shift();
    }

    this.events.set(serverId, serverEvents);

    // Save the event to disk
    this.saveEvent(event);

    // Fire the event
    this._onDidCollectTelemetry.fire(event);
  }

  /**
   * Update server statistics
   * @param serverId Server ID
   * @param updater Function to update the statistics
   */
  private updateStats(serverId: string, updater: (stats: ServerUsageStats) => void): void {
    // Get or create the server stats
    const stats = this.stats.get(serverId) || {
      serverId,
      serverName: '',
      startCount: 0,
      stopCount: 0,
      errorCount: 0,
      toolInvocations: 0,
      toolErrors: 0,
      healthChecks: 0,
      uptime: 0,
      toolUsage: {}
    };

    // Update the stats
    updater(stats);

    // Store the updated stats
    this.stats.set(serverId, stats);

    // Save the stats to disk
    this.saveStats(serverId);
  }

  /**
   * Save a telemetry event to disk
   * @param event Telemetry event
   */
  private saveEvent(event: TelemetryEvent): void {
    if (!this.telemetryEnabled) {
      return;
    }

    try {
      const serverId = event.serverId;
      const eventsFilePath = this.getEventsFilePath(serverId);

      // Append the event to the file
      const eventLine = JSON.stringify(event) + '\n';
      fs.appendFileSync(eventsFilePath, eventLine, 'utf8');
    } catch (error) {
      console.error(`Error saving telemetry event: ${error}`);
    }
  }

  /**
   * Save server statistics to disk
   * @param serverId Server ID
   */
  private saveStats(serverId: string): void {
    if (!this.telemetryEnabled) {
      return;
    }

    try {
      const stats = this.stats.get(serverId);
      if (!stats) {
        return;
      }

      const statsFilePath = this.getStatsFilePath(serverId);
      fs.writeFileSync(statsFilePath, JSON.stringify(stats, null, 2), 'utf8');
    } catch (error) {
      console.error(`Error saving telemetry stats: ${error}`);
    }
  }

  /**
   * Save all telemetry data to disk
   */
  private saveTelemetry(): void {
    if (!this.telemetryEnabled) {
      return;
    }

    // Save all server stats
    for (const serverId of this.stats.keys()) {
      this.saveStats(serverId);
    }
  }

  /**
   * Load telemetry data from disk
   */
  private loadTelemetry(): void {
    if (!this.telemetryEnabled || !fs.existsSync(this.telemetryDir)) {
      return;
    }

    try {
      // Get all server IDs from the telemetry directory
      const files = fs.readdirSync(this.telemetryDir);
      const statsFiles = files.filter(file => file.endsWith('.stats.json'));
      const serverIds = statsFiles.map(file => file.replace('.stats.json', ''));

      // Load stats for each server
      for (const serverId of serverIds) {
        this.loadStats(serverId);
        this.loadEvents(serverId);
      }
    } catch (error) {
      console.error(`Error loading telemetry data: ${error}`);
    }
  }

  /**
   * Load server statistics from disk
   * @param serverId Server ID
   */
  private loadStats(serverId: string): void {
    try {
      const statsFilePath = this.getStatsFilePath(serverId);
      if (!fs.existsSync(statsFilePath)) {
        return;
      }

      const statsJson = fs.readFileSync(statsFilePath, 'utf8');
      const stats = JSON.parse(statsJson) as ServerUsageStats;
      this.stats.set(serverId, stats);
    } catch (error) {
      console.error(`Error loading telemetry stats for ${serverId}: ${error}`);
    }
  }

  /**
   * Load telemetry events from disk
   * @param serverId Server ID
   */
  private loadEvents(serverId: string): void {
    try {
      const eventsFilePath = this.getEventsFilePath(serverId);
      if (!fs.existsSync(eventsFilePath)) {
        return;
      }

      const eventsContent = fs.readFileSync(eventsFilePath, 'utf8');
      const eventLines = eventsContent.split('\n').filter(line => line.trim().length > 0);
      const events: TelemetryEvent[] = [];

      // Parse the most recent events
      const startIndex = Math.max(0, eventLines.length - this.maxEventsPerFile);
      for (let i = startIndex; i < eventLines.length; i++) {
        try {
          const event = JSON.parse(eventLines[i]) as TelemetryEvent;
          events.push(event);
        } catch (error) {
          console.error(`Error parsing telemetry event: ${error}`);
        }
      }

      this.events.set(serverId, events);
    } catch (error) {
      console.error(`Error loading telemetry events for ${serverId}: ${error}`);
    }
  }

  /**
   * Get the events file path for a server
   * @param serverId Server ID
   * @returns Events file path
   */
  private getEventsFilePath(serverId: string): string {
    return path.join(this.telemetryDir, `${serverId}.events.jsonl`);
  }

  /**
   * Get the stats file path for a server
   * @param serverId Server ID
   * @returns Stats file path
   */
  private getStatsFilePath(serverId: string): string {
    return path.join(this.telemetryDir, `${serverId}.stats.json`);
  }
}

```


---

### File: `src/mcp-client/discovery/serverDiscovery.ts`

```typescript
import * as vscode from 'vscode';
import * as os from 'os';
import * as fs from 'fs';
import * as path from 'path';
import * as dns from 'dns';
import { McpServerManager } from '../mcpServerManager';
import { GitHubRepoManager } from '../../github-integration/githubRepoManager';

/**
 * Server discovery result
 */
export interface ServerDiscoveryResult {
  name: string;
  description: string;
  repoUrl: string;
  version: string;
  source: 'registry' | 'github' | 'local' | 'network';
  official: boolean;
  installed: boolean;
  serverId?: string;
}

/**
 * Server discovery options
 */
export interface ServerDiscoveryOptions {
  includeRegistry?: boolean;
  includeGitHub?: boolean;
  includeLocal?: boolean;
  includeNetwork?: boolean;
  searchQuery?: string;
  maxResults?: number;
}

/**
 * Server discovery for MCP servers
 */
export class ServerDiscovery implements vscode.Disposable {
  private serverManager: McpServerManager;
  private githubManager: GitHubRepoManager;
  private registryUrl: string;
  private _onDidDiscoverServers = new vscode.EventEmitter<ServerDiscoveryResult[]>();

  /**
   * Event that fires when servers are discovered
   */
  public readonly onDidDiscoverServers = this._onDidDiscoverServers.event;

  /**
   * Create a new server discovery
   * @param serverManager MCP server manager
   * @param githubManager GitHub repository manager
   * @param options Server discovery options
   */
  constructor(
    serverManager: McpServerManager,
    githubManager: GitHubRepoManager,
    options: {
      registryUrl?: string;
    } = {}
  ) {
    this.serverManager = serverManager;
    this.githubManager = githubManager;
    this.registryUrl = options.registryUrl || 'https://registry.modelcontextprotocol.io';
  }

  /**
   * Dispose of resources
   */
  public dispose(): void {
    this._onDidDiscoverServers.dispose();
  }

  /**
   * Discover servers
   * @param options Discovery options
   * @returns Promise that resolves to the discovered servers
   */
  public async discoverServers(options: ServerDiscoveryOptions = {}): Promise<ServerDiscoveryResult[]> {
    const results: ServerDiscoveryResult[] = [];
    const maxResults = options.maxResults || 100;

    // Get installed servers
    const installedServers = this.serverManager.getServers();
    const installedRepoUrls = new Set(installedServers.map(server => server.repoUrl));

    // Discover servers from the registry
    if (options.includeRegistry !== false) {
      try {
        const registryResults = await this.discoverFromRegistry(options.searchQuery);
        for (const result of registryResults) {
          // Check if the server is already installed
          result.installed = installedRepoUrls.has(result.repoUrl);
          if (result.installed) {
            const server = installedServers.find(s => s.repoUrl === result.repoUrl);
            if (server) {
              result.serverId = server.id;
            }
          }

          results.push(result);

          // Check if we've reached the maximum number of results
          if (results.length >= maxResults) {
            break;
          }
        }
      } catch (error) {
        console.error('Error discovering servers from registry:', error);
      }
    }

    // Discover servers from GitHub
    if (options.includeGitHub !== false && results.length < maxResults) {
      try {
        const githubResults = await this.discoverFromGitHub(options.searchQuery);
        for (const result of githubResults) {
          // Check if the server is already installed
          result.installed = installedRepoUrls.has(result.repoUrl);
          if (result.installed) {
            const server = installedServers.find(s => s.repoUrl === result.repoUrl);
            if (server) {
              result.serverId = server.id;
            }
          }

          // Check if the result is already in the list
          if (!results.some(r => r.repoUrl === result.repoUrl)) {
            results.push(result);
          }

          // Check if we've reached the maximum number of results
          if (results.length >= maxResults) {
            break;
          }
        }
      } catch (error) {
        console.error('Error discovering servers from GitHub:', error);
      }
    }

    // Discover servers from the local network
    if (options.includeNetwork !== false && results.length < maxResults) {
      try {
        const networkResults = await this.discoverFromNetwork();
        for (const result of networkResults) {
          // Check if the result is already in the list
          if (!results.some(r => r.repoUrl === result.repoUrl)) {
            results.push(result);
          }

          // Check if we've reached the maximum number of results
          if (results.length >= maxResults) {
            break;
          }
        }
      } catch (error) {
        console.error('Error discovering servers from network:', error);
      }
    }

    // Discover servers from the local filesystem
    if (options.includeLocal !== false && results.length < maxResults) {
      try {
        const localResults = await this.discoverFromLocal();
        for (const result of localResults) {
          // Check if the server is already installed
          result.installed = installedRepoUrls.has(result.repoUrl);
          if (result.installed) {
            const server = installedServers.find(s => s.repoUrl === result.repoUrl);
            if (server) {
              result.serverId = server.id;
            }
          }

          // Check if the result is already in the list
          if (!results.some(r => r.repoUrl === result.repoUrl)) {
            results.push(result);
          }

          // Check if we've reached the maximum number of results
          if (results.length >= maxResults) {
            break;
          }
        }
      } catch (error) {
        console.error('Error discovering servers from local filesystem:', error);
      }
    }

    // Filter results by search query if provided
    if (options.searchQuery) {
      const query = options.searchQuery.toLowerCase();
      const filteredResults = results.filter(result => {
        return (
          result.name.toLowerCase().includes(query) ||
          result.description.toLowerCase().includes(query) ||
          result.repoUrl.toLowerCase().includes(query)
        );
      });
      
      // Notify listeners
      this._onDidDiscoverServers.fire(filteredResults);
      
      return filteredResults;
    }

    // Notify listeners
    this._onDidDiscoverServers.fire(results);

    return results;
  }

  /**
   * Discover servers from the MCP registry
   * @param searchQuery Search query
   * @returns Promise that resolves to the discovered servers
   */
  private async discoverFromRegistry(searchQuery?: string): Promise<ServerDiscoveryResult[]> {
    try {
      // Construct the registry URL
      let url = `${this.registryUrl}/api/servers`;
      if (searchQuery) {
        url += `?q=${encodeURIComponent(searchQuery)}`;
      }

      // Fetch the servers from the registry
      const response = await fetch(url, {
        method: 'GET',
        headers: {
          'Accept': 'application/json'
        }
      });

      if (!response.ok) {
        throw new Error(`Error fetching servers from registry: ${response.statusText}`);
      }

      const data = await response.json();
      if (!Array.isArray(data)) {
        throw new Error('Invalid response from registry');
      }

      // Convert the registry data to discovery results
      return data.map(item => ({
        name: item.name,
        description: item.description,
        repoUrl: item.repoUrl,
        version: item.version,
        source: 'registry' as const,
        official: item.official || false,
        installed: false
      }));
    } catch (error) {
      console.error('Error discovering servers from registry:', error);
      return [];
    }
  }

  /**
   * Discover servers from GitHub
   * @param searchQuery Search query
   * @returns Promise that resolves to the discovered servers
   */
  private async discoverFromGitHub(searchQuery?: string): Promise<ServerDiscoveryResult[]> {
    try {
      // Construct the search query
      const query = searchQuery
        ? `mcp-server ${searchQuery} in:name,description,readme`
        : 'mcp-server in:name,description,readme';

      // Search for repositories on GitHub
      const repositories = await this.githubManager.searchRepositories(query);

      // Convert the GitHub data to discovery results
      return repositories.map(repo => ({
        name: repo.name,
        description: repo.description || '',
        repoUrl: repo.html_url,
        version: '',
        source: 'github' as const,
        official: repo.owner.login === 'modelcontextprotocol',
        installed: false
      }));
    } catch (error) {
      console.error('Error discovering servers from GitHub:', error);
      return [];
    }
  }

  /**
   * Discover servers from the local network
   * @returns Promise that resolves to the discovered servers
   */
  private async discoverFromNetwork(): Promise<ServerDiscoveryResult[]> {
    try {
      // This is a placeholder implementation
      // In a real implementation, you would use mDNS or a similar protocol to discover MCP servers on the local network
      
      // Get the local IP addresses
      const interfaces = os.networkInterfaces();
      const localIps: string[] = [];
      
      for (const name in interfaces) {
        const networkInterface = interfaces[name];
        if (!networkInterface) {
          continue;
        }
        
        for (const iface of networkInterface) {
          if (iface.family === 'IPv4' && !iface.internal) {
            localIps.push(iface.address);
          }
        }
      }
      
      // Scan the local network for MCP servers
      const results: ServerDiscoveryResult[] = [];
      
      // This is a simplified implementation that just checks a few common ports
      // In a real implementation, you would use a more sophisticated discovery mechanism
      const ports = [8080, 8081, 8082, 8083, 8084, 8085];
      
      for (const ip of localIps) {
        // Get the network prefix
        const parts = ip.split('.');
        const prefix = `${parts[0]}.${parts[1]}.${parts[2]}`;
        
        // Scan the local network
        for (let i = 1; i <= 10; i++) {
          const targetIp = `${prefix}.${i}`;
          
          // Skip the local IP
          if (targetIp === ip) {
            continue;
          }
          
          // Check if the host is reachable
          try {
            await new Promise<void>((resolve, reject) => {
              dns.lookup(targetIp, (err) => {
                if (err) {
                  reject(err);
                } else {
                  resolve();
                }
              });
            });
            
            // Check common ports for MCP servers
            for (const port of ports) {
              try {
                const url = `http://${targetIp}:${port}/health`;
                const response = await fetch(url, {
                  method: 'GET',
                  headers: {
                    'Accept': 'application/json'
                  },
                  timeout: 1000
                });
                
                if (response.ok) {
                  // Try to get the server information
                  const infoUrl = `http://${targetIp}:${port}/info`;
                  const infoResponse = await fetch(infoUrl, {
                    method: 'GET',
                    headers: {
                      'Accept': 'application/json'
                    },
                    timeout: 1000
                  });
                  
                  if (infoResponse.ok) {
                    const info = await infoResponse.json();
                    
                    results.push({
                      name: info.name || `MCP Server at ${targetIp}:${port}`,
                      description: info.description || 'Discovered on local network',
                      repoUrl: info.repoUrl || `http://${targetIp}:${port}`,
                      version: info.version || '',
                      source: 'network' as const,
                      official: false,
                      installed: false
                    });
                  } else {
                    // Add a generic result
                    results.push({
                      name: `MCP Server at ${targetIp}:${port}`,
                      description: 'Discovered on local network',
                      repoUrl: `http://${targetIp}:${port}`,
                      version: '',
                      source: 'network' as const,
                      official: false,
                      installed: false
                    });
                  }
                }
              } catch (error) {
                // Ignore errors - the server might not be running on this port
              }
            }
          } catch (error) {
            // Ignore errors - the host might not be reachable
          }
        }
      }
      
      return results;
    } catch (error) {
      console.error('Error discovering servers from network:', error);
      return [];
    }
  }

  /**
   * Discover servers from the local filesystem
   * @returns Promise that resolves to the discovered servers
   */
  private async discoverFromLocal(): Promise<ServerDiscoveryResult[]> {
    try {
      const results: ServerDiscoveryResult[] = [];
      
      // Check common directories for MCP servers
      const homeDir = os.homedir();
      const directories = [
        path.join(homeDir, 'mcp-servers'),
        path.join(homeDir, 'Documents', 'mcp-servers'),
        path.join(homeDir, 'Projects', 'mcp-servers'),
        path.join(homeDir, 'git', 'mcp-servers')
      ];
      
      for (const directory of directories) {
        if (!fs.existsSync(directory)) {
          continue;
        }
        
        // Get all subdirectories
        const subdirs = fs.readdirSync(directory, { withFileTypes: true })
          .filter(dirent => dirent.isDirectory())
          .map(dirent => dirent.name);
        
        for (const subdir of subdirs) {
          const serverDir = path.join(directory, subdir);
          
          // Check if this is an MCP server
          const schemaPath = path.join(serverDir, 'mcp.json');
          if (!fs.existsSync(schemaPath)) {
            continue;
          }
          
          try {
            // Read the schema file
            const schemaData = fs.readFileSync(schemaPath, 'utf8');
            const schema = JSON.parse(schemaData);
            
            // Check if this is a valid MCP schema
            if (!schema.name || !schema.description || !schema.tools || !Array.isArray(schema.tools)) {
              continue;
            }
            
            // Check if there's a package.json file with repository information
            let repoUrl = '';
            const packagePath = path.join(serverDir, 'package.json');
            if (fs.existsSync(packagePath)) {
              try {
                const packageData = fs.readFileSync(packagePath, 'utf8');
                const packageJson = JSON.parse(packageData);
                
                if (packageJson.repository) {
                  if (typeof packageJson.repository === 'string') {
                    repoUrl = packageJson.repository;
                  } else if (packageJson.repository.url) {
                    repoUrl = packageJson.repository.url;
                  }
                }
              } catch (error) {
                // Ignore errors reading package.json
              }
            }
            
            // Add the result
            results.push({
              name: schema.name,
              description: schema.description,
              repoUrl: repoUrl || `file://${serverDir}`,
              version: schema.version || '',
              source: 'local' as const,
              official: false,
              installed: false
            });
          } catch (error) {
            // Ignore errors reading the schema file
          }
        }
      }
      
      return results;
    } catch (error) {
      console.error('Error discovering servers from local filesystem:', error);
      return [];
    }
  }
}

```


---

### File: `src/mcp-client/logging/mcpLogger.ts`

```typescript
import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';

/**
 * Log level
 */
export enum LogLevel {
  DEBUG = 'DEBUG',
  INFO = 'INFO',
  WARNING = 'WARNING',
  ERROR = 'ERROR'
}

/**
 * Log entry
 */
export interface LogEntry {
  timestamp: string;
  level: LogLevel;
  serverId: string;
  message: string;
  data?: any;
}

/**
 * Logger for MCP servers
 */
export class McpLogger implements vscode.Disposable {
  private outputChannel: vscode.OutputChannel;
  private logDir: string;
  private maxLogSize: number;
  private maxLogFiles: number;
  private logEnabled: boolean;
  private fileLogEnabled: boolean;
  private _onDidLog = new vscode.EventEmitter<LogEntry>();

  /**
   * Event that fires when a log entry is added
   */
  public readonly onDidLog = this._onDidLog.event;

  /**
   * Create a new MCP logger
   * @param context Extension context
   * @param options Logger options
   */
  constructor(
    context: vscode.ExtensionContext,
    options: {
      logDir?: string;
      maxLogSize?: number;
      maxLogFiles?: number;
      logEnabled?: boolean;
      fileLogEnabled?: boolean;
    } = {}
  ) {
    this.outputChannel = vscode.window.createOutputChannel('MCP Servers');
    this.logDir = options.logDir || path.join(context.globalStorageUri.fsPath, 'logs');
    this.maxLogSize = options.maxLogSize || 5 * 1024 * 1024; // 5 MB
    this.maxLogFiles = options.maxLogFiles || 10;
    this.logEnabled = options.logEnabled !== false;
    this.fileLogEnabled = options.fileLogEnabled !== false;

    // Create log directory if it doesn't exist
    if (this.fileLogEnabled && !fs.existsSync(this.logDir)) {
      fs.mkdirSync(this.logDir, { recursive: true });
    }

    // Register the logger with the extension context
    context.subscriptions.push(this);
  }

  /**
   * Dispose of resources
   */
  public dispose(): void {
    this.outputChannel.dispose();
    this._onDidLog.dispose();
  }

  /**
   * Log a message
   * @param level Log level
   * @param serverId Server ID
   * @param message Message
   * @param data Additional data
   */
  public log(level: LogLevel, serverId: string, message: string, data?: any): void {
    if (!this.logEnabled) {
      return;
    }

    const timestamp = new Date().toISOString();
    const entry: LogEntry = {
      timestamp,
      level,
      serverId,
      message,
      data
    };

    // Log to output channel
    this.logToOutputChannel(entry);

    // Log to file
    if (this.fileLogEnabled) {
      this.logToFile(entry);
    }

    // Fire event
    this._onDidLog.fire(entry);
  }

  /**
   * Log a debug message
   * @param serverId Server ID
   * @param message Message
   * @param data Additional data
   */
  public debug(serverId: string, message: string, data?: any): void {
    this.log(LogLevel.DEBUG, serverId, message, data);
  }

  /**
   * Log an info message
   * @param serverId Server ID
   * @param message Message
   * @param data Additional data
   */
  public info(serverId: string, message: string, data?: any): void {
    this.log(LogLevel.INFO, serverId, message, data);
  }

  /**
   * Log a warning message
   * @param serverId Server ID
   * @param message Message
   * @param data Additional data
   */
  public warning(serverId: string, message: string, data?: any): void {
    this.log(LogLevel.WARNING, serverId, message, data);
  }

  /**
   * Log an error message
   * @param serverId Server ID
   * @param message Message
   * @param data Additional data
   */
  public error(serverId: string, message: string, data?: any): void {
    this.log(LogLevel.ERROR, serverId, message, data);
  }

  /**
   * Show the log output channel
   */
  public show(): void {
    this.outputChannel.show();
  }

  /**
   * Get the log file path for a server
   * @param serverId Server ID
   * @returns Log file path
   */
  public getLogFilePath(serverId: string): string {
    return path.join(this.logDir, `${serverId}.log`);
  }

  /**
   * Get the log entries for a server
   * @param serverId Server ID
   * @param maxEntries Maximum number of entries to return
   * @returns Log entries
   */
  public getLogEntries(serverId: string, maxEntries: number = 100): LogEntry[] {
    if (!this.fileLogEnabled) {
      return [];
    }

    const logFilePath = this.getLogFilePath(serverId);
    if (!fs.existsSync(logFilePath)) {
      return [];
    }

    try {
      const logContent = fs.readFileSync(logFilePath, 'utf8');
      const lines = logContent.split('\n').filter(line => line.trim().length > 0);
      const entries: LogEntry[] = [];

      // Parse the most recent entries
      const startIndex = Math.max(0, lines.length - maxEntries);
      for (let i = startIndex; i < lines.length; i++) {
        try {
          const entry = JSON.parse(lines[i]) as LogEntry;
          entries.push(entry);
        } catch (error) {
          console.error(`Error parsing log entry: ${error}`);
        }
      }

      return entries;
    } catch (error) {
      console.error(`Error reading log file: ${error}`);
      return [];
    }
  }

  /**
   * Clear the logs for a server
   * @param serverId Server ID
   */
  public clearLogs(serverId: string): void {
    if (!this.fileLogEnabled) {
      return;
    }

    const logFilePath = this.getLogFilePath(serverId);
    if (fs.existsSync(logFilePath)) {
      fs.writeFileSync(logFilePath, '', 'utf8');
    }
  }

  /**
   * Log to the output channel
   * @param entry Log entry
   */
  private logToOutputChannel(entry: LogEntry): void {
    const { timestamp, level, serverId, message, data } = entry;
    let logMessage = `[${timestamp}] [${level}] [${serverId}] ${message}`;

    if (data !== undefined) {
      try {
        const dataStr = typeof data === 'string' ? data : JSON.stringify(data, null, 2);
        logMessage += `\n${dataStr}`;
      } catch (error) {
        logMessage += `\n[Error serializing data: ${error}]`;
      }
    }

    this.outputChannel.appendLine(logMessage);
  }

  /**
   * Log to a file
   * @param entry Log entry
   */
  private logToFile(entry: LogEntry): void {
    const { serverId } = entry;
    const logFilePath = this.getLogFilePath(serverId);

    try {
      // Check if log rotation is needed
      this.rotateLogFileIfNeeded(logFilePath);

      // Append the log entry to the file
      const logLine = JSON.stringify(entry) + '\n';
      fs.appendFileSync(logFilePath, logLine, 'utf8');
    } catch (error) {
      console.error(`Error writing to log file: ${error}`);
      this.outputChannel.appendLine(`[ERROR] Failed to write to log file: ${error}`);
    }
  }

  /**
   * Rotate the log file if needed
   * @param logFilePath Log file path
   */
  private rotateLogFileIfNeeded(logFilePath: string): void {
    if (!fs.existsSync(logFilePath)) {
      return;
    }

    try {
      const stats = fs.statSync(logFilePath);
      if (stats.size >= this.maxLogSize) {
        this.rotateLogFile(logFilePath);
      }
    } catch (error) {
      console.error(`Error checking log file size: ${error}`);
    }
  }

  /**
   * Rotate the log file
   * @param logFilePath Log file path
   */
  private rotateLogFile(logFilePath: string): void {
    try {
      // Delete the oldest log file if we have reached the maximum number of log files
      const baseLogPath = logFilePath;
      const rotatedLogPath = (index: number) => `${baseLogPath}.${index}`;

      // Check if we need to delete the oldest log file
      if (fs.existsSync(rotatedLogPath(this.maxLogFiles - 1))) {
        fs.unlinkSync(rotatedLogPath(this.maxLogFiles - 1));
      }

      // Shift all existing rotated log files
      for (let i = this.maxLogFiles - 2; i >= 0; i--) {
        const currentPath = rotatedLogPath(i);
        const nextPath = rotatedLogPath(i + 1);

        if (fs.existsSync(currentPath)) {
          fs.renameSync(currentPath, nextPath);
        }
      }

      // Rename the current log file
      fs.renameSync(baseLogPath, rotatedLogPath(0));

      // Create a new empty log file
      fs.writeFileSync(baseLogPath, '', 'utf8');
    } catch (error) {
      console.error(`Error rotating log file: ${error}`);
    }
  }
}

```


---

### File: `media/highlight.js`

```javascript
/**
 * A lightweight syntax highlighting library for code blocks in the webview
 */
class HighlightJS {
  constructor() {
    this.languages = {
      javascript: {
        keywords: [
          'const', 'let', 'var', 'function', 'class', 'extends', 'return', 'if', 'else', 'for', 'while', 'do',
          'switch', 'case', 'break', 'continue', 'new', 'try', 'catch', 'throw', 'finally', 'typeof', 'instanceof',
          'import', 'export', 'default', 'from', 'as', 'async', 'await', 'yield', 'this', 'super', 'null', 'undefined',
          'true', 'false'
        ],
        operators: ['=>', '===', '!==', '==', '!=', '>=', '<=', '>', '<', '+', '-', '*', '/', '%', '&&', '||', '!', '='],
        symbols: ['{', '}', '(', ')', '[', ']', ';', ',', '.', ':'],
        comments: {
          line: '//',
          block: { start: '/*', end: '*/' }
        },
        strings: ['"', "'", '`']
      },
      typescript: {
        keywords: [
          'const', 'let', 'var', 'function', 'class', 'extends', 'return', 'if', 'else', 'for', 'while', 'do',
          'switch', 'case', 'break', 'continue', 'new', 'try', 'catch', 'throw', 'finally', 'typeof', 'instanceof',
          'import', 'export', 'default', 'from', 'as', 'async', 'await', 'yield', 'this', 'super', 'null', 'undefined',
          'true', 'false', 'interface', 'type', 'namespace', 'enum', 'any', 'string', 'number', 'boolean', 'void',
          'readonly', 'private', 'protected', 'public', 'static', 'implements', 'abstract'
        ],
        operators: ['=>', '===', '!==', '==', '!=', '>=', '<=', '>', '<', '+', '-', '*', '/', '%', '&&', '||', '!', '='],
        symbols: ['{', '}', '(', ')', '[', ']', ';', ',', '.', ':', '<', '>'],
        comments: {
          line: '//',
          block: { start: '/*', end: '*/' }
        },
        strings: ['"', "'", '`']
      },
      python: {
        keywords: [
          'def', 'class', 'from', 'import', 'as', 'return', 'if', 'elif', 'else', 'for', 'while', 'break',
          'continue', 'try', 'except', 'finally', 'raise', 'assert', 'with', 'lambda', 'yield', 'pass',
          'None', 'True', 'False', 'and', 'or', 'not', 'is', 'in', 'global', 'nonlocal', 'del', 'async', 'await'
        ],
        operators: ['==', '!=', '>=', '<=', '>', '<', '+', '-', '*', '/', '%', '**', '//', '=', '+=', '-=', '*=', '/=', '%='],
        symbols: ['{', '}', '(', ')', '[', ']', ':', ',', '.'],
        comments: {
          line: '#',
          block: null
        },
        strings: ['"', "'", '"""', "'''"]
      }
    };
  }

  /**
   * Highlight code based on language
   * @param {string} code - The code to highlight
   * @param {string} language - The programming language
   * @returns {string} - HTML with syntax highlighting
   */
  highlight(code, language) {
    if (!code) return '';
    
    // Default to text if language not supported
    const lang = this.languages[language] || null;
    if (!lang) {
      return this.escapeHtml(code);
    }

    let result = '';
    let inComment = false;
    let inString = false;
    let stringChar = '';
    let currentToken = '';
    let i = 0;

    while (i < code.length) {
      const char = code[i];
      const nextChar = code[i + 1] || '';
      
      // Check for comments
      if (!inString && !inComment && lang.comments) {
        // Line comments
        if (lang.comments.line && char === lang.comments.line[0] && nextChar === lang.comments.line[1]) {
          const lineEnd = code.indexOf('\n', i);
          const commentText = lineEnd !== -1 ? code.substring(i, lineEnd) : code.substring(i);
          result += `<span class="hljs-comment">${this.escapeHtml(commentText)}</span>`;
          i += commentText.length;
          continue;
        }
        
        // Block comments
        if (lang.comments.block && 
            char === lang.comments.block.start[0] && 
            nextChar === lang.comments.block.start[1]) {
          const commentEnd = code.indexOf(lang.comments.block.end, i + 2);
          if (commentEnd !== -1) {
            const commentText = code.substring(i, commentEnd + lang.comments.block.end.length);
            result += `<span class="hljs-comment">${this.escapeHtml(commentText)}</span>`;
            i += commentText.length;
            continue;
          }
        }
      }

      // Check for strings
      if (!inComment && lang.strings) {
        if (inString) {
          currentToken += char;
          if (char === stringChar && code[i - 1] !== '\\') {
            result += `<span class="hljs-string">${this.escapeHtml(currentToken)}</span>`;
            inString = false;
            currentToken = '';
          }
          i++;
          continue;
        } else {
          for (const strChar of lang.strings) {
            if (char === strChar[0]) {
              if (strChar.length === 1 || 
                 (strChar.length > 1 && code.substring(i, i + strChar.length) === strChar)) {
                inString = true;
                stringChar = strChar;
                currentToken = char;
                if (strChar.length > 1) {
                  currentToken = strChar;
                  i += strChar.length;
                } else {
                  i++;
                }
                continue;
              }
            }
          }
        }
      }

      // If we're in a comment or string, continue to next character
      if (inComment || inString) {
        i++;
        continue;
      }

      // Check for whitespace
      if (/\s/.test(char)) {
        result += char;
        i++;
        continue;
      }

      // Build token
      currentToken = '';
      while (i < code.length && !/\s/.test(code[i]) && 
             !lang.symbols.includes(code[i]) && 
             !lang.operators.some(op => code.substring(i).startsWith(op))) {
        currentToken += code[i];
        i++;
      }

      // Check if token is a keyword
      if (currentToken && lang.keywords.includes(currentToken)) {
        result += `<span class="hljs-keyword">${currentToken}</span>`;
        continue;
      }

      // If token is not a keyword, add it as is
      if (currentToken) {
        result += this.escapeHtml(currentToken);
        continue;
      }

      // Check for operators
      let foundOperator = false;
      for (const op of lang.operators) {
        if (code.substring(i).startsWith(op)) {
          result += `<span class="hljs-operator">${this.escapeHtml(op)}</span>`;
          i += op.length;
          foundOperator = true;
          break;
        }
      }
      if (foundOperator) continue;

      // Check for symbols
      if (lang.symbols.includes(char)) {
        result += `<span class="hljs-symbol">${char}</span>`;
        i++;
        continue;
      }

      // Default case: just add the character
      result += this.escapeHtml(char);
      i++;
    }

    return result;
  }

  /**
   * Escape HTML special characters
   * @param {string} text - Text to escape
   * @returns {string} - Escaped text
   */
  escapeHtml(text) {
    return text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#039;');
  }
}

// Make available to the webview
window.HighlightJS = new HighlightJS();

```


---

### File: `media/mcpServerConfig.js`

```javascript
// @ts-check

(function () {
  // Get the VS Code API
  const vscode = acquireVsCodeApi();

  // Store state
  let servers = [];
  let currentServerId = null;

  // Wait for the document to load
  document.addEventListener('DOMContentLoaded', () => {
    // Set up event listeners for official server buttons
    document.getElementById('add-github').addEventListener('click', () => {
      vscode.postMessage({
        command: 'addOfficialServer',
        serverType: 'GITHUB'
      });
    });

    document.getElementById('add-docker').addEventListener('click', () => {
      vscode.postMessage({
        command: 'addOfficialServer',
        serverType: 'DOCKER'
      });
    });

    document.getElementById('add-git').addEventListener('click', () => {
      vscode.postMessage({
        command: 'addOfficialServer',
        serverType: 'GIT'
      });
    });

    document.getElementById('add-memory').addEventListener('click', () => {
      vscode.postMessage({
        command: 'addOfficialServer',
        serverType: 'MEMORY'
      });
    });

    document.getElementById('add-filesystem').addEventListener('click', () => {
      vscode.postMessage({
        command: 'addOfficialServer',
        serverType: 'FILESYSTEM'
      });
    });

    document.getElementById('add-all').addEventListener('click', () => {
      vscode.postMessage({
        command: 'addOfficialServer',
        serverType: 'ALL'
      });
    });
  });

  // Handle messages from the extension
  window.addEventListener('message', event => {
    const message = event.data;
    
    switch (message.command) {
      case 'updateServers':
        servers = message.servers;
        currentServerId = message.currentServerId;
        updateServerSelector();
        updateServerConfig();
        break;
    }
  });

  /**
   * Update the server selector
   */
  function updateServerSelector() {
    const selectorContainer = document.getElementById('server-selector');
    selectorContainer.innerHTML = '';

    // Create a select element
    const select = document.createElement('select');
    select.id = 'server-select';
    
    // Add an option for each server
    servers.forEach(server => {
      const option = document.createElement('option');
      option.value = server.id;
      option.textContent = `${server.name} (${server.status})`;
      option.selected = server.id === currentServerId;
      select.appendChild(option);
    });

    // Add event listener
    select.addEventListener('change', () => {
      currentServerId = select.value;
      updateServerConfig();
    });

    // Add to the container
    selectorContainer.appendChild(select);
  }

  /**
   * Update the server configuration
   */
  function updateServerConfig() {
    const configContainer = document.getElementById('server-config');
    configContainer.innerHTML = '';

    // Find the current server
    const server = servers.find(s => s.id === currentServerId);
    if (!server) {
      configContainer.innerHTML = '<p>No server selected</p>';
      return;
    }

    // Create the configuration form
    const form = document.createElement('form');
    form.id = 'config-form';

    // Add server information
    form.innerHTML = `
      <h2>Server Configuration: ${server.name}</h2>
      
      <div class="form-group">
        <label for="name">Name:</label>
        <input type="text" id="name" value="${server.name}" />
      </div>
      
      <div class="form-group">
        <label for="description">Description:</label>
        <textarea id="description">${server.description || ''}</textarea>
      </div>
      
      <div class="form-group">
        <label for="auto-start">Auto Start:</label>
        <input type="checkbox" id="auto-start" ${server.autoStart ? 'checked' : ''} />
      </div>
      
      <div class="form-group">
        <label>Status:</label>
        <span class="status-${server.status}">${server.status}</span>
      </div>
      
      <div class="form-group">
        <label>Health:</label>
        <span class="health-${server.healthStatus || 'unknown'}">${server.healthStatus || 'unknown'}</span>
      </div>
      
      <div class="form-group">
        <label>Endpoint:</label>
        <span>${server.endpoint || 'N/A'}</span>
      </div>
      
      <div class="form-group">
        <label>Repository:</label>
        <span>${server.repoUrl}</span>
      </div>
      
      <div class="form-group">
        <label>Version:</label>
        <span>${server.version}</span>
      </div>
      
      <div class="button-container">
        <button type="button" id="save-config">Save Configuration</button>
        <button type="button" id="start-server" ${server.status === 'running' ? 'disabled' : ''}>Start Server</button>
        <button type="button" id="stop-server" ${server.status !== 'running' ? 'disabled' : ''}>Stop Server</button>
        <button type="button" id="restart-server" ${server.status !== 'running' ? 'disabled' : ''}>Restart Server</button>
        <button type="button" id="check-health">Check Health</button>
        <button type="button" id="view-logs">View Logs</button>
      </div>
    `;

    // Add event listeners
    form.querySelector('#save-config').addEventListener('click', () => {
      const name = form.querySelector('#name').value;
      const description = form.querySelector('#description').value;
      const autoStart = form.querySelector('#auto-start').checked;

      vscode.postMessage({
        command: 'saveConfig',
        serverId: server.id,
        config: {
          name,
          description,
          autoStart
        }
      });
    });

    form.querySelector('#start-server').addEventListener('click', () => {
      vscode.postMessage({
        command: 'startServer',
        serverId: server.id
      });
    });

    form.querySelector('#stop-server').addEventListener('click', () => {
      vscode.postMessage({
        command: 'stopServer',
        serverId: server.id
      });
    });

    form.querySelector('#restart-server').addEventListener('click', () => {
      vscode.postMessage({
        command: 'restartServer',
        serverId: server.id
      });
    });

    form.querySelector('#check-health').addEventListener('click', () => {
      vscode.postMessage({
        command: 'checkHealth',
        serverId: server.id
      });
    });

    form.querySelector('#view-logs').addEventListener('click', () => {
      vscode.postMessage({
        command: 'viewLogs',
        serverId: server.id
      });
    });

    // Add the form to the container
    configContainer.appendChild(form);

    // Add tools section if the server has a schema
    if (server.schema && server.schema.tools && server.schema.tools.length > 0) {
      const toolsContainer = document.createElement('div');
      toolsContainer.className = 'tools-container';
      toolsContainer.innerHTML = `<h3>Available Tools</h3>`;

      const toolsList = document.createElement('ul');
      toolsList.className = 'tools-list';

      server.schema.tools.forEach(tool => {
        const toolItem = document.createElement('li');
        toolItem.className = 'tool-item';
        toolItem.innerHTML = `
          <h4>${tool.name}</h4>
          <p>${tool.description}</p>
        `;
        toolsList.appendChild(toolItem);
      });

      toolsContainer.appendChild(toolsList);
      configContainer.appendChild(toolsContainer);
    }
  }
})();

```
